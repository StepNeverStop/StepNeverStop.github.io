{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/Kicon.jpg","path":"images/Kicon.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"58869ab88fc3856c56c5568dddc859fbc9155423","modified":1590120645445},{"_id":"source/robots.txt","hash":"9fd41b2be16f980cfd7e6099c4f762b0c2a10d16","modified":1557419256049},{"_id":"source/_data/menu.yml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546668958268},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1546668958309},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1546668958309},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1546668958309},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1546668958310},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1546668958310},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1546668958311},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1546668958310},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1546668958311},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1546668958311},{"_id":"themes/next/Gemfile","hash":"620d8296f3bee8f443771dbb17b7d49d3b8fb760","modified":1546668958311},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1546668958311},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1546668958311},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1546668958312},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1546668958311},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1546668958312},{"_id":"themes/next/.DS_Store","hash":"734b05fa7bd5a510851eabad80b9bd6f758a94d1","modified":1557421984992},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1546668958329},{"_id":"themes/next/_config.yml","hash":"211ecf5fdf6ffa72e874ef226ad1eb8683cb0ddd","modified":1567506437255},{"_id":"themes/next/test.md","hash":"acb358c2b395d33ba7cf7011fccbae36f3fa6acc","modified":1546668958447},{"_id":"source/_posts/.DS_Store","hash":"a2aae387bcc6a3ab7282833684b804073d363367","modified":1587787050886},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary.md","hash":"adcc8e646775c2aa3cded7e8c35adda2235ed8b7","modified":1557757625705},{"_id":"source/_posts/Docker命令学习.md","hash":"abfe374fc557aebb7ad37aa91da9fdb20e09414e","modified":1584429911565},{"_id":"source/_posts/Evolution-Strategies-2017.md","hash":"c1c93a5d7b4a0dd3968e28b64b8370128e1602c4","modified":1558625547573},{"_id":"source/_posts/Git-learn.md","hash":"39d9232e0209d2cd4845c750edea19e9949e099b","modified":1557757625706},{"_id":"source/_posts/FuNs.md","hash":"f2028d39ccf0c50bf1f4500540e018e206f45bf6","modified":1587962804286},{"_id":"source/_posts/Hindsight-Experience-Replay.md","hash":"cff01b716d9e87175b8e3e06141428d1000ba3f8","modified":1559209944494},{"_id":"source/_posts/MarkDown-Grammar.md","hash":"869998a83bd6cd5e6390ad01a0c2355bd0d26feb","modified":1586688261149},{"_id":"source/_posts/PaStaNet.md","hash":"965f4650ca31b3e070c16719d89c97adfdd0591c","modified":1586691514924},{"_id":"source/_posts/asynchronous-methods-for-drl.md","hash":"10efa2d0dc886c026f6241b59d82707a20fe0028","modified":1559318509826},{"_id":"source/_posts/Prioritized-Experience-Replay.md","hash":"8972c542784156d8022f5672ae0ccb0759ef18bc","modified":1571235216842},{"_id":"source/_posts/conda环境和pip包的转移.md","hash":"ca4a06e470b82c673cf4011b663df7bbd8d597b5","modified":1557757625706},{"_id":"source/_posts/bootstrapped-dqn.md","hash":"42981b5c96fbf7baa513f4f6119fe11e9e9bf1ae","modified":1586579996646},{"_id":"source/_posts/burn-system2raspberry-in-macos.md","hash":"d35849e6fbb5ad5721d43a2f9300170e3ceca366","modified":1587722423390},{"_id":"source/_posts/config-alios.md","hash":"9219a11e79ab7a1b7204cae5fde9731ed77db7b7","modified":1579197864216},{"_id":"source/_posts/create-sniper-docker-image.md","hash":"8ce9eeb1a483381fc284b181513c900bd994bc7c","modified":1557757625707},{"_id":"source/_posts/dppo.md","hash":"ac50b56629aa5a834a8855e4bd32d1ae039388a3","modified":1586585745331},{"_id":"source/_posts/dynamic-programming.md","hash":"d39cc2248c656bd8ae1f272123dc31a9a0704f40","modified":1557757625707},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization.md","hash":"84089cb72271c898307ab831ba28aef09ef7a87a","modified":1559209944500},{"_id":"source/_posts/install-atari-and-box2d-on-win10.md","hash":"f139f4445d5f08cd1614f9e48cea2aff0487d419","modified":1571322422384},{"_id":"source/_posts/h-dqn.md","hash":"c7e4858621b3a177ff3381893c0a1820d1f45be0","modified":1586580015274},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks.md","hash":"fa563903ffe874e8ae6af4564dc3b8236c84690d","modified":1586404015796},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning.md","hash":"e49de7d29e88259340c3cc6768ba70de578579b0","modified":1562494753194},{"_id":"source/_posts/learn-grpc.md","hash":"424e31db7f461284492538ee9a7619fcdf49f903","modified":1587870916605},{"_id":"source/_posts/leetcode.md","hash":"7bbf25e25974d266f9228c015e22c39460dafc48","modified":1587709218327},{"_id":"source/_posts/mc-td.md","hash":"be054820650ded85517dba334ce3b7436d8d335c","modified":1557757625710},{"_id":"source/_posts/options-critic.md","hash":"9974f35ef0009798c381ff52aa39da178f3250eb","modified":1586862380171},{"_id":"source/_posts/random-network-distillation.md","hash":"6c2a20583ea588deceb15e99e036f7dc977d647b","modified":1592920749263},{"_id":"source/_posts/overleaf.md","hash":"716a82113680eef37f06c539be3c22a0f005b5e4","modified":1587049077678},{"_id":"source/_posts/raspverry4b.md","hash":"03f38a9ac85ff1065b7840982ff1a70f0877eed6","modified":1587781391276},{"_id":"source/_posts/rl-an-introduction.md","hash":"c1920a9fa943f0e1bb2456607610921b6a268de1","modified":1586343205627},{"_id":"source/_posts/rl-classification.md","hash":"a4ae5f03b2e8f3e6807af1946789b08599fc0089","modified":1567506437253},{"_id":"source/_posts/rl-code-pit.md","hash":"b2798b5df455161c2d831b628a241e80b30c91fb","modified":1590053922273},{"_id":"source/_posts/rl-rough-reading.md","hash":"f9ecf542cbcbb8b8eb1eae1ad2111872a4de947a","modified":1586577603946},{"_id":"source/_posts/rl-with-deep-energy-based-policies.md","hash":"d210bf3f51fae1d66446f34afda70f3de12096f7","modified":1562494753227},{"_id":"source/_posts/rl2.md","hash":"ca5d30e182596194f8b098e9b478cafa960bc43f","modified":1559438363071},{"_id":"source/_posts/rl3000questions.md","hash":"5415bf06a8b1498c75ebcef93eb50eff2ed0582b","modified":1587994144620},{"_id":"source/_posts/sarsa-and-q-learning.md","hash":"53b718837e6f1785881b0a6280a076350019c895","modified":1557757625712},{"_id":"source/_posts/something-hard-install-docker.md","hash":"fc2d9a4da062cff55ffc536fbd454875f613d1e8","modified":1557757625713},{"_id":"source/_posts/some-issues-of-install-packages.md","hash":"ebbd00f08e6df85c321f827817472610aad81c03","modified":1584599950648},{"_id":"source/_posts/ss.md","hash":"5de358e8cc00a86c56a7020acb9dc032572237f7","modified":1559401201275},{"_id":"source/_posts/universal-value-function-approximators.md","hash":"e179bc986bd5f436ee1ab79fccae3ee522c098ca","modified":1559445327597},{"_id":"source/_posts/tf2-gaussian-distribution.md","hash":"e26b6ca7bdfb930e62e00b6cc320df5d973ed9a0","modified":1586347389830},{"_id":"source/_posts/use-conda-env-in-jupyter.md","hash":"379e1ac87fee06e356e941c6cfe083109e5911c7","modified":1565052127425},{"_id":"source/_posts/win-rightclick-create-md.md","hash":"1bbca26e0f4ed324c8991d828a286bf5531a3cc4","modified":1567506437253},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面.md","hash":"b706204d35b79880cde7833d15747efac495d1a0","modified":1557491970404},{"_id":"source/_posts/创建ML-Agents的Docker镜像.md","hash":"06bf4cac8b451b757901707b23f4410435d47f4b","modified":1557491970411},{"_id":"source/_posts/价值与贝尔曼方程.md","hash":"eb9928dc0423f468367b54ec3c1bb8fa4a5adfde","modified":1557731399423},{"_id":"source/_posts/强化学习.md","hash":"addc41e29da23798c62c04db94f4252acf85b12e","modified":1592920688944},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程.md","hash":"77ebb7796faf21972008173becf4cf65a336314e","modified":1590054225886},{"_id":"source/_posts/强化学习基本概念.md","hash":"2b1d653f9d16e8c2280adf3f3ed4ba2d0d183f24","modified":1557673168294},{"_id":"source/about/index.md","hash":"eab2633e07b9aad2d5501fa249fff97f970da55d","modified":1567506437254},{"_id":"source/_posts/强化学习的里程碑.md","hash":"b4517e2fc17e1908207786d5562f413d0a068c64","modified":1557491970414},{"_id":"source/categories/index.md","hash":"15ba6b122beaba374443eb7b00c437f0c7637ee4","modified":1546668958290},{"_id":"source/schedule/index.md","hash":"5912ffd66cda4f962850a349b6d280f3c27dc82d","modified":1546668958290},{"_id":"source/sitemap/index.md","hash":"8e394c9a661e0f188a5cf8041dd3d717155ab93a","modified":1546668958291},{"_id":"source/tags/index.md","hash":"77841168533e660b1fd1a20477fa38d439014fc0","modified":1546668958291},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1546668958310},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1546668958309},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1546668958310},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1546668958310},{"_id":"themes/next/layout/_layout.swig","hash":"b44117fd6af5bab30e627e31d3553fac40ef72d2","modified":1557421590536},{"_id":"themes/next/layout/index.swig","hash":"7c632973645ab3f413f1522f8c81536b785a35ac","modified":1557423425226},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1546668958328},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1546668958328},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1546668958328},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1546668958328},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1546668958328},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1546668958329},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1546668958312},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1546668958313},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1546668958313},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1546668958313},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1546668958313},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1546668958313},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1546668958313},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1546668958313},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1546668958313},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1546668958314},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1546668958314},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1546668958314},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1546668958314},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1546668958329},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1546668958314},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1546668958314},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1546668958329},{"_id":"themes/next/languages/zh-Hans.yml","hash":"2d234cc742b44af5824b85fbdc834c93c1f9105a","modified":1555257095793},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1546668958448},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1546668958448},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1546668958448},{"_id":"source/_posts/Evolution-Strategies-2017/algorithm1.png","hash":"f4431c520e0ad825bd463cc447323ebe912259c8","modified":1558625547574},{"_id":"source/_posts/Evolution-Strategies-2017/mujoco.png","hash":"231bd199e610864138cde0c912057836a6d8cf16","modified":1558625547577},{"_id":"source/_posts/Evolution-Strategies-2017/parallelization.png","hash":"1f02681b5fe1680f23b4b48a5ead120f18e07968","modified":1558625547577},{"_id":"source/_posts/Hindsight-Experience-Replay/Her.png","hash":"0308d074bc1bd852f8424c8c29173fe8cd13992f","modified":1559057131902},{"_id":"source/_posts/Hindsight-Experience-Replay/hindsight.png","hash":"d1859e5e2a5fd826f461e4a6d5d57dd38c79c249","modified":1559057131905},{"_id":"source/_posts/PaStaNet/Long_tailed_distribution.png","hash":"ac1455a897618c1eee9f7ae400aabb84f5192714","modified":1586691416990},{"_id":"source/_posts/PaStaNet/table3.png","hash":"6a1140c96cbeb40317bf9c24398ac87918070f9a","modified":1586679377828},{"_id":"source/_posts/Prioritized-Experience-Replay/normalized-score1.png","hash":"d57115611a74e0a25c82668678d0d702c2ce0d45","modified":1558625547582},{"_id":"source/_posts/Prioritized-Experience-Replay/visio.vsdx","hash":"82c57a859ab29e92ede4d9d0ee453782232b1899","modified":1558625547583},{"_id":"source/_posts/asynchronous-methods-for-drl/lossfunction.png","hash":"be9353d8c2b1b81beeadf4c004c0abe4348c3792","modified":1559209944499},{"_id":"source/_posts/asynchronous-methods-for-drl/gd.png","hash":"793f5d0e75c1f42511923da906f93d70b3114727","modified":1559209944498},{"_id":"source/_posts/asynchronous-methods-for-drl/sgdvsgd.png","hash":"83665a9158ebab3a84c4ce770002efb304074dd4","modified":1559209944500},{"_id":"source/_posts/asynchronous-methods-for-drl/regression.png","hash":"b8090fce34ea2ea921bbe44954f499b719d6b232","modified":1559209944499},{"_id":"source/_posts/burn-system2raspberry-in-macos/formatter.png","hash":"443dc06b7d525303306e82b03c9ddaee4280383c","modified":1587715871269},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_08-30-41.png","hash":"83a2093c01bce4def53352c4c8d71ec27cccaef0","modified":1546668958272},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_09-42-07.png","hash":"b95f4dcf0d9e2265cf2061a7e539b2bb9e6656a1","modified":1546668958272},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_09-56-41.png","hash":"82d79b39f34388c7c3e1d53d0df9c184aff173b5","modified":1546668958272},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_10-03-30.png","hash":"14d91d4a1075adb4b2c900f86f08469d360eabe2","modified":1546668958272},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_10-57-56.png","hash":"2ff022de36958966b11fa2767a8ef352464df350","modified":1546668958273},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_10-56-08.png","hash":"0f20561591ddeadfe0df86f1855f0d02aa5a8dc2","modified":1546668958273},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_10-11-01.png","hash":"4f0c7c10d84f0a9736119525b8955cecd38698c1","modified":1546668958273},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-32-08.png","hash":"d66fb1805a685b4fd7b35cc769e1ef4b6d406f0e","modified":1546668958277},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-33-27.png","hash":"729ff5819f4896a125b6e78fb7f11bc5755ece9e","modified":1546668958277},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_17-05-30.png","hash":"a89542c74c04189645d7778481277b6d509245f1","modified":1546668958279},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_17-12-36.png","hash":"cd606d229c598acb674599866015c25fb4b49491","modified":1546668958280},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_17-39-07.png","hash":"cc5d08ae28ac589ddd8fc1a32511cd57d2f1e77a","modified":1546668958280},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_18-08-49.png","hash":"bf515ccdeaa1149af9c1d483436cac1e93625fc5","modified":1546668958281},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_18-14-21.png","hash":"82c07ac184b8d89aa11e718bcf12293e6554bfb7","modified":1546668958281},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_18-11-49.png","hash":"d70c211b0801f50eff38b5d5b4d297ed7b705e0f","modified":1546668958281},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_18-20-07.png","hash":"6ffc920c6da4731a3466a2aa04a9f86a8589efa5","modified":1546668958282},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_18-31-16.png","hash":"648be7fa6a62443d9da38f531d2e8c4768def0e8","modified":1546668958282},{"_id":"source/_posts/dynamic-programming/gridworld.png","hash":"985f08ef2435799c50fb2b0552534e77d361f6f1","modified":1557732232730},{"_id":"source/_posts/dynamic-programming/dp.png","hash":"d6f93fd511036ee9557f60a7d1bb614b76c7824f","modified":1557757625707},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/finalmeanrate.png","hash":"267198b3a9165098038d037d5041c7f5f087e04c","modified":1559209944502},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/issue.png","hash":"5233a522e2346c0734a9ac4a7e8d3d796dbbdcbb","modified":1559209944502},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/issue2.png","hash":"1a616d5bff1afee2e75ea83d63b5bd45a8d211e1","modified":1559209944502},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/issue3.png","hash":"97b54824c376a59b1596989fc8c45f67e8e0599a","modified":1559209944502},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/trainingtime.png","hash":"00f246434d944d815633a6fa8c659f521a0786b9","modified":1559209944507},{"_id":"source/_posts/install-atari-and-box2d-on-win10/box2d.png","hash":"059540f153a08d5d89142a8b652c3383d800f93d","modified":1571322422385},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/sr-example.png","hash":"2243f5ebc512e3116f20f2b193f917d2121b398a","modified":1586401247300},{"_id":"source/_posts/leetcode/42.png","hash":"4dbe378864456df5f8db0e44cfa308ba0640656c","modified":1587705574953},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/inequality.png","hash":"0a09a108a132dcf31d16ca6feb18449911eeaa5b","modified":1562494753196},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/x-x^2.png","hash":"71a404f011e958e5e5f2bc28f6ebb794e37185d9","modified":1562494753209},{"_id":"source/_posts/mc-td/dp.png","hash":"d6f93fd511036ee9557f60a7d1bb614b76c7824f","modified":1557757625710},{"_id":"source/_posts/mc-td/mc.png","hash":"05687b207b833daf3801711572bfc9f687d51ceb","modified":1557757625710},{"_id":"source/_posts/mc-td/td.png","hash":"31e9c68a2ff7e27a51141aee7afbbe7f2bb166b0","modified":1557757625711},{"_id":"source/_posts/rl-classification/non-stationary.png","hash":"1f19121d34404e32f3f2da667f9cab1752b1f3ea","modified":1557673168291},{"_id":"source/_posts/rl-classification/stationary.png","hash":"c316b7092c017c420d2b877c36813f2644775879","modified":1557673168291},{"_id":"source/_posts/rl-classification/model-classification.png","hash":"65beb87ac27c5e8a05a8e96a16b92234cec361df","modified":1557757625711},{"_id":"source/_posts/rl-classification/policy-based.png","hash":"1f50811df42bccb176a8d098721458ea32490852","modified":1557757625711},{"_id":"source/_posts/rl-classification/value-based.png","hash":"bfdf5b70c3f574985c32035807bc70c0d7f19f34","modified":1557757625712},{"_id":"source/_posts/rl-classification/图.vsdx","hash":"cbea18d1d388a938c59c1c0221b9d07466dab1d3","modified":1557757625712},{"_id":"source/_posts/rl-rough-reading/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1586414356477},{"_id":"source/_posts/rl-rough-reading/diayn-pseudo.png","hash":"ed45e55f63b68bb59ead817c0ea2857e3f936d71","modified":1562494753219},{"_id":"source/_posts/rl-rough-reading/diayn.png","hash":"426707f503d64b2dc98bfe5e70d61c2eab5df62b","modified":1562494753220},{"_id":"source/_posts/rl-rough-reading/gorila.png","hash":"beeb25e82565148d03da6f5b7fdca975fb71d8f0","modified":1562494753221},{"_id":"source/_posts/rl-rough-reading/mb-mpo-visio.png","hash":"b9136d3a78ea9f82429e8e1357e18ed1e5514950","modified":1562494753223},{"_id":"source/_posts/rl-rough-reading/visio.vsdx","hash":"822c929a60c77a47bc77ce97a301650487e2b40c","modified":1562494753227},{"_id":"source/_posts/rl-with-deep-energy-based-policies/multimodal-policy.png","hash":"6312bf0d05d23b81556bc20505b5bd35d7378010","modified":1562494753415},{"_id":"source/_posts/rl-with-deep-energy-based-policies/unimodal-policy.png","hash":"56ef3ec995d3fd83cc901a91c8bd44d1af991ed3","modified":1562494753428},{"_id":"source/_posts/something-hard-install-docker/1.png","hash":"87549df7ed37d6d7007050f9ffaa135624924668","modified":1555089337873},{"_id":"source/_posts/use-conda-env-in-jupyter/1.png","hash":"4aac952f561c9a1f1327b93faa841d003dd6601c","modified":1555089337871},{"_id":"source/_posts/use-conda-env-in-jupyter/2.png","hash":"e48c030ee7c801ac51d34cab8ba855f588dcb835","modified":1555089337872},{"_id":"source/_posts/use-conda-env-in-jupyter/3.png","hash":"b83963e3d39d16262fe1a0579fc9ef64a3cff526","modified":1555089337872},{"_id":"source/_posts/use-conda-env-in-jupyter/4.png","hash":"f7583c736bc02436bf03e99121b69f73fe60ddf5","modified":1555089337873},{"_id":"source/_posts/win-rightclick-create-md/1546050455.jpg","hash":"a08a8362d1de59e1e8e5751b28a3fff0d87c47c1","modified":1546668958270},{"_id":"source/_posts/win-rightclick-create-md/20181229103503.png","hash":"836a0cc95e251f2b72d69fbb1690424b3ad37963","modified":1546668958270},{"_id":"source/_posts/win-rightclick-create-md/20181229105408.png","hash":"07faaf69e53752c52dd3307aa8716d5f91d2b124","modified":1546668958271},{"_id":"source/_posts/win-rightclick-create-md/20181229105300.png","hash":"8ca42182e6814c4a2fc27b57fff1dbfb89e7c949","modified":1546668958271},{"_id":"source/_posts/win-rightclick-create-md/20181229103752.png","hash":"6684b234550bfeedbc21a5070450a82a5d4a0086","modified":1546668958270},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/10.png","hash":"064596db0933c2b12490abd6f3989943741a12d1","modified":1547812235111},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/6.png","hash":"47bbca2eb1ddc68d9b6cf156cba85ef210735bd2","modified":1547812235111},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/8.png","hash":"0ce398ad32bc5261fa78eab08b724c8ad96ee56b","modified":1547812235114},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/9.png","hash":"617ce93d753ffa6960bc7806464fd2749231ae95","modified":1547812235114},{"_id":"source/_posts/价值与贝尔曼方程/example1.png","hash":"7a6334c4fce383da569f77b96683d71de9a587ba","modified":1557491970405},{"_id":"source/_posts/价值与贝尔曼方程/example2.png","hash":"646cf9c4c0cafeec786e7b26d3138eb23a0c54c0","modified":1557491970406},{"_id":"source/_posts/价值与贝尔曼方程/example3.png","hash":"019485248ca5fa7e08bbee784ab84fd87e35482e","modified":1557491970406},{"_id":"source/_posts/价值与贝尔曼方程/example5.png","hash":"32caae8ff14e681b53102503a73ee657f40b4265","modified":1557491970408},{"_id":"source/_posts/价值与贝尔曼方程/q.jpg","hash":"e6d379acfa4ccc453a63a4095574c5c8519daea3","modified":1557491970409},{"_id":"source/_posts/价值与贝尔曼方程/example6.png","hash":"68d74c5001b82eda81bf49ed063b72c1c9ef2078","modified":1557491970408},{"_id":"source/_posts/价值与贝尔曼方程/qsa.jpg","hash":"fff83c05644ae4e30b98188acc7fa7866ea5ded3","modified":1557491970409},{"_id":"source/_posts/价值与贝尔曼方程/v.jpg","hash":"b4346c668d4fc48a82dc2efff7d5365bdd3ab68a","modified":1557491970410},{"_id":"source/_posts/价值与贝尔曼方程/vs.jpg","hash":"0444cdf1b4c9f8fa54c9eb2413ca41007850b1bc","modified":1557491970411},{"_id":"source/_posts/价值与贝尔曼方程/vq.jpg","hash":"ebeb9cd0ae060891fe557f73707dfcf9803c021c","modified":1557491970410},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-44-58.png","hash":"711c592ab41c5c3659c6699b950deb0b064d46d4","modified":1546668958284},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-52-49.png","hash":"1e46bb570e4a512f232955983ea18b2190d17398","modified":1546668958285},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-01-32.png","hash":"146aabfccfdf3bfb90309df88304564634ab4aa7","modified":1546668958287},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-02-47.png","hash":"d1d28c63bc96287dc882511a60f0f6a47573836e","modified":1546668958287},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-52.png","hash":"c862d9841a45e1eadcefff91d0ed5f3d65814283","modified":1546668958289},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-15.png","hash":"5ea2f1add0d50e26e0fdece4e6b31641c5c73e8f","modified":1546668958288},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-16-44.png","hash":"5f17cce8addd197a11a86b32875c344e11a8c053","modified":1546668958289},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-25-17.png","hash":"94927046e1aa72159979c02ebae6e6c749a634d4","modified":1547812235108},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-18-40.png","hash":"6138514960948cd4fa20fc9ed6b515919af89110","modified":1546668958289},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-35-56.png","hash":"feecbf78f4e1264cc735fb38a2a2886cfaf4a036","modified":1547812235108},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-39-26.png","hash":"7811d046eded5e6b1535a4f54657e424ac0e5bff","modified":1547812235108},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-11_15-02-16.png","hash":"52698fed5a3555474d50f06aebc1817c09aafae6","modified":1547812235109},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-11_22-38-42.png","hash":"7a1325c15aca2ef2d32e009e97cca73fa3bb05f4","modified":1547812235109},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/MPs.jpg","hash":"3e2a1c41c5cfcbf127dbd97d3e7ff8d3c1b9bf11","modified":1557491970412},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/agent-env.png","hash":"dfe83ed4336f01bbdcdd4e711754ecb5512b16e7","modified":1557491970412},{"_id":"source/_posts/强化学习的里程碑/GKBattleWithDeepBlue.jpeg","hash":"49cd9889ae2ff006e19d2f24b1d3948fafc46f9c","modified":1557191075287},{"_id":"source/_posts/强化学习的里程碑/.DS_Store","hash":"706cf36a14207f18a88d3f1f22ff2ad6ffc9bd62","modified":1557196840128},{"_id":"source/_posts/强化学习的里程碑/KeJieBattleWithAlphaGo.jpeg","hash":"944ea54a8ec7a0d61b08d3548c7ddecf82a6d2d1","modified":1557190473042},{"_id":"source/_posts/强化学习的里程碑/LeeSedolBattleWithAlphaGo.jpeg","hash":"581e4c5538dc4fd621531ae2c368612a90778b3d","modified":1557189726040},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546668958413},{"_id":"source/_posts/Evolution-Strategies-2017/algorithm2.png","hash":"03ee451c83603dba9a3f7e3febdac0803712c37d","modified":1558625547574},{"_id":"source/_posts/Evolution-Strategies-2017/frame-skip.png","hash":"d1bdd98e83cd9ea8779a7e95c70a6175f9e641c1","modified":1558625547577},{"_id":"source/_posts/FuNs/illustration.png","hash":"e2aab98b9a6640eaa582f1046dfcdc452f8305a0","modified":1587957400170},{"_id":"source/_posts/Hindsight-Experience-Replay/rewardshape.png","hash":"d412555c0f7bfa083e620b228a60f7b1c377bbe1","modified":1559057131906},{"_id":"source/_posts/Hindsight-Experience-Replay/singlegoal.png","hash":"69f43fc979088448ab910a05113797f35be15aad","modified":1559057131907},{"_id":"source/_posts/Hindsight-Experience-Replay/tasks.png","hash":"6c3dc1f748102fa8e5e974eb0c6e017f4350287b","modified":1559057131908},{"_id":"source/_posts/PaStaNet/table4.png","hash":"2e2dc4d022997cd85b54ac846519d341742f4663","modified":1586679391710},{"_id":"source/_posts/Prioritized-Experience-Replay/sum-tree.png","hash":"1159ede81fafd294e61951cf9907ded8644b89ae","modified":1558625547583},{"_id":"source/_posts/asynchronous-methods-for-drl/table1.png","hash":"28f03af54f63ab758819d0dfdc3af35a27d1fa5d","modified":1559318509827},{"_id":"source/_posts/asynchronous-methods-for-drl/table2.png","hash":"3ea357bebc2ba31c1428b11a4f3f40e9014aefdb","modified":1559318509829},{"_id":"source/_posts/burn-system2raspberry-in-macos/start.png","hash":"a49decefe2aef3ad6d5630bcfcadbcb8890d4f90","modified":1587715950435},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_13-49-28.png","hash":"ad2ac085e8d096290882398ddf0f402843be6f86","modified":1546668958274},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-24-49.png","hash":"f847e0683355dd3b8c2f94070d689ab64eee5b8a","modified":1546668958275},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-40-53.png","hash":"b9985565ba4eb37e3f68440f1266494959b816c7","modified":1546668958278},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-44-22.png","hash":"5bacfd1dd4315392a705fba900d540a3baca7ef2","modified":1546668958279},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/env.png","hash":"9c12851f8dca8aee4c24e4679ceceb45b60f13ca","modified":1559209944501},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/meansuccessrate.png","hash":"066db04686ddaca262608d9f8cbe9dba563bbc2a","modified":1559209944503},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/sampleefficiency.png","hash":"c86d3324bc229fef8adde3d0e8d49a7a638e695b","modified":1559209944507},{"_id":"source/_posts/learn-grpc/gRPC.svg","hash":"0736849feef0a4cda3d3f665ed96548c20dfe1a2","modified":1587786967219},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/MEP.png","hash":"1095b43f6207f9b9bb294c72b91bfbc0ff28c16d","modified":1562494753195},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/env.png","hash":"da7f5b533d082625d12a83c653763d6f5a0ae79a","modified":1562494753196},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/pseudo.png","hash":"a12f87c7ddac39d98e41a3aa341e5657dc7523b9","modified":1562494753199},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/training-time.png","hash":"f77a955f7b43d9db2789b80a1c15d3c485ca60a4","modified":1562494753208},{"_id":"source/_posts/rl2/meta.png","hash":"149f386ffc5a373c8d6cabe90baae11925450186","modified":1559318509835},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/1.png","hash":"af326825623bbd798b64c0d7b0d55e80987a3908","modified":1547015458196},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-29-30.png","hash":"47fd9073f9cba7b1e7772184e1592d888b0e671b","modified":1546668958285},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-36-31.png","hash":"7b20a4cb60606cc964ca46914ef232b402ae2fd4","modified":1546668958286},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-28-19.png","hash":"cfed661288b897840cf511cf5fc55ff09d792ed9","modified":1546668958288},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/MP.jpg","hash":"1372f421a8b8fb1c0393b80c2e90fcb1b7cad8b5","modified":1557412916454},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/MDP.jpg","hash":"3ffd4dca7a616a6e6aeafc66698f32899f225780","modified":1557412916454},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1546668958315},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1546668958317},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1546668958315},{"_id":"themes/next/layout/_partials/footer.swig","hash":"9318c7025cdac9ac04f047d99e232497e5e00c14","modified":1546668958317},{"_id":"themes/next/layout/_partials/head.swig","hash":"481ae575da1c9857d194dadf3e30d3de5ce6ee9b","modified":1557426253410},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1546668958318},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1557677765359},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1546668958319},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1546668958318},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1546668958320},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1546668958320},{"_id":"themes/next/layout/_macro/my-copyright.swig","hash":"03e23f498cc092617b02f42c860ee6ac29691de3","modified":1546668958315},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1546668958321},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1546668958316},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1546668958316},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"5f7f02ab3e6da84bdd46028611ee538a64ba4e2e","modified":1546668958316},{"_id":"themes/next/layout/_macro/post.swig","hash":"a44e4ec7a92381e6695689a83918dab67659ad2a","modified":1546668958316},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1546668958317},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1546668958326},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1546668958317},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1546668958326},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9dea45fd7b12c0969361c6258b3bcef0e0495713","modified":1557676844401},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1546668958326},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1546668958326},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1546668958326},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1546668958327},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1546668958327},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1546668958330},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1546668958330},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1546668958330},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1546668958330},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1546668958330},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1546668958330},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1546668958330},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1546668958331},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1546668958331},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1546668958413},{"_id":"themes/next/source/images/Kicon.jpg","hash":"4373f42f4a36dac017399219a33355476cdd515a","modified":1546668958413},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1546668958413},{"_id":"themes/next/source/images/apple-touch-icon.png","hash":"baec5880136ee04093a30b43767a09c3a3ff225a","modified":1546668958414},{"_id":"themes/next/source/images/alipay.jpg","hash":"fcff318686daaa2de536e3bbc4d0f692ae87eb61","modified":1546668958413},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1546668958414},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1546668958414},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1546668958414},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1546668958414},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1546668958414},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1546668958414},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1546668958415},{"_id":"themes/next/source/images/favicon-16x16.png","hash":"dbb4ef84d00d2fdf50a12ff69b0c3e988f5888ba","modified":1546668958415},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1546668958415},{"_id":"themes/next/source/images/favicon-32x32.png","hash":"3376ab0494aaf4584d1b5ebfdb5c6d6b53582410","modified":1546668958415},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1546668958415},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1546668958415},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1546668958415},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1546668958416},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1546668958416},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1546668958416},{"_id":"source/_posts/Hindsight-Experience-Replay/finalvsfuture.png","hash":"c7212de7b38806d4a0309910ad8c1ce1184cc1df","modified":1559057131903},{"_id":"source/_posts/PaStaNet/table7.png","hash":"58004253c059a877487fb89e7d7d8f3659b57a5b","modified":1586678627042},{"_id":"source/_posts/Prioritized-Experience-Replay/pseudo.png","hash":"aa580d3591d557b78f9122f979f1e3b08d57fa29","modified":1558625547583},{"_id":"source/_posts/asynchronous-methods-for-drl/a1stepq.png","hash":"9b07fb37e0c19081accc2bf984bcc037a9382172","modified":1559209944496},{"_id":"source/_posts/asynchronous-methods-for-drl/a3c.png","hash":"e73a84246790f8e0a6a62b276a98c9f5fcefdf4f","modified":1559209944497},{"_id":"source/_posts/asynchronous-methods-for-drl/anstepq.png","hash":"919308ed9841a66cf8fb53792ea1c452136698a4","modified":1559209944498},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-29-58.png","hash":"7593af06e466318684d72dd51e0e7d95f5fae824","modified":1546668958276},{"_id":"source/_posts/dynamic-programming/vi.png","hash":"3e2c0e220045b7ec5354565d20a990f8fb09e0d5","modified":1557735968901},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/pearsoncorrelation.png","hash":"e7e97a270a315cf406bdf37740646e82ac93375e","modified":1559209944504},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/sample-efficiency.png","hash":"a4d851bbc8126bf552bbf4c1669decb7dd51a6e7","modified":1562494753204},{"_id":"source/_posts/rl-rough-reading/gorila-pseudo.png","hash":"55db710222283c97d79eb4dee6bc374f90bfeef2","modified":1562494753221},{"_id":"source/_posts/rl-rough-reading/cdp-sg.png","hash":"0596abf360a29555b102daf1ee9553132410c2a1","modified":1562494753219},{"_id":"source/_posts/rl-rough-reading/mb-mpo-pseudo.png","hash":"4ba8ca1132a492540276bafd688eac3397e1eaf3","modified":1562494753223},{"_id":"source/_posts/rl-rough-reading/naf-pseudo.png","hash":"694309346a8436db231f565f95ae4979b56d7d28","modified":1565052127425},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/3.png","hash":"fe7dfe4d8603d45162f9d1769931d03386efd1fa","modified":1547016184534},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/4.png","hash":"8f156494735cf0350b426abe850903dc712e08cf","modified":1547016267962},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/M.jpg","hash":"60afd253a45442fa846c2e960a34fe36974f7315","modified":1557329433621},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546668958321},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546668958321},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546668958412},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546668958412},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546668958408},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546668958408},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1546668958409},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"0e2196955d6229673c92143a929ff5a54d04a4c7","modified":1546668958416},{"_id":"source/_posts/Hindsight-Experience-Replay/fourmodel.png","hash":"4e623e54421af73bc241fb49c4e7f167843d0ede","modified":1559057131904},{"_id":"source/_posts/PaStaNet/fig4.png","hash":"4794c4d1f78f76be437f78c2768e37446c66f7e5","modified":1586661861567},{"_id":"source/_posts/PaStaNet/table1.png","hash":"cc6ac1b2d77843c9d2886c7b641cabe6b33ad4cf","modified":1586679270763},{"_id":"source/_posts/PaStaNet/table2.png","hash":"dc5724985d80b2cde44c47185602547f72c46ecd","modified":1586679286410},{"_id":"source/_posts/Prioritized-Experience-Replay/normalized-score.png","hash":"702b384a45e97ebaf5289a38efe9340767673fb6","modified":1558625547581},{"_id":"source/_posts/burn-system2raspberry-in-macos/downloads.png","hash":"3930bd3d402fa86496a56e592a9704070cdba7ff","modified":1587715573218},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/experiment2.png","hash":"e4a37c574dfc8fc8ecd8ee1b288341d554a90991","modified":1585980299615},{"_id":"source/_posts/rl-rough-reading/MANet-structure.png","hash":"227babf64607017c5e0ed9ebdec0548ea12fe26c","modified":1586255584682},{"_id":"source/_posts/options-critic/pseudo.png","hash":"b94e342b5b07f6c08c687d0aff64050f844350de","modified":1586862281517},{"_id":"source/_posts/rl-rough-reading/cdp-pseudo.png","hash":"700e498fb25894be143e019197da28c0ca982bd5","modified":1562494753214},{"_id":"source/_posts/rl-with-deep-energy-based-policies/pseudo.png","hash":"fb069fcc0e0a27003e31ebdbbfc6e52c013e43a6","modified":1562494753428},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/7.png","hash":"a588ebe2f2088c621a5260a9a0086b79d40408b9","modified":1547812235113},{"_id":"source/_posts/价值与贝尔曼方程/example4.png","hash":"11b071b9e060a8222b23394fc1cf4fad7280f7ea","modified":1557491970408},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1546668958318},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1546668958319},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1546668958318},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1546668958319},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1546668958319},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1546668958319},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1546668958320},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1546668958320},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1546668958321},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1546668958320},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1546668958321},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1546668958321},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1546668958322},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1546668958322},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1546668958322},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1546668958322},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1546668958322},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1546668958323},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1546668958323},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1546668958323},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1546668958323},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1546668958324},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1546668958323},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1546668958324},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1546668958324},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1546668958324},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1546668958324},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1546668958325},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1546668958325},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1546668958325},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1546668958325},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1546668958326},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1546668958325},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1546668958326},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1546668958328},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1546668958327},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1546668958327},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1546668958328},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1546668958412},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1546668958412},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1546668958412},{"_id":"themes/next/source/css/_variables/base.styl","hash":"c01ae2e4235083b6730f9e4a72752bd27376460f","modified":1546668958412},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"8f0760e72b67818f73f1d8e178d3258e4780315b","modified":1546668958408},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1546668958408},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1546668958409},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1546668958408},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1546668958417},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1546668958417},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1546668958417},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1546668958418},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1546668958418},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1546668958419},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1546668958419},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1546668958419},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1546668958419},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1546668958420},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1546668958420},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1546668958423},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1546668958425},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1546668958425},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1546668958427},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1546668958427},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1546668958428},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1546668958428},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1546668958429},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1546668958428},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1546668958429},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1546668958429},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1546668958429},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1546668958433},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1546668958434},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1546668958435},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1546668958435},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1546668958435},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1546668958435},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1546668958435},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1546668958436},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1546668958436},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1546668958436},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1546668958440},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1546668958437},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1546668958440},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1546668958437},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1546668958437},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1546668958437},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1546668958438},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1546668958438},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1546668958438},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1546668958440},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1546668958438},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1546668958438},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1546668958439},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1546668958438},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1546668958439},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1546668958439},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1546668958439},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1546668958445},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1546668958445},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1546668958447},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1546668958447},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1546668958447},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/17.png","hash":"8ab98d82828a90fdbbe9550c6e8f4a2aeaf6c33c","modified":1555089337891},{"_id":"source/_posts/Evolution-Strategies-2017/atari.png","hash":"4ac985cb7c9e0797f8bcc02e0d482bde90288468","modified":1558625547576},{"_id":"source/_posts/burn-system2raspberry-in-macos/cmd2.png","hash":"1feb661d88519d365d911121c47efbd8e47815ff","modified":1587716376340},{"_id":"source/_posts/dynamic-programming/iteration.png","hash":"ad52cf8b064058e77a0ffb995c047d9c0c25e411","modified":1557732628309},{"_id":"source/_posts/dynamic-programming/pi.png","hash":"8bb2d97d896e05a2f74dbd44598f19eb871f94ec","modified":1557734731113},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/mean-success.png","hash":"c8ceb00055b96b132be3df14fc424133efa70d8d","modified":1562494753198},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/2.png","hash":"249f4af7270f3d1d4d5058938671c596dc66fc5d","modified":1547016017783},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/MRP.png","hash":"08ab5eba51d5be16a0a9709d32e98137cd316187","modified":1557412916457},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1546668958434},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/16.png","hash":"f40be3c8ef3ef8803c17c9e749547396e3e92e90","modified":1555089337889},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/2.png","hash":"900849540a078f00d12be63bb507a039dd37de7a","modified":1555089337897},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/4.png","hash":"d80992d6b39c753ac20baec4a50073c907b706e2","modified":1555089337914},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/7.png","hash":"6847e7b98b582d5941ebe109154477ab72be1fba","modified":1555089337919},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/5.png","hash":"30f3723a5f63ceb668c0ceb838b27da85c262cc3","modified":1555089337916},{"_id":"source/_posts/PaStaNet/fig5.png","hash":"540f3b676274b5a5159e308164a1b012343d7c49","modified":1586661887913},{"_id":"source/_posts/PaStaNet/table6.png","hash":"63605d7f525a9665f6b13371d306f58a25fe99cc","modified":1586678614813},{"_id":"source/_posts/burn-system2raspberry-in-macos/success.png","hash":"38c9a864a70b4338e749e344d4b6fe36a29e3808","modified":1587716964348},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/pseudo.png","hash":"5e7b87272623cc17949a5b37ac0e7b2fc5421bc8","modified":1559209944506},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/motivating-example.png","hash":"98f0c08501194fbe39b30d0bd2e017362a790d7a","modified":1585980109670},{"_id":"source/_posts/rl-rough-reading/Agakov.png","hash":"d3c93953485488c6b7e5e28f3962505eafa3bfa7","modified":1562494753212},{"_id":"source/_posts/universal-value-function-approximators/sg.png","hash":"6ead6568bf504ee9a5f7ab3aee112b2417631fda","modified":1559442696284},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1546668958331},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1546668958331},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1546668958327},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1546668958327},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1546668958331},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1546668958331},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1546668958331},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1546668958334},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1546668958394},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1546668958407},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1546668958407},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1546668958407},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1546668958408},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1546668958408},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1546668958405},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1546668958408},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1546668958409},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1546668958409},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1546668958409},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1546668958409},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1546668958409},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1546668958410},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1546668958410},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1546668958410},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1546668958411},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1546668958410},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1546668958411},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1546668958410},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1546668958411},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1546668958411},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1546668958411},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1546668958411},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1546668958412},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1546668958412},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1546668958412},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1546668958419},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1546668958422},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1546668958428},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1546668958428},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1546668958422},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1546668958429},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1546668958430},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1546668958430},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1546668958425},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1546668958425},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1546668958425},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1546668958426},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1546668958426},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1546668958427},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1546668958427},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1546668958426},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1546668958427},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1546668958444},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1546668958445},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/1.png","hash":"1fb0066b7b6b502080c42ba8d336d41bb0c86138","modified":1555089337875},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/11.png","hash":"806bd3d8b1556a72083f5357c8c5220c127cb5ec","modified":1555089337879},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/21.png","hash":"3c45b12dc0e1e4929ea22ca0d14740062ccc2280","modified":1555089337901},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/23.png","hash":"72112f7660bdb4d4f7096607745f7dd4760a86ed","modified":1555089337904},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/3.png","hash":"139fafcf0d0ec69aa31336e2f07be08afabc96cf","modified":1555089337913},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/6.png","hash":"e4c51c5ffb065d86f98621fc3cbc73037b6d516a","modified":1555089337917},{"_id":"source/_posts/PaStaNet/fig8.png","hash":"3a465f7d85636e2c854fa80936c527d306ac11a9","modified":1586662111486},{"_id":"source/_posts/Prioritized-Experience-Replay/learning-speed.png","hash":"d0473fd72e38609063a631c24e2c440347560da3","modified":1558625547580},{"_id":"source/_posts/asynchronous-methods-for-drl/threeoptimizer.png","hash":"b5b0926d093cf93a7d02a4fad026a4df19605f21","modified":1559318509831},{"_id":"source/_posts/burn-system2raspberry-in-macos/end.png","hash":"9c3fba37bb3da9ee3fc3f5960c5d99ff5c5967c9","modified":1587716141733},{"_id":"source/_posts/PaStaNet/fig1.png","hash":"b6eee30f1e28c22374b8ef893386271ebfea9261","modified":1586656167578},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/5.png","hash":"b649040df6d1ee3c8aff5dbfbfbe4d55168f5d98","modified":1547016789406},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1546668958421},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1546668958422},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1546668958433},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1546668958433},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1546668958446},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/12.png","hash":"40ee94e807e5fb8107a389669696df5b88c77f6e","modified":1555089337881},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/14.png","hash":"487768f9ce9a801ba04652376a7a1e8e3efbf8ff","modified":1555089337885},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/15.png","hash":"2c612516fef737d86623692f8bdc75f4c687b8cd","modified":1555089337887},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/19.png","hash":"70457762d1bd3dd19da38c8ef970f889a5c87e34","modified":1555089337895},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/22.png","hash":"4b16ac8d30269c22ff4c79185ce28c57af303bac","modified":1555089337902},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/26.png","hash":"d8cf18e3730c405f6d6c187b44b64a21010c7f0f","modified":1555089337908},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/28.png","hash":"4adaa88692fbacfbd2305513e82b14fda94753d2","modified":1555089337911},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/27.png","hash":"1ca67a0009a59aa3ae25ccc21d153a2ceb665fd7","modified":1555089337910},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/9.png","hash":"1e1a8203b22f610b8097db6f862f4abe57aa4fa1","modified":1555089337922},{"_id":"source/_posts/Hindsight-Experience-Replay/pseudo.png","hash":"494263d98f77b11524318620f2ccb9531628a373","modified":1559057131906},{"_id":"source/_posts/PaStaNet/fig10.png","hash":"e5454d75aa07b0e85076fb35faaaeedac2d92d42","modified":1586671173845},{"_id":"source/_posts/PaStaNet/fig9.png","hash":"96d91616441ee2cb54eac2cd15a563350507d9f6","modified":1586662129527},{"_id":"source/_posts/burn-system2raspberry-in-macos/cmd1.png","hash":"031cdfc6cedc720c73c39ef1988a2c12df2c190a","modified":1587716258130},{"_id":"source/_posts/rl2/meta-rl.png","hash":"17c8eace305bf615ddf9f74d1664a7cce73b961a","modified":1559318509834},{"_id":"source/_posts/rl-rough-reading/skill.png","hash":"330e407c59580b9e28ed124b903b4c28f9073150","modified":1562494753226},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1546668958332},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1546668958332},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1546668958332},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1546668958332},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1546668958332},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1546668958393},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"20bed71bbff09f8d54d157a24b1beb73f5a1f001","modified":1546668958393},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1546668958393},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1546668958393},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1546668958332},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1546668958394},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1546668958393},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1546668958394},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1546668958394},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1546668958394},{"_id":"themes/next/source/css/_common/components/post/my-post-copyright.styl","hash":"3496dc2ca5647bbf6a827f991d61849205a5955a","modified":1546668958335},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1546668958335},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1546668958335},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1546668958335},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1546668958336},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1546668958335},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1546668958337},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1546668958391},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1546668958336},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1546668958337},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"9c36b78790009816ed482cba3afeed31ebd0f770","modified":1546668958337},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1546668958392},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1546668958392},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1546668958392},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1546668958334},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1546668958392},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bf0a970e4153f82ba15b2d167f09f1759e19c346","modified":1546668958392},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1546668958393},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1546668958333},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1546668958334},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1546668958334},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1546668958334},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1546668958395},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1546668958395},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1546668958395},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1546668958395},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1546668958395},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1546668958395},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1546668958395},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1546668958396},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1546668958396},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1546668958396},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1546668958396},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1546668958404},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1546668958403},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1546668958404},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1546668958404},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1546668958404},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1546668958405},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1546668958405},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1546668958405},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1546668958333},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1546668958333},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1546668958333},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1546668958410},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1546668958410},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1546668958411},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1546668958420},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1546668958421},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1546668958421},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1546668958421},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1546668958421},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1546668958426},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1546668958426},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1546668958426},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1546668958426},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1546668958432},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1546668958427},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1546668958430},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/13.png","hash":"7381a254604ce2061aaf70e3ebc64cc36da5d78c","modified":1555089337883},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/18.png","hash":"c1a2a91e36bed04f9e1e68adf07c2f85edd942d9","modified":1555089337893},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/25.png","hash":"b1e06712ce17fd066ce754d15090c6f0482de641","modified":1555089337907},{"_id":"source/_posts/burn-system2raspberry-in-macos/imgs.png","hash":"d7ea2e13be01ad19b2b81cdbd7cf6e33a582368e","modified":1587715678043},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1546668958431},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/20.png","hash":"6702cec99aefcb56a3d87b681a65c06dd2db33ab","modified":1555089337899},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1546668958426},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/experiment3.png","hash":"81edc086a915b913bda5bbd92b09399b443552dc","modified":1585980331820},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/10.png","hash":"471375e196748ccb29bf050bc737a3b96b678513","modified":1555089337877},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/24.png","hash":"f567c2f97adc1279c643338f6783a4308e3f17cf","modified":1555089337905},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/8.png","hash":"a09129f8740daa1c9d31dbbbf3e690f1967dec03","modified":1555089337920},{"_id":"source/_posts/random-network-distillation/pseudo.png","hash":"5906f39ce0b3b690a2a0d76caae9f55aa2fc89c2","modified":1592919142558},{"_id":"source/_posts/rl-rough-reading/ere-pseudo.png","hash":"90d556bdbade3c5a852428d088d2068b5f69fb15","modified":1585806673999},{"_id":"source/_posts/dynamic-programming/pivsvi.png","hash":"1fc85aa51fb007eac28c7d89b6a8fce5c7415c49","modified":1557757625710},{"_id":"source/_posts/rl-rough-reading/6san.png","hash":"8fe64044267eb7eb768bf8069a59768cc0e8e60f","modified":1586064681006},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/pseudo.png","hash":"f1f7716a70d5df47e0a66b60056d1c5de124ff64","modified":1585980201304},{"_id":"source/_posts/rl-with-deep-energy-based-policies/1dgmm.gif","hash":"6a8c180515d4754935c24d9f88ad622f720970e8","modified":1562494753415},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1546668958444},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1546668958424},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1546668958432},{"_id":"source/_posts/PaStaNet/fig3.png","hash":"5b68914cb40647723779eaf9ea746fdf3b579d19","modified":1586661830526},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/experiment1.png","hash":"cf3349794c989056300f125e99ea2646061f852a","modified":1585980264074},{"_id":"source/_posts/rl-with-deep-energy-based-policies/vp.gif","hash":"3f528b7cd76f62fc3d802ad1e3ee3d8a335a7035","modified":1562494753438},{"_id":"source/_posts/PaStaNet/fig2.png","hash":"4195b80c53d5e32f79d567d5fb8537280f70ab65","modified":1586660161273},{"_id":"source/_posts/PaStaNet/fig6.png","hash":"fc1f1211b247157dfc281c422b4d5c4cf384714a","modified":1586661973751},{"_id":"source/_posts/PaStaNet/fig14.png","hash":"89dd24d0642f07b45c0387b644c039d2bba422f6","modified":1586662059447},{"_id":"public/atom.xml","hash":"d4bf1b8d69ef43b717e31d7f6f52ad64e8139c6f","modified":1592920799064},{"_id":"public/search.xml","hash":"e5e5d2b947507913c12b730c9ef85cc213dbdd2c","modified":1592920800203},{"_id":"public/sitemap.xml","hash":"196d20ed5deafff907e39e785c3ce31363fcfcca","modified":1592920800205},{"_id":"public/baidusitemap.xml","hash":"95cb27934e11392acb375ecd561a0ba167407aeb","modified":1592920800334},{"_id":"public/about/index.html","hash":"4e1d65f07f2171dec2ba001e3c842d0a48e887bc","modified":1592920801274},{"_id":"public/categories/index.html","hash":"9a9d485db007dac35d850294f4f5199a246519dc","modified":1592920801305},{"_id":"public/schedule/index.html","hash":"1bdbcc8815f85626dd0a03b297917a79675b8898","modified":1592920801305},{"_id":"public/sitemap/index.html","hash":"4f4a64aeac41293374b477b38190d0f3b0d5f4ae","modified":1592920801311},{"_id":"public/tags/index.html","hash":"fc748923ebc75f86e57b670c17f7211cac5d442e","modified":1592920801311},{"_id":"public/rl-code-pit.html","hash":"eba537d3234742903e607dadfdf53134db50679c","modified":1592920801311},{"_id":"public/FuNs.html","hash":"99bafe8d25217608d9556317d617aca945562bcf","modified":1592920801311},{"_id":"public/raspverry4b.html","hash":"665b65fcc96a1b79a43b095d616ee1b03656fc4f","modified":1592920801312},{"_id":"public/burn-system2raspberry-in-macos.html","hash":"dfd7721b9d885642489606296ca79cc439622164","modified":1592920801312},{"_id":"public/leetcode.html","hash":"18a72fc0c46a5d7a77c558ea3c793f09137c0960","modified":1592920801312},{"_id":"public/overleaf.html","hash":"8200dc8edd2c82f1d5a4ac42ed33b599e0fb10b5","modified":1592920801312},{"_id":"public/options-critic.html","hash":"96b936c0bb9a1ea4c4c2a80fac62461300962704","modified":1592920801312},{"_id":"public/rl3000questions.html","hash":"33332bb7a7944764072c7c2acc601d4d67622911","modified":1592920801312},{"_id":"public/PaStaNet.html","hash":"4d2b2c7cddb07432b437c194897a6225a0ae3156","modified":1592920801312},{"_id":"public/h-dqn.html","hash":"3f765be94da333e55c876df5e041ef77cc235ede","modified":1592920801312},{"_id":"public/bootstrapped-dqn.html","hash":"9075a4e35a1c54778014ff90fc45da4a1e89274f","modified":1592920801313},{"_id":"public/dppo.html","hash":"76ca2eb6438fa467421ce00574f82294a5ce12b6","modified":1592920801313},{"_id":"public/tf2-gaussian-distribution.html","hash":"4f4c693186a814019eb624887aa059b7065ffb1f","modified":1592920801313},{"_id":"public/learn-grpc.html","hash":"3183b0d13b0a29bfb34016eb829a4945b7072c52","modified":1592920801313},{"_id":"public/rl-an-introduction.html","hash":"0451fe37b3f1648e07f6d254460ef3518d634bab","modified":1592920801313},{"_id":"public/keeping-your-distance-solving-sparse-reward-tasks.html","hash":"e5c8cd18480d7c6236a5645856fa0fb52d5f88eb","modified":1592920801313},{"_id":"public/some-issues-of-install-packages.html","hash":"bb645e4acdab95be9f65666c1b0bc8c998613868","modified":1592920801313},{"_id":"public/config-alios.html","hash":"bac18584f737835f78b46e65b19deec177f4201b","modified":1592920801313},{"_id":"public/install-atari-and-box2d-on-win10.html","hash":"212180eba378d365bc4a2007d2fe30a2c0a494e1","modified":1592920801313},{"_id":"public/rl-with-deep-energy-based-policies.html","hash":"1be2163713c1ce05c7277afd8d840337bcce4502","modified":1592920801313},{"_id":"public/maximum-entropy-regularized-multi-goal-reinforcement-learning.html","hash":"4a2fb2a4c793a2914ad1b62a9c45f24e23495558","modified":1592920801313},{"_id":"public/rl-rough-reading.html","hash":"9c1355ad5e0a752475f050dfbce2cc04abc75226","modified":1592920801314},{"_id":"public/universal-value-function-approximators.html","hash":"f36b1023f136f956d55d1b4fca8d61b87e98ae3c","modified":1592920801314},{"_id":"public/ss.html","hash":"24b081f101617e077999267802bbf8a4623a2350","modified":1592920801314},{"_id":"public/rl2.html","hash":"1f5e6aa80be076639dac6c130e986df8187c5f5d","modified":1592920801314},{"_id":"public/asynchronous-methods-for-drl.html","hash":"dab4465d0a5491a059e5f90bcb930b286821a7b9","modified":1592920801314},{"_id":"public/energy-based-hindsight-experience-prioritization.html","hash":"153353ae041d73d90edf4c5d7f8cdb67fab5ff6b","modified":1592920801314},{"_id":"public/Hindsight-Experience-Replay.html","hash":"00a5f9bd3e31ce9dc7918fbabcba9a0c887d68f6","modified":1592920801314},{"_id":"public/Prioritized-Experience-Replay.html","hash":"6d95e50c8a7236c054d96f989c70142347d5f56c","modified":1592920801314},{"_id":"public/Evolution-Strategies-2017.html","hash":"de6d53f449e9d4947bc5e8302f47050dae78e5e8","modified":1592920801314},{"_id":"public/sarsa-and-q-learning.html","hash":"32e56ef66013ad97d0e0a0bcc1cc3f4d45e48c73","modified":1592920801314},{"_id":"public/mc-td.html","hash":"d2f18400f8dca24497a39180394285377393ae46","modified":1592920801315},{"_id":"public/dynamic-programming.html","hash":"6b4b6ae6dd1cae8b75a748f0c2e6e2b02f83c97b","modified":1592920801315},{"_id":"public/rl-classification.html","hash":"f8895755b7947f94f4f6f3b895f51212506110ed","modified":1592920801315},{"_id":"public/价值与贝尔曼方程.html","hash":"93ba3e283ac08c25e31368ebc73e9675ba8f9836","modified":1592920801315},{"_id":"public/强化学习.html","hash":"d3d57385fc1ade8604476aededa592394e513e35","modified":1592920801315},{"_id":"public/强化学习之MDP马尔科夫决策过程.html","hash":"cb0f57c32ab406721b510fa92cb49e31a7d0287f","modified":1592920801315},{"_id":"public/强化学习的里程碑.html","hash":"bc9b9daa4426cad6cef3df52eafa1b7365eb700d","modified":1592920801315},{"_id":"public/conda环境和pip包的转移.html","hash":"d3f22d84c8f6f031859e9072bb55472268a71bec","modified":1592920801315},{"_id":"public/强化学习基本概念.html","hash":"97b69d92944bbc73720d65db4d027446fb7c4381","modified":1592920801315},{"_id":"public/AnderewNg-deeplearning-note-summary.html","hash":"c242571ae00a53c109d4db22d22e191f20446df4","modified":1592920801315},{"_id":"public/something-hard-install-docker.html","hash":"9f88598b1459639790b2c1d575aad9e11909fb95","modified":1592920801315},{"_id":"public/use-conda-env-in-jupyter.html","hash":"19b0a33d8305104501a3a1d76d6e5b359942c320","modified":1592920801316},{"_id":"public/为远程Ubuntu服务器安装图像界面.html","hash":"8b06b67dfe9d1bf6416a70d3d1beec686c0ea4bf","modified":1592920801316},{"_id":"public/创建ML-Agents的Docker镜像.html","hash":"1ea3a9aa7feab3c103e74bcc4b43583412da6481","modified":1592920801316},{"_id":"public/Docker命令学习.html","hash":"37edc98efe0ffb7f9087ee81d2734addf178e7cf","modified":1592920801316},{"_id":"public/create-sniper-docker-image.html","hash":"2c468677071f0459dcb66fb892cd1bc345e6b572","modified":1592920801316},{"_id":"public/Git-learn.html","hash":"32be643ed2f334a72629cb5f1717c135a8ad7f80","modified":1592920801316},{"_id":"public/MarkDown-Grammar.html","hash":"980458ca39b7c848c4637e23002b945d07bfa10c","modified":1592920801316},{"_id":"public/win-rightclick-create-md.html","hash":"f79d5cc110bee4d330f0cd8ce710ae0362c26273","modified":1592920801316},{"_id":"public/archives/index.html","hash":"0486edaddb295ed8668f25093f35a37eac73177a","modified":1592920801316},{"_id":"public/archives/page/2/index.html","hash":"3814d8dd17c2518064dd0ef476c9562288421180","modified":1592920801316},{"_id":"public/archives/page/3/index.html","hash":"7950a96f31c3af2b61eb2ff92fee991029c4458a","modified":1592920801316},{"_id":"public/archives/page/4/index.html","hash":"0f1fac9b882c56c697db42c74608633f7432971c","modified":1592920801316},{"_id":"public/archives/page/5/index.html","hash":"158a7ea02525c879d6390c1938b9ae336ccaecb1","modified":1592920801317},{"_id":"public/archives/2018/index.html","hash":"1495a5255c313736c847d5053a1e7ccceab7a8c2","modified":1592920801317},{"_id":"public/archives/2018/12/index.html","hash":"88fb63750b17e808555a4f82b488be84f7492f6b","modified":1592920801317},{"_id":"public/archives/2019/index.html","hash":"0b528b851b381187180df16464aa338e38415d4b","modified":1592920801317},{"_id":"public/archives/2019/page/2/index.html","hash":"098fb9ae957aeae0f33d705f1aaedb3e34734232","modified":1592920801317},{"_id":"public/archives/2019/page/3/index.html","hash":"793bf1b5da624851d027f3fea2bb8fa3ac9afb53","modified":1592920801317},{"_id":"public/archives/2019/01/index.html","hash":"5a1a08fc73fbb68e78aa4be6d2eb990ce8d41f9c","modified":1592920801318},{"_id":"public/archives/2019/03/index.html","hash":"0bc962f5255aa267b45d3fa692ec2e5230fd60f8","modified":1592920801318},{"_id":"public/archives/2019/04/index.html","hash":"7bfb6c4a4b9249188ef68170bbf99d333e155e2f","modified":1592920801318},{"_id":"public/archives/2019/05/index.html","hash":"74995bdafee9b2d9a0edf90242fae82fa5ab3c88","modified":1592920801318},{"_id":"public/archives/2019/05/page/2/index.html","hash":"0cef8a1f4eae42ff6e6df21102660d65f9aab6fb","modified":1592920801318},{"_id":"public/archives/2019/06/index.html","hash":"fa98ac7a7515754c378192c2ce0aa68c84c2192c","modified":1592920801318},{"_id":"public/archives/2019/10/index.html","hash":"1842efb6f56855dd65b0f6360ad426d3d73ed091","modified":1592920801318},{"_id":"public/archives/2020/index.html","hash":"5b0d03fec68cb9eb4f92bd3fbbf153749627c09c","modified":1592920801318},{"_id":"public/archives/2020/page/2/index.html","hash":"5cab454ee301c3f5489dae04b4639c4234804568","modified":1592920801318},{"_id":"public/archives/2020/01/index.html","hash":"b1efe612aed8848948b70cea66681f7ee7da3613","modified":1592920801318},{"_id":"public/archives/2020/03/index.html","hash":"a5b3475fba0e33e9d37e8881302fbc5a1b5f8df8","modified":1592920801318},{"_id":"public/archives/2020/04/index.html","hash":"0b7bd84bc853658965313038e96f1c24640394a4","modified":1592920801318},{"_id":"public/archives/2020/04/page/2/index.html","hash":"a0348967d7bbef9dfc4111ccd422d598e2bc07bc","modified":1592920801319},{"_id":"public/archives/2020/05/index.html","hash":"4c9bfb28e43ff7ff92c92ed6c6ab62e771748d99","modified":1592920801319},{"_id":"public/categories/DeepLearning/index.html","hash":"3c547dcf10e6daed81499d582a026172566ec8d6","modified":1592920801320},{"_id":"public/categories/Docker/index.html","hash":"e8623553ca705f37d2dd7330dd040c1343e162a7","modified":1592920801320},{"_id":"public/categories/小知识/index.html","hash":"ff54d4d7c5f53fc6569570b92bd3ba9b4fd161ee","modified":1592920801320},{"_id":"public/categories/Conda/index.html","hash":"d0f02c03721bc9c1623649f4e2260e6a62c3cce6","modified":1592920801320},{"_id":"public/categories/ReinforcementLearning/index.html","hash":"65e6ba6e4c97b592306e84f32917b9a1850a2eb4","modified":1592920801321},{"_id":"public/categories/ReinforcementLearning/page/2/index.html","hash":"2f233bb9f991f542d4d0b46e07863513818d8cf8","modified":1592920801321},{"_id":"public/categories/ReinforcementLearning/page/3/index.html","hash":"787d5117d9c9d1e4a4bc141656d899ec28cc7814","modified":1592920801321},{"_id":"public/categories/MacOS/index.html","hash":"dd8d5739007cf3ac33411235c259498eb8bf9eff","modified":1592920801321},{"_id":"public/categories/Python/index.html","hash":"5f882f0d95814b8f08464d920da0a51f722b022a","modified":1592920801321},{"_id":"public/categories/Raspberry/index.html","hash":"c14d62904d5a8982e8446273f0594feaeeccb40b","modified":1592920801323},{"_id":"public/categories/Ubuntu/index.html","hash":"9004f60d01224eda4e739026b605e7f85cef7542","modified":1592920801323},{"_id":"public/categories/TensorFlow/index.html","hash":"3432ef4737bb4e0c3a77708d9db850421a500bf7","modified":1592920801323},{"_id":"public/categories/Docker/Unity/index.html","hash":"658442dcfa14f0732840d126c0893d87e428d2c6","modified":1592920801323},{"_id":"public/index.html","hash":"e291bb77281490b02d10e1d7ee6b419ca007047f","modified":1592920801323},{"_id":"public/page/2/index.html","hash":"2b3dcc48ab250bdc81ae9b043e21cedb4ba2649a","modified":1592920801323},{"_id":"public/page/3/index.html","hash":"86657bda9a80b1f3de715f86943315d0a55ffa52","modified":1592920801323},{"_id":"public/tags/note/index.html","hash":"9cd14caf79b787b82d4a675d4f627cb506ca110c","modified":1592920801323},{"_id":"public/tags/deeplearning/index.html","hash":"6e7d23903a28f0f1f7258a5d7c7cb3a23451ddae","modified":1592920801324},{"_id":"public/tags/docker/index.html","hash":"cb9d81eea669c8b1004cd98291f4a2b87c1d0600","modified":1592920801324},{"_id":"public/tags/Git/index.html","hash":"e29441bacb51fcb30f747ffacc92271d0f06ae36","modified":1592920801324},{"_id":"public/tags/markdown/index.html","hash":"fb0bfe333da94e33ff3c1ae83d85ee10096a2c0e","modified":1592920801324},{"_id":"public/tags/conda/index.html","hash":"3d9519c62e16231518bf2524a27fbf28fabbc13d","modified":1592920801324},{"_id":"public/tags/rl/index.html","hash":"c79900fa947067be3e13d5b7e6a9fcee5ce37854","modified":1592920801324},{"_id":"public/tags/rl/page/2/index.html","hash":"674a35aaf977b0bdb2b8eb496e821f3a9eafd8e1","modified":1592920801324},{"_id":"public/tags/rl/page/3/index.html","hash":"2250bd5ba967007849c7c9a948c7b6f75f34ce8f","modified":1592920801324},{"_id":"public/tags/os/index.html","hash":"e52a000e2be0679dbc77733192121ba068806eaa","modified":1592920801324},{"_id":"public/tags/raspberry/index.html","hash":"d459072f7574d2b745f84aca78ae9c264f107105","modified":1592920801325},{"_id":"public/tags/gym/index.html","hash":"2e17eba4e5ef13ed32b4257750963e56b1e98474","modified":1592920801325},{"_id":"public/tags/python/index.html","hash":"571a7807a359b894a107c4061e29a47060fb2403","modified":1592920801325},{"_id":"public/tags/leetcode/index.html","hash":"a1259d240f2af334029fc31930023724d260139d","modified":1592920801325},{"_id":"public/tags/overleaf/index.html","hash":"8f364c08fc3f0110e958ba477251f04f2fee245d","modified":1592920801325},{"_id":"public/tags/RL/index.html","hash":"3ec16a4da18562974cba7a713653ced1560b7a02","modified":1592920801326},{"_id":"public/tags/pip/index.html","hash":"7496e2f1bfb62c1bac9fdc8dee95b35625238b3d","modified":1592920801326},{"_id":"public/tags/ubuntu/index.html","hash":"b06e9a14b6a0b3a90802802520c73c53f00dee9f","modified":1592920801327},{"_id":"public/tags/jupyter-notebook/index.html","hash":"85079835f583739f3a8c5855a23c47b3af661600","modified":1592920801327},{"_id":"public/tags/x2go/index.html","hash":"cae7d33478782f4a828dc3ae81205eac6e165b3e","modified":1592920801327},{"_id":"public/tags/hrl/index.html","hash":"a3f20fb55c8276868d4d2ecd4c040c0bf8a655f7","modified":1592920801328},{"_id":"public/tags/mxnet/index.html","hash":"f0a2df5ac985af75bf043312b8263a7885f8c0ce","modified":1592920801328},{"_id":"public/tags/sniper/index.html","hash":"2358c2bf33d0e74895706d9b42c7d799c690b1e7","modified":1592920801328},{"_id":"public/tags/tf2/index.html","hash":"424e764fc26574dc39d459bd4a152c877f8c1c5a","modified":1592920801328},{"_id":"public/tags/unity/index.html","hash":"93018e5e8fd319cd100dc6a681b170376cbd559e","modified":1592920801328},{"_id":"public/tags/ml-agents/index.html","hash":"b002986446b20d519440c0237df52d3bf39331ee","modified":1592920801328},{"_id":"public/tags/dl/index.html","hash":"c364e246ef70f72187c17ff6b126f54d752d6aae","modified":1592920801328},{"_id":"public/random-network-distillation.html","hash":"ed47cecfdfedd05be5ae41fe4e9e43c4fe28c148","modified":1592920801406},{"_id":"public/archives/page/6/index.html","hash":"34ecea18192d4045356b17c4f20816eb2f1e2012","modified":1592920801406},{"_id":"public/archives/2020/06/index.html","hash":"989c43e3921f381adfd8d4bc8d6bd8848918eb49","modified":1592920801407},{"_id":"public/tags/exploration/index.html","hash":"b47073b84fb535b2c843c6eb0a96f72981f71944","modified":1592920801407},{"_id":"public/live2dw/assets/hijiki.model.json","hash":"feff43bf7498d213982c3736c2c029664e4bcbd2","modified":1592920801434},{"_id":"public/live2dw/assets/hijiki.pose.json","hash":"81438bf69b32c7c11e311b4fe043730cdc7b7ec2","modified":1592920801436},{"_id":"public/live2dw/assets/mtn/00_idle.mtn","hash":"b224c60e463b9f71ddbfc0c720e430496c175f4f","modified":1592920801436},{"_id":"public/live2dw/assets/mtn/02.mtn","hash":"7eafc52edc73b7cb80ae70d34b43c6ac778fa47b","modified":1592920801439},{"_id":"public/live2dw/assets/mtn/03.mtn","hash":"f900737c7a98441cbb2e05255427e6260e19ae68","modified":1592920801440},{"_id":"public/live2dw/assets/mtn/04.mtn","hash":"c7a25d3c5d783639bae18db2f3cd284b819c3c85","modified":1592920801441},{"_id":"public/live2dw/assets/mtn/05.mtn","hash":"dd20ad24b5d1830a5d44b9bccb28f922eea5e0e5","modified":1592920801441},{"_id":"public/live2dw/assets/mtn/01.mtn","hash":"fb550833ae22c9954c3e01df37ed29b2d61700f2","modified":1592920801442},{"_id":"public/live2dw/assets/mtn/06.mtn","hash":"ad404bd852d276cdd3d054c953e23f90e4e45ae1","modified":1592920801442},{"_id":"public/live2dw/assets/mtn/08.mtn","hash":"4411c7651ff65195b113d95e7d5ebef8a59a37d9","modified":1592920801442},{"_id":"public/live2dw/assets/mtn/07.mtn","hash":"b7f2e3a9fa4f3ffbb6e64a08f8d9f45ca1868ffb","modified":1592920801447},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1592920801447},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1592920801468},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1592920802536},{"_id":"public/live2dw/assets/moc/hijiki.2048/texture_00.png","hash":"66464e0d96439695b5542c5e2f5be60739c29999","modified":1592920802538},{"_id":"public/live2dw/assets/moc/hijiki.moc","hash":"44289e62545a7046e0f5231103a851750b78524e","modified":1592920802538},{"_id":"public/random-network-distillation/pseudo.png","hash":"5906f39ce0b3b690a2a0d76caae9f55aa2fc89c2","modified":1592920802546},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1592920802546}],"Category":[{"name":"DeepLearning","_id":"ckbrzusw2000320cd40357ph2"},{"name":"Docker","_id":"ckbrzuswb000820cdyg17badw"},{"name":"小知识","_id":"ckbrzuswe000d20cd8cjtu6xp"},{"name":"Conda","_id":"ckbrzusx7000q20cdgblhfte6"},{"name":"ReinforcementLearning","_id":"ckbrzusxy000x20cdruoikxo3"},{"name":"MacOS","_id":"ckbrzusy8001520cd8uilm9s7"},{"name":"Python","_id":"ckbrzusyn001q20cd6vrd1jtz"},{"name":"Raspberry","_id":"ckbrzusz6002d20cdaps7378v"},{"name":"Ubuntu","_id":"ckbrzuszg002s20cdyrdpnbv9"},{"name":"TensorFlow","_id":"ckbrzut9k005920cdufe21js0"},{"name":"Unity","parent":"ckbrzuswb000820cdyg17badw","_id":"ckbrzutb5005h20cd326euho1"}],"Data":[],"Page":[{"title":"自我介绍","date":"2019-01-02T07:30:04.000Z","type":"about","comments":0,"_content":"\n​\t\n\n- 上海大学计算机工程与科学学院研究生在读，目前研二\n- 主要研究方向：强化学习\n- 邮箱地址：271668153@qq.com\n- 代码仓库：[https://github.com/StepNeverStop](https://github.com/StepNeverStop)\n\n","source":"about/index.md","raw":"---\ntitle: 自我介绍\ndate: 2019-01-02 15:30:04\ntype: \"about\"\ncomments: false\n---\n\n​\t\n\n- 上海大学计算机工程与科学学院研究生在读，目前研二\n- 主要研究方向：强化学习\n- 邮箱地址：271668153@qq.com\n- 代码仓库：[https://github.com/StepNeverStop](https://github.com/StepNeverStop)\n\n","updated":"2019-09-03T10:27:17.254Z","path":"about/index.html","layout":"page","_id":"ckbrzusvx000120cdq5fnjap4","content":"<p>​    </p>\n<ul>\n<li>上海大学计算机工程与科学学院研究生在读，目前研二</li>\n<li>主要研究方向：强化学习</li>\n<li>邮箱地址：271668153@qq.com</li>\n<li>代码仓库：<a href=\"https://github.com/StepNeverStop\" rel=\"external nofollow\" target=\"_blank\">https://github.com/StepNeverStop</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>​    </p>\n<ul>\n<li>上海大学计算机工程与科学学院研究生在读，目前研二</li>\n<li>主要研究方向：强化学习</li>\n<li>邮箱地址：271668153@qq.com</li>\n<li>代码仓库：<a href=\"https://github.com/StepNeverStop\" rel=\"external nofollow\" target=\"_blank\">https://github.com/StepNeverStop</a></li>\n</ul>\n"},{"title":"categories","date":"2019-01-02T07:40:45.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-01-02 15:40:45\ntype: \"categories\"\ncomments: false\n---\n","updated":"2019-01-05T06:15:58.290Z","path":"categories/index.html","layout":"page","_id":"ckbrzut8d004920cdbtv9xvmv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"schedule","date":"2019-01-02T07:46:05.000Z","type":"schedule","_content":"","source":"schedule/index.md","raw":"---\ntitle: schedule\ndate: 2019-01-02 15:46:05\ntype: \"schedule\"\n---\n","updated":"2019-01-05T06:15:58.290Z","path":"schedule/index.html","comments":1,"layout":"page","_id":"ckbrzut8f004b20cdky9ubn4s","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"sitemap","date":"2019-01-02T07:46:11.000Z","type":"sitemap","_content":"","source":"sitemap/index.md","raw":"---\ntitle: sitemap\ndate: 2019-01-02 15:46:11\ntype: \"sitemap\"\n---\n","updated":"2019-01-05T06:15:58.291Z","path":"sitemap/index.html","comments":1,"layout":"page","_id":"ckbrzut8j004e20cdtuyco7aj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tagcloud","date":"2019-01-02T07:32:57.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: Tagcloud\ndate: 2019-01-02 15:32:57\ntype: \"tags\"\ncomments: false\n---\n","updated":"2019-01-05T06:15:58.291Z","path":"tags/index.html","layout":"page","_id":"ckbrzut8l004i20cdvjp7l6k6","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"吴恩达deeplearning.ai课程笔记总结","copyright":true,"top":1,"date":"2019-03-25T10:30:30.000Z","_content":"\n在吴恩达机器学习系列课程完结后不久，一位名叫[Tess Ferrandez](https://www.slideshare.net/TessFerrandez?utm_campaign=profiletracking&utm_medium=sssite&utm_source=ssslideview \"Tess Ferrandez小姐姐的主页\")的小姐姐在推特上分享了一套自己的课程笔记，瞬间收获了3k+赞和1k+转发。\n\n不同于满屏公式代码的黑白笔记，这套信息图不仅知识点满满，且行文构图都像插画一样颜值颇高。吴恩达自己也在推特上转发称赞了这一位有诚意的学习者，毕竟他一直倡导学习是一件简单快乐的事情。\n\nLink: [笔记源地址](https://www.slideshare.net/TessFerrandez/notes-from-coursera-deep-learning-courses-by-andrew-ng \"笔记源地址\")\n\n<!--more-->\n\n# 深度学习介绍\n![](./AnderewNg-deeplearning-note-summary/1.png)\n# 逻辑回归\n![](./AnderewNg-deeplearning-note-summary/2.png)\n# 浅层神经网络\n![](./AnderewNg-deeplearning-note-summary/3.png)\n# 深层神经网络\n![](./AnderewNg-deeplearning-note-summary/4.png)\n# 机器学习应用程序设置\n![](./AnderewNg-deeplearning-note-summary/5.png)\n# 正则化——防止过拟合\n![](./AnderewNg-deeplearning-note-summary/6.png)\n# 优化训练\n![](./AnderewNg-deeplearning-note-summary/7.png)\n# 优化算法\n![](./AnderewNg-deeplearning-note-summary/8.png)\n# 超参数调试\n![](./AnderewNg-deeplearning-note-summary/9.png)\n# 机器学习项目构建\n![](./AnderewNg-deeplearning-note-summary/10.png)\n# 错误分析\n![](./AnderewNg-deeplearning-note-summary/11.png)\n# 训练 vs 验证/测试 失配\n![](./AnderewNg-deeplearning-note-summary/12.png)\n# 扩展学习\n![](./AnderewNg-deeplearning-note-summary/13.png)\n# 卷积基础\n![](./AnderewNg-deeplearning-note-summary/14.png)\n# Padding\n![](./AnderewNg-deeplearning-note-summary/15.png)\n# 深层 CNN\n![](./AnderewNg-deeplearning-note-summary/16.png)\n# 典型的 CNN 模型\n![](./AnderewNg-deeplearning-note-summary/17.png)\n# ResNet\n![](./AnderewNg-deeplearning-note-summary/18.png)\n# 实用建议\n![](./AnderewNg-deeplearning-note-summary/19.png)\n# 检测算法\n![](./AnderewNg-deeplearning-note-summary/20.png)\n# 人脸识别\n![](./AnderewNg-deeplearning-note-summary/21.png)\n# 神经风格迁移\n![](./AnderewNg-deeplearning-note-summary/22.png)\n# 循环神经网络\n![](./AnderewNg-deeplearning-note-summary/23.png)\n# 更多 RNN 模型\n![](./AnderewNg-deeplearning-note-summary/24.png)\n# NLP-词嵌入\n![](./AnderewNg-deeplearning-note-summary/25.png)\n# 词嵌入详解\n![](./AnderewNg-deeplearning-note-summary/26.png)\n# 序列到序列基本模型\n![](./AnderewNg-deeplearning-note-summary/27.png)\n# 序列到序列\n![](./AnderewNg-deeplearning-note-summary/28.png)","source":"_posts/AnderewNg-deeplearning-note-summary.md","raw":"---\ntitle: 吴恩达deeplearning.ai课程笔记总结\ncopyright: true\ntop: 1\ndate: 2019-03-25 18:30:30\ncategories: DeepLearning\ntags:\n- note\n- deeplearning\n---\n\n在吴恩达机器学习系列课程完结后不久，一位名叫[Tess Ferrandez](https://www.slideshare.net/TessFerrandez?utm_campaign=profiletracking&utm_medium=sssite&utm_source=ssslideview \"Tess Ferrandez小姐姐的主页\")的小姐姐在推特上分享了一套自己的课程笔记，瞬间收获了3k+赞和1k+转发。\n\n不同于满屏公式代码的黑白笔记，这套信息图不仅知识点满满，且行文构图都像插画一样颜值颇高。吴恩达自己也在推特上转发称赞了这一位有诚意的学习者，毕竟他一直倡导学习是一件简单快乐的事情。\n\nLink: [笔记源地址](https://www.slideshare.net/TessFerrandez/notes-from-coursera-deep-learning-courses-by-andrew-ng \"笔记源地址\")\n\n<!--more-->\n\n# 深度学习介绍\n![](./AnderewNg-deeplearning-note-summary/1.png)\n# 逻辑回归\n![](./AnderewNg-deeplearning-note-summary/2.png)\n# 浅层神经网络\n![](./AnderewNg-deeplearning-note-summary/3.png)\n# 深层神经网络\n![](./AnderewNg-deeplearning-note-summary/4.png)\n# 机器学习应用程序设置\n![](./AnderewNg-deeplearning-note-summary/5.png)\n# 正则化——防止过拟合\n![](./AnderewNg-deeplearning-note-summary/6.png)\n# 优化训练\n![](./AnderewNg-deeplearning-note-summary/7.png)\n# 优化算法\n![](./AnderewNg-deeplearning-note-summary/8.png)\n# 超参数调试\n![](./AnderewNg-deeplearning-note-summary/9.png)\n# 机器学习项目构建\n![](./AnderewNg-deeplearning-note-summary/10.png)\n# 错误分析\n![](./AnderewNg-deeplearning-note-summary/11.png)\n# 训练 vs 验证/测试 失配\n![](./AnderewNg-deeplearning-note-summary/12.png)\n# 扩展学习\n![](./AnderewNg-deeplearning-note-summary/13.png)\n# 卷积基础\n![](./AnderewNg-deeplearning-note-summary/14.png)\n# Padding\n![](./AnderewNg-deeplearning-note-summary/15.png)\n# 深层 CNN\n![](./AnderewNg-deeplearning-note-summary/16.png)\n# 典型的 CNN 模型\n![](./AnderewNg-deeplearning-note-summary/17.png)\n# ResNet\n![](./AnderewNg-deeplearning-note-summary/18.png)\n# 实用建议\n![](./AnderewNg-deeplearning-note-summary/19.png)\n# 检测算法\n![](./AnderewNg-deeplearning-note-summary/20.png)\n# 人脸识别\n![](./AnderewNg-deeplearning-note-summary/21.png)\n# 神经风格迁移\n![](./AnderewNg-deeplearning-note-summary/22.png)\n# 循环神经网络\n![](./AnderewNg-deeplearning-note-summary/23.png)\n# 更多 RNN 模型\n![](./AnderewNg-deeplearning-note-summary/24.png)\n# NLP-词嵌入\n![](./AnderewNg-deeplearning-note-summary/25.png)\n# 词嵌入详解\n![](./AnderewNg-deeplearning-note-summary/26.png)\n# 序列到序列基本模型\n![](./AnderewNg-deeplearning-note-summary/27.png)\n# 序列到序列\n![](./AnderewNg-deeplearning-note-summary/28.png)","slug":"AnderewNg-deeplearning-note-summary","published":1,"updated":"2019-05-13T14:27:05.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusvp000020cd1zyq3v36","content":"<p>在吴恩达机器学习系列课程完结后不久，一位名叫<a href=\"https://www.slideshare.net/TessFerrandez?utm_campaign=profiletracking&amp;utm_medium=sssite&amp;utm_source=ssslideview\" title=\"Tess Ferrandez小姐姐的主页\" rel=\"external nofollow\" target=\"_blank\">Tess Ferrandez</a>的小姐姐在推特上分享了一套自己的课程笔记，瞬间收获了3k+赞和1k+转发。</p>\n<p>不同于满屏公式代码的黑白笔记，这套信息图不仅知识点满满，且行文构图都像插画一样颜值颇高。吴恩达自己也在推特上转发称赞了这一位有诚意的学习者，毕竟他一直倡导学习是一件简单快乐的事情。</p>\n<p>Link: <a href=\"https://www.slideshare.net/TessFerrandez/notes-from-coursera-deep-learning-courses-by-andrew-ng\" title=\"笔记源地址\" rel=\"external nofollow\" target=\"_blank\">笔记源地址</a></p>\n<a id=\"more\"></a>\n<h1 id=\"深度学习介绍\"><a href=\"#深度学习介绍\" class=\"headerlink\" title=\"深度学习介绍\"></a>深度学习介绍</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/1.png\" alt=\"\"></p>\n<h1 id=\"逻辑回归\"><a href=\"#逻辑回归\" class=\"headerlink\" title=\"逻辑回归\"></a>逻辑回归</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/2.png\" alt=\"\"></p>\n<h1 id=\"浅层神经网络\"><a href=\"#浅层神经网络\" class=\"headerlink\" title=\"浅层神经网络\"></a>浅层神经网络</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/3.png\" alt=\"\"></p>\n<h1 id=\"深层神经网络\"><a href=\"#深层神经网络\" class=\"headerlink\" title=\"深层神经网络\"></a>深层神经网络</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/4.png\" alt=\"\"></p>\n<h1 id=\"机器学习应用程序设置\"><a href=\"#机器学习应用程序设置\" class=\"headerlink\" title=\"机器学习应用程序设置\"></a>机器学习应用程序设置</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/5.png\" alt=\"\"></p>\n<h1 id=\"正则化——防止过拟合\"><a href=\"#正则化——防止过拟合\" class=\"headerlink\" title=\"正则化——防止过拟合\"></a>正则化——防止过拟合</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/6.png\" alt=\"\"></p>\n<h1 id=\"优化训练\"><a href=\"#优化训练\" class=\"headerlink\" title=\"优化训练\"></a>优化训练</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/7.png\" alt=\"\"></p>\n<h1 id=\"优化算法\"><a href=\"#优化算法\" class=\"headerlink\" title=\"优化算法\"></a>优化算法</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/8.png\" alt=\"\"></p>\n<h1 id=\"超参数调试\"><a href=\"#超参数调试\" class=\"headerlink\" title=\"超参数调试\"></a>超参数调试</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/9.png\" alt=\"\"></p>\n<h1 id=\"机器学习项目构建\"><a href=\"#机器学习项目构建\" class=\"headerlink\" title=\"机器学习项目构建\"></a>机器学习项目构建</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/10.png\" alt=\"\"></p>\n<h1 id=\"错误分析\"><a href=\"#错误分析\" class=\"headerlink\" title=\"错误分析\"></a>错误分析</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/11.png\" alt=\"\"></p>\n<h1 id=\"训练-vs-验证-测试-失配\"><a href=\"#训练-vs-验证-测试-失配\" class=\"headerlink\" title=\"训练 vs 验证/测试 失配\"></a>训练 vs 验证/测试 失配</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/12.png\" alt=\"\"></p>\n<h1 id=\"扩展学习\"><a href=\"#扩展学习\" class=\"headerlink\" title=\"扩展学习\"></a>扩展学习</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/13.png\" alt=\"\"></p>\n<h1 id=\"卷积基础\"><a href=\"#卷积基础\" class=\"headerlink\" title=\"卷积基础\"></a>卷积基础</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/14.png\" alt=\"\"></p>\n<h1 id=\"Padding\"><a href=\"#Padding\" class=\"headerlink\" title=\"Padding\"></a>Padding</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/15.png\" alt=\"\"></p>\n<h1 id=\"深层-CNN\"><a href=\"#深层-CNN\" class=\"headerlink\" title=\"深层 CNN\"></a>深层 CNN</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/16.png\" alt=\"\"></p>\n<h1 id=\"典型的-CNN-模型\"><a href=\"#典型的-CNN-模型\" class=\"headerlink\" title=\"典型的 CNN 模型\"></a>典型的 CNN 模型</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/17.png\" alt=\"\"></p>\n<h1 id=\"ResNet\"><a href=\"#ResNet\" class=\"headerlink\" title=\"ResNet\"></a>ResNet</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/18.png\" alt=\"\"></p>\n<h1 id=\"实用建议\"><a href=\"#实用建议\" class=\"headerlink\" title=\"实用建议\"></a>实用建议</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/19.png\" alt=\"\"></p>\n<h1 id=\"检测算法\"><a href=\"#检测算法\" class=\"headerlink\" title=\"检测算法\"></a>检测算法</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/20.png\" alt=\"\"></p>\n<h1 id=\"人脸识别\"><a href=\"#人脸识别\" class=\"headerlink\" title=\"人脸识别\"></a>人脸识别</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/21.png\" alt=\"\"></p>\n<h1 id=\"神经风格迁移\"><a href=\"#神经风格迁移\" class=\"headerlink\" title=\"神经风格迁移\"></a>神经风格迁移</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/22.png\" alt=\"\"></p>\n<h1 id=\"循环神经网络\"><a href=\"#循环神经网络\" class=\"headerlink\" title=\"循环神经网络\"></a>循环神经网络</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/23.png\" alt=\"\"></p>\n<h1 id=\"更多-RNN-模型\"><a href=\"#更多-RNN-模型\" class=\"headerlink\" title=\"更多 RNN 模型\"></a>更多 RNN 模型</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/24.png\" alt=\"\"></p>\n<h1 id=\"NLP-词嵌入\"><a href=\"#NLP-词嵌入\" class=\"headerlink\" title=\"NLP-词嵌入\"></a>NLP-词嵌入</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/25.png\" alt=\"\"></p>\n<h1 id=\"词嵌入详解\"><a href=\"#词嵌入详解\" class=\"headerlink\" title=\"词嵌入详解\"></a>词嵌入详解</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/26.png\" alt=\"\"></p>\n<h1 id=\"序列到序列基本模型\"><a href=\"#序列到序列基本模型\" class=\"headerlink\" title=\"序列到序列基本模型\"></a>序列到序列基本模型</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/27.png\" alt=\"\"></p>\n<h1 id=\"序列到序列\"><a href=\"#序列到序列\" class=\"headerlink\" title=\"序列到序列\"></a>序列到序列</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/28.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>在吴恩达机器学习系列课程完结后不久，一位名叫<a href=\"https://www.slideshare.net/TessFerrandez?utm_campaign=profiletracking&amp;utm_medium=sssite&amp;utm_source=ssslideview\" title=\"Tess Ferrandez小姐姐的主页\" rel=\"external nofollow\" target=\"_blank\">Tess Ferrandez</a>的小姐姐在推特上分享了一套自己的课程笔记，瞬间收获了3k+赞和1k+转发。</p>\n<p>不同于满屏公式代码的黑白笔记，这套信息图不仅知识点满满，且行文构图都像插画一样颜值颇高。吴恩达自己也在推特上转发称赞了这一位有诚意的学习者，毕竟他一直倡导学习是一件简单快乐的事情。</p>\n<p>Link: <a href=\"https://www.slideshare.net/TessFerrandez/notes-from-coursera-deep-learning-courses-by-andrew-ng\" title=\"笔记源地址\" rel=\"external nofollow\" target=\"_blank\">笔记源地址</a></p>","more":"<h1 id=\"深度学习介绍\"><a href=\"#深度学习介绍\" class=\"headerlink\" title=\"深度学习介绍\"></a>深度学习介绍</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/1.png\" alt=\"\"></p>\n<h1 id=\"逻辑回归\"><a href=\"#逻辑回归\" class=\"headerlink\" title=\"逻辑回归\"></a>逻辑回归</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/2.png\" alt=\"\"></p>\n<h1 id=\"浅层神经网络\"><a href=\"#浅层神经网络\" class=\"headerlink\" title=\"浅层神经网络\"></a>浅层神经网络</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/3.png\" alt=\"\"></p>\n<h1 id=\"深层神经网络\"><a href=\"#深层神经网络\" class=\"headerlink\" title=\"深层神经网络\"></a>深层神经网络</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/4.png\" alt=\"\"></p>\n<h1 id=\"机器学习应用程序设置\"><a href=\"#机器学习应用程序设置\" class=\"headerlink\" title=\"机器学习应用程序设置\"></a>机器学习应用程序设置</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/5.png\" alt=\"\"></p>\n<h1 id=\"正则化——防止过拟合\"><a href=\"#正则化——防止过拟合\" class=\"headerlink\" title=\"正则化——防止过拟合\"></a>正则化——防止过拟合</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/6.png\" alt=\"\"></p>\n<h1 id=\"优化训练\"><a href=\"#优化训练\" class=\"headerlink\" title=\"优化训练\"></a>优化训练</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/7.png\" alt=\"\"></p>\n<h1 id=\"优化算法\"><a href=\"#优化算法\" class=\"headerlink\" title=\"优化算法\"></a>优化算法</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/8.png\" alt=\"\"></p>\n<h1 id=\"超参数调试\"><a href=\"#超参数调试\" class=\"headerlink\" title=\"超参数调试\"></a>超参数调试</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/9.png\" alt=\"\"></p>\n<h1 id=\"机器学习项目构建\"><a href=\"#机器学习项目构建\" class=\"headerlink\" title=\"机器学习项目构建\"></a>机器学习项目构建</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/10.png\" alt=\"\"></p>\n<h1 id=\"错误分析\"><a href=\"#错误分析\" class=\"headerlink\" title=\"错误分析\"></a>错误分析</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/11.png\" alt=\"\"></p>\n<h1 id=\"训练-vs-验证-测试-失配\"><a href=\"#训练-vs-验证-测试-失配\" class=\"headerlink\" title=\"训练 vs 验证/测试 失配\"></a>训练 vs 验证/测试 失配</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/12.png\" alt=\"\"></p>\n<h1 id=\"扩展学习\"><a href=\"#扩展学习\" class=\"headerlink\" title=\"扩展学习\"></a>扩展学习</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/13.png\" alt=\"\"></p>\n<h1 id=\"卷积基础\"><a href=\"#卷积基础\" class=\"headerlink\" title=\"卷积基础\"></a>卷积基础</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/14.png\" alt=\"\"></p>\n<h1 id=\"Padding\"><a href=\"#Padding\" class=\"headerlink\" title=\"Padding\"></a>Padding</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/15.png\" alt=\"\"></p>\n<h1 id=\"深层-CNN\"><a href=\"#深层-CNN\" class=\"headerlink\" title=\"深层 CNN\"></a>深层 CNN</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/16.png\" alt=\"\"></p>\n<h1 id=\"典型的-CNN-模型\"><a href=\"#典型的-CNN-模型\" class=\"headerlink\" title=\"典型的 CNN 模型\"></a>典型的 CNN 模型</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/17.png\" alt=\"\"></p>\n<h1 id=\"ResNet\"><a href=\"#ResNet\" class=\"headerlink\" title=\"ResNet\"></a>ResNet</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/18.png\" alt=\"\"></p>\n<h1 id=\"实用建议\"><a href=\"#实用建议\" class=\"headerlink\" title=\"实用建议\"></a>实用建议</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/19.png\" alt=\"\"></p>\n<h1 id=\"检测算法\"><a href=\"#检测算法\" class=\"headerlink\" title=\"检测算法\"></a>检测算法</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/20.png\" alt=\"\"></p>\n<h1 id=\"人脸识别\"><a href=\"#人脸识别\" class=\"headerlink\" title=\"人脸识别\"></a>人脸识别</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/21.png\" alt=\"\"></p>\n<h1 id=\"神经风格迁移\"><a href=\"#神经风格迁移\" class=\"headerlink\" title=\"神经风格迁移\"></a>神经风格迁移</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/22.png\" alt=\"\"></p>\n<h1 id=\"循环神经网络\"><a href=\"#循环神经网络\" class=\"headerlink\" title=\"循环神经网络\"></a>循环神经网络</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/23.png\" alt=\"\"></p>\n<h1 id=\"更多-RNN-模型\"><a href=\"#更多-RNN-模型\" class=\"headerlink\" title=\"更多 RNN 模型\"></a>更多 RNN 模型</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/24.png\" alt=\"\"></p>\n<h1 id=\"NLP-词嵌入\"><a href=\"#NLP-词嵌入\" class=\"headerlink\" title=\"NLP-词嵌入\"></a>NLP-词嵌入</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/25.png\" alt=\"\"></p>\n<h1 id=\"词嵌入详解\"><a href=\"#词嵌入详解\" class=\"headerlink\" title=\"词嵌入详解\"></a>词嵌入详解</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/26.png\" alt=\"\"></p>\n<h1 id=\"序列到序列基本模型\"><a href=\"#序列到序列基本模型\" class=\"headerlink\" title=\"序列到序列基本模型\"></a>序列到序列基本模型</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/27.png\" alt=\"\"></p>\n<h1 id=\"序列到序列\"><a href=\"#序列到序列\" class=\"headerlink\" title=\"序列到序列\"></a>序列到序列</h1><p><img src=\"./AnderewNg-deeplearning-note-summary/28.png\" alt=\"\"></p>"},{"title":"Docker常用以及组合命令学习","copyright":true,"top":1,"date":"2019-01-03T05:52:04.000Z","_content":"\n本文记录了使用Docker过程中的一些常用的、复杂的命令。\n\n<!--more-->\n\n- 停止并删除正在运行的容器\n`docker rm $(docker stop $(docker ps -aq))`\n如果是在windows操作系统，可能会执行出错，可以切换至powershell或者使用命令：\n`FOR /f \"tokens=*\" %i IN ('command 1') DO [command 2] %i`\n- 查看容器的长ID\n`docker inspect -f '{?{.ID}}' [name]`\n**去掉命令中的`?`,因为双括号会转义失败**\n- 宿主机向容器内传输文件/文件夹\n`docker cp 本地文件路径 ID全称:容器路径`\n- 容器传输文件/文件夹到宿主机\n`docker cp ID全称:容器文件路径 本地路径`\n- 修改本地已有镜像的名字\n`docker tag [ImageID] [NewImageNmae]:[tag]`\n- 创建新的镜像\n`docker build -t [name]:[tag] -f [dockerfile_path] .`\n- 开启一个容器\n`docker run -it(交互模式) -d(后台运行) --name [name] [name]:[tag]`\n如果需要启用`NVIDIA GPU`，可以加上命令参数`--gpus [all or device=0]`\n- 进入一个正在运行的容器\n`docker exec -it [name] [command]`\n- 从容器生成镜像\n`docker commit [container name or id] [image name:version]`\n- 把docker容器中的文件传输到本机\n`docker cp [container name or id]:[path] [本机path]`\n- 把本机文件传输到docker容器内\n`docker cp [本机path] [container name or id]:[path]`\n\n\n","source":"_posts/Docker命令学习.md","raw":"---\ntitle: Docker常用以及组合命令学习\ncopyright: true\ntop: 1\ndate: 2019-01-03 13:52:04\ncategories: Docker\ntags:\n- docker\n\n---\n\n本文记录了使用Docker过程中的一些常用的、复杂的命令。\n\n<!--more-->\n\n- 停止并删除正在运行的容器\n`docker rm $(docker stop $(docker ps -aq))`\n如果是在windows操作系统，可能会执行出错，可以切换至powershell或者使用命令：\n`FOR /f \"tokens=*\" %i IN ('command 1') DO [command 2] %i`\n- 查看容器的长ID\n`docker inspect -f '{?{.ID}}' [name]`\n**去掉命令中的`?`,因为双括号会转义失败**\n- 宿主机向容器内传输文件/文件夹\n`docker cp 本地文件路径 ID全称:容器路径`\n- 容器传输文件/文件夹到宿主机\n`docker cp ID全称:容器文件路径 本地路径`\n- 修改本地已有镜像的名字\n`docker tag [ImageID] [NewImageNmae]:[tag]`\n- 创建新的镜像\n`docker build -t [name]:[tag] -f [dockerfile_path] .`\n- 开启一个容器\n`docker run -it(交互模式) -d(后台运行) --name [name] [name]:[tag]`\n如果需要启用`NVIDIA GPU`，可以加上命令参数`--gpus [all or device=0]`\n- 进入一个正在运行的容器\n`docker exec -it [name] [command]`\n- 从容器生成镜像\n`docker commit [container name or id] [image name:version]`\n- 把docker容器中的文件传输到本机\n`docker cp [container name or id]:[path] [本机path]`\n- 把本机文件传输到docker容器内\n`docker cp [本机path] [container name or id]:[path]`\n\n\n","slug":"Docker命令学习","published":1,"updated":"2020-03-17T07:25:11.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusvy000220cdofcp1bim","content":"<p>本文记录了使用Docker过程中的一些常用的、复杂的命令。</p>\n<a id=\"more\"></a>\n<ul>\n<li>停止并删除正在运行的容器<br><code>docker rm $(docker stop $(docker ps -aq))</code><br>如果是在windows操作系统，可能会执行出错，可以切换至powershell或者使用命令：<br><code>FOR /f &quot;tokens=*&quot; %i IN (&#39;command 1&#39;) DO [command 2] %i</code></li>\n<li>查看容器的长ID<br><code>docker inspect -f &#39;{?{.ID}}&#39; [name]</code><br><strong>去掉命令中的<code>?</code>,因为双括号会转义失败</strong></li>\n<li>宿主机向容器内传输文件/文件夹<br><code>docker cp 本地文件路径 ID全称:容器路径</code></li>\n<li>容器传输文件/文件夹到宿主机<br><code>docker cp ID全称:容器文件路径 本地路径</code></li>\n<li>修改本地已有镜像的名字<br><code>docker tag [ImageID] [NewImageNmae]:[tag]</code></li>\n<li>创建新的镜像<br><code>docker build -t [name]:[tag] -f [dockerfile_path] .</code></li>\n<li>开启一个容器<br><code>docker run -it(交互模式) -d(后台运行) --name [name] [name]:[tag]</code><br>如果需要启用<code>NVIDIA GPU</code>，可以加上命令参数<code>--gpus [all or device=0]</code></li>\n<li>进入一个正在运行的容器<br><code>docker exec -it [name] [command]</code></li>\n<li>从容器生成镜像<br><code>docker commit [container name or id] [image name:version]</code></li>\n<li>把docker容器中的文件传输到本机<br><code>docker cp [container name or id]:[path] [本机path]</code></li>\n<li>把本机文件传输到docker容器内<br><code>docker cp [本机path] [container name or id]:[path]</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文记录了使用Docker过程中的一些常用的、复杂的命令。</p>","more":"<ul>\n<li>停止并删除正在运行的容器<br><code>docker rm $(docker stop $(docker ps -aq))</code><br>如果是在windows操作系统，可能会执行出错，可以切换至powershell或者使用命令：<br><code>FOR /f &quot;tokens=*&quot; %i IN (&#39;command 1&#39;) DO [command 2] %i</code></li>\n<li>查看容器的长ID<br><code>docker inspect -f &#39;{?{.ID}}&#39; [name]</code><br><strong>去掉命令中的<code>?</code>,因为双括号会转义失败</strong></li>\n<li>宿主机向容器内传输文件/文件夹<br><code>docker cp 本地文件路径 ID全称:容器路径</code></li>\n<li>容器传输文件/文件夹到宿主机<br><code>docker cp ID全称:容器文件路径 本地路径</code></li>\n<li>修改本地已有镜像的名字<br><code>docker tag [ImageID] [NewImageNmae]:[tag]</code></li>\n<li>创建新的镜像<br><code>docker build -t [name]:[tag] -f [dockerfile_path] .</code></li>\n<li>开启一个容器<br><code>docker run -it(交互模式) -d(后台运行) --name [name] [name]:[tag]</code><br>如果需要启用<code>NVIDIA GPU</code>，可以加上命令参数<code>--gpus [all or device=0]</code></li>\n<li>进入一个正在运行的容器<br><code>docker exec -it [name] [command]</code></li>\n<li>从容器生成镜像<br><code>docker commit [container name or id] [image name:version]</code></li>\n<li>把docker容器中的文件传输到本机<br><code>docker cp [container name or id]:[path] [本机path]</code></li>\n<li>把本机文件传输到docker容器内<br><code>docker cp [本机path] [container name or id]:[path]</code></li>\n</ul>"},{"title":"Git命令学习记录","date":"2018-12-29T07:48:51.000Z","updated":"2019-01-02T06:38:24.000Z","_content":"\n本文记录了使用Git过程中一些常用的、复杂的命令。\n\n<!--more-->\n\n- 删除远程仓库的文件,保留本地的文件\n\n  ```\n  git rm -r /path/to/filename\n  git commit -m \"msg\"\n  git push\n  ```\n\n- 删除远程仓库的文件,同时删除本地文件\n\n  ```\n  git rm /path/to/filename\n  git commit -m \"msg\"\n  git push\n  ```\n\n\n- 查看本地所有分支\n\n  ```\n  git branch -a\n  ```\n  \n- 查看本地分支\n\n  ```\n  git branch\n  ```\n\n- 切换分支\n\n  ```\n  git checkout [branchname]\n  ```\n  \n- 查看各个分支当前所指的对象\n\n  ```\n  git log --oneline --decorate\n  ```\n  \n- 如果我同一项目有两个不同的版本，怎么切换某一版本到master分支呢？比如说我有两个分支名字为A和B，目前默认master分支指向A，现在我想把master切换至B，该怎么做呢？\n  \n  ```\n  git branch -m master A\n  把当前的master分支内容放置分支A\n  git branch -m B master\n  将分支B重命名为master\n  git push -f origin master\n  更新master分支\n  ```\n  \n- 如果在本地git仓库下有另外一个clone过来的git仓库，那么当使用`git add .`，然后再`git commit ...`时会报错。并且上传到仓库的文件夹是空的，解决方案如下：\n  1. `cd`到`clone`的仓库目录下，执行`rd /s/q .git`命令，删除`clone`的仓库目录下的`.git`文件夹\n  2. 回到仓库根目录删除仓库中的空文件夹\n\n     2.1 `git rm -r --cached \"themes/[branchname]\"`\n     \n     2.2 `git commit -m \"remove empty folder\"`\n     \n     2.3 `git push origin master`\n     \n  3. 在仓库根目录重新提交代码\n\n     3.1 `git add .`\n     \n     3.2 `git commit -m \"repush\"`\n     \n     3.3 `git push origin master`","source":"_posts/Git-learn.md","raw":"---\ntitle: Git命令学习记录\ndate: 2018-12-29 15:48:51\nupdated: 2019-01-02 14:38:24\ncategories: 小知识\ntags: Git\n---\n\n本文记录了使用Git过程中一些常用的、复杂的命令。\n\n<!--more-->\n\n- 删除远程仓库的文件,保留本地的文件\n\n  ```\n  git rm -r /path/to/filename\n  git commit -m \"msg\"\n  git push\n  ```\n\n- 删除远程仓库的文件,同时删除本地文件\n\n  ```\n  git rm /path/to/filename\n  git commit -m \"msg\"\n  git push\n  ```\n\n\n- 查看本地所有分支\n\n  ```\n  git branch -a\n  ```\n  \n- 查看本地分支\n\n  ```\n  git branch\n  ```\n\n- 切换分支\n\n  ```\n  git checkout [branchname]\n  ```\n  \n- 查看各个分支当前所指的对象\n\n  ```\n  git log --oneline --decorate\n  ```\n  \n- 如果我同一项目有两个不同的版本，怎么切换某一版本到master分支呢？比如说我有两个分支名字为A和B，目前默认master分支指向A，现在我想把master切换至B，该怎么做呢？\n  \n  ```\n  git branch -m master A\n  把当前的master分支内容放置分支A\n  git branch -m B master\n  将分支B重命名为master\n  git push -f origin master\n  更新master分支\n  ```\n  \n- 如果在本地git仓库下有另外一个clone过来的git仓库，那么当使用`git add .`，然后再`git commit ...`时会报错。并且上传到仓库的文件夹是空的，解决方案如下：\n  1. `cd`到`clone`的仓库目录下，执行`rd /s/q .git`命令，删除`clone`的仓库目录下的`.git`文件夹\n  2. 回到仓库根目录删除仓库中的空文件夹\n\n     2.1 `git rm -r --cached \"themes/[branchname]\"`\n     \n     2.2 `git commit -m \"remove empty folder\"`\n     \n     2.3 `git push origin master`\n     \n  3. 在仓库根目录重新提交代码\n\n     3.1 `git add .`\n     \n     3.2 `git commit -m \"repush\"`\n     \n     3.3 `git push origin master`","slug":"Git-learn","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusw8000520cddz241ks4","content":"<p>本文记录了使用Git过程中一些常用的、复杂的命令。</p>\n<a id=\"more\"></a>\n<ul>\n<li><p>删除远程仓库的文件,保留本地的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r /path/to/filename</span><br><span class=\"line\">git commit -m &quot;msg&quot;</span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除远程仓库的文件,同时删除本地文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm /path/to/filename</span><br><span class=\"line\">git commit -m &quot;msg&quot;</span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看本地所有分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>查看本地分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切换分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [branchname]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>查看各个分支当前所指的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --oneline --decorate</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>如果我同一项目有两个不同的版本，怎么切换某一版本到master分支呢？比如说我有两个分支名字为A和B，目前默认master分支指向A，现在我想把master切换至B，该怎么做呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m master A</span><br><span class=\"line\">把当前的master分支内容放置分支A</span><br><span class=\"line\">git branch -m B master</span><br><span class=\"line\">将分支B重命名为master</span><br><span class=\"line\">git push -f origin master</span><br><span class=\"line\">更新master分支</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>如果在本地git仓库下有另外一个clone过来的git仓库，那么当使用<code>git add .</code>，然后再<code>git commit ...</code>时会报错。并且上传到仓库的文件夹是空的，解决方案如下：</p>\n<ol>\n<li><code>cd</code>到<code>clone</code>的仓库目录下，执行<code>rd /s/q .git</code>命令，删除<code>clone</code>的仓库目录下的<code>.git</code>文件夹</li>\n<li><p>回到仓库根目录删除仓库中的空文件夹</p>\n<p>2.1 <code>git rm -r --cached &quot;themes/[branchname]&quot;</code></p>\n<p>2.2 <code>git commit -m &quot;remove empty folder&quot;</code></p>\n<p>2.3 <code>git push origin master</code></p>\n</li>\n<li><p>在仓库根目录重新提交代码</p>\n<p>3.1 <code>git add .</code></p>\n<p>3.2 <code>git commit -m &quot;repush&quot;</code></p>\n<p>3.3 <code>git push origin master</code></p>\n</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文记录了使用Git过程中一些常用的、复杂的命令。</p>","more":"<ul>\n<li><p>删除远程仓库的文件,保留本地的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r /path/to/filename</span><br><span class=\"line\">git commit -m &quot;msg&quot;</span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>删除远程仓库的文件,同时删除本地文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm /path/to/filename</span><br><span class=\"line\">git commit -m &quot;msg&quot;</span><br><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看本地所有分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -a</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>查看本地分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切换分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout [branchname]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>查看各个分支当前所指的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log --oneline --decorate</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>如果我同一项目有两个不同的版本，怎么切换某一版本到master分支呢？比如说我有两个分支名字为A和B，目前默认master分支指向A，现在我想把master切换至B，该怎么做呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m master A</span><br><span class=\"line\">把当前的master分支内容放置分支A</span><br><span class=\"line\">git branch -m B master</span><br><span class=\"line\">将分支B重命名为master</span><br><span class=\"line\">git push -f origin master</span><br><span class=\"line\">更新master分支</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>如果在本地git仓库下有另外一个clone过来的git仓库，那么当使用<code>git add .</code>，然后再<code>git commit ...</code>时会报错。并且上传到仓库的文件夹是空的，解决方案如下：</p>\n<ol>\n<li><code>cd</code>到<code>clone</code>的仓库目录下，执行<code>rd /s/q .git</code>命令，删除<code>clone</code>的仓库目录下的<code>.git</code>文件夹</li>\n<li><p>回到仓库根目录删除仓库中的空文件夹</p>\n<p>2.1 <code>git rm -r --cached &quot;themes/[branchname]&quot;</code></p>\n<p>2.2 <code>git commit -m &quot;remove empty folder&quot;</code></p>\n<p>2.3 <code>git push origin master</code></p>\n</li>\n<li><p>在仓库根目录重新提交代码</p>\n<p>3.1 <code>git add .</code></p>\n<p>3.2 <code>git commit -m &quot;repush&quot;</code></p>\n<p>3.3 <code>git push origin master</code></p>\n</li>\n</ol>\n</li>\n</ul>"},{"title":"MarkDown基本语法","date":"2018-12-29T07:23:57.000Z","_content":"\n本文介绍了Markdown的基本语法。\n\n<!--more-->\n\n所有使用Markdown语法标记的符号后要加一个空格`Space`\n\n# 一、 标题\t{{ '{#' }}...}\n\n使用`#`来设置标题级数,一个`#`则代表一级标题,字体大小最大\n\n`#` \n\n# 一级标题\n\n`##`\n\n## 二级标题\n\n`###`\n\n### 三级标题\n\n`####`\n\n#### 四级标题\n\n`#####`\n\n##### 五级标题\n\n`######`\n\n###### 六级标题 \n\n# 二、 列表\n\n## 1. 无序列表\n使用`-`、`+`、`*`三个符号都可以\n\n- 使用`-`\n\n+ 使用`+`\n\n* 使用`*`\n\n如果在列表中想取消下一行的列表性质,需要按下退格`Backspace`删除列表前的圆点后,然后按`Shift`+`Tab`组合键来退回首位.\n\n- 一级列表\n  - 二级列表\n    - 三级列表\n      - 四级列表\n\n共有三级标题\n\n## 2. 有序列表\n\n数字加点加空格,如`1.[Space]`、`2.[Space]`\n\n需要往前挪动请按`Tab`键,往后挪动请按`Shift`+`Tab`组合键\n\n1. 第一级\n2. 第二级\n   1. 第二级第一小节\n   2. 第二级第二小节\n      1. 第二级第二小节第一小小节\n      2. 第二级第二小节第二小小节\n   3. 第二级第三小节\n3. 第三级\n\n# 三、 字体\n\n- *斜体*\n\n  用法:`*[内容]*`或`_[内容]_`,包含在两个`*`星号或两个`_`下划线中间的内容会倾斜\n\n  `*Hello World*`:*Hello World*\n\n  `_Hello World_`:_Hello World_\n\n- **加粗**\n\n  用法:`**[内容]**`,包含在四个`*`星号中间的内容会加粗\n\n  `**Hello World**`:**Hello World**\n\n- ***斜体加粗***\n\n  用法:`***[内容]***`,包含在六个`*`星号中间的内容会加粗并斜体\n\n  `***Hello World***`:***Hello World***\n\n- ~~删除线~~\n\n  用法:`~~[内容]~~`,包含在四个`~`波浪号中间的内容会添加删除线\n\n  `~~Hello World~~`:~~Hello World~~\n\n# 四、 引用\n\n`>`表示引用,与`#`用法相同\n\n`>`\n\n> 一级引用\n\n`>>`\n\n> > 二级引用\n\n`>>>`\n\n> > > 三级引用\n\n退格使用`Shift`+`Tab`\n\n# 五、 分割线\n\n大于等于三个的`-`或`+`或`*`\n\n`---`\n\n---\n\n`+++`\n\n+++\n\n`***`\n\n***\n\n# 六、 图片\n\n语法:`![图片文字](图片地址 \"鼠标放置时显示的信息\")`\n\n例子:\n\n`![大桥](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1546072097132&di=8669a22f7be9af8266cb1580d15c155d&imgtype=0&src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F63d9f2d3572c11dfea8f528e6e2762d0f603c2c5.jpg \"美丽的桥梁\")`\n\n![大桥](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1546072097132&di=8669a22f7be9af8266cb1580d15c155d&imgtype=0&src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F63d9f2d3572c11dfea8f528e6e2762d0f603c2c5.jpg \"美丽的桥梁\")\n\n# 七、 超链接\n\n语法:`[超链接名](超链接地址 \"鼠标放置时显示的信息\")`\n\n例子:`[百度一下,你就知道](www.baidu.com \"我就是百度\")`\n\n[百度一下,你就知道](https://www.baidu.com \"我就是百度\")\n\n# 八、 代码\n\n## 1. 单行\n\n使用<code>&#96;</code>反引号包裹\n\n## 2.多行,代码块\n\n使用三个反引号包裹\n\n<code>&#96;&#96;&#96;</code>\n\n使用<code>&#96;&#96;&#96;</code>+编程语言可以打开代码编辑器\n\n如 <code>&#96;&#96;&#96;</code>+python\n\n```python\nimport sys\n这是一个python语法的编译器\n```\n\n# 九、 表格\n\n每一行都使用`|`隔开\n\n第二行使用`:`设置对齐,两边都加表示文字居中,加在左边表示居左\n\n```\n|标题1|标题2|标题3|\n|-|:-:|:-|\n|1|2|3|\n```\n\n| 标题1 | 标题2 | 标题3 |\n| ----- | :---: | :---- |\n| 1     |   2   | 3     |\n\n\n\n\n\n# 十、 流程图\n\n```\n​```flow\nst=>start: 开始\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n​```\n```\n\n```flow\nst=>start: 开始\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n\n\n# 其他疑难杂症\n\n1. 如何在页面中显示左右尖括号呢？比如`<`和`>`\n\n   左尖括号使用ASCII码`&#60;`，右尖括号使用`&#62;`\n\n   ","source":"_posts/MarkDown-Grammar.md","raw":"---\ntitle:  MarkDown基本语法\ndate:   2018-12-29 15:23:57\ncategories: 小知识\ntags: markdown\n---\n\n本文介绍了Markdown的基本语法。\n\n<!--more-->\n\n所有使用Markdown语法标记的符号后要加一个空格`Space`\n\n# 一、 标题\t{{ '{#' }}...}\n\n使用`#`来设置标题级数,一个`#`则代表一级标题,字体大小最大\n\n`#` \n\n# 一级标题\n\n`##`\n\n## 二级标题\n\n`###`\n\n### 三级标题\n\n`####`\n\n#### 四级标题\n\n`#####`\n\n##### 五级标题\n\n`######`\n\n###### 六级标题 \n\n# 二、 列表\n\n## 1. 无序列表\n使用`-`、`+`、`*`三个符号都可以\n\n- 使用`-`\n\n+ 使用`+`\n\n* 使用`*`\n\n如果在列表中想取消下一行的列表性质,需要按下退格`Backspace`删除列表前的圆点后,然后按`Shift`+`Tab`组合键来退回首位.\n\n- 一级列表\n  - 二级列表\n    - 三级列表\n      - 四级列表\n\n共有三级标题\n\n## 2. 有序列表\n\n数字加点加空格,如`1.[Space]`、`2.[Space]`\n\n需要往前挪动请按`Tab`键,往后挪动请按`Shift`+`Tab`组合键\n\n1. 第一级\n2. 第二级\n   1. 第二级第一小节\n   2. 第二级第二小节\n      1. 第二级第二小节第一小小节\n      2. 第二级第二小节第二小小节\n   3. 第二级第三小节\n3. 第三级\n\n# 三、 字体\n\n- *斜体*\n\n  用法:`*[内容]*`或`_[内容]_`,包含在两个`*`星号或两个`_`下划线中间的内容会倾斜\n\n  `*Hello World*`:*Hello World*\n\n  `_Hello World_`:_Hello World_\n\n- **加粗**\n\n  用法:`**[内容]**`,包含在四个`*`星号中间的内容会加粗\n\n  `**Hello World**`:**Hello World**\n\n- ***斜体加粗***\n\n  用法:`***[内容]***`,包含在六个`*`星号中间的内容会加粗并斜体\n\n  `***Hello World***`:***Hello World***\n\n- ~~删除线~~\n\n  用法:`~~[内容]~~`,包含在四个`~`波浪号中间的内容会添加删除线\n\n  `~~Hello World~~`:~~Hello World~~\n\n# 四、 引用\n\n`>`表示引用,与`#`用法相同\n\n`>`\n\n> 一级引用\n\n`>>`\n\n> > 二级引用\n\n`>>>`\n\n> > > 三级引用\n\n退格使用`Shift`+`Tab`\n\n# 五、 分割线\n\n大于等于三个的`-`或`+`或`*`\n\n`---`\n\n---\n\n`+++`\n\n+++\n\n`***`\n\n***\n\n# 六、 图片\n\n语法:`![图片文字](图片地址 \"鼠标放置时显示的信息\")`\n\n例子:\n\n`![大桥](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1546072097132&di=8669a22f7be9af8266cb1580d15c155d&imgtype=0&src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F63d9f2d3572c11dfea8f528e6e2762d0f603c2c5.jpg \"美丽的桥梁\")`\n\n![大桥](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1546072097132&di=8669a22f7be9af8266cb1580d15c155d&imgtype=0&src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F63d9f2d3572c11dfea8f528e6e2762d0f603c2c5.jpg \"美丽的桥梁\")\n\n# 七、 超链接\n\n语法:`[超链接名](超链接地址 \"鼠标放置时显示的信息\")`\n\n例子:`[百度一下,你就知道](www.baidu.com \"我就是百度\")`\n\n[百度一下,你就知道](https://www.baidu.com \"我就是百度\")\n\n# 八、 代码\n\n## 1. 单行\n\n使用<code>&#96;</code>反引号包裹\n\n## 2.多行,代码块\n\n使用三个反引号包裹\n\n<code>&#96;&#96;&#96;</code>\n\n使用<code>&#96;&#96;&#96;</code>+编程语言可以打开代码编辑器\n\n如 <code>&#96;&#96;&#96;</code>+python\n\n```python\nimport sys\n这是一个python语法的编译器\n```\n\n# 九、 表格\n\n每一行都使用`|`隔开\n\n第二行使用`:`设置对齐,两边都加表示文字居中,加在左边表示居左\n\n```\n|标题1|标题2|标题3|\n|-|:-:|:-|\n|1|2|3|\n```\n\n| 标题1 | 标题2 | 标题3 |\n| ----- | :---: | :---- |\n| 1     |   2   | 3     |\n\n\n\n\n\n# 十、 流程图\n\n```\n​```flow\nst=>start: 开始\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n​```\n```\n\n```flow\nst=>start: 开始\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n\n\n# 其他疑难杂症\n\n1. 如何在页面中显示左右尖括号呢？比如`<`和`>`\n\n   左尖括号使用ASCII码`&#60;`，右尖括号使用`&#62;`\n\n   ","slug":"MarkDown-Grammar","published":1,"updated":"2020-04-12T10:44:21.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusw9000620cdp2ojwudj","content":"<p>本文介绍了Markdown的基本语法。</p>\n<a id=\"more\"></a>\n<p>所有使用Markdown语法标记的符号后要加一个空格<code>Space</code></p>\n<h1 id=\"一、-标题-…\"><a href=\"#一、-标题-…\" class=\"headerlink\" title=\"一、 标题    …}\"></a>一、 标题    {#…}</h1><p>使用<code>#</code>来设置标题级数,一个<code>#</code>则代表一级标题,字体大小最大</p>\n<p><code>#</code> </p>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><p><code>##</code></p>\n<h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><p><code>###</code></p>\n<h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><p><code>####</code></p>\n<h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><p><code>#####</code></p>\n<h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><p><code>######</code></p>\n<h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><h1 id=\"二、-列表\"><a href=\"#二、-列表\" class=\"headerlink\" title=\"二、 列表\"></a>二、 列表</h1><h2 id=\"1-无序列表\"><a href=\"#1-无序列表\" class=\"headerlink\" title=\"1. 无序列表\"></a>1. 无序列表</h2><p>使用<code>-</code>、<code>+</code>、<code>*</code>三个符号都可以</p>\n<ul>\n<li>使用<code>-</code></li>\n</ul>\n<ul>\n<li>使用<code>+</code></li>\n</ul>\n<ul>\n<li>使用<code>*</code></li>\n</ul>\n<p>如果在列表中想取消下一行的列表性质,需要按下退格<code>Backspace</code>删除列表前的圆点后,然后按<code>Shift</code>+<code>Tab</code>组合键来退回首位.</p>\n<ul>\n<li>一级列表<ul>\n<li>二级列表<ul>\n<li>三级列表<ul>\n<li>四级列表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>共有三级标题</p>\n<h2 id=\"2-有序列表\"><a href=\"#2-有序列表\" class=\"headerlink\" title=\"2. 有序列表\"></a>2. 有序列表</h2><p>数字加点加空格,如<code>1.[Space]</code>、<code>2.[Space]</code></p>\n<p>需要往前挪动请按<code>Tab</code>键,往后挪动请按<code>Shift</code>+<code>Tab</code>组合键</p>\n<ol>\n<li>第一级</li>\n<li>第二级<ol>\n<li>第二级第一小节</li>\n<li>第二级第二小节<ol>\n<li>第二级第二小节第一小小节</li>\n<li>第二级第二小节第二小小节</li>\n</ol>\n</li>\n<li>第二级第三小节</li>\n</ol>\n</li>\n<li>第三级</li>\n</ol>\n<h1 id=\"三、-字体\"><a href=\"#三、-字体\" class=\"headerlink\" title=\"三、 字体\"></a>三、 字体</h1><ul>\n<li><p><em>斜体</em></p>\n<p>用法:<code>*[内容]*</code>或<code>_[内容]_</code>,包含在两个<code>*</code>星号或两个<code>_</code>下划线中间的内容会倾斜</p>\n<p><code>*Hello World*</code>:<em>Hello World</em></p>\n<p><code>_Hello World_</code>:_Hello World_</p>\n</li>\n<li><p><strong>加粗</strong></p>\n<p>用法:<code>**[内容]**</code>,包含在四个<code>*</code>星号中间的内容会加粗</p>\n<p><code>**Hello World**</code>:<strong>Hello World</strong></p>\n</li>\n<li><p><strong><em>斜体加粗</em></strong></p>\n<p>用法:<code>***[内容]***</code>,包含在六个<code>*</code>星号中间的内容会加粗并斜体</p>\n<p><code>***Hello World***</code>:<strong><em>Hello World</em></strong></p>\n</li>\n<li><p><del>删除线</del></p>\n<p>用法:<code>~~[内容]~~</code>,包含在四个<code>~</code>波浪号中间的内容会添加删除线</p>\n<p><code>~~Hello World~~</code>:<del>Hello World</del></p>\n</li>\n</ul>\n<h1 id=\"四、-引用\"><a href=\"#四、-引用\" class=\"headerlink\" title=\"四、 引用\"></a>四、 引用</h1><p><code>&gt;</code>表示引用,与<code>#</code>用法相同</p>\n<p><code>&gt;</code></p>\n<blockquote>\n<p>一级引用</p>\n</blockquote>\n<p><code>&gt;&gt;</code></p>\n<blockquote>\n<blockquote>\n<p>二级引用</p>\n</blockquote>\n</blockquote>\n<p><code>&gt;&gt;&gt;</code></p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>三级引用</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>退格使用<code>Shift</code>+<code>Tab</code></p>\n<h1 id=\"五、-分割线\"><a href=\"#五、-分割线\" class=\"headerlink\" title=\"五、 分割线\"></a>五、 分割线</h1><p>大于等于三个的<code>-</code>或<code>+</code>或<code>*</code></p>\n<p><code>---</code></p>\n<hr>\n<p><code>+++</code></p>\n<p>+++</p>\n<p><code>***</code></p>\n<hr>\n<h1 id=\"六、-图片\"><a href=\"#六、-图片\" class=\"headerlink\" title=\"六、 图片\"></a>六、 图片</h1><p>语法:<code>![图片文字](图片地址 &quot;鼠标放置时显示的信息&quot;)</code></p>\n<p>例子:</p>\n<p><code>![大桥](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1546072097132&amp;di=8669a22f7be9af8266cb1580d15c155d&amp;imgtype=0&amp;src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F63d9f2d3572c11dfea8f528e6e2762d0f603c2c5.jpg &quot;美丽的桥梁&quot;)</code></p>\n<p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1546072097132&amp;di=8669a22f7be9af8266cb1580d15c155d&amp;imgtype=0&amp;src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F63d9f2d3572c11dfea8f528e6e2762d0f603c2c5.jpg\" alt=\"大桥\" title=\"美丽的桥梁\"></p>\n<h1 id=\"七、-超链接\"><a href=\"#七、-超链接\" class=\"headerlink\" title=\"七、 超链接\"></a>七、 超链接</h1><p>语法:<code>[超链接名](超链接地址 &quot;鼠标放置时显示的信息&quot;)</code></p>\n<p>例子:<code>[百度一下,你就知道](www.baidu.com &quot;我就是百度&quot;)</code></p>\n<p><a href=\"https://www.baidu.com\" title=\"我就是百度\" rel=\"external nofollow\" target=\"_blank\">百度一下,你就知道</a></p>\n<h1 id=\"八、-代码\"><a href=\"#八、-代码\" class=\"headerlink\" title=\"八、 代码\"></a>八、 代码</h1><h2 id=\"1-单行\"><a href=\"#1-单行\" class=\"headerlink\" title=\"1. 单行\"></a>1. 单行</h2><p>使用<code>&#96;</code>反引号包裹</p>\n<h2 id=\"2-多行-代码块\"><a href=\"#2-多行-代码块\" class=\"headerlink\" title=\"2.多行,代码块\"></a>2.多行,代码块</h2><p>使用三个反引号包裹</p>\n<p><code>&#96;&#96;&#96;</code></p>\n<p>使用<code>&#96;&#96;&#96;</code>+编程语言可以打开代码编辑器</p>\n<p>如 <code>&#96;&#96;&#96;</code>+python</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">这是一个python语法的编译器</span><br></pre></td></tr></table></figure>\n<h1 id=\"九、-表格\"><a href=\"#九、-表格\" class=\"headerlink\" title=\"九、 表格\"></a>九、 表格</h1><p>每一行都使用<code>|</code>隔开</p>\n<p>第二行使用<code>:</code>设置对齐,两边都加表示文字居中,加在左边表示居左</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|标题1|标题2|标题3|</span><br><span class=\"line\">|-|:-:|:-|</span><br><span class=\"line\">|1|2|3|</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>标题1</th>\n<th style=\"text-align:center\">标题2</th>\n<th style=\"text-align:left\">标题3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:left\">3</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"十、-流程图\"><a href=\"#十、-流程图\" class=\"headerlink\" title=\"十、 流程图\"></a>十、 流程图</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">​```flow</span><br><span class=\"line\">st=&gt;start: 开始</span><br><span class=\"line\">op=&gt;operation: My Operation</span><br><span class=\"line\">cond=&gt;condition: Yes or No?</span><br><span class=\"line\">e=&gt;end</span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;op</span><br><span class=\"line\">​</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```flow</span><br><span class=\"line\">st=&gt;start: 开始</span><br><span class=\"line\">op=&gt;operation: My Operation</span><br><span class=\"line\">cond=&gt;condition: Yes or No?</span><br><span class=\"line\">e=&gt;end</span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n<h1 id=\"其他疑难杂症\"><a href=\"#其他疑难杂症\" class=\"headerlink\" title=\"其他疑难杂症\"></a>其他疑难杂症</h1><ol>\n<li><p>如何在页面中显示左右尖括号呢？比如<code>&lt;</code>和<code>&gt;</code></p>\n<p>左尖括号使用ASCII码<code>&amp;#60;</code>，右尖括号使用<code>&amp;#62;</code></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文介绍了Markdown的基本语法。</p>","more":"<p>所有使用Markdown语法标记的符号后要加一个空格<code>Space</code></p>\n<h1 id=\"一、-标题-…\"><a href=\"#一、-标题-…\" class=\"headerlink\" title=\"一、 标题    …}\"></a>一、 标题    {#…}</h1><p>使用<code>#</code>来设置标题级数,一个<code>#</code>则代表一级标题,字体大小最大</p>\n<p><code>#</code> </p>\n<h1 id=\"一级标题\"><a href=\"#一级标题\" class=\"headerlink\" title=\"一级标题\"></a>一级标题</h1><p><code>##</code></p>\n<h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><p><code>###</code></p>\n<h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><p><code>####</code></p>\n<h4 id=\"四级标题\"><a href=\"#四级标题\" class=\"headerlink\" title=\"四级标题\"></a>四级标题</h4><p><code>#####</code></p>\n<h5 id=\"五级标题\"><a href=\"#五级标题\" class=\"headerlink\" title=\"五级标题\"></a>五级标题</h5><p><code>######</code></p>\n<h6 id=\"六级标题\"><a href=\"#六级标题\" class=\"headerlink\" title=\"六级标题\"></a>六级标题</h6><h1 id=\"二、-列表\"><a href=\"#二、-列表\" class=\"headerlink\" title=\"二、 列表\"></a>二、 列表</h1><h2 id=\"1-无序列表\"><a href=\"#1-无序列表\" class=\"headerlink\" title=\"1. 无序列表\"></a>1. 无序列表</h2><p>使用<code>-</code>、<code>+</code>、<code>*</code>三个符号都可以</p>\n<ul>\n<li>使用<code>-</code></li>\n</ul>\n<ul>\n<li>使用<code>+</code></li>\n</ul>\n<ul>\n<li>使用<code>*</code></li>\n</ul>\n<p>如果在列表中想取消下一行的列表性质,需要按下退格<code>Backspace</code>删除列表前的圆点后,然后按<code>Shift</code>+<code>Tab</code>组合键来退回首位.</p>\n<ul>\n<li>一级列表<ul>\n<li>二级列表<ul>\n<li>三级列表<ul>\n<li>四级列表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>共有三级标题</p>\n<h2 id=\"2-有序列表\"><a href=\"#2-有序列表\" class=\"headerlink\" title=\"2. 有序列表\"></a>2. 有序列表</h2><p>数字加点加空格,如<code>1.[Space]</code>、<code>2.[Space]</code></p>\n<p>需要往前挪动请按<code>Tab</code>键,往后挪动请按<code>Shift</code>+<code>Tab</code>组合键</p>\n<ol>\n<li>第一级</li>\n<li>第二级<ol>\n<li>第二级第一小节</li>\n<li>第二级第二小节<ol>\n<li>第二级第二小节第一小小节</li>\n<li>第二级第二小节第二小小节</li>\n</ol>\n</li>\n<li>第二级第三小节</li>\n</ol>\n</li>\n<li>第三级</li>\n</ol>\n<h1 id=\"三、-字体\"><a href=\"#三、-字体\" class=\"headerlink\" title=\"三、 字体\"></a>三、 字体</h1><ul>\n<li><p><em>斜体</em></p>\n<p>用法:<code>*[内容]*</code>或<code>_[内容]_</code>,包含在两个<code>*</code>星号或两个<code>_</code>下划线中间的内容会倾斜</p>\n<p><code>*Hello World*</code>:<em>Hello World</em></p>\n<p><code>_Hello World_</code>:_Hello World_</p>\n</li>\n<li><p><strong>加粗</strong></p>\n<p>用法:<code>**[内容]**</code>,包含在四个<code>*</code>星号中间的内容会加粗</p>\n<p><code>**Hello World**</code>:<strong>Hello World</strong></p>\n</li>\n<li><p><strong><em>斜体加粗</em></strong></p>\n<p>用法:<code>***[内容]***</code>,包含在六个<code>*</code>星号中间的内容会加粗并斜体</p>\n<p><code>***Hello World***</code>:<strong><em>Hello World</em></strong></p>\n</li>\n<li><p><del>删除线</del></p>\n<p>用法:<code>~~[内容]~~</code>,包含在四个<code>~</code>波浪号中间的内容会添加删除线</p>\n<p><code>~~Hello World~~</code>:<del>Hello World</del></p>\n</li>\n</ul>\n<h1 id=\"四、-引用\"><a href=\"#四、-引用\" class=\"headerlink\" title=\"四、 引用\"></a>四、 引用</h1><p><code>&gt;</code>表示引用,与<code>#</code>用法相同</p>\n<p><code>&gt;</code></p>\n<blockquote>\n<p>一级引用</p>\n</blockquote>\n<p><code>&gt;&gt;</code></p>\n<blockquote>\n<blockquote>\n<p>二级引用</p>\n</blockquote>\n</blockquote>\n<p><code>&gt;&gt;&gt;</code></p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>三级引用</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>退格使用<code>Shift</code>+<code>Tab</code></p>\n<h1 id=\"五、-分割线\"><a href=\"#五、-分割线\" class=\"headerlink\" title=\"五、 分割线\"></a>五、 分割线</h1><p>大于等于三个的<code>-</code>或<code>+</code>或<code>*</code></p>\n<p><code>---</code></p>\n<hr>\n<p><code>+++</code></p>\n<p>+++</p>\n<p><code>***</code></p>\n<hr>\n<h1 id=\"六、-图片\"><a href=\"#六、-图片\" class=\"headerlink\" title=\"六、 图片\"></a>六、 图片</h1><p>语法:<code>![图片文字](图片地址 &quot;鼠标放置时显示的信息&quot;)</code></p>\n<p>例子:</p>\n<p><code>![大桥](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1546072097132&amp;di=8669a22f7be9af8266cb1580d15c155d&amp;imgtype=0&amp;src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F63d9f2d3572c11dfea8f528e6e2762d0f603c2c5.jpg &quot;美丽的桥梁&quot;)</code></p>\n<p><img src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1546072097132&amp;di=8669a22f7be9af8266cb1580d15c155d&amp;imgtype=0&amp;src=http%3A%2F%2Fd.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F63d9f2d3572c11dfea8f528e6e2762d0f603c2c5.jpg\" alt=\"大桥\" title=\"美丽的桥梁\"></p>\n<h1 id=\"七、-超链接\"><a href=\"#七、-超链接\" class=\"headerlink\" title=\"七、 超链接\"></a>七、 超链接</h1><p>语法:<code>[超链接名](超链接地址 &quot;鼠标放置时显示的信息&quot;)</code></p>\n<p>例子:<code>[百度一下,你就知道](www.baidu.com &quot;我就是百度&quot;)</code></p>\n<p><a href=\"https://www.baidu.com\" title=\"我就是百度\" rel=\"external nofollow\" target=\"_blank\">百度一下,你就知道</a></p>\n<h1 id=\"八、-代码\"><a href=\"#八、-代码\" class=\"headerlink\" title=\"八、 代码\"></a>八、 代码</h1><h2 id=\"1-单行\"><a href=\"#1-单行\" class=\"headerlink\" title=\"1. 单行\"></a>1. 单行</h2><p>使用<code>&#96;</code>反引号包裹</p>\n<h2 id=\"2-多行-代码块\"><a href=\"#2-多行-代码块\" class=\"headerlink\" title=\"2.多行,代码块\"></a>2.多行,代码块</h2><p>使用三个反引号包裹</p>\n<p><code>&#96;&#96;&#96;</code></p>\n<p>使用<code>&#96;&#96;&#96;</code>+编程语言可以打开代码编辑器</p>\n<p>如 <code>&#96;&#96;&#96;</code>+python</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\">这是一个python语法的编译器</span><br></pre></td></tr></table></figure>\n<h1 id=\"九、-表格\"><a href=\"#九、-表格\" class=\"headerlink\" title=\"九、 表格\"></a>九、 表格</h1><p>每一行都使用<code>|</code>隔开</p>\n<p>第二行使用<code>:</code>设置对齐,两边都加表示文字居中,加在左边表示居左</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|标题1|标题2|标题3|</span><br><span class=\"line\">|-|:-:|:-|</span><br><span class=\"line\">|1|2|3|</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>标题1</th>\n<th style=\"text-align:center\">标题2</th>\n<th style=\"text-align:left\">标题3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:left\">3</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"十、-流程图\"><a href=\"#十、-流程图\" class=\"headerlink\" title=\"十、 流程图\"></a>十、 流程图</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">​```flow</span><br><span class=\"line\">st=&gt;start: 开始</span><br><span class=\"line\">op=&gt;operation: My Operation</span><br><span class=\"line\">cond=&gt;condition: Yes or No?</span><br><span class=\"line\">e=&gt;end</span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;op</span><br><span class=\"line\">​</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```flow</span><br><span class=\"line\">st=&gt;start: 开始</span><br><span class=\"line\">op=&gt;operation: My Operation</span><br><span class=\"line\">cond=&gt;condition: Yes or No?</span><br><span class=\"line\">e=&gt;end</span><br><span class=\"line\">st-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>\n<h1 id=\"其他疑难杂症\"><a href=\"#其他疑难杂症\" class=\"headerlink\" title=\"其他疑难杂症\"></a>其他疑难杂症</h1><ol>\n<li><p>如何在页面中显示左右尖括号呢？比如<code>&lt;</code>和<code>&gt;</code></p>\n<p>左尖括号使用ASCII码<code>&amp;#60;</code>，右尖括号使用<code>&amp;#62;</code></p>\n</li>\n</ol>"},{"title":"conda环境和pip包的转移","copyright":true,"top":1,"date":"2019-04-14T08:52:41.000Z","_content":"\n本文记录了如何导出、导入自己的conda环境，对于pip安装的包如何导出、导入。\n\n<!--more-->\n\n# Conda 环境\n\n1. 激活环境\n`conda activate [env_name]`\n2. 导出环境\n`conda env export > [env_filename].yaml`\n当前环境将被保存在定义的`.yaml`文件中\n3. 导入环境\n`conda env create -f [env_filename].yaml`\n移植过来的conda环境只安装了原环境中使用`conda install`等命令安装的包, 使用`pip`命令安装的包需要重新安装\n\n# pip包\n\n1. 导出\n`pip freeze > requirements.txt`\n2. 导入\n`pip install -r requirements.txt`\n","source":"_posts/conda环境和pip包的转移.md","raw":"---\ntitle: conda环境和pip包的转移\ncopyright: true\ntop: 1\ndate: 2019-04-14 16:52:41\ncategories: Conda\ntags:\n- conda\n---\n\n本文记录了如何导出、导入自己的conda环境，对于pip安装的包如何导出、导入。\n\n<!--more-->\n\n# Conda 环境\n\n1. 激活环境\n`conda activate [env_name]`\n2. 导出环境\n`conda env export > [env_filename].yaml`\n当前环境将被保存在定义的`.yaml`文件中\n3. 导入环境\n`conda env create -f [env_filename].yaml`\n移植过来的conda环境只安装了原环境中使用`conda install`等命令安装的包, 使用`pip`命令安装的包需要重新安装\n\n# pip包\n\n1. 导出\n`pip freeze > requirements.txt`\n2. 导入\n`pip install -r requirements.txt`\n","slug":"conda环境和pip包的转移","published":1,"updated":"2019-05-13T14:27:05.706Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzuswa000720cddcoz0rgu","content":"<p>本文记录了如何导出、导入自己的conda环境，对于pip安装的包如何导出、导入。</p>\n<a id=\"more\"></a>\n<h1 id=\"Conda-环境\"><a href=\"#Conda-环境\" class=\"headerlink\" title=\"Conda 环境\"></a>Conda 环境</h1><ol>\n<li>激活环境<br><code>conda activate [env_name]</code></li>\n<li>导出环境<br><code>conda env export &gt; [env_filename].yaml</code><br>当前环境将被保存在定义的<code>.yaml</code>文件中</li>\n<li>导入环境<br><code>conda env create -f [env_filename].yaml</code><br>移植过来的conda环境只安装了原环境中使用<code>conda install</code>等命令安装的包, 使用<code>pip</code>命令安装的包需要重新安装</li>\n</ol>\n<h1 id=\"pip包\"><a href=\"#pip包\" class=\"headerlink\" title=\"pip包\"></a>pip包</h1><ol>\n<li>导出<br><code>pip freeze &gt; requirements.txt</code></li>\n<li>导入<br><code>pip install -r requirements.txt</code></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文记录了如何导出、导入自己的conda环境，对于pip安装的包如何导出、导入。</p>","more":"<h1 id=\"Conda-环境\"><a href=\"#Conda-环境\" class=\"headerlink\" title=\"Conda 环境\"></a>Conda 环境</h1><ol>\n<li>激活环境<br><code>conda activate [env_name]</code></li>\n<li>导出环境<br><code>conda env export &gt; [env_filename].yaml</code><br>当前环境将被保存在定义的<code>.yaml</code>文件中</li>\n<li>导入环境<br><code>conda env create -f [env_filename].yaml</code><br>移植过来的conda环境只安装了原环境中使用<code>conda install</code>等命令安装的包, 使用<code>pip</code>命令安装的包需要重新安装</li>\n</ol>\n<h1 id=\"pip包\"><a href=\"#pip包\" class=\"headerlink\" title=\"pip包\"></a>pip包</h1><ol>\n<li>导出<br><code>pip freeze &gt; requirements.txt</code></li>\n<li>导入<br><code>pip install -r requirements.txt</code></li>\n</ol>"},{"title":"Deep Exploration via Bootstrapped DQN","copyright":true,"mathjax":true,"top":1,"date":"2020-04-11T04:35:24.000Z","keywords":null,"description":null,"_content":"\n\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1602.04621](http://arxiv.org/abs/1602.04621)\n\n","source":"_posts/bootstrapped-dqn.md","raw":"---\ntitle: Deep Exploration via Bootstrapped DQN\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-04-11 12:35:24\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1602.04621](http://arxiv.org/abs/1602.04621)\n\n","slug":"bootstrapped-dqn","published":1,"updated":"2020-04-11T04:39:56.646Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzuswb000a20cdfekfv8t7","content":"<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1602.04621\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1602.04621</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1602.04621\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1602.04621</a></p>"},{"title":"在MacOS上为树莓派烧录系统","copyright":true,"mathjax":false,"top":1,"date":"2020-04-24T08:03:37.000Z","keywords":null,"description":null,"_content":"\n此篇博文用于记录在MacOS系统上为TF卡烧录树莓派操作系统。\n\n<!--more-->\n\n# 下载镜像\n\n网址：[https://www.raspberrypi.org/downloads/](https://www.raspberrypi.org/downloads/)\n\n![](./burn-system2raspberry-in-macos/downloads.png)\n\n我试验下来，上图中的`Raspberry Pi Imager for macOS`并不好用。因此，我们点左下角的Raspbian图片下载镜像。\n\n![](./burn-system2raspberry-in-macos/imgs.png)\n\n这边目前有三种版本：\n\n1. 系统+桌面+推荐软件\n2. 系统+桌面\n3. 系统\n\n我选择了最简洁的Raspbian Buster Lite，下载`.zip`并解压出其中的`.img`文件。\n\n# TF卡格式化\n\n首先需要下载格式化工具，我这边使用的是`SD Memory Card Formatter`，这个软件在`windows`和`macos`上都可以用。这里是`macos`下的下载链接：[https://www.sdcard.org/downloads/formatter/eula_mac/index.html](https://www.sdcard.org/downloads/formatter/eula_mac/index.html)\n\n![](./burn-system2raspberry-in-macos/formatter.png)\n\n## 格式化\n\n1. 插入`TF`卡\n2. 打开`SD Memory Card Formatter`\n\n![](./burn-system2raspberry-in-macos/start.png)\n\n注意不要格式化错了卡，假如你插入了多个TF卡。上图中的`Volume label`是格式化后磁盘的命名。\n\n![](./burn-system2raspberry-in-macos/end.png)\n\n# 开始烧录\n\n## 查看驱动器列表\n\n在控制台输入命令：`diskutil list`\n\n![](./burn-system2raspberry-in-macos/cmd1.png)\n\n这里，我们获取到TF卡的磁盘路径为`/dev/disk2`\n\n## 取消TF卡的挂载\n\n在控制台输入命令：`diskutil unmountDisk + SD卡设备路径`\n\n![](./burn-system2raspberry-in-macos/cmd2.png)\n\n## 开始烧录\n\n在控制台输入命令：`sudo dd if=镜像路径 of=SD卡设备的路径 bs=1m;sync`，并输入管理员密码。\n\n注意：文件路径不要出现中文。可以将`bs=1m`改为`bs=4m`加快烧录的速度。\n\n这个时间有点长，需要耐心等待，400M的镜像大概耗时2分钟左右。\n\n![](./burn-system2raspberry-in-macos/success.png)\n\n## 编写树莓派的ssh配置与wifi配置文件\n\n新建两个`.txt`文件，分别命名为：\n\n- ssh\n- wpa_supplicant.conf\n\n注意，取消`.txt`后缀。\n\nssh文件为空即可，wpa_supplicant.conf文件中写入：\n\n```\ncountry=CN\nctrl_interface=DIR=/var/run/wpa_supplicant Group=netdev\nupdate_config=1\n\nnetwork={\n\tssid=\"Wifi1的名字\"\n\tpsk=\"密码\"\n\tpriority=优先级，越大越优先\n}\n\nnetwork={\n\tssid=\"Wifi2的名字\"\n\tpsk=\"密码\"\n\tpriority=优先级\n}\n```\n\n**然后将这两个文件移动至烧录系统镜像后TF卡的根目录。**\n\n这里有两个坑点：\n\n1. SSID名字中不能有符号`.`\n2. 优先级范围为1-10\n\n## 推出TF卡\n\n`diskutil eject SD卡设备路径`\n\n# 参考\n\n1. [MacOS下树莓派烧录img/iso文件到SD卡](https://www.jianshu.com/p/e95c406badaa)\n2. [mac下烧写树莓派系统](https://www.jianshu.com/p/4c5b7c1ad2a3)\n3. [树莓派raspbian系统自动连接WIFI开启ssh](http://relyn.cn/share/38)\n\n","source":"_posts/burn-system2raspberry-in-macos.md","raw":"---\ntitle: 在MacOS上为树莓派烧录系统\ncopyright: true\nmathjax: false\ntop: 1\ndate: 2020-04-24 16:03:37\ncategories: MacOS\ntags:\n- os\n- raspberry\nkeywords:\ndescription:\n---\n\n此篇博文用于记录在MacOS系统上为TF卡烧录树莓派操作系统。\n\n<!--more-->\n\n# 下载镜像\n\n网址：[https://www.raspberrypi.org/downloads/](https://www.raspberrypi.org/downloads/)\n\n![](./burn-system2raspberry-in-macos/downloads.png)\n\n我试验下来，上图中的`Raspberry Pi Imager for macOS`并不好用。因此，我们点左下角的Raspbian图片下载镜像。\n\n![](./burn-system2raspberry-in-macos/imgs.png)\n\n这边目前有三种版本：\n\n1. 系统+桌面+推荐软件\n2. 系统+桌面\n3. 系统\n\n我选择了最简洁的Raspbian Buster Lite，下载`.zip`并解压出其中的`.img`文件。\n\n# TF卡格式化\n\n首先需要下载格式化工具，我这边使用的是`SD Memory Card Formatter`，这个软件在`windows`和`macos`上都可以用。这里是`macos`下的下载链接：[https://www.sdcard.org/downloads/formatter/eula_mac/index.html](https://www.sdcard.org/downloads/formatter/eula_mac/index.html)\n\n![](./burn-system2raspberry-in-macos/formatter.png)\n\n## 格式化\n\n1. 插入`TF`卡\n2. 打开`SD Memory Card Formatter`\n\n![](./burn-system2raspberry-in-macos/start.png)\n\n注意不要格式化错了卡，假如你插入了多个TF卡。上图中的`Volume label`是格式化后磁盘的命名。\n\n![](./burn-system2raspberry-in-macos/end.png)\n\n# 开始烧录\n\n## 查看驱动器列表\n\n在控制台输入命令：`diskutil list`\n\n![](./burn-system2raspberry-in-macos/cmd1.png)\n\n这里，我们获取到TF卡的磁盘路径为`/dev/disk2`\n\n## 取消TF卡的挂载\n\n在控制台输入命令：`diskutil unmountDisk + SD卡设备路径`\n\n![](./burn-system2raspberry-in-macos/cmd2.png)\n\n## 开始烧录\n\n在控制台输入命令：`sudo dd if=镜像路径 of=SD卡设备的路径 bs=1m;sync`，并输入管理员密码。\n\n注意：文件路径不要出现中文。可以将`bs=1m`改为`bs=4m`加快烧录的速度。\n\n这个时间有点长，需要耐心等待，400M的镜像大概耗时2分钟左右。\n\n![](./burn-system2raspberry-in-macos/success.png)\n\n## 编写树莓派的ssh配置与wifi配置文件\n\n新建两个`.txt`文件，分别命名为：\n\n- ssh\n- wpa_supplicant.conf\n\n注意，取消`.txt`后缀。\n\nssh文件为空即可，wpa_supplicant.conf文件中写入：\n\n```\ncountry=CN\nctrl_interface=DIR=/var/run/wpa_supplicant Group=netdev\nupdate_config=1\n\nnetwork={\n\tssid=\"Wifi1的名字\"\n\tpsk=\"密码\"\n\tpriority=优先级，越大越优先\n}\n\nnetwork={\n\tssid=\"Wifi2的名字\"\n\tpsk=\"密码\"\n\tpriority=优先级\n}\n```\n\n**然后将这两个文件移动至烧录系统镜像后TF卡的根目录。**\n\n这里有两个坑点：\n\n1. SSID名字中不能有符号`.`\n2. 优先级范围为1-10\n\n## 推出TF卡\n\n`diskutil eject SD卡设备路径`\n\n# 参考\n\n1. [MacOS下树莓派烧录img/iso文件到SD卡](https://www.jianshu.com/p/e95c406badaa)\n2. [mac下烧写树莓派系统](https://www.jianshu.com/p/4c5b7c1ad2a3)\n3. [树莓派raspbian系统自动连接WIFI开启ssh](http://relyn.cn/share/38)\n\n","slug":"burn-system2raspberry-in-macos","published":1,"updated":"2020-04-24T10:00:23.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzuswd000b20cdzyfh9un4","content":"<p>此篇博文用于记录在MacOS系统上为TF卡烧录树莓派操作系统。</p>\n<a id=\"more\"></a>\n<h1 id=\"下载镜像\"><a href=\"#下载镜像\" class=\"headerlink\" title=\"下载镜像\"></a>下载镜像</h1><p>网址：<a href=\"https://www.raspberrypi.org/downloads/\" rel=\"external nofollow\" target=\"_blank\">https://www.raspberrypi.org/downloads/</a></p>\n<p><img src=\"./burn-system2raspberry-in-macos/downloads.png\" alt=\"\"></p>\n<p>我试验下来，上图中的<code>Raspberry Pi Imager for macOS</code>并不好用。因此，我们点左下角的Raspbian图片下载镜像。</p>\n<p><img src=\"./burn-system2raspberry-in-macos/imgs.png\" alt=\"\"></p>\n<p>这边目前有三种版本：</p>\n<ol>\n<li>系统+桌面+推荐软件</li>\n<li>系统+桌面</li>\n<li>系统</li>\n</ol>\n<p>我选择了最简洁的Raspbian Buster Lite，下载<code>.zip</code>并解压出其中的<code>.img</code>文件。</p>\n<h1 id=\"TF卡格式化\"><a href=\"#TF卡格式化\" class=\"headerlink\" title=\"TF卡格式化\"></a>TF卡格式化</h1><p>首先需要下载格式化工具，我这边使用的是<code>SD Memory Card Formatter</code>，这个软件在<code>windows</code>和<code>macos</code>上都可以用。这里是<code>macos</code>下的下载链接：<a href=\"https://www.sdcard.org/downloads/formatter/eula_mac/index.html\" rel=\"external nofollow\" target=\"_blank\">https://www.sdcard.org/downloads/formatter/eula_mac/index.html</a></p>\n<p><img src=\"./burn-system2raspberry-in-macos/formatter.png\" alt=\"\"></p>\n<h2 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h2><ol>\n<li>插入<code>TF</code>卡</li>\n<li>打开<code>SD Memory Card Formatter</code></li>\n</ol>\n<p><img src=\"./burn-system2raspberry-in-macos/start.png\" alt=\"\"></p>\n<p>注意不要格式化错了卡，假如你插入了多个TF卡。上图中的<code>Volume label</code>是格式化后磁盘的命名。</p>\n<p><img src=\"./burn-system2raspberry-in-macos/end.png\" alt=\"\"></p>\n<h1 id=\"开始烧录\"><a href=\"#开始烧录\" class=\"headerlink\" title=\"开始烧录\"></a>开始烧录</h1><h2 id=\"查看驱动器列表\"><a href=\"#查看驱动器列表\" class=\"headerlink\" title=\"查看驱动器列表\"></a>查看驱动器列表</h2><p>在控制台输入命令：<code>diskutil list</code></p>\n<p><img src=\"./burn-system2raspberry-in-macos/cmd1.png\" alt=\"\"></p>\n<p>这里，我们获取到TF卡的磁盘路径为<code>/dev/disk2</code></p>\n<h2 id=\"取消TF卡的挂载\"><a href=\"#取消TF卡的挂载\" class=\"headerlink\" title=\"取消TF卡的挂载\"></a>取消TF卡的挂载</h2><p>在控制台输入命令：<code>diskutil unmountDisk + SD卡设备路径</code></p>\n<p><img src=\"./burn-system2raspberry-in-macos/cmd2.png\" alt=\"\"></p>\n<h2 id=\"开始烧录-1\"><a href=\"#开始烧录-1\" class=\"headerlink\" title=\"开始烧录\"></a>开始烧录</h2><p>在控制台输入命令：<code>sudo dd if=镜像路径 of=SD卡设备的路径 bs=1m;sync</code>，并输入管理员密码。</p>\n<p>注意：文件路径不要出现中文。可以将<code>bs=1m</code>改为<code>bs=4m</code>加快烧录的速度。</p>\n<p>这个时间有点长，需要耐心等待，400M的镜像大概耗时2分钟左右。</p>\n<p><img src=\"./burn-system2raspberry-in-macos/success.png\" alt=\"\"></p>\n<h2 id=\"编写树莓派的ssh配置与wifi配置文件\"><a href=\"#编写树莓派的ssh配置与wifi配置文件\" class=\"headerlink\" title=\"编写树莓派的ssh配置与wifi配置文件\"></a>编写树莓派的ssh配置与wifi配置文件</h2><p>新建两个<code>.txt</code>文件，分别命名为：</p>\n<ul>\n<li>ssh</li>\n<li>wpa_supplicant.conf</li>\n</ul>\n<p>注意，取消<code>.txt</code>后缀。</p>\n<p>ssh文件为空即可，wpa_supplicant.conf文件中写入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">country=CN</span><br><span class=\"line\">ctrl_interface=DIR=/var/run/wpa_supplicant Group=netdev</span><br><span class=\"line\">update_config=1</span><br><span class=\"line\"></span><br><span class=\"line\">network=&#123;</span><br><span class=\"line\">\tssid=&quot;Wifi1的名字&quot;</span><br><span class=\"line\">\tpsk=&quot;密码&quot;</span><br><span class=\"line\">\tpriority=优先级，越大越优先</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">network=&#123;</span><br><span class=\"line\">\tssid=&quot;Wifi2的名字&quot;</span><br><span class=\"line\">\tpsk=&quot;密码&quot;</span><br><span class=\"line\">\tpriority=优先级</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>然后将这两个文件移动至烧录系统镜像后TF卡的根目录。</strong></p>\n<p>这里有两个坑点：</p>\n<ol>\n<li>SSID名字中不能有符号<code>.</code></li>\n<li>优先级范围为1-10</li>\n</ol>\n<h2 id=\"推出TF卡\"><a href=\"#推出TF卡\" class=\"headerlink\" title=\"推出TF卡\"></a>推出TF卡</h2><p><code>diskutil eject SD卡设备路径</code></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://www.jianshu.com/p/e95c406badaa\" rel=\"external nofollow\" target=\"_blank\">MacOS下树莓派烧录img/iso文件到SD卡</a></li>\n<li><a href=\"https://www.jianshu.com/p/4c5b7c1ad2a3\" rel=\"external nofollow\" target=\"_blank\">mac下烧写树莓派系统</a></li>\n<li><a href=\"http://relyn.cn/share/38\" rel=\"external nofollow\" target=\"_blank\">树莓派raspbian系统自动连接WIFI开启ssh</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>此篇博文用于记录在MacOS系统上为TF卡烧录树莓派操作系统。</p>","more":"<h1 id=\"下载镜像\"><a href=\"#下载镜像\" class=\"headerlink\" title=\"下载镜像\"></a>下载镜像</h1><p>网址：<a href=\"https://www.raspberrypi.org/downloads/\" rel=\"external nofollow\" target=\"_blank\">https://www.raspberrypi.org/downloads/</a></p>\n<p><img src=\"./burn-system2raspberry-in-macos/downloads.png\" alt=\"\"></p>\n<p>我试验下来，上图中的<code>Raspberry Pi Imager for macOS</code>并不好用。因此，我们点左下角的Raspbian图片下载镜像。</p>\n<p><img src=\"./burn-system2raspberry-in-macos/imgs.png\" alt=\"\"></p>\n<p>这边目前有三种版本：</p>\n<ol>\n<li>系统+桌面+推荐软件</li>\n<li>系统+桌面</li>\n<li>系统</li>\n</ol>\n<p>我选择了最简洁的Raspbian Buster Lite，下载<code>.zip</code>并解压出其中的<code>.img</code>文件。</p>\n<h1 id=\"TF卡格式化\"><a href=\"#TF卡格式化\" class=\"headerlink\" title=\"TF卡格式化\"></a>TF卡格式化</h1><p>首先需要下载格式化工具，我这边使用的是<code>SD Memory Card Formatter</code>，这个软件在<code>windows</code>和<code>macos</code>上都可以用。这里是<code>macos</code>下的下载链接：<a href=\"https://www.sdcard.org/downloads/formatter/eula_mac/index.html\" rel=\"external nofollow\" target=\"_blank\">https://www.sdcard.org/downloads/formatter/eula_mac/index.html</a></p>\n<p><img src=\"./burn-system2raspberry-in-macos/formatter.png\" alt=\"\"></p>\n<h2 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h2><ol>\n<li>插入<code>TF</code>卡</li>\n<li>打开<code>SD Memory Card Formatter</code></li>\n</ol>\n<p><img src=\"./burn-system2raspberry-in-macos/start.png\" alt=\"\"></p>\n<p>注意不要格式化错了卡，假如你插入了多个TF卡。上图中的<code>Volume label</code>是格式化后磁盘的命名。</p>\n<p><img src=\"./burn-system2raspberry-in-macos/end.png\" alt=\"\"></p>\n<h1 id=\"开始烧录\"><a href=\"#开始烧录\" class=\"headerlink\" title=\"开始烧录\"></a>开始烧录</h1><h2 id=\"查看驱动器列表\"><a href=\"#查看驱动器列表\" class=\"headerlink\" title=\"查看驱动器列表\"></a>查看驱动器列表</h2><p>在控制台输入命令：<code>diskutil list</code></p>\n<p><img src=\"./burn-system2raspberry-in-macos/cmd1.png\" alt=\"\"></p>\n<p>这里，我们获取到TF卡的磁盘路径为<code>/dev/disk2</code></p>\n<h2 id=\"取消TF卡的挂载\"><a href=\"#取消TF卡的挂载\" class=\"headerlink\" title=\"取消TF卡的挂载\"></a>取消TF卡的挂载</h2><p>在控制台输入命令：<code>diskutil unmountDisk + SD卡设备路径</code></p>\n<p><img src=\"./burn-system2raspberry-in-macos/cmd2.png\" alt=\"\"></p>\n<h2 id=\"开始烧录-1\"><a href=\"#开始烧录-1\" class=\"headerlink\" title=\"开始烧录\"></a>开始烧录</h2><p>在控制台输入命令：<code>sudo dd if=镜像路径 of=SD卡设备的路径 bs=1m;sync</code>，并输入管理员密码。</p>\n<p>注意：文件路径不要出现中文。可以将<code>bs=1m</code>改为<code>bs=4m</code>加快烧录的速度。</p>\n<p>这个时间有点长，需要耐心等待，400M的镜像大概耗时2分钟左右。</p>\n<p><img src=\"./burn-system2raspberry-in-macos/success.png\" alt=\"\"></p>\n<h2 id=\"编写树莓派的ssh配置与wifi配置文件\"><a href=\"#编写树莓派的ssh配置与wifi配置文件\" class=\"headerlink\" title=\"编写树莓派的ssh配置与wifi配置文件\"></a>编写树莓派的ssh配置与wifi配置文件</h2><p>新建两个<code>.txt</code>文件，分别命名为：</p>\n<ul>\n<li>ssh</li>\n<li>wpa_supplicant.conf</li>\n</ul>\n<p>注意，取消<code>.txt</code>后缀。</p>\n<p>ssh文件为空即可，wpa_supplicant.conf文件中写入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">country=CN</span><br><span class=\"line\">ctrl_interface=DIR=/var/run/wpa_supplicant Group=netdev</span><br><span class=\"line\">update_config=1</span><br><span class=\"line\"></span><br><span class=\"line\">network=&#123;</span><br><span class=\"line\">\tssid=&quot;Wifi1的名字&quot;</span><br><span class=\"line\">\tpsk=&quot;密码&quot;</span><br><span class=\"line\">\tpriority=优先级，越大越优先</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">network=&#123;</span><br><span class=\"line\">\tssid=&quot;Wifi2的名字&quot;</span><br><span class=\"line\">\tpsk=&quot;密码&quot;</span><br><span class=\"line\">\tpriority=优先级</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>然后将这两个文件移动至烧录系统镜像后TF卡的根目录。</strong></p>\n<p>这里有两个坑点：</p>\n<ol>\n<li>SSID名字中不能有符号<code>.</code></li>\n<li>优先级范围为1-10</li>\n</ol>\n<h2 id=\"推出TF卡\"><a href=\"#推出TF卡\" class=\"headerlink\" title=\"推出TF卡\"></a>推出TF卡</h2><p><code>diskutil eject SD卡设备路径</code></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://www.jianshu.com/p/e95c406badaa\" rel=\"external nofollow\" target=\"_blank\">MacOS下树莓派烧录img/iso文件到SD卡</a></li>\n<li><a href=\"https://www.jianshu.com/p/4c5b7c1ad2a3\" rel=\"external nofollow\" target=\"_blank\">mac下烧写树莓派系统</a></li>\n<li><a href=\"http://relyn.cn/share/38\" rel=\"external nofollow\" target=\"_blank\">树莓派raspbian系统自动连接WIFI开启ssh</a></li>\n</ol>"},{"title":"配置阿里云上的服务器","copyright":true,"mathjax":false,"top":1,"date":"2020-01-13T01:22:24.000Z","keywords":null,"description":null,"_content":"\n本文记录了在阿里云服务器上配置自己训练环境的过程。\n\n<!--more-->\n\n# 安装Miniconda\n\n`wget https://repo.continuum.io/miniconda/Miniconda3-4.6.14-Linux-x86_64.sh`\n\n`sh Miniconda3-4.6.14-Linux-x86_64.sh`\n一路`ENTER`和`yes`\n\n`source ~/.bashrc`\n\n更新\n\n```\nconda update conda\nconda update --all\napt-get update\n```\n\n\n# 安装Git\n\n```\napt-get install git\nmkdir ~/keavnn\ncd ~/keavnn/\ngit clone https://github.com/StepNeverStop/RLt.git\nconda create -n tf2 python=3.6\nconda activate tf2\nconda install -y docopt numpy pillow yaml pyyaml pandas openpyxl\n\napt-get install apt-file\napt-file update\napt-file search libSM.so.6\napt-get install libsm6\napt-file search libXrender.so.1\napt-get install libxrender1\n\npip install protobuf grpcio grpcio-tools tensorflow tensorflow_probability\n```\n\n# 安装MuJoCo\n\n\n\n```\nmkdir ~/.mujoco\ncd .mujoco/\nwget url https://www.roboti.us/download/mujoco200_linux.zip\napt-get install zip\nunzip mujoco200_linux.zip\nwget url https://www.roboti.us/getid/getid_linux\nchmod +x getid_linux\n./getid_linux\n```\n\n接着把获取到的计算机ID用于注册30天免费的Mujoco引擎https://www.roboti.us/license.html\n\n把邮箱里的mjkey.txt通过ssh连接或者sftp软件File Zilla放置云服务器上\n\n放在`~/.mujoco`与`~/.mujoco/mujoco200_linux/bin`文件夹下\n\n```\nmv ~/.mujoco/mujoco200_linux ~/.mujoco/mujoco200\napt-get install nano\nnano ~/.bashrc\n```\n\n在尾部添加`export LD_LIBRARY_PATH=$HOME/.mujoco/mujoco200/bin`，` export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/.mujoco/mujoco200/bin`然后保存退出\n\n```\nsource ~/.bashrc\napt install python3-pip\npip install --upgrade pip\n```\n\n注意：在配置完Git之后：\n\n```\nconda activate tf2\napt install libosmesa6-dev\napt-get install python3 python-dev python3-dev \\\n     build-essential libssl-dev libffi-dev \\\n     libxml2-dev libxslt1-dev zlib1g-dev \\\n     python-pip libgl1-mesa-dev patchelf libglfw3 libglfw3-dev\npip install fasteners\npip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -U 'mujoco-py<2.1,>=2.0'\n\ncd ~/keavnn/RLt/gym\npip install -e '.[all]'\n```\n\n```\nSuccessfully built mujoco-py\nInstalling collected packages: mujoco-py\nSuccessfully installed mujoco-py-2.0.2.9\n```\n\n测试一下：\n\n```\n$ python3\nimport mujoco_py\nimport os\nmj_path, _ = mujoco_py.utils.discover_mujoco()\nxml_path = os.path.join(mj_path, 'model', 'humanoid.xml')\nmodel = mujoco_py.load_model_from_path(xml_path)\nsim = mujoco_py.MjSim(model)\n\nprint(sim.data.qpos)\n# [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n\nsim.step()\nprint(sim.data.qpos)\n# [-2.09531783e-19  2.72130735e-05  6.14480786e-22 -3.45474715e-06\n#   7.42993721e-06 -1.40711141e-04 -3.04253586e-04 -2.07559344e-04\n#   8.50646247e-05 -3.45474715e-06  7.42993721e-06 -1.40711141e-04\n#  -3.04253586e-04 -2.07559344e-04 -8.50646247e-05  1.11317030e-04\n#  -7.03465386e-05 -2.22862221e-05 -1.11317030e-04  7.03465386e-05\n#  -2.22862221e-05]\n```\n\n\n","source":"_posts/config-alios.md","raw":"---\ntitle: 配置阿里云上的服务器\ncopyright: true\nmathjax: false\ntop: 1\ndate: 2020-01-13 09:22:24\ncategories: Docker\ntags:\n- docker\n- conda\nkeywords:\ndescription:\n---\n\n本文记录了在阿里云服务器上配置自己训练环境的过程。\n\n<!--more-->\n\n# 安装Miniconda\n\n`wget https://repo.continuum.io/miniconda/Miniconda3-4.6.14-Linux-x86_64.sh`\n\n`sh Miniconda3-4.6.14-Linux-x86_64.sh`\n一路`ENTER`和`yes`\n\n`source ~/.bashrc`\n\n更新\n\n```\nconda update conda\nconda update --all\napt-get update\n```\n\n\n# 安装Git\n\n```\napt-get install git\nmkdir ~/keavnn\ncd ~/keavnn/\ngit clone https://github.com/StepNeverStop/RLt.git\nconda create -n tf2 python=3.6\nconda activate tf2\nconda install -y docopt numpy pillow yaml pyyaml pandas openpyxl\n\napt-get install apt-file\napt-file update\napt-file search libSM.so.6\napt-get install libsm6\napt-file search libXrender.so.1\napt-get install libxrender1\n\npip install protobuf grpcio grpcio-tools tensorflow tensorflow_probability\n```\n\n# 安装MuJoCo\n\n\n\n```\nmkdir ~/.mujoco\ncd .mujoco/\nwget url https://www.roboti.us/download/mujoco200_linux.zip\napt-get install zip\nunzip mujoco200_linux.zip\nwget url https://www.roboti.us/getid/getid_linux\nchmod +x getid_linux\n./getid_linux\n```\n\n接着把获取到的计算机ID用于注册30天免费的Mujoco引擎https://www.roboti.us/license.html\n\n把邮箱里的mjkey.txt通过ssh连接或者sftp软件File Zilla放置云服务器上\n\n放在`~/.mujoco`与`~/.mujoco/mujoco200_linux/bin`文件夹下\n\n```\nmv ~/.mujoco/mujoco200_linux ~/.mujoco/mujoco200\napt-get install nano\nnano ~/.bashrc\n```\n\n在尾部添加`export LD_LIBRARY_PATH=$HOME/.mujoco/mujoco200/bin`，` export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/.mujoco/mujoco200/bin`然后保存退出\n\n```\nsource ~/.bashrc\napt install python3-pip\npip install --upgrade pip\n```\n\n注意：在配置完Git之后：\n\n```\nconda activate tf2\napt install libosmesa6-dev\napt-get install python3 python-dev python3-dev \\\n     build-essential libssl-dev libffi-dev \\\n     libxml2-dev libxslt1-dev zlib1g-dev \\\n     python-pip libgl1-mesa-dev patchelf libglfw3 libglfw3-dev\npip install fasteners\npip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -U 'mujoco-py<2.1,>=2.0'\n\ncd ~/keavnn/RLt/gym\npip install -e '.[all]'\n```\n\n```\nSuccessfully built mujoco-py\nInstalling collected packages: mujoco-py\nSuccessfully installed mujoco-py-2.0.2.9\n```\n\n测试一下：\n\n```\n$ python3\nimport mujoco_py\nimport os\nmj_path, _ = mujoco_py.utils.discover_mujoco()\nxml_path = os.path.join(mj_path, 'model', 'humanoid.xml')\nmodel = mujoco_py.load_model_from_path(xml_path)\nsim = mujoco_py.MjSim(model)\n\nprint(sim.data.qpos)\n# [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\n\nsim.step()\nprint(sim.data.qpos)\n# [-2.09531783e-19  2.72130735e-05  6.14480786e-22 -3.45474715e-06\n#   7.42993721e-06 -1.40711141e-04 -3.04253586e-04 -2.07559344e-04\n#   8.50646247e-05 -3.45474715e-06  7.42993721e-06 -1.40711141e-04\n#  -3.04253586e-04 -2.07559344e-04 -8.50646247e-05  1.11317030e-04\n#  -7.03465386e-05 -2.22862221e-05 -1.11317030e-04  7.03465386e-05\n#  -2.22862221e-05]\n```\n\n\n","slug":"config-alios","published":1,"updated":"2020-01-16T18:04:24.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzuswf000f20cd28atv86w","content":"<p>本文记录了在阿里云服务器上配置自己训练环境的过程。</p>\n<a id=\"more\"></a>\n<h1 id=\"安装Miniconda\"><a href=\"#安装Miniconda\" class=\"headerlink\" title=\"安装Miniconda\"></a>安装Miniconda</h1><p><code>wget https://repo.continuum.io/miniconda/Miniconda3-4.6.14-Linux-x86_64.sh</code></p>\n<p><code>sh Miniconda3-4.6.14-Linux-x86_64.sh</code><br>一路<code>ENTER</code>和<code>yes</code></p>\n<p><code>source ~/.bashrc</code></p>\n<p>更新</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda update conda</span><br><span class=\"line\">conda update --all</span><br><span class=\"line\">apt-get update</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install git</span><br><span class=\"line\">mkdir ~/keavnn</span><br><span class=\"line\">cd ~/keavnn/</span><br><span class=\"line\">git clone https://github.com/StepNeverStop/RLt.git</span><br><span class=\"line\">conda create -n tf2 python=3.6</span><br><span class=\"line\">conda activate tf2</span><br><span class=\"line\">conda install -y docopt numpy pillow yaml pyyaml pandas openpyxl</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install apt-file</span><br><span class=\"line\">apt-file update</span><br><span class=\"line\">apt-file search libSM.so.6</span><br><span class=\"line\">apt-get install libsm6</span><br><span class=\"line\">apt-file search libXrender.so.1</span><br><span class=\"line\">apt-get install libxrender1</span><br><span class=\"line\"></span><br><span class=\"line\">pip install protobuf grpcio grpcio-tools tensorflow tensorflow_probability</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装MuJoCo\"><a href=\"#安装MuJoCo\" class=\"headerlink\" title=\"安装MuJoCo\"></a>安装MuJoCo</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir ~/.mujoco</span><br><span class=\"line\">cd .mujoco/</span><br><span class=\"line\">wget url https://www.roboti.us/download/mujoco200_linux.zip</span><br><span class=\"line\">apt-get install zip</span><br><span class=\"line\">unzip mujoco200_linux.zip</span><br><span class=\"line\">wget url https://www.roboti.us/getid/getid_linux</span><br><span class=\"line\">chmod +x getid_linux</span><br><span class=\"line\">./getid_linux</span><br></pre></td></tr></table></figure>\n<p>接着把获取到的计算机ID用于注册30天免费的Mujoco引擎<a href=\"https://www.roboti.us/license.html\" rel=\"external nofollow\" target=\"_blank\">https://www.roboti.us/license.html</a></p>\n<p>把邮箱里的mjkey.txt通过ssh连接或者sftp软件File Zilla放置云服务器上</p>\n<p>放在<code>~/.mujoco</code>与<code>~/.mujoco/mujoco200_linux/bin</code>文件夹下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv ~/.mujoco/mujoco200_linux ~/.mujoco/mujoco200</span><br><span class=\"line\">apt-get install nano</span><br><span class=\"line\">nano ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>在尾部添加<code>export LD_LIBRARY_PATH=$HOME/.mujoco/mujoco200/bin</code>，<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/.mujoco/mujoco200/bin</code>然后保存退出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.bashrc</span><br><span class=\"line\">apt install python3-pip</span><br><span class=\"line\">pip install --upgrade pip</span><br></pre></td></tr></table></figure>\n<p>注意：在配置完Git之后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda activate tf2</span><br><span class=\"line\">apt install libosmesa6-dev</span><br><span class=\"line\">apt-get install python3 python-dev python3-dev \\</span><br><span class=\"line\">     build-essential libssl-dev libffi-dev \\</span><br><span class=\"line\">     libxml2-dev libxslt1-dev zlib1g-dev \\</span><br><span class=\"line\">     python-pip libgl1-mesa-dev patchelf libglfw3 libglfw3-dev</span><br><span class=\"line\">pip install fasteners</span><br><span class=\"line\">pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -U &apos;mujoco-py&lt;2.1,&gt;=2.0&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">cd ~/keavnn/RLt/gym</span><br><span class=\"line\">pip install -e &apos;.[all]&apos;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Successfully built mujoco-py</span><br><span class=\"line\">Installing collected packages: mujoco-py</span><br><span class=\"line\">Successfully installed mujoco-py-2.0.2.9</span><br></pre></td></tr></table></figure>\n<p>测试一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3</span><br><span class=\"line\">import mujoco_py</span><br><span class=\"line\">import os</span><br><span class=\"line\">mj_path, _ = mujoco_py.utils.discover_mujoco()</span><br><span class=\"line\">xml_path = os.path.join(mj_path, &apos;model&apos;, &apos;humanoid.xml&apos;)</span><br><span class=\"line\">model = mujoco_py.load_model_from_path(xml_path)</span><br><span class=\"line\">sim = mujoco_py.MjSim(model)</span><br><span class=\"line\"></span><br><span class=\"line\">print(sim.data.qpos)</span><br><span class=\"line\"># [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]</span><br><span class=\"line\"></span><br><span class=\"line\">sim.step()</span><br><span class=\"line\">print(sim.data.qpos)</span><br><span class=\"line\"># [-2.09531783e-19  2.72130735e-05  6.14480786e-22 -3.45474715e-06</span><br><span class=\"line\">#   7.42993721e-06 -1.40711141e-04 -3.04253586e-04 -2.07559344e-04</span><br><span class=\"line\">#   8.50646247e-05 -3.45474715e-06  7.42993721e-06 -1.40711141e-04</span><br><span class=\"line\">#  -3.04253586e-04 -2.07559344e-04 -8.50646247e-05  1.11317030e-04</span><br><span class=\"line\">#  -7.03465386e-05 -2.22862221e-05 -1.11317030e-04  7.03465386e-05</span><br><span class=\"line\">#  -2.22862221e-05]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>本文记录了在阿里云服务器上配置自己训练环境的过程。</p>","more":"<h1 id=\"安装Miniconda\"><a href=\"#安装Miniconda\" class=\"headerlink\" title=\"安装Miniconda\"></a>安装Miniconda</h1><p><code>wget https://repo.continuum.io/miniconda/Miniconda3-4.6.14-Linux-x86_64.sh</code></p>\n<p><code>sh Miniconda3-4.6.14-Linux-x86_64.sh</code><br>一路<code>ENTER</code>和<code>yes</code></p>\n<p><code>source ~/.bashrc</code></p>\n<p>更新</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda update conda</span><br><span class=\"line\">conda update --all</span><br><span class=\"line\">apt-get update</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install git</span><br><span class=\"line\">mkdir ~/keavnn</span><br><span class=\"line\">cd ~/keavnn/</span><br><span class=\"line\">git clone https://github.com/StepNeverStop/RLt.git</span><br><span class=\"line\">conda create -n tf2 python=3.6</span><br><span class=\"line\">conda activate tf2</span><br><span class=\"line\">conda install -y docopt numpy pillow yaml pyyaml pandas openpyxl</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install apt-file</span><br><span class=\"line\">apt-file update</span><br><span class=\"line\">apt-file search libSM.so.6</span><br><span class=\"line\">apt-get install libsm6</span><br><span class=\"line\">apt-file search libXrender.so.1</span><br><span class=\"line\">apt-get install libxrender1</span><br><span class=\"line\"></span><br><span class=\"line\">pip install protobuf grpcio grpcio-tools tensorflow tensorflow_probability</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装MuJoCo\"><a href=\"#安装MuJoCo\" class=\"headerlink\" title=\"安装MuJoCo\"></a>安装MuJoCo</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir ~/.mujoco</span><br><span class=\"line\">cd .mujoco/</span><br><span class=\"line\">wget url https://www.roboti.us/download/mujoco200_linux.zip</span><br><span class=\"line\">apt-get install zip</span><br><span class=\"line\">unzip mujoco200_linux.zip</span><br><span class=\"line\">wget url https://www.roboti.us/getid/getid_linux</span><br><span class=\"line\">chmod +x getid_linux</span><br><span class=\"line\">./getid_linux</span><br></pre></td></tr></table></figure>\n<p>接着把获取到的计算机ID用于注册30天免费的Mujoco引擎<a href=\"https://www.roboti.us/license.html\" rel=\"external nofollow\" target=\"_blank\">https://www.roboti.us/license.html</a></p>\n<p>把邮箱里的mjkey.txt通过ssh连接或者sftp软件File Zilla放置云服务器上</p>\n<p>放在<code>~/.mujoco</code>与<code>~/.mujoco/mujoco200_linux/bin</code>文件夹下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv ~/.mujoco/mujoco200_linux ~/.mujoco/mujoco200</span><br><span class=\"line\">apt-get install nano</span><br><span class=\"line\">nano ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>在尾部添加<code>export LD_LIBRARY_PATH=$HOME/.mujoco/mujoco200/bin</code>，<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/.mujoco/mujoco200/bin</code>然后保存退出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.bashrc</span><br><span class=\"line\">apt install python3-pip</span><br><span class=\"line\">pip install --upgrade pip</span><br></pre></td></tr></table></figure>\n<p>注意：在配置完Git之后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda activate tf2</span><br><span class=\"line\">apt install libosmesa6-dev</span><br><span class=\"line\">apt-get install python3 python-dev python3-dev \\</span><br><span class=\"line\">     build-essential libssl-dev libffi-dev \\</span><br><span class=\"line\">     libxml2-dev libxslt1-dev zlib1g-dev \\</span><br><span class=\"line\">     python-pip libgl1-mesa-dev patchelf libglfw3 libglfw3-dev</span><br><span class=\"line\">pip install fasteners</span><br><span class=\"line\">pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple -U &apos;mujoco-py&lt;2.1,&gt;=2.0&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">cd ~/keavnn/RLt/gym</span><br><span class=\"line\">pip install -e &apos;.[all]&apos;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Successfully built mujoco-py</span><br><span class=\"line\">Installing collected packages: mujoco-py</span><br><span class=\"line\">Successfully installed mujoco-py-2.0.2.9</span><br></pre></td></tr></table></figure>\n<p>测试一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ python3</span><br><span class=\"line\">import mujoco_py</span><br><span class=\"line\">import os</span><br><span class=\"line\">mj_path, _ = mujoco_py.utils.discover_mujoco()</span><br><span class=\"line\">xml_path = os.path.join(mj_path, &apos;model&apos;, &apos;humanoid.xml&apos;)</span><br><span class=\"line\">model = mujoco_py.load_model_from_path(xml_path)</span><br><span class=\"line\">sim = mujoco_py.MjSim(model)</span><br><span class=\"line\"></span><br><span class=\"line\">print(sim.data.qpos)</span><br><span class=\"line\"># [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]</span><br><span class=\"line\"></span><br><span class=\"line\">sim.step()</span><br><span class=\"line\">print(sim.data.qpos)</span><br><span class=\"line\"># [-2.09531783e-19  2.72130735e-05  6.14480786e-22 -3.45474715e-06</span><br><span class=\"line\">#   7.42993721e-06 -1.40711141e-04 -3.04253586e-04 -2.07559344e-04</span><br><span class=\"line\">#   8.50646247e-05 -3.45474715e-06  7.42993721e-06 -1.40711141e-04</span><br><span class=\"line\">#  -3.04253586e-04 -2.07559344e-04 -8.50646247e-05  1.11317030e-04</span><br><span class=\"line\">#  -7.03465386e-05 -2.22862221e-05 -1.11317030e-04  7.03465386e-05</span><br><span class=\"line\">#  -2.22862221e-05]</span><br></pre></td></tr></table></figure>"},{"title":"Emergence of Locomotion Behaviours in Rich Environments","copyright":true,"mathjax":true,"top":1,"date":"2020-04-11T04:35:16.000Z","keywords":null,"description":null,"_content":"\n这篇论文主要提出了DPPO——Distributed PPO。\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1707.02286](http://arxiv.org/abs/1707.02286)\n\n\n\n# 文中精要\n\n作者提到PG算法通常具有高方差，而且策略对于超参数的选择十分敏感。很多种方法","source":"_posts/dppo.md","raw":"---\ntitle: Emergence of Locomotion Behaviours in Rich Environments\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-04-11 12:35:16\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n这篇论文主要提出了DPPO——Distributed PPO。\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1707.02286](http://arxiv.org/abs/1707.02286)\n\n\n\n# 文中精要\n\n作者提到PG算法通常具有高方差，而且策略对于超参数的选择十分敏感。很多种方法","slug":"dppo","published":1,"updated":"2020-04-11T06:15:45.331Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzuswh000h20cdzcowqs1r","content":"<p>这篇论文主要提出了DPPO——Distributed PPO。</p>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1707.02286\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1707.02286</a></p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>作者提到PG算法通常具有高方差，而且策略对于超参数的选择十分敏感。很多种方法</p>\n","site":{"data":{}},"excerpt":"<p>这篇论文主要提出了DPPO——Distributed PPO。</p>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1707.02286\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1707.02286</a></p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>作者提到PG算法通常具有高方差，而且策略对于超参数的选择十分敏感。很多种方法</p>"},{"title":"在Windows 10系统上安装gym等环境","copyright":true,"mathjax":false,"top":1,"date":"2019-10-17T07:04:58.000Z","keywords":null,"description":null,"_content":"\n在Win 10系统安装gym，atari，Box2D等环境\n\n<!--more-->\n\n# 环境\n\n- win 10 专业版\n- python 3.6\n\n# 安装gym\n\n```bash\ngit clone https://github.com/openai/gym\ncd gym\npip install -e .\n```\n\n# 安装atari\n\n```bash\npip install --no-index -f https://github.com/Kojoley/atari-py/releases atari_py\n```\n\n# 安装box2d\n\n在[https://www.lfd.uci.edu/~gohlke/pythonlibs/#pybox2d](https://www.lfd.uci.edu/~gohlke/pythonlibs/#pybox2d)下载相应的`.whl`文件\n\n![](./install-atari-and-box2d-on-win10/box2d.png)\n\n*注意分清python版本与操作系统位数*\n\n之后再`cmd`中输入：\n\n```bash\ncd download_dir\npip install [name].whl\n```\n\n","source":"_posts/install-atari-and-box2d-on-win10.md","raw":"---\ntitle: 在Windows 10系统上安装gym等环境\ncopyright: true\nmathjax: false\ntop: 1\ndate: 2019-10-17 15:04:58\ncategories:\t小知识\ntags:\n- rl\n- gym\nkeywords:\ndescription:\n---\n\n在Win 10系统安装gym，atari，Box2D等环境\n\n<!--more-->\n\n# 环境\n\n- win 10 专业版\n- python 3.6\n\n# 安装gym\n\n```bash\ngit clone https://github.com/openai/gym\ncd gym\npip install -e .\n```\n\n# 安装atari\n\n```bash\npip install --no-index -f https://github.com/Kojoley/atari-py/releases atari_py\n```\n\n# 安装box2d\n\n在[https://www.lfd.uci.edu/~gohlke/pythonlibs/#pybox2d](https://www.lfd.uci.edu/~gohlke/pythonlibs/#pybox2d)下载相应的`.whl`文件\n\n![](./install-atari-and-box2d-on-win10/box2d.png)\n\n*注意分清python版本与操作系统位数*\n\n之后再`cmd`中输入：\n\n```bash\ncd download_dir\npip install [name].whl\n```\n\n","slug":"install-atari-and-box2d-on-win10","published":1,"updated":"2019-10-17T14:27:02.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusx1000m20cdyeez4ghq","content":"<p>在Win 10系统安装gym，atari，Box2D等环境</p>\n<a id=\"more\"></a>\n<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><ul>\n<li>win 10 专业版</li>\n<li>python 3.6</li>\n</ul>\n<h1 id=\"安装gym\"><a href=\"#安装gym\" class=\"headerlink\" title=\"安装gym\"></a>安装gym</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/openai/gym</span><br><span class=\"line\"><span class=\"built_in\">cd</span> gym</span><br><span class=\"line\">pip install -e .</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装atari\"><a href=\"#安装atari\" class=\"headerlink\" title=\"安装atari\"></a>安装atari</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install --no-index -f https://github.com/Kojoley/atari-py/releases atari_py</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装box2d\"><a href=\"#安装box2d\" class=\"headerlink\" title=\"安装box2d\"></a>安装box2d</h1><p>在<a href=\"https://www.lfd.uci.edu/~gohlke/pythonlibs/#pybox2d\" rel=\"external nofollow\" target=\"_blank\">https://www.lfd.uci.edu/~gohlke/pythonlibs/#pybox2d</a>下载相应的<code>.whl</code>文件</p>\n<p><img src=\"./install-atari-and-box2d-on-win10/box2d.png\" alt=\"\"></p>\n<p><em>注意分清python版本与操作系统位数</em></p>\n<p>之后再<code>cmd</code>中输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> download_dir</span><br><span class=\"line\">pip install [name].whl</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>在Win 10系统安装gym，atari，Box2D等环境</p>","more":"<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><ul>\n<li>win 10 专业版</li>\n<li>python 3.6</li>\n</ul>\n<h1 id=\"安装gym\"><a href=\"#安装gym\" class=\"headerlink\" title=\"安装gym\"></a>安装gym</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/openai/gym</span><br><span class=\"line\"><span class=\"built_in\">cd</span> gym</span><br><span class=\"line\">pip install -e .</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装atari\"><a href=\"#安装atari\" class=\"headerlink\" title=\"安装atari\"></a>安装atari</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install --no-index -f https://github.com/Kojoley/atari-py/releases atari_py</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装box2d\"><a href=\"#安装box2d\" class=\"headerlink\" title=\"安装box2d\"></a>安装box2d</h1><p>在<a href=\"https://www.lfd.uci.edu/~gohlke/pythonlibs/#pybox2d\" rel=\"external nofollow\" target=\"_blank\">https://www.lfd.uci.edu/~gohlke/pythonlibs/#pybox2d</a>下载相应的<code>.whl</code>文件</p>\n<p><img src=\"./install-atari-and-box2d-on-win10/box2d.png\" alt=\"\"></p>\n<p><em>注意分清python版本与操作系统位数</em></p>\n<p>之后再<code>cmd</code>中输入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> download_dir</span><br><span class=\"line\">pip install [name].whl</span><br></pre></td></tr></table></figure>"},{"title":"Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation","copyright":true,"mathjax":true,"top":1,"date":"2020-04-11T04:35:31.000Z","keywords":null,"description":null,"_content":"\n\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1604.06057](http://arxiv.org/abs/1604.06057)\n\n","source":"_posts/h-dqn.md","raw":"---\ntitle: \"Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation\"\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-04-11 12:35:31\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1604.06057](http://arxiv.org/abs/1604.06057)\n\n","slug":"h-dqn","published":1,"updated":"2020-04-11T04:40:15.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusx3000o20cdfedfs1fg","content":"<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1604.06057\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1604.06057</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1604.06057\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1604.06057</a></p>"},{"title":"学习gRPC过程点滴记录","copyright":true,"mathjax":false,"top":1,"date":"2020-04-05T03:14:26.000Z","keywords":null,"description":null,"_content":"\n![](./learn-grpc/gRPC.svg)\n\n此博客用于记录学习gRPC(python)的过程。\n\n<!--more-->\n\n# gRPC\n\ngRPC默认使用协议缓冲池(Protocol Buffers)进行服务器与客户端之间的交互，它是用于序列化结构化数据的成熟的谷歌开源机制。\n\n大致流程是三步：\n\n- Define a service in a `.proto` file.\n- Generate server and client code using the `protocol buffer compiler`.\n- Use the Python gRPC API to write a simple client and server for your service.\n\n# 安装 gRPC\n\n```shell\n$ python -m pip install --upgrade pip\n$ python -m pip install grpcio\n$ python -m pip install grpcio-tools\t# 这个用来编译proto文件\n```\n\n# Protocal Buffer 3\n\n官方推荐使用**proto3**语法，因为它更简洁、强大，也支持更多语言。\n\n一个简单的`.proto`文件示例：\n\n```protobuf\nsyntax = \"proto3\";\n\n/* SearchRequest represents a search query, with pagination options to\n * indicate which results to include in the response. */\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n  repeated int32 int_list=4;\n}\n```\n\n- 第一行的`syntax`指定portobuf的语法版本，必须在第一行，不过不指定，默认为`proto2`\n- `message`用来定义客户端与服务器交互的数据结构，在上边例子中，`string query=1;`称为`field`，string/query/1分别为type/name/value\n- 每一个`field`有一个独特的值，用于在二进制消息格式中标识`field`。这个值的范围是[1, 2^29-1(536870911)]，其中，[19000,19999]是禁用的，是为协议缓冲区实现保留的。1-15使用1个字节编码，16-2047使用2个字节，所以常出现的`filed`应该尽量给予小的值\n- 注释是C/C++样式，使用`//`和`/*...*/`\n- `repeated`字段用于传输**列表数据**，比如上边的`int_list`，我就可以从客户端feed [1,2,3]，或者从客户端返回[1,2,3]\n\nproto与python数据类型对应表：\n\n|                        proto                        |   Python    |\n| :-------------------------------------------------: | :---------: |\n|                    float/double                     |    float    |\n|                int32/sint32/sfixed32                |     int     |\n| int64/uint32/uint64/sint64/fixed32/fixed64/sfixed64 |  int/long   |\n|                        bool                         |    bool     |\n|                       string                        | str/unicode |\n|                        Bytes                        |     str     |\n\n默认值：\n\n- strings, empty string\n- bytes, empty bytes\n- bools, false\n- numeric types, 0\n- enums, 默认值为第一个定义的枚举值，必须为0\n\n在`message`中使用枚举，可以这么定义：\n\n```protobuf\nmessage Cooking {\n    enum VegeType {\n        CAULIFLOWER = 0;\n        CUCUMBER = 1;\n    }\n    required VegeType type = 1;\n}\n```\n\n在python端可以用**以下三种方式**定义枚举字段：\n\n```python\nname_pb2.Cooking.CUCUMBER\nname_pb2.Cooking.VegeType.CUCUMBER\nname_pb2.Cooking.VegeTypeValue.Value('CUCUMBER')\n```\n\n\n\n对于客户端可RPC调用服务器的方式主要有四种，可以这样写：\n\n```protobuf\nsyntax = \"proto3\";\n\nservice RouteGuide {\n\t// 最简单方式，请求->响应\n  rpc GetFeature(Point) returns (Feature) {}\n\t// A server-to-client streaming RPC. 服务器流式响应\n  rpc ListFeatures(Rectangle) returns (stream Feature) {}\n\t// A client-to-server streaming RPC. 客户端流式请求\n  rpc RecordRoute(stream Point) returns (RouteSummary) {}\n  // A Bidirectional streaming RPC. 双向流式交互\n  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}\n}\n```\n\n重点在`stream`修饰符。\n\n就拿`rpc GetFeature(Point) returns (Feature) {}`来说，它生成的服务器端函数接口应该是这样的：\n\n`def GetFeature(self, request, context):`\n\n其中，request即为客户端发送的`Point`消息类，context提供特定于rpc的信息，如超时限制，该方法返回给客户端`Feature`类。\n\n# 下载官方示例\n\n```shell\n# Clone the repository to get the example code:\n$ git clone -b v1.28.1 https://github.com/grpc/grpc\n# Navigate to the \"hello, world\" Python example:\n$ cd grpc/examples/python/helloworld\n```\n\n```shell\n# server\n$ python greeter_server.py\n# client\n$ python greeter_client.py\n```\n\n# 生成服务器与客户端代码\n\n```shell\n$ python -m grpc_tools.protoc -I ../../protos --python_out=. --grpc_python_out=. ../../protos/[name].proto\n```\n\n- `--python_out`：指定编译生成处理 protobuf 相关的代码的路径\n- `--grpc_python_out`：指定编译生成处理 grpc 相关的代码的路径\n- `-I`：指定proto 文件的**目录**，然后再写文件路径\n\n这条命令会生成两个文件：\n\n- `name_pb2.py`包含我们定义的请求(request)、响应(response)类。\n- `name_pb2_grpc.py`包含服务器(server)、客户端(client)类。\n  - `&Stub`类被客户端调用服务端RPC\n  - `&Servicer`类定义实现服务端代码的接口\n  - 方法`add_&Servicer_to_server`，把我们定义的服务器类添加到`grpc.Server`\n\n\n\n# 编写服务器\n\n主要步骤：\n\n- 实现服务端接口函数。Implementing the servicer interface generated from our service definition with functions that perform the actual “work” of the service.\n- 开启服务器并监听客户端请求，产生响应。Running a gRPC server to listen for requests from clients and transmit responses.\n\n简而言之，就是重载`name_pb2_grpc.py`中`&Servicer`类的所有RPC方法。比如:\n\n```python\nclass RouteGuideServicer(route_guide_pb2_grpc.RouteGuideServicer):\n    \"\"\"Provides methods that implement functionality of route guide server.\"\"\"\n```\n\n接下来就是开启服务器，监听客户端请求了。\n\n```python\ndef serve():\n    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))\n    route_guide_pb2_grpc.add_RouteGuideServicer_to_server(RouteGuideServicer(), server)\n    server.add_insecure_port('[::]:50051')\n    server.start()\n    server.wait_for_termination()\n```\n\n# 编写客户端\n\n创建存根(stub)，从`name_pb2_grpc.py`中实例化`&Stub`类。\n\n```python\nchannel = grpc.insecure_channel('localhost:50051')\nstub = route_guide_pb2_grpc.RouteGuideStub(channel)\n```\n\n或者使用`with`上下文管理器：\n\n```python\nwith grpc.insecure_channel('localhost:50051') as channel:\n        stub = route_guide_pb2_grpc.RouteGuideStub(channel)\n```\n\n使用存根调用服务器端的方法，可以有同步与异步两种。\n\n同步：`feature = stub.GetFeature(point)`\n\n异步：\n\n```python\nfeature_future = stub.GetFeature.future(point)\nfeature = feature_future.result()\n```\n\n# 参考\n\n- [gRPC](https://www.grpc.io/docs/quickstart/python/)\n- [https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3)\n- [How to access python enums in protobufs](https://stackoverflow.com/questions/34407696/how-to-access-python-enums-in-protobufs)\n\n","source":"_posts/learn-grpc.md","raw":"---\ntitle: 学习gRPC过程点滴记录\ncopyright: true\nmathjax: false\ntop: 1\ndate: 2020-04-05 11:14:26\ncategories: Python\ntags:\n- python\nkeywords:\ndescription:\n---\n\n![](./learn-grpc/gRPC.svg)\n\n此博客用于记录学习gRPC(python)的过程。\n\n<!--more-->\n\n# gRPC\n\ngRPC默认使用协议缓冲池(Protocol Buffers)进行服务器与客户端之间的交互，它是用于序列化结构化数据的成熟的谷歌开源机制。\n\n大致流程是三步：\n\n- Define a service in a `.proto` file.\n- Generate server and client code using the `protocol buffer compiler`.\n- Use the Python gRPC API to write a simple client and server for your service.\n\n# 安装 gRPC\n\n```shell\n$ python -m pip install --upgrade pip\n$ python -m pip install grpcio\n$ python -m pip install grpcio-tools\t# 这个用来编译proto文件\n```\n\n# Protocal Buffer 3\n\n官方推荐使用**proto3**语法，因为它更简洁、强大，也支持更多语言。\n\n一个简单的`.proto`文件示例：\n\n```protobuf\nsyntax = \"proto3\";\n\n/* SearchRequest represents a search query, with pagination options to\n * indicate which results to include in the response. */\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n  repeated int32 int_list=4;\n}\n```\n\n- 第一行的`syntax`指定portobuf的语法版本，必须在第一行，不过不指定，默认为`proto2`\n- `message`用来定义客户端与服务器交互的数据结构，在上边例子中，`string query=1;`称为`field`，string/query/1分别为type/name/value\n- 每一个`field`有一个独特的值，用于在二进制消息格式中标识`field`。这个值的范围是[1, 2^29-1(536870911)]，其中，[19000,19999]是禁用的，是为协议缓冲区实现保留的。1-15使用1个字节编码，16-2047使用2个字节，所以常出现的`filed`应该尽量给予小的值\n- 注释是C/C++样式，使用`//`和`/*...*/`\n- `repeated`字段用于传输**列表数据**，比如上边的`int_list`，我就可以从客户端feed [1,2,3]，或者从客户端返回[1,2,3]\n\nproto与python数据类型对应表：\n\n|                        proto                        |   Python    |\n| :-------------------------------------------------: | :---------: |\n|                    float/double                     |    float    |\n|                int32/sint32/sfixed32                |     int     |\n| int64/uint32/uint64/sint64/fixed32/fixed64/sfixed64 |  int/long   |\n|                        bool                         |    bool     |\n|                       string                        | str/unicode |\n|                        Bytes                        |     str     |\n\n默认值：\n\n- strings, empty string\n- bytes, empty bytes\n- bools, false\n- numeric types, 0\n- enums, 默认值为第一个定义的枚举值，必须为0\n\n在`message`中使用枚举，可以这么定义：\n\n```protobuf\nmessage Cooking {\n    enum VegeType {\n        CAULIFLOWER = 0;\n        CUCUMBER = 1;\n    }\n    required VegeType type = 1;\n}\n```\n\n在python端可以用**以下三种方式**定义枚举字段：\n\n```python\nname_pb2.Cooking.CUCUMBER\nname_pb2.Cooking.VegeType.CUCUMBER\nname_pb2.Cooking.VegeTypeValue.Value('CUCUMBER')\n```\n\n\n\n对于客户端可RPC调用服务器的方式主要有四种，可以这样写：\n\n```protobuf\nsyntax = \"proto3\";\n\nservice RouteGuide {\n\t// 最简单方式，请求->响应\n  rpc GetFeature(Point) returns (Feature) {}\n\t// A server-to-client streaming RPC. 服务器流式响应\n  rpc ListFeatures(Rectangle) returns (stream Feature) {}\n\t// A client-to-server streaming RPC. 客户端流式请求\n  rpc RecordRoute(stream Point) returns (RouteSummary) {}\n  // A Bidirectional streaming RPC. 双向流式交互\n  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}\n}\n```\n\n重点在`stream`修饰符。\n\n就拿`rpc GetFeature(Point) returns (Feature) {}`来说，它生成的服务器端函数接口应该是这样的：\n\n`def GetFeature(self, request, context):`\n\n其中，request即为客户端发送的`Point`消息类，context提供特定于rpc的信息，如超时限制，该方法返回给客户端`Feature`类。\n\n# 下载官方示例\n\n```shell\n# Clone the repository to get the example code:\n$ git clone -b v1.28.1 https://github.com/grpc/grpc\n# Navigate to the \"hello, world\" Python example:\n$ cd grpc/examples/python/helloworld\n```\n\n```shell\n# server\n$ python greeter_server.py\n# client\n$ python greeter_client.py\n```\n\n# 生成服务器与客户端代码\n\n```shell\n$ python -m grpc_tools.protoc -I ../../protos --python_out=. --grpc_python_out=. ../../protos/[name].proto\n```\n\n- `--python_out`：指定编译生成处理 protobuf 相关的代码的路径\n- `--grpc_python_out`：指定编译生成处理 grpc 相关的代码的路径\n- `-I`：指定proto 文件的**目录**，然后再写文件路径\n\n这条命令会生成两个文件：\n\n- `name_pb2.py`包含我们定义的请求(request)、响应(response)类。\n- `name_pb2_grpc.py`包含服务器(server)、客户端(client)类。\n  - `&Stub`类被客户端调用服务端RPC\n  - `&Servicer`类定义实现服务端代码的接口\n  - 方法`add_&Servicer_to_server`，把我们定义的服务器类添加到`grpc.Server`\n\n\n\n# 编写服务器\n\n主要步骤：\n\n- 实现服务端接口函数。Implementing the servicer interface generated from our service definition with functions that perform the actual “work” of the service.\n- 开启服务器并监听客户端请求，产生响应。Running a gRPC server to listen for requests from clients and transmit responses.\n\n简而言之，就是重载`name_pb2_grpc.py`中`&Servicer`类的所有RPC方法。比如:\n\n```python\nclass RouteGuideServicer(route_guide_pb2_grpc.RouteGuideServicer):\n    \"\"\"Provides methods that implement functionality of route guide server.\"\"\"\n```\n\n接下来就是开启服务器，监听客户端请求了。\n\n```python\ndef serve():\n    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))\n    route_guide_pb2_grpc.add_RouteGuideServicer_to_server(RouteGuideServicer(), server)\n    server.add_insecure_port('[::]:50051')\n    server.start()\n    server.wait_for_termination()\n```\n\n# 编写客户端\n\n创建存根(stub)，从`name_pb2_grpc.py`中实例化`&Stub`类。\n\n```python\nchannel = grpc.insecure_channel('localhost:50051')\nstub = route_guide_pb2_grpc.RouteGuideStub(channel)\n```\n\n或者使用`with`上下文管理器：\n\n```python\nwith grpc.insecure_channel('localhost:50051') as channel:\n        stub = route_guide_pb2_grpc.RouteGuideStub(channel)\n```\n\n使用存根调用服务器端的方法，可以有同步与异步两种。\n\n同步：`feature = stub.GetFeature(point)`\n\n异步：\n\n```python\nfeature_future = stub.GetFeature.future(point)\nfeature = feature_future.result()\n```\n\n# 参考\n\n- [gRPC](https://www.grpc.io/docs/quickstart/python/)\n- [https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3)\n- [How to access python enums in protobufs](https://stackoverflow.com/questions/34407696/how-to-access-python-enums-in-protobufs)\n\n","slug":"learn-grpc","published":1,"updated":"2020-04-26T03:15:16.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusxv000s20cdb0q3pvfe","content":"<p><img src=\"./learn-grpc/gRPC.svg\" alt=\"\"></p>\n<p>此博客用于记录学习gRPC(python)的过程。</p>\n<a id=\"more\"></a>\n<h1 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h1><p>gRPC默认使用协议缓冲池(Protocol Buffers)进行服务器与客户端之间的交互，它是用于序列化结构化数据的成熟的谷歌开源机制。</p>\n<p>大致流程是三步：</p>\n<ul>\n<li>Define a service in a <code>.proto</code> file.</li>\n<li>Generate server and client code using the <code>protocol buffer compiler</code>.</li>\n<li>Use the Python gRPC API to write a simple client and server for your service.</li>\n</ul>\n<h1 id=\"安装-gRPC\"><a href=\"#安装-gRPC\" class=\"headerlink\" title=\"安装 gRPC\"></a>安装 gRPC</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python -m pip install --upgrade pip</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python -m pip install grpcio</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python -m pip install grpcio-tools\t<span class=\"comment\"># 这个用来编译proto文件</span></span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Protocal-Buffer-3\"><a href=\"#Protocal-Buffer-3\" class=\"headerlink\" title=\"Protocal Buffer 3\"></a>Protocal Buffer 3</h1><p>官方推荐使用<strong>proto3</strong>语法，因为它更简洁、强大，也支持更多语言。</p>\n<p>一个简单的<code>.proto</code>文件示例：</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">\"proto3\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">/* SearchRequest represents a search query, with pagination options to</span><br><span class=\"line\"> * indicate which results to include in the response. */</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">SearchRequest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> query = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">int32</span> page_number = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">int32</span> result_per_page = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> <span class=\"built_in\">int32</span> int_list=<span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一行的<code>syntax</code>指定portobuf的语法版本，必须在第一行，不过不指定，默认为<code>proto2</code></li>\n<li><code>message</code>用来定义客户端与服务器交互的数据结构，在上边例子中，<code>string query=1;</code>称为<code>field</code>，string/query/1分别为type/name/value</li>\n<li>每一个<code>field</code>有一个独特的值，用于在二进制消息格式中标识<code>field</code>。这个值的范围是[1, 2^29-1(536870911)]，其中，[19000,19999]是禁用的，是为协议缓冲区实现保留的。1-15使用1个字节编码，16-2047使用2个字节，所以常出现的<code>filed</code>应该尽量给予小的值</li>\n<li>注释是C/C++样式，使用<code>//</code>和<code>/*...*/</code></li>\n<li><code>repeated</code>字段用于传输<strong>列表数据</strong>，比如上边的<code>int_list</code>，我就可以从客户端feed [1,2,3]，或者从客户端返回[1,2,3]</li>\n</ul>\n<p>proto与python数据类型对应表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">proto</th>\n<th style=\"text-align:center\">Python</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">float/double</td>\n<td style=\"text-align:center\">float</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">int32/sint32/sfixed32</td>\n<td style=\"text-align:center\">int</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">int64/uint32/uint64/sint64/fixed32/fixed64/sfixed64</td>\n<td style=\"text-align:center\">int/long</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bool</td>\n<td style=\"text-align:center\">bool</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">string</td>\n<td style=\"text-align:center\">str/unicode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Bytes</td>\n<td style=\"text-align:center\">str</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>默认值：</p>\n<ul>\n<li>strings, empty string</li>\n<li>bytes, empty bytes</li>\n<li>bools, false</li>\n<li>numeric types, 0</li>\n<li>enums, 默认值为第一个定义的枚举值，必须为0</li>\n</ul>\n<p>在<code>message</code>中使用枚举，可以这么定义：</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">Cooking</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">VegeType</span> </span>&#123;</span><br><span class=\"line\">        CAULIFLOWER = <span class=\"number\">0</span>;</span><br><span class=\"line\">        CUCUMBER = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> VegeType type = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在python端可以用<strong>以下三种方式</strong>定义枚举字段：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name_pb2.Cooking.CUCUMBER</span><br><span class=\"line\">name_pb2.Cooking.VegeType.CUCUMBER</span><br><span class=\"line\">name_pb2.Cooking.VegeTypeValue.Value(<span class=\"string\">'CUCUMBER'</span>)</span><br></pre></td></tr></table></figure>\n<p>对于客户端可RPC调用服务器的方式主要有四种，可以这样写：</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">\"proto3\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">RouteGuide</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 最简单方式，请求-&gt;响应</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">rpc</span> GetFeature(Point) <span class=\"keyword\">returns</span> (Feature) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"function\">\t// A server-to-client streaming RPC. 服务器流式响应</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">rpc</span> ListFeatures(Rectangle) <span class=\"keyword\">returns</span> (stream Feature) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"function\">\t// A client-to-server streaming RPC. 客户端流式请求</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">rpc</span> RecordRoute(stream Point) <span class=\"keyword\">returns</span> (RouteSummary) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"function\">  // A Bidirectional streaming RPC. 双向流式交互</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">rpc</span> RouteChat(stream RouteNote) <span class=\"keyword\">returns</span> (stream RouteNote) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>重点在<code>stream</code>修饰符。</p>\n<p>就拿<code>rpc GetFeature(Point) returns (Feature) {}</code>来说，它生成的服务器端函数接口应该是这样的：</p>\n<p><code>def GetFeature(self, request, context):</code></p>\n<p>其中，request即为客户端发送的<code>Point</code>消息类，context提供特定于rpc的信息，如超时限制，该方法返回给客户端<code>Feature</code>类。</p>\n<h1 id=\"下载官方示例\"><a href=\"#下载官方示例\" class=\"headerlink\" title=\"下载官方示例\"></a>下载官方示例</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Clone the repository to get the example code:</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> -b v1.28.1 https://github.com/grpc/grpc</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Navigate to the <span class=\"string\">\"hello, world\"</span> Python example:</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> grpc/examples/python/helloworld</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> server</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python greeter_server.py</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> client</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python greeter_client.py</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"生成服务器与客户端代码\"><a href=\"#生成服务器与客户端代码\" class=\"headerlink\" title=\"生成服务器与客户端代码\"></a>生成服务器与客户端代码</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python -m grpc_tools.protoc -I ../../protos --python_out=. --grpc_python_out=. ../../protos/[name].proto</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>--python_out</code>：指定编译生成处理 protobuf 相关的代码的路径</li>\n<li><code>--grpc_python_out</code>：指定编译生成处理 grpc 相关的代码的路径</li>\n<li><code>-I</code>：指定proto 文件的<strong>目录</strong>，然后再写文件路径</li>\n</ul>\n<p>这条命令会生成两个文件：</p>\n<ul>\n<li><code>name_pb2.py</code>包含我们定义的请求(request)、响应(response)类。</li>\n<li><code>name_pb2_grpc.py</code>包含服务器(server)、客户端(client)类。<ul>\n<li><code>&amp;Stub</code>类被客户端调用服务端RPC</li>\n<li><code>&amp;Servicer</code>类定义实现服务端代码的接口</li>\n<li>方法<code>add_&amp;Servicer_to_server</code>，把我们定义的服务器类添加到<code>grpc.Server</code></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"编写服务器\"><a href=\"#编写服务器\" class=\"headerlink\" title=\"编写服务器\"></a>编写服务器</h1><p>主要步骤：</p>\n<ul>\n<li>实现服务端接口函数。Implementing the servicer interface generated from our service definition with functions that perform the actual “work” of the service.</li>\n<li>开启服务器并监听客户端请求，产生响应。Running a gRPC server to listen for requests from clients and transmit responses.</li>\n</ul>\n<p>简而言之，就是重载<code>name_pb2_grpc.py</code>中<code>&amp;Servicer</code>类的所有RPC方法。比如:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouteGuideServicer</span><span class=\"params\">(route_guide_pb2_grpc.RouteGuideServicer)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Provides methods that implement functionality of route guide server.\"\"\"</span></span><br></pre></td></tr></table></figure>\n<p>接下来就是开启服务器，监听客户端请求了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">serve</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class=\"number\">10</span>))</span><br><span class=\"line\">    route_guide_pb2_grpc.add_RouteGuideServicer_to_server(RouteGuideServicer(), server)</span><br><span class=\"line\">    server.add_insecure_port(<span class=\"string\">'[::]:50051'</span>)</span><br><span class=\"line\">    server.start()</span><br><span class=\"line\">    server.wait_for_termination()</span><br></pre></td></tr></table></figure>\n<h1 id=\"编写客户端\"><a href=\"#编写客户端\" class=\"headerlink\" title=\"编写客户端\"></a>编写客户端</h1><p>创建存根(stub)，从<code>name_pb2_grpc.py</code>中实例化<code>&amp;Stub</code>类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel = grpc.insecure_channel(<span class=\"string\">'localhost:50051'</span>)</span><br><span class=\"line\">stub = route_guide_pb2_grpc.RouteGuideStub(channel)</span><br></pre></td></tr></table></figure>\n<p>或者使用<code>with</code>上下文管理器：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> grpc.insecure_channel(<span class=\"string\">'localhost:50051'</span>) <span class=\"keyword\">as</span> channel:</span><br><span class=\"line\">        stub = route_guide_pb2_grpc.RouteGuideStub(channel)</span><br></pre></td></tr></table></figure>\n<p>使用存根调用服务器端的方法，可以有同步与异步两种。</p>\n<p>同步：<code>feature = stub.GetFeature(point)</code></p>\n<p>异步：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feature_future = stub.GetFeature.future(point)</span><br><span class=\"line\">feature = feature_future.result()</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"https://www.grpc.io/docs/quickstart/python/\" rel=\"external nofollow\" target=\"_blank\">gRPC</a></li>\n<li><a href=\"https://developers.google.com/protocol-buffers/docs/proto3\" rel=\"external nofollow\" target=\"_blank\">https://developers.google.com/protocol-buffers/docs/proto3</a></li>\n<li><a href=\"https://stackoverflow.com/questions/34407696/how-to-access-python-enums-in-protobufs\" rel=\"external nofollow\" target=\"_blank\">How to access python enums in protobufs</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"./learn-grpc/gRPC.svg\" alt=\"\"></p>\n<p>此博客用于记录学习gRPC(python)的过程。</p>","more":"<h1 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h1><p>gRPC默认使用协议缓冲池(Protocol Buffers)进行服务器与客户端之间的交互，它是用于序列化结构化数据的成熟的谷歌开源机制。</p>\n<p>大致流程是三步：</p>\n<ul>\n<li>Define a service in a <code>.proto</code> file.</li>\n<li>Generate server and client code using the <code>protocol buffer compiler</code>.</li>\n<li>Use the Python gRPC API to write a simple client and server for your service.</li>\n</ul>\n<h1 id=\"安装-gRPC\"><a href=\"#安装-gRPC\" class=\"headerlink\" title=\"安装 gRPC\"></a>安装 gRPC</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python -m pip install --upgrade pip</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python -m pip install grpcio</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python -m pip install grpcio-tools\t<span class=\"comment\"># 这个用来编译proto文件</span></span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Protocal-Buffer-3\"><a href=\"#Protocal-Buffer-3\" class=\"headerlink\" title=\"Protocal Buffer 3\"></a>Protocal Buffer 3</h1><p>官方推荐使用<strong>proto3</strong>语法，因为它更简洁、强大，也支持更多语言。</p>\n<p>一个简单的<code>.proto</code>文件示例：</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">\"proto3\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">/* SearchRequest represents a search query, with pagination options to</span><br><span class=\"line\"> * indicate which results to include in the response. */</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">SearchRequest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> query = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">int32</span> page_number = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">int32</span> result_per_page = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">repeated</span> <span class=\"built_in\">int32</span> int_list=<span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一行的<code>syntax</code>指定portobuf的语法版本，必须在第一行，不过不指定，默认为<code>proto2</code></li>\n<li><code>message</code>用来定义客户端与服务器交互的数据结构，在上边例子中，<code>string query=1;</code>称为<code>field</code>，string/query/1分别为type/name/value</li>\n<li>每一个<code>field</code>有一个独特的值，用于在二进制消息格式中标识<code>field</code>。这个值的范围是[1, 2^29-1(536870911)]，其中，[19000,19999]是禁用的，是为协议缓冲区实现保留的。1-15使用1个字节编码，16-2047使用2个字节，所以常出现的<code>filed</code>应该尽量给予小的值</li>\n<li>注释是C/C++样式，使用<code>//</code>和<code>/*...*/</code></li>\n<li><code>repeated</code>字段用于传输<strong>列表数据</strong>，比如上边的<code>int_list</code>，我就可以从客户端feed [1,2,3]，或者从客户端返回[1,2,3]</li>\n</ul>\n<p>proto与python数据类型对应表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">proto</th>\n<th style=\"text-align:center\">Python</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">float/double</td>\n<td style=\"text-align:center\">float</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">int32/sint32/sfixed32</td>\n<td style=\"text-align:center\">int</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">int64/uint32/uint64/sint64/fixed32/fixed64/sfixed64</td>\n<td style=\"text-align:center\">int/long</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bool</td>\n<td style=\"text-align:center\">bool</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">string</td>\n<td style=\"text-align:center\">str/unicode</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Bytes</td>\n<td style=\"text-align:center\">str</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>默认值：</p>\n<ul>\n<li>strings, empty string</li>\n<li>bytes, empty bytes</li>\n<li>bools, false</li>\n<li>numeric types, 0</li>\n<li>enums, 默认值为第一个定义的枚举值，必须为0</li>\n</ul>\n<p>在<code>message</code>中使用枚举，可以这么定义：</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">Cooking</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">VegeType</span> </span>&#123;</span><br><span class=\"line\">        CAULIFLOWER = <span class=\"number\">0</span>;</span><br><span class=\"line\">        CUCUMBER = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">required</span> VegeType type = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在python端可以用<strong>以下三种方式</strong>定义枚举字段：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name_pb2.Cooking.CUCUMBER</span><br><span class=\"line\">name_pb2.Cooking.VegeType.CUCUMBER</span><br><span class=\"line\">name_pb2.Cooking.VegeTypeValue.Value(<span class=\"string\">'CUCUMBER'</span>)</span><br></pre></td></tr></table></figure>\n<p>对于客户端可RPC调用服务器的方式主要有四种，可以这样写：</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">\"proto3\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">RouteGuide</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 最简单方式，请求-&gt;响应</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">rpc</span> GetFeature(Point) <span class=\"keyword\">returns</span> (Feature) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"function\">\t// A server-to-client streaming RPC. 服务器流式响应</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">rpc</span> ListFeatures(Rectangle) <span class=\"keyword\">returns</span> (stream Feature) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"function\">\t// A client-to-server streaming RPC. 客户端流式请求</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">rpc</span> RecordRoute(stream Point) <span class=\"keyword\">returns</span> (RouteSummary) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"function\">  // A Bidirectional streaming RPC. 双向流式交互</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">rpc</span> RouteChat(stream RouteNote) <span class=\"keyword\">returns</span> (stream RouteNote) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>重点在<code>stream</code>修饰符。</p>\n<p>就拿<code>rpc GetFeature(Point) returns (Feature) {}</code>来说，它生成的服务器端函数接口应该是这样的：</p>\n<p><code>def GetFeature(self, request, context):</code></p>\n<p>其中，request即为客户端发送的<code>Point</code>消息类，context提供特定于rpc的信息，如超时限制，该方法返回给客户端<code>Feature</code>类。</p>\n<h1 id=\"下载官方示例\"><a href=\"#下载官方示例\" class=\"headerlink\" title=\"下载官方示例\"></a>下载官方示例</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Clone the repository to get the example code:</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> -b v1.28.1 https://github.com/grpc/grpc</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Navigate to the <span class=\"string\">\"hello, world\"</span> Python example:</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> grpc/examples/python/helloworld</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> server</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python greeter_server.py</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> client</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python greeter_client.py</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"生成服务器与客户端代码\"><a href=\"#生成服务器与客户端代码\" class=\"headerlink\" title=\"生成服务器与客户端代码\"></a>生成服务器与客户端代码</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> python -m grpc_tools.protoc -I ../../protos --python_out=. --grpc_python_out=. ../../protos/[name].proto</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>--python_out</code>：指定编译生成处理 protobuf 相关的代码的路径</li>\n<li><code>--grpc_python_out</code>：指定编译生成处理 grpc 相关的代码的路径</li>\n<li><code>-I</code>：指定proto 文件的<strong>目录</strong>，然后再写文件路径</li>\n</ul>\n<p>这条命令会生成两个文件：</p>\n<ul>\n<li><code>name_pb2.py</code>包含我们定义的请求(request)、响应(response)类。</li>\n<li><code>name_pb2_grpc.py</code>包含服务器(server)、客户端(client)类。<ul>\n<li><code>&amp;Stub</code>类被客户端调用服务端RPC</li>\n<li><code>&amp;Servicer</code>类定义实现服务端代码的接口</li>\n<li>方法<code>add_&amp;Servicer_to_server</code>，把我们定义的服务器类添加到<code>grpc.Server</code></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"编写服务器\"><a href=\"#编写服务器\" class=\"headerlink\" title=\"编写服务器\"></a>编写服务器</h1><p>主要步骤：</p>\n<ul>\n<li>实现服务端接口函数。Implementing the servicer interface generated from our service definition with functions that perform the actual “work” of the service.</li>\n<li>开启服务器并监听客户端请求，产生响应。Running a gRPC server to listen for requests from clients and transmit responses.</li>\n</ul>\n<p>简而言之，就是重载<code>name_pb2_grpc.py</code>中<code>&amp;Servicer</code>类的所有RPC方法。比如:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouteGuideServicer</span><span class=\"params\">(route_guide_pb2_grpc.RouteGuideServicer)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"Provides methods that implement functionality of route guide server.\"\"\"</span></span><br></pre></td></tr></table></figure>\n<p>接下来就是开启服务器，监听客户端请求了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">serve</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class=\"number\">10</span>))</span><br><span class=\"line\">    route_guide_pb2_grpc.add_RouteGuideServicer_to_server(RouteGuideServicer(), server)</span><br><span class=\"line\">    server.add_insecure_port(<span class=\"string\">'[::]:50051'</span>)</span><br><span class=\"line\">    server.start()</span><br><span class=\"line\">    server.wait_for_termination()</span><br></pre></td></tr></table></figure>\n<h1 id=\"编写客户端\"><a href=\"#编写客户端\" class=\"headerlink\" title=\"编写客户端\"></a>编写客户端</h1><p>创建存根(stub)，从<code>name_pb2_grpc.py</code>中实例化<code>&amp;Stub</code>类。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel = grpc.insecure_channel(<span class=\"string\">'localhost:50051'</span>)</span><br><span class=\"line\">stub = route_guide_pb2_grpc.RouteGuideStub(channel)</span><br></pre></td></tr></table></figure>\n<p>或者使用<code>with</code>上下文管理器：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> grpc.insecure_channel(<span class=\"string\">'localhost:50051'</span>) <span class=\"keyword\">as</span> channel:</span><br><span class=\"line\">        stub = route_guide_pb2_grpc.RouteGuideStub(channel)</span><br></pre></td></tr></table></figure>\n<p>使用存根调用服务器端的方法，可以有同步与异步两种。</p>\n<p>同步：<code>feature = stub.GetFeature(point)</code></p>\n<p>异步：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feature_future = stub.GetFeature.future(point)</span><br><span class=\"line\">feature = feature_future.result()</span><br></pre></td></tr></table></figure>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li><a href=\"https://www.grpc.io/docs/quickstart/python/\" rel=\"external nofollow\" target=\"_blank\">gRPC</a></li>\n<li><a href=\"https://developers.google.com/protocol-buffers/docs/proto3\" rel=\"external nofollow\" target=\"_blank\">https://developers.google.com/protocol-buffers/docs/proto3</a></li>\n<li><a href=\"https://stackoverflow.com/questions/34407696/how-to-access-python-enums-in-protobufs\" rel=\"external nofollow\" target=\"_blank\">How to access python enums in protobufs</a></li>\n</ul>"},{"title":"LeetCode刷题记录(python)","copyright":true,"mathjax":false,"top":1,"date":"2020-04-24T03:58:00.000Z","keywords":null,"description":null,"_content":"\n这篇博客用于学习并记录在LeetCode刷题的过程及其相关题目解决思路。\n\n<!--more-->\n\n# 栈\n\n## 20. [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n\n判断字符串内括号顺序是否正确，`()[]`正确，`([)]`不正确，因为左方括号与右圆括号不合法。\n\n解题思路1：\n\n将左括号进栈，遍历到右括号就出栈，判断最后栈中是否还有剩余。\n\n```python\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        if len(s) % 2 == 1:\n            return False\n        d = {')':'(', ']':'[', '}':'{'}\n        tmp = ['t']\t# 终结符，为了避免tmp为空时执行.pop方法出错\n        for i in s:\n            if i in d.keys():\n                if d.get(i) != tmp.pop():\n                    return False\n            else:\n                tmp.append(i)\n        return False if len(tmp) != 1 else True\n```\n\n\n\n解题思路2：\n\n将`()`,`[]`,`{}`替换为空，如果最终字符串为空，则为真。\n\n```python\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        if len(s)%2:\n            return False\n        while '()' in s or '[]' in s or '{}' in s:\n            s = s.replace('[]','').replace('()','').replace('{}','')\n        return False if len(s) else True\n```\n\n## 42. [接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n这道题挺有意思的，根据数组判断某个地形可容纳的积水。\n\n![](./leetcode/42.png)\n\n```\n输入: [0,1,0,2,1,0,1,3,2,1,2,1]\n输出: 6\n```\n\n```python\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        '''\n        思路：\n            1. 先找到左侧制高点，将数组分为两部分，右边部分reversed一下\n            2. 在两部分数组都执行“左低右高”式累加即可\n        '''\n        if len(height) < 3: # 数组至少有三个元素才能积水\n            return 0\n        max_idx = height.index(max(height))\n        h1 = height[:max_idx+1]\n        h2 = list(reversed(height[max_idx:]))\n        def get_v(arr):\n            v = 0\n            left = arr[0]\n            cv = 0  # 某个区间的累计蓄水\n            for h in arr:\n                if h < left:\n                    cv += left - h\n                else:\n                    v += cv\n                    cv = 0\n                    left = h\n            return v\n        return get_v(h1) + get_v(h2)\n```\n\n## 71. [简化路径](https://leetcode-cn.com/problems/simplify-path/)\n\n以 Unix 风格给出一个文件的**绝对路径**。右侧不带斜杠`/`，去除相对路径符号`.`（当前目录），`..`（上级目录）。\n\n```python\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        '''\n        思路：\n            1. 按'/'切分\n            2. 去除空字符串\n            3. 去除当前目录符号'.'\n            4. 抵消'..'前的目录\n            5. 给最后输入加入左斜杠'/'\n        '''\n        dirs = path.split('/')\n        while '' in dirs:\n            dirs.pop(dirs.index(''))\n        while '.' in dirs:\n            dirs.pop(dirs.index('.'))\n        while '..' in dirs:\n            idx = dirs.index('..')\n            dirs.pop(idx)\n            if idx > 0:\n                dirs.pop(idx-1)\n        return '/' + '/'.join(dirs)\n```\n\n\n\n# 队列\n\n...\n\n","source":"_posts/leetcode.md","raw":"---\ntitle: LeetCode刷题记录(python)\ncopyright: true\nmathjax: false\ntop: 1\ndate: 2020-04-24 11:58:00\ncategories: Python\ntags:\n- python\n- leetcode\nkeywords:\ndescription:\n---\n\n这篇博客用于学习并记录在LeetCode刷题的过程及其相关题目解决思路。\n\n<!--more-->\n\n# 栈\n\n## 20. [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)\n\n判断字符串内括号顺序是否正确，`()[]`正确，`([)]`不正确，因为左方括号与右圆括号不合法。\n\n解题思路1：\n\n将左括号进栈，遍历到右括号就出栈，判断最后栈中是否还有剩余。\n\n```python\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        if len(s) % 2 == 1:\n            return False\n        d = {')':'(', ']':'[', '}':'{'}\n        tmp = ['t']\t# 终结符，为了避免tmp为空时执行.pop方法出错\n        for i in s:\n            if i in d.keys():\n                if d.get(i) != tmp.pop():\n                    return False\n            else:\n                tmp.append(i)\n        return False if len(tmp) != 1 else True\n```\n\n\n\n解题思路2：\n\n将`()`,`[]`,`{}`替换为空，如果最终字符串为空，则为真。\n\n```python\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        if len(s)%2:\n            return False\n        while '()' in s or '[]' in s or '{}' in s:\n            s = s.replace('[]','').replace('()','').replace('{}','')\n        return False if len(s) else True\n```\n\n## 42. [接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)\n\n这道题挺有意思的，根据数组判断某个地形可容纳的积水。\n\n![](./leetcode/42.png)\n\n```\n输入: [0,1,0,2,1,0,1,3,2,1,2,1]\n输出: 6\n```\n\n```python\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        '''\n        思路：\n            1. 先找到左侧制高点，将数组分为两部分，右边部分reversed一下\n            2. 在两部分数组都执行“左低右高”式累加即可\n        '''\n        if len(height) < 3: # 数组至少有三个元素才能积水\n            return 0\n        max_idx = height.index(max(height))\n        h1 = height[:max_idx+1]\n        h2 = list(reversed(height[max_idx:]))\n        def get_v(arr):\n            v = 0\n            left = arr[0]\n            cv = 0  # 某个区间的累计蓄水\n            for h in arr:\n                if h < left:\n                    cv += left - h\n                else:\n                    v += cv\n                    cv = 0\n                    left = h\n            return v\n        return get_v(h1) + get_v(h2)\n```\n\n## 71. [简化路径](https://leetcode-cn.com/problems/simplify-path/)\n\n以 Unix 风格给出一个文件的**绝对路径**。右侧不带斜杠`/`，去除相对路径符号`.`（当前目录），`..`（上级目录）。\n\n```python\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        '''\n        思路：\n            1. 按'/'切分\n            2. 去除空字符串\n            3. 去除当前目录符号'.'\n            4. 抵消'..'前的目录\n            5. 给最后输入加入左斜杠'/'\n        '''\n        dirs = path.split('/')\n        while '' in dirs:\n            dirs.pop(dirs.index(''))\n        while '.' in dirs:\n            dirs.pop(dirs.index('.'))\n        while '..' in dirs:\n            idx = dirs.index('..')\n            dirs.pop(idx)\n            if idx > 0:\n                dirs.pop(idx-1)\n        return '/' + '/'.join(dirs)\n```\n\n\n\n# 队列\n\n...\n\n","slug":"leetcode","published":1,"updated":"2020-04-24T06:20:18.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusxx000v20cd531plkiw","content":"<p>这篇博客用于学习并记录在LeetCode刷题的过程及其相关题目解决思路。</p>\n<a id=\"more\"></a>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><h2 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20. 有效的括号\"></a>20. <a href=\"https://leetcode-cn.com/problems/valid-parentheses/\" rel=\"external nofollow\" target=\"_blank\">有效的括号</a></h2><p>判断字符串内括号顺序是否正确，<code>()[]</code>正确，<code>([)]</code>不正确，因为左方括号与右圆括号不合法。</p>\n<p>解题思路1：</p>\n<p>将左括号进栈，遍历到右括号就出栈，判断最后栈中是否还有剩余。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s) % <span class=\"number\">2</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        d = &#123;<span class=\"string\">')'</span>:<span class=\"string\">'('</span>, <span class=\"string\">']'</span>:<span class=\"string\">'['</span>, <span class=\"string\">'&#125;'</span>:<span class=\"string\">'&#123;'</span>&#125;</span><br><span class=\"line\">        tmp = [<span class=\"string\">'t'</span>]\t<span class=\"comment\"># 终结符，为了避免tmp为空时执行.pop方法出错</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">in</span> d.keys():</span><br><span class=\"line\">                <span class=\"keyword\">if</span> d.get(i) != tmp.pop():</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmp.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span> <span class=\"keyword\">if</span> len(tmp) != <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>解题思路2：</p>\n<p>将<code>()</code>,<code>[]</code>,<code>{}</code>替换为空，如果最终字符串为空，则为真。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s)%<span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"string\">'()'</span> <span class=\"keyword\">in</span> s <span class=\"keyword\">or</span> <span class=\"string\">'[]'</span> <span class=\"keyword\">in</span> s <span class=\"keyword\">or</span> <span class=\"string\">'&#123;&#125;'</span> <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            s = s.replace(<span class=\"string\">'[]'</span>,<span class=\"string\">''</span>).replace(<span class=\"string\">'()'</span>,<span class=\"string\">''</span>).replace(<span class=\"string\">'&#123;&#125;'</span>,<span class=\"string\">''</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span> <span class=\"keyword\">if</span> len(s) <span class=\"keyword\">else</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42. 接雨水\"></a>42. <a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\" rel=\"external nofollow\" target=\"_blank\">接雨水</a></h2><p>这道题挺有意思的，根据数组判断某个地形可容纳的积水。</p>\n<p><img src=\"./leetcode/42.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class=\"line\">输出: 6</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trap</span><span class=\"params\">(self, height: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        思路：</span></span><br><span class=\"line\"><span class=\"string\">            1. 先找到左侧制高点，将数组分为两部分，右边部分reversed一下</span></span><br><span class=\"line\"><span class=\"string\">            2. 在两部分数组都执行“左低右高”式累加即可</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(height) &lt; <span class=\"number\">3</span>: <span class=\"comment\"># 数组至少有三个元素才能积水</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        max_idx = height.index(max(height))</span><br><span class=\"line\">        h1 = height[:max_idx+<span class=\"number\">1</span>]</span><br><span class=\"line\">        h2 = list(reversed(height[max_idx:]))</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_v</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">            v = <span class=\"number\">0</span></span><br><span class=\"line\">            left = arr[<span class=\"number\">0</span>]</span><br><span class=\"line\">            cv = <span class=\"number\">0</span>  <span class=\"comment\"># 某个区间的累计蓄水</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> h <span class=\"keyword\">in</span> arr:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> h &lt; left:</span><br><span class=\"line\">                    cv += left - h</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    v += cv</span><br><span class=\"line\">                    cv = <span class=\"number\">0</span></span><br><span class=\"line\">                    left = h</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get_v(h1) + get_v(h2)</span><br></pre></td></tr></table></figure>\n<h2 id=\"71-简化路径\"><a href=\"#71-简化路径\" class=\"headerlink\" title=\"71. 简化路径\"></a>71. <a href=\"https://leetcode-cn.com/problems/simplify-path/\" rel=\"external nofollow\" target=\"_blank\">简化路径</a></h2><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>。右侧不带斜杠<code>/</code>，去除相对路径符号<code>.</code>（当前目录），<code>..</code>（上级目录）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simplifyPath</span><span class=\"params\">(self, path: str)</span> -&gt; str:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        思路：</span></span><br><span class=\"line\"><span class=\"string\">            1. 按'/'切分</span></span><br><span class=\"line\"><span class=\"string\">            2. 去除空字符串</span></span><br><span class=\"line\"><span class=\"string\">            3. 去除当前目录符号'.'</span></span><br><span class=\"line\"><span class=\"string\">            4. 抵消'..'前的目录</span></span><br><span class=\"line\"><span class=\"string\">            5. 给最后输入加入左斜杠'/'</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        dirs = path.split(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"string\">''</span> <span class=\"keyword\">in</span> dirs:</span><br><span class=\"line\">            dirs.pop(dirs.index(<span class=\"string\">''</span>))</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"string\">'.'</span> <span class=\"keyword\">in</span> dirs:</span><br><span class=\"line\">            dirs.pop(dirs.index(<span class=\"string\">'.'</span>))</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"string\">'..'</span> <span class=\"keyword\">in</span> dirs:</span><br><span class=\"line\">            idx = dirs.index(<span class=\"string\">'..'</span>)</span><br><span class=\"line\">            dirs.pop(idx)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> idx &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                dirs.pop(idx<span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'/'</span> + <span class=\"string\">'/'</span>.join(dirs)</span><br></pre></td></tr></table></figure>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><p>…</p>\n","site":{"data":{}},"excerpt":"<p>这篇博客用于学习并记录在LeetCode刷题的过程及其相关题目解决思路。</p>","more":"<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><h2 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20. 有效的括号\"></a>20. <a href=\"https://leetcode-cn.com/problems/valid-parentheses/\" rel=\"external nofollow\" target=\"_blank\">有效的括号</a></h2><p>判断字符串内括号顺序是否正确，<code>()[]</code>正确，<code>([)]</code>不正确，因为左方括号与右圆括号不合法。</p>\n<p>解题思路1：</p>\n<p>将左括号进栈，遍历到右括号就出栈，判断最后栈中是否还有剩余。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s) % <span class=\"number\">2</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        d = &#123;<span class=\"string\">')'</span>:<span class=\"string\">'('</span>, <span class=\"string\">']'</span>:<span class=\"string\">'['</span>, <span class=\"string\">'&#125;'</span>:<span class=\"string\">'&#123;'</span>&#125;</span><br><span class=\"line\">        tmp = [<span class=\"string\">'t'</span>]\t<span class=\"comment\"># 终结符，为了避免tmp为空时执行.pop方法出错</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i <span class=\"keyword\">in</span> d.keys():</span><br><span class=\"line\">                <span class=\"keyword\">if</span> d.get(i) != tmp.pop():</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                tmp.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span> <span class=\"keyword\">if</span> len(tmp) != <span class=\"number\">1</span> <span class=\"keyword\">else</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>解题思路2：</p>\n<p>将<code>()</code>,<code>[]</code>,<code>{}</code>替换为空，如果最终字符串为空，则为真。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isValid</span><span class=\"params\">(self, s: str)</span> -&gt; bool:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(s)%<span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"string\">'()'</span> <span class=\"keyword\">in</span> s <span class=\"keyword\">or</span> <span class=\"string\">'[]'</span> <span class=\"keyword\">in</span> s <span class=\"keyword\">or</span> <span class=\"string\">'&#123;&#125;'</span> <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            s = s.replace(<span class=\"string\">'[]'</span>,<span class=\"string\">''</span>).replace(<span class=\"string\">'()'</span>,<span class=\"string\">''</span>).replace(<span class=\"string\">'&#123;&#125;'</span>,<span class=\"string\">''</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span> <span class=\"keyword\">if</span> len(s) <span class=\"keyword\">else</span> <span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"42-接雨水\"><a href=\"#42-接雨水\" class=\"headerlink\" title=\"42. 接雨水\"></a>42. <a href=\"https://leetcode-cn.com/problems/trapping-rain-water/\" rel=\"external nofollow\" target=\"_blank\">接雨水</a></h2><p>这道题挺有意思的，根据数组判断某个地形可容纳的积水。</p>\n<p><img src=\"./leetcode/42.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class=\"line\">输出: 6</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">trap</span><span class=\"params\">(self, height: List[int])</span> -&gt; int:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        思路：</span></span><br><span class=\"line\"><span class=\"string\">            1. 先找到左侧制高点，将数组分为两部分，右边部分reversed一下</span></span><br><span class=\"line\"><span class=\"string\">            2. 在两部分数组都执行“左低右高”式累加即可</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> len(height) &lt; <span class=\"number\">3</span>: <span class=\"comment\"># 数组至少有三个元素才能积水</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        max_idx = height.index(max(height))</span><br><span class=\"line\">        h1 = height[:max_idx+<span class=\"number\">1</span>]</span><br><span class=\"line\">        h2 = list(reversed(height[max_idx:]))</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_v</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">            v = <span class=\"number\">0</span></span><br><span class=\"line\">            left = arr[<span class=\"number\">0</span>]</span><br><span class=\"line\">            cv = <span class=\"number\">0</span>  <span class=\"comment\"># 某个区间的累计蓄水</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> h <span class=\"keyword\">in</span> arr:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> h &lt; left:</span><br><span class=\"line\">                    cv += left - h</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    v += cv</span><br><span class=\"line\">                    cv = <span class=\"number\">0</span></span><br><span class=\"line\">                    left = h</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get_v(h1) + get_v(h2)</span><br></pre></td></tr></table></figure>\n<h2 id=\"71-简化路径\"><a href=\"#71-简化路径\" class=\"headerlink\" title=\"71. 简化路径\"></a>71. <a href=\"https://leetcode-cn.com/problems/simplify-path/\" rel=\"external nofollow\" target=\"_blank\">简化路径</a></h2><p>以 Unix 风格给出一个文件的<strong>绝对路径</strong>。右侧不带斜杠<code>/</code>，去除相对路径符号<code>.</code>（当前目录），<code>..</code>（上级目录）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">simplifyPath</span><span class=\"params\">(self, path: str)</span> -&gt; str:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        思路：</span></span><br><span class=\"line\"><span class=\"string\">            1. 按'/'切分</span></span><br><span class=\"line\"><span class=\"string\">            2. 去除空字符串</span></span><br><span class=\"line\"><span class=\"string\">            3. 去除当前目录符号'.'</span></span><br><span class=\"line\"><span class=\"string\">            4. 抵消'..'前的目录</span></span><br><span class=\"line\"><span class=\"string\">            5. 给最后输入加入左斜杠'/'</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        dirs = path.split(<span class=\"string\">'/'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"string\">''</span> <span class=\"keyword\">in</span> dirs:</span><br><span class=\"line\">            dirs.pop(dirs.index(<span class=\"string\">''</span>))</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"string\">'.'</span> <span class=\"keyword\">in</span> dirs:</span><br><span class=\"line\">            dirs.pop(dirs.index(<span class=\"string\">'.'</span>))</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"string\">'..'</span> <span class=\"keyword\">in</span> dirs:</span><br><span class=\"line\">            idx = dirs.index(<span class=\"string\">'..'</span>)</span><br><span class=\"line\">            dirs.pop(idx)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> idx &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                dirs.pop(idx<span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'/'</span> + <span class=\"string\">'/'</span>.join(dirs)</span><br></pre></td></tr></table></figure>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><p>…</p>"},{"title":"Monte Carlo and Temporal-Difference","copyright":true,"mathjax":true,"password":123,"top":1,"date":"2019-05-13T11:11:58.000Z","keywords":null,"description":null,"_content":"\n本位介绍了强化学习中解决Model-Free问题的两个基本解决思路：蒙特卡洛Monte Carlo与时间差分Temporal-Difference。\n\n<!--more-->\n\n![](./mc-td/dp.png)\n\n![](./mc-td/mc.png)\n\n![](./mc-td/td.png)\n\n\n\n# 蒙特卡洛方法 Monte Carlo Methods\n\n\n\n# 时间差分学习 Temporal-Difference Learning\n\n","source":"_posts/mc-td.md","raw":"---\ntitle: Monte Carlo and Temporal-Difference\ncopyright: true\nmathjax: true\npassword: 123\ntop: 1\ndate: 2019-05-13 19:11:58\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n本位介绍了强化学习中解决Model-Free问题的两个基本解决思路：蒙特卡洛Monte Carlo与时间差分Temporal-Difference。\n\n<!--more-->\n\n![](./mc-td/dp.png)\n\n![](./mc-td/mc.png)\n\n![](./mc-td/td.png)\n\n\n\n# 蒙特卡洛方法 Monte Carlo Methods\n\n\n\n# 时间差分学习 Temporal-Difference Learning\n\n","slug":"mc-td","published":1,"updated":"2019-05-13T14:27:05.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusxz000y20cdkzz0y24v","content":"<p>本位介绍了强化学习中解决Model-Free问题的两个基本解决思路：蒙特卡洛Monte Carlo与时间差分Temporal-Difference。</p>\n<a id=\"more\"></a>\n<p><img src=\"./mc-td/dp.png\" alt=\"\"></p>\n<p><img src=\"./mc-td/mc.png\" alt=\"\"></p>\n<p><img src=\"./mc-td/td.png\" alt=\"\"></p>\n<h1 id=\"蒙特卡洛方法-Monte-Carlo-Methods\"><a href=\"#蒙特卡洛方法-Monte-Carlo-Methods\" class=\"headerlink\" title=\"蒙特卡洛方法 Monte Carlo Methods\"></a>蒙特卡洛方法 Monte Carlo Methods</h1><h1 id=\"时间差分学习-Temporal-Difference-Learning\"><a href=\"#时间差分学习-Temporal-Difference-Learning\" class=\"headerlink\" title=\"时间差分学习 Temporal-Difference Learning\"></a>时间差分学习 Temporal-Difference Learning</h1>","site":{"data":{}},"excerpt":"<p>本位介绍了强化学习中解决Model-Free问题的两个基本解决思路：蒙特卡洛Monte Carlo与时间差分Temporal-Difference。</p>","more":"<p><img src=\"./mc-td/dp.png\" alt=\"\"></p>\n<p><img src=\"./mc-td/mc.png\" alt=\"\"></p>\n<p><img src=\"./mc-td/td.png\" alt=\"\"></p>\n<h1 id=\"蒙特卡洛方法-Monte-Carlo-Methods\"><a href=\"#蒙特卡洛方法-Monte-Carlo-Methods\" class=\"headerlink\" title=\"蒙特卡洛方法 Monte Carlo Methods\"></a>蒙特卡洛方法 Monte Carlo Methods</h1><h1 id=\"时间差分学习-Temporal-Difference-Learning\"><a href=\"#时间差分学习-Temporal-Difference-Learning\" class=\"headerlink\" title=\"时间差分学习 Temporal-Difference Learning\"></a>时间差分学习 Temporal-Difference Learning</h1>"},{"title":"The Option-Critic Architecture","copyright":true,"mathjax":true,"top":1,"date":"2020-04-14T10:57:10.000Z","keywords":null,"description":null,"_content":"\n这篇论文将Option-Critic这种端对端的分层强化学习算法推导出随机策略梯度的更新方式。\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1609.05140](http://arxiv.org/abs/1609.05140)\n\n# 文中精要\n\n$$\nQ_{\\Omega}(s, \\omega)=\\sum_{a} \\pi_{\\omega, \\theta}(a | s) Q_{U}(s, \\omega, a)\n$$\n\n$Q_{U}: \\mathcal{S} \\times \\Omega \\times \\mathcal{A} \\rightarrow \\mathbb{R}$\n$$\nQ_{U}(s, \\omega, a)=r(s, a)+\\gamma \\sum_{s^{\\prime}} \\mathrm{P}\\left(s^{\\prime} | s, a\\right) U\\left(\\omega, s^{\\prime}\\right)\n$$\n\n$$\nU\\left(\\omega, s^{\\prime}\\right)=\\left(1-\\beta_{\\omega, \\vartheta}\\left(s^{\\prime}\\right)\\right) Q_{\\Omega}\\left(s^{\\prime}, \\omega\\right)+\\beta_{\\omega, \\vartheta}\\left(s^{\\prime}\\right) V_{\\Omega}\\left(s^{\\prime}\\right)\n$$\n\n$$\n\\mathrm{P}\\left(s_{t+1}, \\omega_{t+1} | s_{t}, \\omega_{t}\\right)=\\sum_{a} \\pi_{\\omega_{t}, \\theta}\\left(a | s_{t}\\right) \\mathrm{P}\\left(s_{t+1} | s_{t}, a\\right) \\left.\\left(1-\\beta_{\\omega_{t}, \\vartheta}\\left(s_{t+1}\\right)\\right) \\mathbf{1}_{\\omega_{t}=\\omega_{t+1}}+\\beta_{\\omega_{t}, \\vartheta}\\left(s_{t+1}\\right) \\pi_{\\Omega}\\left(\\omega_{t+1} | s_{t+1}\\right)\\right)\n$$\n\n$$\n\\frac{\\partial Q_{\\Omega}(s, \\omega)}{\\partial \\theta} =\\left(\\sum_{a} \\frac{\\partial \\pi_{\\omega, \\theta}(a | s)}{\\partial \\theta} Q_{U}(s, \\omega, a)\\right) +\\sum_{a} \\pi_{\\omega, \\theta}(a | s) \\sum_{s^{\\prime}} \\gamma \\mathrm{P}\\left(s^{\\prime} | s, a\\right) \\frac{\\partial U\\left(\\omega, s^{\\prime}\\right)}{\\partial \\theta}\n$$\n\n# 伪代码\n\n![](./options-critic/pseudo.png)","source":"_posts/options-critic.md","raw":"---\ntitle: The Option-Critic Architecture\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-04-14 18:57:10\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n这篇论文将Option-Critic这种端对端的分层强化学习算法推导出随机策略梯度的更新方式。\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1609.05140](http://arxiv.org/abs/1609.05140)\n\n# 文中精要\n\n$$\nQ_{\\Omega}(s, \\omega)=\\sum_{a} \\pi_{\\omega, \\theta}(a | s) Q_{U}(s, \\omega, a)\n$$\n\n$Q_{U}: \\mathcal{S} \\times \\Omega \\times \\mathcal{A} \\rightarrow \\mathbb{R}$\n$$\nQ_{U}(s, \\omega, a)=r(s, a)+\\gamma \\sum_{s^{\\prime}} \\mathrm{P}\\left(s^{\\prime} | s, a\\right) U\\left(\\omega, s^{\\prime}\\right)\n$$\n\n$$\nU\\left(\\omega, s^{\\prime}\\right)=\\left(1-\\beta_{\\omega, \\vartheta}\\left(s^{\\prime}\\right)\\right) Q_{\\Omega}\\left(s^{\\prime}, \\omega\\right)+\\beta_{\\omega, \\vartheta}\\left(s^{\\prime}\\right) V_{\\Omega}\\left(s^{\\prime}\\right)\n$$\n\n$$\n\\mathrm{P}\\left(s_{t+1}, \\omega_{t+1} | s_{t}, \\omega_{t}\\right)=\\sum_{a} \\pi_{\\omega_{t}, \\theta}\\left(a | s_{t}\\right) \\mathrm{P}\\left(s_{t+1} | s_{t}, a\\right) \\left.\\left(1-\\beta_{\\omega_{t}, \\vartheta}\\left(s_{t+1}\\right)\\right) \\mathbf{1}_{\\omega_{t}=\\omega_{t+1}}+\\beta_{\\omega_{t}, \\vartheta}\\left(s_{t+1}\\right) \\pi_{\\Omega}\\left(\\omega_{t+1} | s_{t+1}\\right)\\right)\n$$\n\n$$\n\\frac{\\partial Q_{\\Omega}(s, \\omega)}{\\partial \\theta} =\\left(\\sum_{a} \\frac{\\partial \\pi_{\\omega, \\theta}(a | s)}{\\partial \\theta} Q_{U}(s, \\omega, a)\\right) +\\sum_{a} \\pi_{\\omega, \\theta}(a | s) \\sum_{s^{\\prime}} \\gamma \\mathrm{P}\\left(s^{\\prime} | s, a\\right) \\frac{\\partial U\\left(\\omega, s^{\\prime}\\right)}{\\partial \\theta}\n$$\n\n# 伪代码\n\n![](./options-critic/pseudo.png)","slug":"options-critic","published":1,"updated":"2020-04-14T11:06:20.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusy2001220cdmp6iscmu","content":"<p>这篇论文将Option-Critic这种端对端的分层强化学习算法推导出随机策略梯度的更新方式。</p>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1609.05140\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1609.05140</a></p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><script type=\"math/tex; mode=display\">\nQ_{\\Omega}(s, \\omega)=\\sum_{a} \\pi_{\\omega, \\theta}(a | s) Q_{U}(s, \\omega, a)</script><p>$Q_{U}: \\mathcal{S} \\times \\Omega \\times \\mathcal{A} \\rightarrow \\mathbb{R}$</p>\n<script type=\"math/tex; mode=display\">\nQ_{U}(s, \\omega, a)=r(s, a)+\\gamma \\sum_{s^{\\prime}} \\mathrm{P}\\left(s^{\\prime} | s, a\\right) U\\left(\\omega, s^{\\prime}\\right)</script><script type=\"math/tex; mode=display\">\nU\\left(\\omega, s^{\\prime}\\right)=\\left(1-\\beta_{\\omega, \\vartheta}\\left(s^{\\prime}\\right)\\right) Q_{\\Omega}\\left(s^{\\prime}, \\omega\\right)+\\beta_{\\omega, \\vartheta}\\left(s^{\\prime}\\right) V_{\\Omega}\\left(s^{\\prime}\\right)</script><script type=\"math/tex; mode=display\">\n\\mathrm{P}\\left(s_{t+1}, \\omega_{t+1} | s_{t}, \\omega_{t}\\right)=\\sum_{a} \\pi_{\\omega_{t}, \\theta}\\left(a | s_{t}\\right) \\mathrm{P}\\left(s_{t+1} | s_{t}, a\\right) \\left.\\left(1-\\beta_{\\omega_{t}, \\vartheta}\\left(s_{t+1}\\right)\\right) \\mathbf{1}_{\\omega_{t}=\\omega_{t+1}}+\\beta_{\\omega_{t}, \\vartheta}\\left(s_{t+1}\\right) \\pi_{\\Omega}\\left(\\omega_{t+1} | s_{t+1}\\right)\\right)</script><script type=\"math/tex; mode=display\">\n\\frac{\\partial Q_{\\Omega}(s, \\omega)}{\\partial \\theta} =\\left(\\sum_{a} \\frac{\\partial \\pi_{\\omega, \\theta}(a | s)}{\\partial \\theta} Q_{U}(s, \\omega, a)\\right) +\\sum_{a} \\pi_{\\omega, \\theta}(a | s) \\sum_{s^{\\prime}} \\gamma \\mathrm{P}\\left(s^{\\prime} | s, a\\right) \\frac{\\partial U\\left(\\omega, s^{\\prime}\\right)}{\\partial \\theta}</script><h1 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h1><p><img src=\"./options-critic/pseudo.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>这篇论文将Option-Critic这种端对端的分层强化学习算法推导出随机策略梯度的更新方式。</p>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1609.05140\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1609.05140</a></p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><script type=\"math/tex; mode=display\">\nQ_{\\Omega}(s, \\omega)=\\sum_{a} \\pi_{\\omega, \\theta}(a | s) Q_{U}(s, \\omega, a)</script><p>$Q_{U}: \\mathcal{S} \\times \\Omega \\times \\mathcal{A} \\rightarrow \\mathbb{R}$</p>\n<script type=\"math/tex; mode=display\">\nQ_{U}(s, \\omega, a)=r(s, a)+\\gamma \\sum_{s^{\\prime}} \\mathrm{P}\\left(s^{\\prime} | s, a\\right) U\\left(\\omega, s^{\\prime}\\right)</script><script type=\"math/tex; mode=display\">\nU\\left(\\omega, s^{\\prime}\\right)=\\left(1-\\beta_{\\omega, \\vartheta}\\left(s^{\\prime}\\right)\\right) Q_{\\Omega}\\left(s^{\\prime}, \\omega\\right)+\\beta_{\\omega, \\vartheta}\\left(s^{\\prime}\\right) V_{\\Omega}\\left(s^{\\prime}\\right)</script><script type=\"math/tex; mode=display\">\n\\mathrm{P}\\left(s_{t+1}, \\omega_{t+1} | s_{t}, \\omega_{t}\\right)=\\sum_{a} \\pi_{\\omega_{t}, \\theta}\\left(a | s_{t}\\right) \\mathrm{P}\\left(s_{t+1} | s_{t}, a\\right) \\left.\\left(1-\\beta_{\\omega_{t}, \\vartheta}\\left(s_{t+1}\\right)\\right) \\mathbf{1}_{\\omega_{t}=\\omega_{t+1}}+\\beta_{\\omega_{t}, \\vartheta}\\left(s_{t+1}\\right) \\pi_{\\Omega}\\left(\\omega_{t+1} | s_{t+1}\\right)\\right)</script><script type=\"math/tex; mode=display\">\n\\frac{\\partial Q_{\\Omega}(s, \\omega)}{\\partial \\theta} =\\left(\\sum_{a} \\frac{\\partial \\pi_{\\omega, \\theta}(a | s)}{\\partial \\theta} Q_{U}(s, \\omega, a)\\right) +\\sum_{a} \\pi_{\\omega, \\theta}(a | s) \\sum_{s^{\\prime}} \\gamma \\mathrm{P}\\left(s^{\\prime} | s, a\\right) \\frac{\\partial U\\left(\\omega, s^{\\prime}\\right)}{\\partial \\theta}</script><h1 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h1><p><img src=\"./options-critic/pseudo.png\" alt=\"\"></p>"},{"title":"Exploration By Random Network Distillation","copyright":true,"mathjax":true,"top":1,"date":"2020-06-23T12:50:48.000Z","keywords":null,"description":null,"_content":"\n这篇论文提出了RND，是一种新奇的内在探索机制，主要原理是使预测网络的特征逼近随机网络的特征，以此使得预测网络对不熟悉的状态给出较大的预测误差，由此设定内在奖励。\n\n推荐程度中等：\n\n- 1个额外的固定、不训练的随机网络\n- RND在强探索（hard exploration，奖励很稀疏）环境中表现不错\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1810.12894](http://arxiv.org/abs/1810.12894)\n\n代码地址：[https://github.com/openai/random-network-distillation](https://github.com/openai/random-network-distillation)\n\n这篇论文的思想特别简单：**设定一个固定不训练的随机网络和一个训练的预测网络，将同一个图像特征分别放入两个网络计算出特征，两个特征的差异程度就为状态的“新奇”程度，由此设定内在奖励**。\n\n这么做的意义在与：对于与环境交互时经常访问到的状态，其预测网络产生的特征与随机网络产生的特征相差无几，但是如果突然出现一个新的状态或者很少遇见的状态，那么预测网络与随机网络输出之间的差异性比较大，由此说明状态的新颖性，并根据新颖性计算出内在奖励值。**状态常见，则内在奖励小；状态罕见，则内在奖励大。**\n\n这篇论文提出的RND方法在蒙特祖玛的复仇（Montezuma's Revenge）上刷新了历史新高，并且没有使用专家示例经验（如模仿学习），也没有使用额外的游戏状态信息。\n\n# 方法\n\n奖励包括内在与外在两部分：\n$$\nr_{t}=e_{t}+i_{t}\n$$\n其中，$e_t$为外部奖励，即环境给的，$i_t$为内部激励。\n\n传统的内在奖励方法主要分为2类：\n\n1. 计数\n\n   1. 在tabular setting中，状态、动作都是可数的，可以用一张表格来维护每个状态-动作对的访问次数，并且使用形如以下的公式来定义内在奖励：\n      $$\n      i_t=\\frac{1}{n_t(s)}\n      $$\n\n      $$\n      i_t=\\frac{1}{\\sqrt {n_t(s)}}\n      $$\n\n   2. 在非tabular setting中，状态、动作不完全可数，则可使用伪计数法（pseudo-counts），主要是使用状态密度估计的变化程度来衡量。参考论文：《Unifying count-based exploration and intrinsic motivation》\n\n2. 预测，主要是通过前向(s,a->s')/反向(s,s'->a)预测环境动态的误差来设计内在奖励\n\n\n\n> This paper introduces a different approach where the prediction problem is randomly generated. This involves two neural networks: a ﬁxed and randomly initialized target network which sets the prediction problem, and a predictor network trained on data collected by the agent.\n\nRND引入两个网络：\n\n1. 预测网络，是强化学习网络的一部分，可训练，预测观测值的隐特征，$\\hat{f}: \\mathcal{O} \\rightarrow \\mathbb{R}^{k}$；\n2. 目标网络，额外引入的网络，不训练，固定参数，随机初始化，输出观测值的隐特征作为真值，$f: \\mathcal{O} \\rightarrow \\mathbb{R}^{k}$。\n\n目标函数即为最小二乘误差：$\\|\\hat{f}(\\mathbf{x} ; \\theta)-f(\\mathbf{x})\\|^{2}$，优化参数$\\theta_{\\hat{f}}$。这个过程将随机初始化的神经网络蒸馏到一个学习的预测网络中去。\n\n**上边的最小二乘误差也为内在奖励$i_t$**，作者在使用这个内在奖励时还对其进行了归一化，因为任务不同，这个最小二乘的值偏好范围也不相同，所以作者对这个内在奖励进行了正态分布归一化的处理，主要是将最小二乘误差除以移动平均标准差估计。\n\n\n\n作者说这个预测误差主要有以下几个影响因素：\n\n1. 训练数据少。当样本中相似数据不多时，预测误差会大\n2. 环境的动态随机。环境的随机转换是前向预测误差增大的原因。\n3. 模型不适合。关键信息缺失（我也不明白是什么关键信息）或者预测的模型不足以拟合目标函数，会使得预测误差很大\n4. 动态学习。学习到最后不能稳定地拟合目标函数。\n\n\n\n作者还建议在使用内在奖励时，分开两个值函数估计，即一个值函数近似外部奖励，另一个值函数近似内部奖励。这是因为外部奖励稳定，内部奖励不稳定。\n\n> Note that even where one is not trying to combine episodic and non-episodic reward streams, or reward streams with different discount factors, there may still be a beneﬁt to having separate value functions since there is an additional supervisory signal to the value function. This may be especially important for exploration bonuses since the extrinsic reward function is stationary whereas the intrinsic reward function is non-stationary.\n\n## 状态归一化\n\n作者在训练时还对状态进行了归一化处理，主要是以下流程：\n\n1. 在训练开始之前与环境随机交互取得经验初始化移动平均均值和标准差\n2. 训练开始之后，状态减去移动平均均值\n3. 再除以移动平均标准差\n4. 将状态clip到[-5, 5]\n\n作者对状态归一化的原因主要是不归一化的状态其特征的方差非常低，携带信息少（属实不明白）：\n\n> Observation normalization is often important in deep learning but it is crucial when using a random neural network as a target, since the parameters are frozen and hence cannot adjust to the scale of different datasets. \n>\n> Lack of normalization can result in the variance of the embedding being extremely low and carrying little information about the inputs.\n\n这个状态归一化，作者用在随机目标网络和预测网络，但是没有用在策略网络中。\n\n\n\n# 伪代码\n\n![](./random-network-distillation/pseudo.png)\n\n\n\n# 评价\n\n作者认为RND在局部探索中有用，在全局探索中作用不明显：\n\n> We ﬁnd that the RND exploration bonus is sufﬁcient to deal with local exploration, i.e. exploring the consequences of short-term decisions, like whether to interact with a particular object, or avoid it. However global exploration that involves coordinated decisions over long time horizons is beyond the reach of our method.\n\n","source":"_posts/random-network-distillation.md","raw":"---\ntitle: Exploration By Random Network Distillation\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-06-23 20:50:48\ncategories: ReinforcementLearning\ntags:\n- rl\n- exploration\nkeywords:\ndescription:\n---\n\n这篇论文提出了RND，是一种新奇的内在探索机制，主要原理是使预测网络的特征逼近随机网络的特征，以此使得预测网络对不熟悉的状态给出较大的预测误差，由此设定内在奖励。\n\n推荐程度中等：\n\n- 1个额外的固定、不训练的随机网络\n- RND在强探索（hard exploration，奖励很稀疏）环境中表现不错\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1810.12894](http://arxiv.org/abs/1810.12894)\n\n代码地址：[https://github.com/openai/random-network-distillation](https://github.com/openai/random-network-distillation)\n\n这篇论文的思想特别简单：**设定一个固定不训练的随机网络和一个训练的预测网络，将同一个图像特征分别放入两个网络计算出特征，两个特征的差异程度就为状态的“新奇”程度，由此设定内在奖励**。\n\n这么做的意义在与：对于与环境交互时经常访问到的状态，其预测网络产生的特征与随机网络产生的特征相差无几，但是如果突然出现一个新的状态或者很少遇见的状态，那么预测网络与随机网络输出之间的差异性比较大，由此说明状态的新颖性，并根据新颖性计算出内在奖励值。**状态常见，则内在奖励小；状态罕见，则内在奖励大。**\n\n这篇论文提出的RND方法在蒙特祖玛的复仇（Montezuma's Revenge）上刷新了历史新高，并且没有使用专家示例经验（如模仿学习），也没有使用额外的游戏状态信息。\n\n# 方法\n\n奖励包括内在与外在两部分：\n$$\nr_{t}=e_{t}+i_{t}\n$$\n其中，$e_t$为外部奖励，即环境给的，$i_t$为内部激励。\n\n传统的内在奖励方法主要分为2类：\n\n1. 计数\n\n   1. 在tabular setting中，状态、动作都是可数的，可以用一张表格来维护每个状态-动作对的访问次数，并且使用形如以下的公式来定义内在奖励：\n      $$\n      i_t=\\frac{1}{n_t(s)}\n      $$\n\n      $$\n      i_t=\\frac{1}{\\sqrt {n_t(s)}}\n      $$\n\n   2. 在非tabular setting中，状态、动作不完全可数，则可使用伪计数法（pseudo-counts），主要是使用状态密度估计的变化程度来衡量。参考论文：《Unifying count-based exploration and intrinsic motivation》\n\n2. 预测，主要是通过前向(s,a->s')/反向(s,s'->a)预测环境动态的误差来设计内在奖励\n\n\n\n> This paper introduces a different approach where the prediction problem is randomly generated. This involves two neural networks: a ﬁxed and randomly initialized target network which sets the prediction problem, and a predictor network trained on data collected by the agent.\n\nRND引入两个网络：\n\n1. 预测网络，是强化学习网络的一部分，可训练，预测观测值的隐特征，$\\hat{f}: \\mathcal{O} \\rightarrow \\mathbb{R}^{k}$；\n2. 目标网络，额外引入的网络，不训练，固定参数，随机初始化，输出观测值的隐特征作为真值，$f: \\mathcal{O} \\rightarrow \\mathbb{R}^{k}$。\n\n目标函数即为最小二乘误差：$\\|\\hat{f}(\\mathbf{x} ; \\theta)-f(\\mathbf{x})\\|^{2}$，优化参数$\\theta_{\\hat{f}}$。这个过程将随机初始化的神经网络蒸馏到一个学习的预测网络中去。\n\n**上边的最小二乘误差也为内在奖励$i_t$**，作者在使用这个内在奖励时还对其进行了归一化，因为任务不同，这个最小二乘的值偏好范围也不相同，所以作者对这个内在奖励进行了正态分布归一化的处理，主要是将最小二乘误差除以移动平均标准差估计。\n\n\n\n作者说这个预测误差主要有以下几个影响因素：\n\n1. 训练数据少。当样本中相似数据不多时，预测误差会大\n2. 环境的动态随机。环境的随机转换是前向预测误差增大的原因。\n3. 模型不适合。关键信息缺失（我也不明白是什么关键信息）或者预测的模型不足以拟合目标函数，会使得预测误差很大\n4. 动态学习。学习到最后不能稳定地拟合目标函数。\n\n\n\n作者还建议在使用内在奖励时，分开两个值函数估计，即一个值函数近似外部奖励，另一个值函数近似内部奖励。这是因为外部奖励稳定，内部奖励不稳定。\n\n> Note that even where one is not trying to combine episodic and non-episodic reward streams, or reward streams with different discount factors, there may still be a beneﬁt to having separate value functions since there is an additional supervisory signal to the value function. This may be especially important for exploration bonuses since the extrinsic reward function is stationary whereas the intrinsic reward function is non-stationary.\n\n## 状态归一化\n\n作者在训练时还对状态进行了归一化处理，主要是以下流程：\n\n1. 在训练开始之前与环境随机交互取得经验初始化移动平均均值和标准差\n2. 训练开始之后，状态减去移动平均均值\n3. 再除以移动平均标准差\n4. 将状态clip到[-5, 5]\n\n作者对状态归一化的原因主要是不归一化的状态其特征的方差非常低，携带信息少（属实不明白）：\n\n> Observation normalization is often important in deep learning but it is crucial when using a random neural network as a target, since the parameters are frozen and hence cannot adjust to the scale of different datasets. \n>\n> Lack of normalization can result in the variance of the embedding being extremely low and carrying little information about the inputs.\n\n这个状态归一化，作者用在随机目标网络和预测网络，但是没有用在策略网络中。\n\n\n\n# 伪代码\n\n![](./random-network-distillation/pseudo.png)\n\n\n\n# 评价\n\n作者认为RND在局部探索中有用，在全局探索中作用不明显：\n\n> We ﬁnd that the RND exploration bonus is sufﬁcient to deal with local exploration, i.e. exploring the consequences of short-term decisions, like whether to interact with a particular object, or avoid it. However global exploration that involves coordinated decisions over long time horizons is beyond the reach of our method.\n\n","slug":"random-network-distillation","published":1,"updated":"2020-06-23T13:59:09.263Z","_id":"ckbrzusy7001420cdibi72fyh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇论文提出了RND，是一种新奇的内在探索机制，主要原理是使预测网络的特征逼近随机网络的特征，以此使得预测网络对不熟悉的状态给出较大的预测误差，由此设定内在奖励。</p>\n<p>推荐程度中等：</p>\n<ul>\n<li>1个额外的固定、不训练的随机网络</li>\n<li>RND在强探索（hard exploration，奖励很稀疏）环境中表现不错</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1810.12894\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1810.12894</a></p>\n<p>代码地址：<a href=\"https://github.com/openai/random-network-distillation\" rel=\"external nofollow\" target=\"_blank\">https://github.com/openai/random-network-distillation</a></p>\n<p>这篇论文的思想特别简单：<strong>设定一个固定不训练的随机网络和一个训练的预测网络，将同一个图像特征分别放入两个网络计算出特征，两个特征的差异程度就为状态的“新奇”程度，由此设定内在奖励</strong>。</p>\n<p>这么做的意义在与：对于与环境交互时经常访问到的状态，其预测网络产生的特征与随机网络产生的特征相差无几，但是如果突然出现一个新的状态或者很少遇见的状态，那么预测网络与随机网络输出之间的差异性比较大，由此说明状态的新颖性，并根据新颖性计算出内在奖励值。<strong>状态常见，则内在奖励小；状态罕见，则内在奖励大。</strong></p>\n<p>这篇论文提出的RND方法在蒙特祖玛的复仇（Montezuma’s Revenge）上刷新了历史新高，并且没有使用专家示例经验（如模仿学习），也没有使用额外的游戏状态信息。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>奖励包括内在与外在两部分：</p>\n<script type=\"math/tex; mode=display\">\nr_{t}=e_{t}+i_{t}</script><p>其中，$e_t$为外部奖励，即环境给的，$i_t$为内部激励。</p>\n<p>传统的内在奖励方法主要分为2类：</p>\n<ol>\n<li><p>计数</p>\n<ol>\n<li><p>在tabular setting中，状态、动作都是可数的，可以用一张表格来维护每个状态-动作对的访问次数，并且使用形如以下的公式来定义内在奖励：</p>\n<script type=\"math/tex; mode=display\">\ni_t=\\frac{1}{n_t(s)}</script><script type=\"math/tex; mode=display\">\ni_t=\\frac{1}{\\sqrt {n_t(s)}}</script></li>\n<li><p>在非tabular setting中，状态、动作不完全可数，则可使用伪计数法（pseudo-counts），主要是使用状态密度估计的变化程度来衡量。参考论文：《Unifying count-based exploration and intrinsic motivation》</p>\n</li>\n</ol>\n</li>\n<li><p>预测，主要是通过前向(s,a-&gt;s’)/反向(s,s’-&gt;a)预测环境动态的误差来设计内在奖励</p>\n</li>\n</ol>\n<blockquote>\n<p>This paper introduces a different approach where the prediction problem is randomly generated. This involves two neural networks: a ﬁxed and randomly initialized target network which sets the prediction problem, and a predictor network trained on data collected by the agent.</p>\n</blockquote>\n<p>RND引入两个网络：</p>\n<ol>\n<li>预测网络，是强化学习网络的一部分，可训练，预测观测值的隐特征，$\\hat{f}: \\mathcal{O} \\rightarrow \\mathbb{R}^{k}$；</li>\n<li>目标网络，额外引入的网络，不训练，固定参数，随机初始化，输出观测值的隐特征作为真值，$f: \\mathcal{O} \\rightarrow \\mathbb{R}^{k}$。</li>\n</ol>\n<p>目标函数即为最小二乘误差：$|\\hat{f}(\\mathbf{x} ; \\theta)-f(\\mathbf{x})|^{2}$，优化参数$\\theta_{\\hat{f}}$。这个过程将随机初始化的神经网络蒸馏到一个学习的预测网络中去。</p>\n<p><strong>上边的最小二乘误差也为内在奖励$i_t$</strong>，作者在使用这个内在奖励时还对其进行了归一化，因为任务不同，这个最小二乘的值偏好范围也不相同，所以作者对这个内在奖励进行了正态分布归一化的处理，主要是将最小二乘误差除以移动平均标准差估计。</p>\n<p>作者说这个预测误差主要有以下几个影响因素：</p>\n<ol>\n<li>训练数据少。当样本中相似数据不多时，预测误差会大</li>\n<li>环境的动态随机。环境的随机转换是前向预测误差增大的原因。</li>\n<li>模型不适合。关键信息缺失（我也不明白是什么关键信息）或者预测的模型不足以拟合目标函数，会使得预测误差很大</li>\n<li>动态学习。学习到最后不能稳定地拟合目标函数。</li>\n</ol>\n<p>作者还建议在使用内在奖励时，分开两个值函数估计，即一个值函数近似外部奖励，另一个值函数近似内部奖励。这是因为外部奖励稳定，内部奖励不稳定。</p>\n<blockquote>\n<p>Note that even where one is not trying to combine episodic and non-episodic reward streams, or reward streams with different discount factors, there may still be a beneﬁt to having separate value functions since there is an additional supervisory signal to the value function. This may be especially important for exploration bonuses since the extrinsic reward function is stationary whereas the intrinsic reward function is non-stationary.</p>\n</blockquote>\n<h2 id=\"状态归一化\"><a href=\"#状态归一化\" class=\"headerlink\" title=\"状态归一化\"></a>状态归一化</h2><p>作者在训练时还对状态进行了归一化处理，主要是以下流程：</p>\n<ol>\n<li>在训练开始之前与环境随机交互取得经验初始化移动平均均值和标准差</li>\n<li>训练开始之后，状态减去移动平均均值</li>\n<li>再除以移动平均标准差</li>\n<li>将状态clip到[-5, 5]</li>\n</ol>\n<p>作者对状态归一化的原因主要是不归一化的状态其特征的方差非常低，携带信息少（属实不明白）：</p>\n<blockquote>\n<p>Observation normalization is often important in deep learning but it is crucial when using a random neural network as a target, since the parameters are frozen and hence cannot adjust to the scale of different datasets. </p>\n<p>Lack of normalization can result in the variance of the embedding being extremely low and carrying little information about the inputs.</p>\n</blockquote>\n<p>这个状态归一化，作者用在随机目标网络和预测网络，但是没有用在策略网络中。</p>\n<h1 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h1><p><img src=\"./random-network-distillation/pseudo.png\" alt=\"\"></p>\n<h1 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"评价\"></a>评价</h1><p>作者认为RND在局部探索中有用，在全局探索中作用不明显：</p>\n<blockquote>\n<p>We ﬁnd that the RND exploration bonus is sufﬁcient to deal with local exploration, i.e. exploring the consequences of short-term decisions, like whether to interact with a particular object, or avoid it. However global exploration that involves coordinated decisions over long time horizons is beyond the reach of our method.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>这篇论文提出了RND，是一种新奇的内在探索机制，主要原理是使预测网络的特征逼近随机网络的特征，以此使得预测网络对不熟悉的状态给出较大的预测误差，由此设定内在奖励。</p>\n<p>推荐程度中等：</p>\n<ul>\n<li>1个额外的固定、不训练的随机网络</li>\n<li>RND在强探索（hard exploration，奖励很稀疏）环境中表现不错</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1810.12894\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1810.12894</a></p>\n<p>代码地址：<a href=\"https://github.com/openai/random-network-distillation\" rel=\"external nofollow\" target=\"_blank\">https://github.com/openai/random-network-distillation</a></p>\n<p>这篇论文的思想特别简单：<strong>设定一个固定不训练的随机网络和一个训练的预测网络，将同一个图像特征分别放入两个网络计算出特征，两个特征的差异程度就为状态的“新奇”程度，由此设定内在奖励</strong>。</p>\n<p>这么做的意义在与：对于与环境交互时经常访问到的状态，其预测网络产生的特征与随机网络产生的特征相差无几，但是如果突然出现一个新的状态或者很少遇见的状态，那么预测网络与随机网络输出之间的差异性比较大，由此说明状态的新颖性，并根据新颖性计算出内在奖励值。<strong>状态常见，则内在奖励小；状态罕见，则内在奖励大。</strong></p>\n<p>这篇论文提出的RND方法在蒙特祖玛的复仇（Montezuma’s Revenge）上刷新了历史新高，并且没有使用专家示例经验（如模仿学习），也没有使用额外的游戏状态信息。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>奖励包括内在与外在两部分：</p>\n<script type=\"math/tex; mode=display\">\nr_{t}=e_{t}+i_{t}</script><p>其中，$e_t$为外部奖励，即环境给的，$i_t$为内部激励。</p>\n<p>传统的内在奖励方法主要分为2类：</p>\n<ol>\n<li><p>计数</p>\n<ol>\n<li><p>在tabular setting中，状态、动作都是可数的，可以用一张表格来维护每个状态-动作对的访问次数，并且使用形如以下的公式来定义内在奖励：</p>\n<script type=\"math/tex; mode=display\">\ni_t=\\frac{1}{n_t(s)}</script><script type=\"math/tex; mode=display\">\ni_t=\\frac{1}{\\sqrt {n_t(s)}}</script></li>\n<li><p>在非tabular setting中，状态、动作不完全可数，则可使用伪计数法（pseudo-counts），主要是使用状态密度估计的变化程度来衡量。参考论文：《Unifying count-based exploration and intrinsic motivation》</p>\n</li>\n</ol>\n</li>\n<li><p>预测，主要是通过前向(s,a-&gt;s’)/反向(s,s’-&gt;a)预测环境动态的误差来设计内在奖励</p>\n</li>\n</ol>\n<blockquote>\n<p>This paper introduces a different approach where the prediction problem is randomly generated. This involves two neural networks: a ﬁxed and randomly initialized target network which sets the prediction problem, and a predictor network trained on data collected by the agent.</p>\n</blockquote>\n<p>RND引入两个网络：</p>\n<ol>\n<li>预测网络，是强化学习网络的一部分，可训练，预测观测值的隐特征，$\\hat{f}: \\mathcal{O} \\rightarrow \\mathbb{R}^{k}$；</li>\n<li>目标网络，额外引入的网络，不训练，固定参数，随机初始化，输出观测值的隐特征作为真值，$f: \\mathcal{O} \\rightarrow \\mathbb{R}^{k}$。</li>\n</ol>\n<p>目标函数即为最小二乘误差：$|\\hat{f}(\\mathbf{x} ; \\theta)-f(\\mathbf{x})|^{2}$，优化参数$\\theta_{\\hat{f}}$。这个过程将随机初始化的神经网络蒸馏到一个学习的预测网络中去。</p>\n<p><strong>上边的最小二乘误差也为内在奖励$i_t$</strong>，作者在使用这个内在奖励时还对其进行了归一化，因为任务不同，这个最小二乘的值偏好范围也不相同，所以作者对这个内在奖励进行了正态分布归一化的处理，主要是将最小二乘误差除以移动平均标准差估计。</p>\n<p>作者说这个预测误差主要有以下几个影响因素：</p>\n<ol>\n<li>训练数据少。当样本中相似数据不多时，预测误差会大</li>\n<li>环境的动态随机。环境的随机转换是前向预测误差增大的原因。</li>\n<li>模型不适合。关键信息缺失（我也不明白是什么关键信息）或者预测的模型不足以拟合目标函数，会使得预测误差很大</li>\n<li>动态学习。学习到最后不能稳定地拟合目标函数。</li>\n</ol>\n<p>作者还建议在使用内在奖励时，分开两个值函数估计，即一个值函数近似外部奖励，另一个值函数近似内部奖励。这是因为外部奖励稳定，内部奖励不稳定。</p>\n<blockquote>\n<p>Note that even where one is not trying to combine episodic and non-episodic reward streams, or reward streams with different discount factors, there may still be a beneﬁt to having separate value functions since there is an additional supervisory signal to the value function. This may be especially important for exploration bonuses since the extrinsic reward function is stationary whereas the intrinsic reward function is non-stationary.</p>\n</blockquote>\n<h2 id=\"状态归一化\"><a href=\"#状态归一化\" class=\"headerlink\" title=\"状态归一化\"></a>状态归一化</h2><p>作者在训练时还对状态进行了归一化处理，主要是以下流程：</p>\n<ol>\n<li>在训练开始之前与环境随机交互取得经验初始化移动平均均值和标准差</li>\n<li>训练开始之后，状态减去移动平均均值</li>\n<li>再除以移动平均标准差</li>\n<li>将状态clip到[-5, 5]</li>\n</ol>\n<p>作者对状态归一化的原因主要是不归一化的状态其特征的方差非常低，携带信息少（属实不明白）：</p>\n<blockquote>\n<p>Observation normalization is often important in deep learning but it is crucial when using a random neural network as a target, since the parameters are frozen and hence cannot adjust to the scale of different datasets. </p>\n<p>Lack of normalization can result in the variance of the embedding being extremely low and carrying little information about the inputs.</p>\n</blockquote>\n<p>这个状态归一化，作者用在随机目标网络和预测网络，但是没有用在策略网络中。</p>\n<h1 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h1><p><img src=\"./random-network-distillation/pseudo.png\" alt=\"\"></p>\n<h1 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"评价\"></a>评价</h1><p>作者认为RND在局部探索中有用，在全局探索中作用不明显：</p>\n<blockquote>\n<p>We ﬁnd that the RND exploration bonus is sufﬁcient to deal with local exploration, i.e. exploring the consequences of short-term decisions, like whether to interact with a particular object, or avoid it. However global exploration that involves coordinated decisions over long time horizons is beyond the reach of our method.</p>\n</blockquote>"},{"title":"配置OverLeaf私人服务器","copyright":true,"mathjax":false,"top":1,"date":"2020-04-16T14:53:53.000Z","keywords":null,"description":null,"_content":"\n此文转载自好友[BlueFisher]([https://bluefisher.github.io/2020/04/16/Overleaf-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/](https://bluefisher.github.io/2020/04/16/Overleaf-服务器配置/)。\n\n<!--more-->\n\n1. 首先根据官方教程 [https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/) 确保服务器已经安装了 Docker，同时根据 [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/) 安装 Docker Compose。\n\n2. 拉取最新的 overleaf 服务器版本\n\n   ```bash\n   $ docker pull sharelatex/sharelatex\n   ```\n\n3. 在用户目录 `~` 下新建文件夹 `~/sharelatex/, ~/sharelatex/sharelatex_data/, ~/sharelatex/mongo_data/, ~/sharelatex/redis_data/`\n\n4. 下载 [docker-compose.yml](https://github.com/overleaf/overleaf/blob/master/docker-compose.yml) 文件，并存在 `~/sharelatex/` 文件夹中\n\n5. 根据需要修改 docker-compose.yml 文件，可以更改服务器映射的端口号 `ports` ，修改 sharelatex, mongo 和 redis 的`volumes` 到步骤3创建的文件夹中\n\n6. 进入 `~sharelatex` 启动 docker-compose.yml\n\n   ```shell\n   $ docker-compose up\n   ```\n\n7. 由于默认安装的是最小版本 TeXLive，如果要安装完整包，执行\n\n   ```shell\n   $ docker exec sharelatex tlmgr install scheme-full\n   ```\n\n   或者也可以安装任意的单个包，只需要把 `sheme-full` 替换为包的名称即可\n\n8. 第一次启动镜像后，访问 `/launchpad` 页面设置管理员账号","source":"_posts/overleaf.md","raw":"---\ntitle: 配置OverLeaf私人服务器\ncopyright: true\nmathjax: false\ntop: 1\ndate: 2020-04-16 22:53:53\ncategories: 小知识\ntags:\n- docker\n- overleaf\nkeywords:\ndescription:\n---\n\n此文转载自好友[BlueFisher]([https://bluefisher.github.io/2020/04/16/Overleaf-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/](https://bluefisher.github.io/2020/04/16/Overleaf-服务器配置/)。\n\n<!--more-->\n\n1. 首先根据官方教程 [https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/) 确保服务器已经安装了 Docker，同时根据 [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/) 安装 Docker Compose。\n\n2. 拉取最新的 overleaf 服务器版本\n\n   ```bash\n   $ docker pull sharelatex/sharelatex\n   ```\n\n3. 在用户目录 `~` 下新建文件夹 `~/sharelatex/, ~/sharelatex/sharelatex_data/, ~/sharelatex/mongo_data/, ~/sharelatex/redis_data/`\n\n4. 下载 [docker-compose.yml](https://github.com/overleaf/overleaf/blob/master/docker-compose.yml) 文件，并存在 `~/sharelatex/` 文件夹中\n\n5. 根据需要修改 docker-compose.yml 文件，可以更改服务器映射的端口号 `ports` ，修改 sharelatex, mongo 和 redis 的`volumes` 到步骤3创建的文件夹中\n\n6. 进入 `~sharelatex` 启动 docker-compose.yml\n\n   ```shell\n   $ docker-compose up\n   ```\n\n7. 由于默认安装的是最小版本 TeXLive，如果要安装完整包，执行\n\n   ```shell\n   $ docker exec sharelatex tlmgr install scheme-full\n   ```\n\n   或者也可以安装任意的单个包，只需要把 `sheme-full` 替换为包的名称即可\n\n8. 第一次启动镜像后，访问 `/launchpad` 页面设置管理员账号","slug":"overleaf","published":1,"updated":"2020-04-16T14:57:57.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusy9001720cdpimsg0gt","content":"<p>此文转载自好友<a href=\"[https://bluefisher.github.io/2020/04/16/Overleaf-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/](https://bluefisher.github.io/2020/04/16/Overleaf-服务器配置/\">BlueFisher</a>。</p>\n<a id=\"more\"></a>\n<ol>\n<li><p>首先根据官方教程 <a href=\"https://docs.docker.com/engine/install/ubuntu/\" rel=\"external nofollow\" target=\"_blank\">https://docs.docker.com/engine/install/ubuntu/</a> 确保服务器已经安装了 Docker，同时根据 <a href=\"https://docs.docker.com/compose/install/\" rel=\"external nofollow\" target=\"_blank\">https://docs.docker.com/compose/install/</a> 安装 Docker Compose。</p>\n</li>\n<li><p>拉取最新的 overleaf 服务器版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull sharelatex/sharelatex</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在用户目录 <code>~</code> 下新建文件夹 <code>~/sharelatex/, ~/sharelatex/sharelatex_data/, ~/sharelatex/mongo_data/, ~/sharelatex/redis_data/</code></p>\n</li>\n<li><p>下载 <a href=\"https://github.com/overleaf/overleaf/blob/master/docker-compose.yml\" rel=\"external nofollow\" target=\"_blank\">docker-compose.yml</a> 文件，并存在 <code>~/sharelatex/</code> 文件夹中</p>\n</li>\n<li><p>根据需要修改 docker-compose.yml 文件，可以更改服务器映射的端口号 <code>ports</code> ，修改 sharelatex, mongo 和 redis 的<code>volumes</code> 到步骤3创建的文件夹中</p>\n</li>\n<li><p>进入 <code>~sharelatex</code> 启动 docker-compose.yml</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> docker-compose up</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>由于默认安装的是最小版本 TeXLive，如果要安装完整包，执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> docker <span class=\"built_in\">exec</span> sharelatex tlmgr install scheme-full</span></span><br></pre></td></tr></table></figure>\n<p>或者也可以安装任意的单个包，只需要把 <code>sheme-full</code> 替换为包的名称即可</p>\n</li>\n<li><p>第一次启动镜像后，访问 <code>/launchpad</code> 页面设置管理员账号</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>此文转载自好友<a href=\"[https://bluefisher.github.io/2020/04/16/Overleaf-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/](https://bluefisher.github.io/2020/04/16/Overleaf-服务器配置/\">BlueFisher</a>。</p>","more":"<ol>\n<li><p>首先根据官方教程 <a href=\"https://docs.docker.com/engine/install/ubuntu/\" rel=\"external nofollow\" target=\"_blank\">https://docs.docker.com/engine/install/ubuntu/</a> 确保服务器已经安装了 Docker，同时根据 <a href=\"https://docs.docker.com/compose/install/\" rel=\"external nofollow\" target=\"_blank\">https://docs.docker.com/compose/install/</a> 安装 Docker Compose。</p>\n</li>\n<li><p>拉取最新的 overleaf 服务器版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull sharelatex/sharelatex</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在用户目录 <code>~</code> 下新建文件夹 <code>~/sharelatex/, ~/sharelatex/sharelatex_data/, ~/sharelatex/mongo_data/, ~/sharelatex/redis_data/</code></p>\n</li>\n<li><p>下载 <a href=\"https://github.com/overleaf/overleaf/blob/master/docker-compose.yml\" rel=\"external nofollow\" target=\"_blank\">docker-compose.yml</a> 文件，并存在 <code>~/sharelatex/</code> 文件夹中</p>\n</li>\n<li><p>根据需要修改 docker-compose.yml 文件，可以更改服务器映射的端口号 <code>ports</code> ，修改 sharelatex, mongo 和 redis 的<code>volumes</code> 到步骤3创建的文件夹中</p>\n</li>\n<li><p>进入 <code>~sharelatex</code> 启动 docker-compose.yml</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> docker-compose up</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>由于默认安装的是最小版本 TeXLive，如果要安装完整包，执行</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> docker <span class=\"built_in\">exec</span> sharelatex tlmgr install scheme-full</span></span><br></pre></td></tr></table></figure>\n<p>或者也可以安装任意的单个包，只需要把 <code>sheme-full</code> 替换为包的名称即可</p>\n</li>\n<li><p>第一次启动镜像后，访问 <code>/launchpad</code> 页面设置管理员账号</p>\n</li>\n</ol>"},{"title":"记录在树莓派4B上的配置命令","copyright":true,"mathjax":false,"top":1,"date":"2020-04-24T13:20:56.000Z","keywords":null,"description":null,"_content":"\n学习在树莓派4B上通过命令行配置各个模块。官方文档：[docs](https://www.raspberrypi.org/documentation/)。\n\n<!--more-->\n\n打开配置窗口\n\n`sudo raspi-config`\n\n可以通过这个配置窗口打开摄像机模块\n\n# 换源\n\n```shell\nsudo -s\necho -e \"deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi \\n deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi\" > /etc/apt/sources.list\nexit\nsudo apt update && sudo apt -y upgrade\n```\n\n# 更新库\n\n```shell\nsudo apt-get update\nsudo apt-get upgrade\nsudo apt full-upgrade\n```\n\n# 安装 BerryConda\n\n```shell\nwget https://github.com/jjhelmus/berryconda/releases/download/v2.0.0/Berryconda3-2.0.0-Linux-armv7l.sh\nchmod a+x Berryconda3-2.0.0-Linux-armv7l.sh\n./Berryconda3-2.0.0-Linux-armv7l.sh\n```\n\n一路`ENTER`+`yes`就ok了。\n\n`source ~/.bashrc`\n\n```shell\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\nconda config --set show_channel_urls yes\nconda config --show\n```\n\n# 使用摄像机模块拍照\n\n在终端使用命令`raspistill`，点击[这里](https://www.raspberrypi.org/documentation/usage/camera/raspicam/raspistill.md)查看详细API。\n\n`raspistill -o 路径/image.jpg -w 640 -h 480`\n\n`raspistill -vf -hf -o cam2.jpg`这个可以指定水平和垂直翻转图像\n\n录像的命令是`raspivid`，点击[这里](https://www.raspberrypi.org/documentation/usage/camera/raspicam/raspivid.md)查看详细API，比如\n\n`raspivid -o 路径/video.h264`\n\n如要录制`.mp4`格式，需要先安装MP4BOX：\n\n`sudo apt install -y gpac`\n\n```shell\n# Capture 30 seconds of raw video at 640x480 and 150kB/s bit rate into a pivideo.h264 file:\nraspivid -t 30000 -w 640 -h 480 -fps 25 -b 1200000 -p 0,0,640,480 -o pivideo.h264\n# Wrap the raw video with an MP4 container:\nMP4Box -add pivideo.h264 pivideo.mp4\n# Remove the source raw file, leaving the remaining pivideo.mp4 file to play\nrm pivideo.h264\n```\n\n## 使用python拍照\n\n创建一个`.py`文件。\n\n安装`picamera`：\n\n```shell\npip install picamera\n# If you wish to use the classes in the picamera.array module then specify the “array” option which will pull in numpy as a dependency:\npip install \"picamera[array]\"\nsudo pip install -U picamera # 更新\n```\n\n下面是我写的一个测试各项功能的脚本：\n\n```python\nimport os\nfrom time import sleep\nfrom picamera import PiCamera, Color\n\nBASE_FOLD = './'\n\nclass Cam(object):\n\n    def __init__(self, camera, path='./', alpha=0):\n        '''\n        params:\n            camera: PiCamera\n            alpha: the degree of transparency, [0, 255]\n        '''\n        self.camera = camera\n        self.path = path\n        self.create_date_folder()\n        self.alpha = alpha\n        self.start()\n\n    def create_date_folder(self):\n        '''\n        创建存放图片和视频的文件夹\n        '''\n        if not os.path.exists(self.path+'images'):\n            os.makedirs(self.path+'images')\n        if not os.path.exists(self.path+'vedios'):\n            os.makedirs(self.path+'vedios')\n\n    def start(self, alpha=-1):\n        if alpha<0:\n            alpha = self.alpha\n        self.camera.start_preview(alpha=alpha)\n\n    def close(self):\n        self.camera.stop_preview()\n\n    def review(self, time):\n        '''\n        检视\n        params:\n            time: sleep time\n            rot: rotation angle, within [0, 90, 180, 270, 360]\n        '''\n        sleep(time)\n\n    def capture(self, time, name):\n        '''\n        拍摄单张图片\n        '''\n        sleep(time)\n        self.camera.capture(self.path+f'images/{name}.jpg')\n\n    def capture_batch(self, time, name, n):\n        '''\n        连续拍照\n        '''\n        for i in range(n):\n            self.capture(time, name=name+f'-{i}')\n\n    def record(self, time, name):\n        '''\n        录制视频\n        '''\n        self.camera.start_recording(self.path+f'vedios/{name}.h264')\n        sleep(time)\n        self.camera.stop_recording()\n\n    def set_camera_attrs(self, d):\n        '''\n        批量设置相机属性\n        '''\n        # self.close()\n        for k, v in d.items():\n            self.set_camera_attr(k, v)\n        # self.start()\n\n    def set_camera_attr(self, k, v):\n        '''\n        设置相机某个属性\n        '''\n        setattr(self.camera, k, v)\n    \n    def traverse_effects(self, time, name):\n        '''\n        遍历图像特效\n        '''\n        for effect in self.camera.IMAGE_EFFECTS:\n            self.camera.image_effect = effect\n            self.camera.annotate_text = \"Effect: %s\" % effect\n            self.capture(time, name+'-'+str(effect))\n        self.camera.image_effect = 'none'\n        self.camera.annotate_text = ''\n\n    def traverse_exposure_mode(self, time, name):\n        '''\n        遍历曝光模式\n        '''\n        for exposure_mode in self.camera.EXPOSURE_MODES:\n            self.camera.exposure_mode = exposure_mode\n            self.camera.annotate_text = \"Exposure Mode: %s\" % exposure_mode\n            self.capture(time, name+'-'+str(exposure_mode))\n        self.camera.exposure_mode = 'auto'\n        self.camera.annotate_text = ''\n\n    def traverse_white_balance(self, time, name):\n        '''\n        遍历白平衡模式\n        '''\n        for awb_mode in self.camera.AWB_MODES:\n            self.camera.awb_mode = awb_mode\n            self.camera.annotate_text = \"Write Balamce: %s\" % awb_mode\n            self.capture(time, name+'-'+str(awb_mode))\n        self.camera.awb_mode = 'auto'\n        self.camera.annotate_text = ''\n\n\ndef run():\n    camera_config={\n        'rotation': 180,    # rotation angle, within [0, 90, 180, 270, 360]\n        'resolution': (800, 600), # The maximum resolution is 2592×1944 for still photos, and 1920×1080 for video recording. The minimum resolution is 64×64.\n        'framerate': 15,\n        'annotate_text': \"Hello world!\", \n        'annotate_text_size': 50,   #[6, 160], default 32\n        'annotate_background': Color('blue'),\n        'annotate_foreground': Color('red'),\n        'brightness': 50,   # 亮度  [0, 100], default 50\n        'contrast': 0   # 对比度\n    }\n    camera = Cam(PiCamera(), path=BASE_FOLD)\n    camera.set_camera_attrs(camera_config)\n    camera.review(2)\n    camera.capture(2, 'test_capture')\n    camera.capture_batch(2, 'test_capture_batch', 4)\n    camera.record(2, 'test_record')\n    camera.traverse_effects(2, 'test_traverse_effects')\n    camera.traverse_exposure_mode(2, 'test_traverse_exposure_mode')\n    camera.traverse_white_balance(2, 'test_traverse_white_balance')\n    camera.close()\n\nif __name__ == \"__main__\":\n    run()\n```\n\n更多复杂操作，请看官方[API文档](https://picamera.readthedocs.io/en/release-1.13/recipes1.html)。\n\n# GPIO\n\n这个库好像是用来与树莓派的引脚进行交互的。\n\n# 参考\n\n1. [树莓派 更换国内源，安装vim，berryconda，opencv](https://blog.csdn.net/xuzhexing/article/details/99404943)","source":"_posts/raspverry4b.md","raw":"---\ntitle: 记录在树莓派4B上的配置命令\ncopyright: true\nmathjax: false\ntop: 1\ndate: 2020-04-24 21:20:56\ncategories: Raspberry\ntags:\n- os\n- raspberry\nkeywords:\ndescription:\n---\n\n学习在树莓派4B上通过命令行配置各个模块。官方文档：[docs](https://www.raspberrypi.org/documentation/)。\n\n<!--more-->\n\n打开配置窗口\n\n`sudo raspi-config`\n\n可以通过这个配置窗口打开摄像机模块\n\n# 换源\n\n```shell\nsudo -s\necho -e \"deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi \\n deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi\" > /etc/apt/sources.list\nexit\nsudo apt update && sudo apt -y upgrade\n```\n\n# 更新库\n\n```shell\nsudo apt-get update\nsudo apt-get upgrade\nsudo apt full-upgrade\n```\n\n# 安装 BerryConda\n\n```shell\nwget https://github.com/jjhelmus/berryconda/releases/download/v2.0.0/Berryconda3-2.0.0-Linux-armv7l.sh\nchmod a+x Berryconda3-2.0.0-Linux-armv7l.sh\n./Berryconda3-2.0.0-Linux-armv7l.sh\n```\n\n一路`ENTER`+`yes`就ok了。\n\n`source ~/.bashrc`\n\n```shell\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\nconda config --set show_channel_urls yes\nconda config --show\n```\n\n# 使用摄像机模块拍照\n\n在终端使用命令`raspistill`，点击[这里](https://www.raspberrypi.org/documentation/usage/camera/raspicam/raspistill.md)查看详细API。\n\n`raspistill -o 路径/image.jpg -w 640 -h 480`\n\n`raspistill -vf -hf -o cam2.jpg`这个可以指定水平和垂直翻转图像\n\n录像的命令是`raspivid`，点击[这里](https://www.raspberrypi.org/documentation/usage/camera/raspicam/raspivid.md)查看详细API，比如\n\n`raspivid -o 路径/video.h264`\n\n如要录制`.mp4`格式，需要先安装MP4BOX：\n\n`sudo apt install -y gpac`\n\n```shell\n# Capture 30 seconds of raw video at 640x480 and 150kB/s bit rate into a pivideo.h264 file:\nraspivid -t 30000 -w 640 -h 480 -fps 25 -b 1200000 -p 0,0,640,480 -o pivideo.h264\n# Wrap the raw video with an MP4 container:\nMP4Box -add pivideo.h264 pivideo.mp4\n# Remove the source raw file, leaving the remaining pivideo.mp4 file to play\nrm pivideo.h264\n```\n\n## 使用python拍照\n\n创建一个`.py`文件。\n\n安装`picamera`：\n\n```shell\npip install picamera\n# If you wish to use the classes in the picamera.array module then specify the “array” option which will pull in numpy as a dependency:\npip install \"picamera[array]\"\nsudo pip install -U picamera # 更新\n```\n\n下面是我写的一个测试各项功能的脚本：\n\n```python\nimport os\nfrom time import sleep\nfrom picamera import PiCamera, Color\n\nBASE_FOLD = './'\n\nclass Cam(object):\n\n    def __init__(self, camera, path='./', alpha=0):\n        '''\n        params:\n            camera: PiCamera\n            alpha: the degree of transparency, [0, 255]\n        '''\n        self.camera = camera\n        self.path = path\n        self.create_date_folder()\n        self.alpha = alpha\n        self.start()\n\n    def create_date_folder(self):\n        '''\n        创建存放图片和视频的文件夹\n        '''\n        if not os.path.exists(self.path+'images'):\n            os.makedirs(self.path+'images')\n        if not os.path.exists(self.path+'vedios'):\n            os.makedirs(self.path+'vedios')\n\n    def start(self, alpha=-1):\n        if alpha<0:\n            alpha = self.alpha\n        self.camera.start_preview(alpha=alpha)\n\n    def close(self):\n        self.camera.stop_preview()\n\n    def review(self, time):\n        '''\n        检视\n        params:\n            time: sleep time\n            rot: rotation angle, within [0, 90, 180, 270, 360]\n        '''\n        sleep(time)\n\n    def capture(self, time, name):\n        '''\n        拍摄单张图片\n        '''\n        sleep(time)\n        self.camera.capture(self.path+f'images/{name}.jpg')\n\n    def capture_batch(self, time, name, n):\n        '''\n        连续拍照\n        '''\n        for i in range(n):\n            self.capture(time, name=name+f'-{i}')\n\n    def record(self, time, name):\n        '''\n        录制视频\n        '''\n        self.camera.start_recording(self.path+f'vedios/{name}.h264')\n        sleep(time)\n        self.camera.stop_recording()\n\n    def set_camera_attrs(self, d):\n        '''\n        批量设置相机属性\n        '''\n        # self.close()\n        for k, v in d.items():\n            self.set_camera_attr(k, v)\n        # self.start()\n\n    def set_camera_attr(self, k, v):\n        '''\n        设置相机某个属性\n        '''\n        setattr(self.camera, k, v)\n    \n    def traverse_effects(self, time, name):\n        '''\n        遍历图像特效\n        '''\n        for effect in self.camera.IMAGE_EFFECTS:\n            self.camera.image_effect = effect\n            self.camera.annotate_text = \"Effect: %s\" % effect\n            self.capture(time, name+'-'+str(effect))\n        self.camera.image_effect = 'none'\n        self.camera.annotate_text = ''\n\n    def traverse_exposure_mode(self, time, name):\n        '''\n        遍历曝光模式\n        '''\n        for exposure_mode in self.camera.EXPOSURE_MODES:\n            self.camera.exposure_mode = exposure_mode\n            self.camera.annotate_text = \"Exposure Mode: %s\" % exposure_mode\n            self.capture(time, name+'-'+str(exposure_mode))\n        self.camera.exposure_mode = 'auto'\n        self.camera.annotate_text = ''\n\n    def traverse_white_balance(self, time, name):\n        '''\n        遍历白平衡模式\n        '''\n        for awb_mode in self.camera.AWB_MODES:\n            self.camera.awb_mode = awb_mode\n            self.camera.annotate_text = \"Write Balamce: %s\" % awb_mode\n            self.capture(time, name+'-'+str(awb_mode))\n        self.camera.awb_mode = 'auto'\n        self.camera.annotate_text = ''\n\n\ndef run():\n    camera_config={\n        'rotation': 180,    # rotation angle, within [0, 90, 180, 270, 360]\n        'resolution': (800, 600), # The maximum resolution is 2592×1944 for still photos, and 1920×1080 for video recording. The minimum resolution is 64×64.\n        'framerate': 15,\n        'annotate_text': \"Hello world!\", \n        'annotate_text_size': 50,   #[6, 160], default 32\n        'annotate_background': Color('blue'),\n        'annotate_foreground': Color('red'),\n        'brightness': 50,   # 亮度  [0, 100], default 50\n        'contrast': 0   # 对比度\n    }\n    camera = Cam(PiCamera(), path=BASE_FOLD)\n    camera.set_camera_attrs(camera_config)\n    camera.review(2)\n    camera.capture(2, 'test_capture')\n    camera.capture_batch(2, 'test_capture_batch', 4)\n    camera.record(2, 'test_record')\n    camera.traverse_effects(2, 'test_traverse_effects')\n    camera.traverse_exposure_mode(2, 'test_traverse_exposure_mode')\n    camera.traverse_white_balance(2, 'test_traverse_white_balance')\n    camera.close()\n\nif __name__ == \"__main__\":\n    run()\n```\n\n更多复杂操作，请看官方[API文档](https://picamera.readthedocs.io/en/release-1.13/recipes1.html)。\n\n# GPIO\n\n这个库好像是用来与树莓派的引脚进行交互的。\n\n# 参考\n\n1. [树莓派 更换国内源，安装vim，berryconda，opencv](https://blog.csdn.net/xuzhexing/article/details/99404943)","slug":"raspverry4b","published":1,"updated":"2020-04-25T02:23:11.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusyc001920cdaw53ppl2","content":"<p>学习在树莓派4B上通过命令行配置各个模块。官方文档：<a href=\"https://www.raspberrypi.org/documentation/\" rel=\"external nofollow\" target=\"_blank\">docs</a>。</p>\n<a id=\"more\"></a>\n<p>打开配置窗口</p>\n<p><code>sudo raspi-config</code></p>\n<p>可以通过这个配置窗口打开摄像机模块</p>\n<h1 id=\"换源\"><a href=\"#换源\" class=\"headerlink\" title=\"换源\"></a>换源</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -s</span><br><span class=\"line\">echo -e \"deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi \\n deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi\" &gt; /etc/apt/sources.list</span><br><span class=\"line\">exit</span><br><span class=\"line\">sudo apt update &amp;&amp; sudo apt -y upgrade</span><br></pre></td></tr></table></figure>\n<h1 id=\"更新库\"><a href=\"#更新库\" class=\"headerlink\" title=\"更新库\"></a>更新库</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br><span class=\"line\">sudo apt full-upgrade</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装-BerryConda\"><a href=\"#安装-BerryConda\" class=\"headerlink\" title=\"安装 BerryConda\"></a>安装 BerryConda</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/jjhelmus/berryconda/releases/download/v2.0.0/Berryconda3-2.0.0-Linux-armv7l.sh</span><br><span class=\"line\">chmod a+x Berryconda3-2.0.0-Linux-armv7l.sh</span><br><span class=\"line\">./Berryconda3-2.0.0-Linux-armv7l.sh</span><br></pre></td></tr></table></figure>\n<p>一路<code>ENTER</code>+<code>yes</code>就ok了。</p>\n<p><code>source ~/.bashrc</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class=\"line\">conda config --set show_channel_urls yes</span><br><span class=\"line\">conda config --show</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用摄像机模块拍照\"><a href=\"#使用摄像机模块拍照\" class=\"headerlink\" title=\"使用摄像机模块拍照\"></a>使用摄像机模块拍照</h1><p>在终端使用命令<code>raspistill</code>，点击<a href=\"https://www.raspberrypi.org/documentation/usage/camera/raspicam/raspistill.md\" rel=\"external nofollow\" target=\"_blank\">这里</a>查看详细API。</p>\n<p><code>raspistill -o 路径/image.jpg -w 640 -h 480</code></p>\n<p><code>raspistill -vf -hf -o cam2.jpg</code>这个可以指定水平和垂直翻转图像</p>\n<p>录像的命令是<code>raspivid</code>，点击<a href=\"https://www.raspberrypi.org/documentation/usage/camera/raspicam/raspivid.md\" rel=\"external nofollow\" target=\"_blank\">这里</a>查看详细API，比如</p>\n<p><code>raspivid -o 路径/video.h264</code></p>\n<p>如要录制<code>.mp4</code>格式，需要先安装MP4BOX：</p>\n<p><code>sudo apt install -y gpac</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Capture 30 seconds of raw video at 640x480 and 150kB/s bit rate into a pivideo.h264 file:</span></span><br><span class=\"line\">raspivid -t 30000 -w 640 -h 480 -fps 25 -b 1200000 -p 0,0,640,480 -o pivideo.h264</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Wrap the raw video with an MP4 container:</span></span><br><span class=\"line\">MP4Box -add pivideo.h264 pivideo.mp4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Remove the <span class=\"built_in\">source</span> raw file, leaving the remaining pivideo.mp4 file to play</span></span><br><span class=\"line\">rm pivideo.h264</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用python拍照\"><a href=\"#使用python拍照\" class=\"headerlink\" title=\"使用python拍照\"></a>使用python拍照</h2><p>创建一个<code>.py</code>文件。</p>\n<p>安装<code>picamera</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install picamera</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If you wish to use the classes <span class=\"keyword\">in</span> the picamera.array module <span class=\"keyword\">then</span> specify the “array” option <span class=\"built_in\">which</span> will pull <span class=\"keyword\">in</span> numpy as a dependency:</span></span><br><span class=\"line\">pip install \"picamera[array]\"</span><br><span class=\"line\">sudo pip install -U picamera # 更新</span><br></pre></td></tr></table></figure>\n<p>下面是我写的一个测试各项功能的脚本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</span><br><span class=\"line\"><span class=\"keyword\">from</span> picamera <span class=\"keyword\">import</span> PiCamera, Color</span><br><span class=\"line\"></span><br><span class=\"line\">BASE_FOLD = <span class=\"string\">'./'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cam</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, camera, path=<span class=\"string\">'./'</span>, alpha=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        params:</span></span><br><span class=\"line\"><span class=\"string\">            camera: PiCamera</span></span><br><span class=\"line\"><span class=\"string\">            alpha: the degree of transparency, [0, 255]</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        self.camera = camera</span><br><span class=\"line\">        self.path = path</span><br><span class=\"line\">        self.create_date_folder()</span><br><span class=\"line\">        self.alpha = alpha</span><br><span class=\"line\">        self.start()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_date_folder</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        创建存放图片和视频的文件夹</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(self.path+<span class=\"string\">'images'</span>):</span><br><span class=\"line\">            os.makedirs(self.path+<span class=\"string\">'images'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(self.path+<span class=\"string\">'vedios'</span>):</span><br><span class=\"line\">            os.makedirs(self.path+<span class=\"string\">'vedios'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start</span><span class=\"params\">(self, alpha=<span class=\"number\">-1</span>)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> alpha&lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">            alpha = self.alpha</span><br><span class=\"line\">        self.camera.start_preview(alpha=alpha)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">close</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.camera.stop_preview()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">review</span><span class=\"params\">(self, time)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        检视</span></span><br><span class=\"line\"><span class=\"string\">        params:</span></span><br><span class=\"line\"><span class=\"string\">            time: sleep time</span></span><br><span class=\"line\"><span class=\"string\">            rot: rotation angle, within [0, 90, 180, 270, 360]</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        sleep(time)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">capture</span><span class=\"params\">(self, time, name)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        拍摄单张图片</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        sleep(time)</span><br><span class=\"line\">        self.camera.capture(self.path+<span class=\"string\">f'images/<span class=\"subst\">&#123;name&#125;</span>.jpg'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">capture_batch</span><span class=\"params\">(self, time, name, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        连续拍照</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            self.capture(time, name=name+<span class=\"string\">f'-<span class=\"subst\">&#123;i&#125;</span>'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">record</span><span class=\"params\">(self, time, name)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        录制视频</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        self.camera.start_recording(self.path+<span class=\"string\">f'vedios/<span class=\"subst\">&#123;name&#125;</span>.h264'</span>)</span><br><span class=\"line\">        sleep(time)</span><br><span class=\"line\">        self.camera.stop_recording()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_camera_attrs</span><span class=\"params\">(self, d)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        批量设置相机属性</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"comment\"># self.close()</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> d.items():</span><br><span class=\"line\">            self.set_camera_attr(k, v)</span><br><span class=\"line\">        <span class=\"comment\"># self.start()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_camera_attr</span><span class=\"params\">(self, k, v)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        设置相机某个属性</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        setattr(self.camera, k, v)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">traverse_effects</span><span class=\"params\">(self, time, name)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        遍历图像特效</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> effect <span class=\"keyword\">in</span> self.camera.IMAGE_EFFECTS:</span><br><span class=\"line\">            self.camera.image_effect = effect</span><br><span class=\"line\">            self.camera.annotate_text = <span class=\"string\">\"Effect: %s\"</span> % effect</span><br><span class=\"line\">            self.capture(time, name+<span class=\"string\">'-'</span>+str(effect))</span><br><span class=\"line\">        self.camera.image_effect = <span class=\"string\">'none'</span></span><br><span class=\"line\">        self.camera.annotate_text = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">traverse_exposure_mode</span><span class=\"params\">(self, time, name)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        遍历曝光模式</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> exposure_mode <span class=\"keyword\">in</span> self.camera.EXPOSURE_MODES:</span><br><span class=\"line\">            self.camera.exposure_mode = exposure_mode</span><br><span class=\"line\">            self.camera.annotate_text = <span class=\"string\">\"Exposure Mode: %s\"</span> % exposure_mode</span><br><span class=\"line\">            self.capture(time, name+<span class=\"string\">'-'</span>+str(exposure_mode))</span><br><span class=\"line\">        self.camera.exposure_mode = <span class=\"string\">'auto'</span></span><br><span class=\"line\">        self.camera.annotate_text = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">traverse_white_balance</span><span class=\"params\">(self, time, name)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        遍历白平衡模式</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> awb_mode <span class=\"keyword\">in</span> self.camera.AWB_MODES:</span><br><span class=\"line\">            self.camera.awb_mode = awb_mode</span><br><span class=\"line\">            self.camera.annotate_text = <span class=\"string\">\"Write Balamce: %s\"</span> % awb_mode</span><br><span class=\"line\">            self.capture(time, name+<span class=\"string\">'-'</span>+str(awb_mode))</span><br><span class=\"line\">        self.camera.awb_mode = <span class=\"string\">'auto'</span></span><br><span class=\"line\">        self.camera.annotate_text = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    camera_config=&#123;</span><br><span class=\"line\">        <span class=\"string\">'rotation'</span>: <span class=\"number\">180</span>,    <span class=\"comment\"># rotation angle, within [0, 90, 180, 270, 360]</span></span><br><span class=\"line\">        <span class=\"string\">'resolution'</span>: (<span class=\"number\">800</span>, <span class=\"number\">600</span>), <span class=\"comment\"># The maximum resolution is 2592×1944 for still photos, and 1920×1080 for video recording. The minimum resolution is 64×64.</span></span><br><span class=\"line\">        <span class=\"string\">'framerate'</span>: <span class=\"number\">15</span>,</span><br><span class=\"line\">        <span class=\"string\">'annotate_text'</span>: <span class=\"string\">\"Hello world!\"</span>, </span><br><span class=\"line\">        <span class=\"string\">'annotate_text_size'</span>: <span class=\"number\">50</span>,   <span class=\"comment\">#[6, 160], default 32</span></span><br><span class=\"line\">        <span class=\"string\">'annotate_background'</span>: Color(<span class=\"string\">'blue'</span>),</span><br><span class=\"line\">        <span class=\"string\">'annotate_foreground'</span>: Color(<span class=\"string\">'red'</span>),</span><br><span class=\"line\">        <span class=\"string\">'brightness'</span>: <span class=\"number\">50</span>,   <span class=\"comment\"># 亮度  [0, 100], default 50</span></span><br><span class=\"line\">        <span class=\"string\">'contrast'</span>: <span class=\"number\">0</span>   <span class=\"comment\"># 对比度</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    camera = Cam(PiCamera(), path=BASE_FOLD)</span><br><span class=\"line\">    camera.set_camera_attrs(camera_config)</span><br><span class=\"line\">    camera.review(<span class=\"number\">2</span>)</span><br><span class=\"line\">    camera.capture(<span class=\"number\">2</span>, <span class=\"string\">'test_capture'</span>)</span><br><span class=\"line\">    camera.capture_batch(<span class=\"number\">2</span>, <span class=\"string\">'test_capture_batch'</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    camera.record(<span class=\"number\">2</span>, <span class=\"string\">'test_record'</span>)</span><br><span class=\"line\">    camera.traverse_effects(<span class=\"number\">2</span>, <span class=\"string\">'test_traverse_effects'</span>)</span><br><span class=\"line\">    camera.traverse_exposure_mode(<span class=\"number\">2</span>, <span class=\"string\">'test_traverse_exposure_mode'</span>)</span><br><span class=\"line\">    camera.traverse_white_balance(<span class=\"number\">2</span>, <span class=\"string\">'test_traverse_white_balance'</span>)</span><br><span class=\"line\">    camera.close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    run()</span><br></pre></td></tr></table></figure>\n<p>更多复杂操作，请看官方<a href=\"https://picamera.readthedocs.io/en/release-1.13/recipes1.html\" rel=\"external nofollow\" target=\"_blank\">API文档</a>。</p>\n<h1 id=\"GPIO\"><a href=\"#GPIO\" class=\"headerlink\" title=\"GPIO\"></a>GPIO</h1><p>这个库好像是用来与树莓派的引脚进行交互的。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://blog.csdn.net/xuzhexing/article/details/99404943\" rel=\"external nofollow\" target=\"_blank\">树莓派 更换国内源，安装vim，berryconda，opencv</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>学习在树莓派4B上通过命令行配置各个模块。官方文档：<a href=\"https://www.raspberrypi.org/documentation/\" rel=\"external nofollow\" target=\"_blank\">docs</a>。</p>","more":"<p>打开配置窗口</p>\n<p><code>sudo raspi-config</code></p>\n<p>可以通过这个配置窗口打开摄像机模块</p>\n<h1 id=\"换源\"><a href=\"#换源\" class=\"headerlink\" title=\"换源\"></a>换源</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -s</span><br><span class=\"line\">echo -e \"deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi \\n deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi\" &gt; /etc/apt/sources.list</span><br><span class=\"line\">exit</span><br><span class=\"line\">sudo apt update &amp;&amp; sudo apt -y upgrade</span><br></pre></td></tr></table></figure>\n<h1 id=\"更新库\"><a href=\"#更新库\" class=\"headerlink\" title=\"更新库\"></a>更新库</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br><span class=\"line\">sudo apt full-upgrade</span><br></pre></td></tr></table></figure>\n<h1 id=\"安装-BerryConda\"><a href=\"#安装-BerryConda\" class=\"headerlink\" title=\"安装 BerryConda\"></a>安装 BerryConda</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/jjhelmus/berryconda/releases/download/v2.0.0/Berryconda3-2.0.0-Linux-armv7l.sh</span><br><span class=\"line\">chmod a+x Berryconda3-2.0.0-Linux-armv7l.sh</span><br><span class=\"line\">./Berryconda3-2.0.0-Linux-armv7l.sh</span><br></pre></td></tr></table></figure>\n<p>一路<code>ENTER</code>+<code>yes</code>就ok了。</p>\n<p><code>source ~/.bashrc</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class=\"line\">conda config --set show_channel_urls yes</span><br><span class=\"line\">conda config --show</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用摄像机模块拍照\"><a href=\"#使用摄像机模块拍照\" class=\"headerlink\" title=\"使用摄像机模块拍照\"></a>使用摄像机模块拍照</h1><p>在终端使用命令<code>raspistill</code>，点击<a href=\"https://www.raspberrypi.org/documentation/usage/camera/raspicam/raspistill.md\" rel=\"external nofollow\" target=\"_blank\">这里</a>查看详细API。</p>\n<p><code>raspistill -o 路径/image.jpg -w 640 -h 480</code></p>\n<p><code>raspistill -vf -hf -o cam2.jpg</code>这个可以指定水平和垂直翻转图像</p>\n<p>录像的命令是<code>raspivid</code>，点击<a href=\"https://www.raspberrypi.org/documentation/usage/camera/raspicam/raspivid.md\" rel=\"external nofollow\" target=\"_blank\">这里</a>查看详细API，比如</p>\n<p><code>raspivid -o 路径/video.h264</code></p>\n<p>如要录制<code>.mp4</code>格式，需要先安装MP4BOX：</p>\n<p><code>sudo apt install -y gpac</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Capture 30 seconds of raw video at 640x480 and 150kB/s bit rate into a pivideo.h264 file:</span></span><br><span class=\"line\">raspivid -t 30000 -w 640 -h 480 -fps 25 -b 1200000 -p 0,0,640,480 -o pivideo.h264</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Wrap the raw video with an MP4 container:</span></span><br><span class=\"line\">MP4Box -add pivideo.h264 pivideo.mp4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Remove the <span class=\"built_in\">source</span> raw file, leaving the remaining pivideo.mp4 file to play</span></span><br><span class=\"line\">rm pivideo.h264</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用python拍照\"><a href=\"#使用python拍照\" class=\"headerlink\" title=\"使用python拍照\"></a>使用python拍照</h2><p>创建一个<code>.py</code>文件。</p>\n<p>安装<code>picamera</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install picamera</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> If you wish to use the classes <span class=\"keyword\">in</span> the picamera.array module <span class=\"keyword\">then</span> specify the “array” option <span class=\"built_in\">which</span> will pull <span class=\"keyword\">in</span> numpy as a dependency:</span></span><br><span class=\"line\">pip install \"picamera[array]\"</span><br><span class=\"line\">sudo pip install -U picamera # 更新</span><br></pre></td></tr></table></figure>\n<p>下面是我写的一个测试各项功能的脚本：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</span><br><span class=\"line\"><span class=\"keyword\">from</span> picamera <span class=\"keyword\">import</span> PiCamera, Color</span><br><span class=\"line\"></span><br><span class=\"line\">BASE_FOLD = <span class=\"string\">'./'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cam</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, camera, path=<span class=\"string\">'./'</span>, alpha=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        params:</span></span><br><span class=\"line\"><span class=\"string\">            camera: PiCamera</span></span><br><span class=\"line\"><span class=\"string\">            alpha: the degree of transparency, [0, 255]</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        self.camera = camera</span><br><span class=\"line\">        self.path = path</span><br><span class=\"line\">        self.create_date_folder()</span><br><span class=\"line\">        self.alpha = alpha</span><br><span class=\"line\">        self.start()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_date_folder</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        创建存放图片和视频的文件夹</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(self.path+<span class=\"string\">'images'</span>):</span><br><span class=\"line\">            os.makedirs(self.path+<span class=\"string\">'images'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(self.path+<span class=\"string\">'vedios'</span>):</span><br><span class=\"line\">            os.makedirs(self.path+<span class=\"string\">'vedios'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start</span><span class=\"params\">(self, alpha=<span class=\"number\">-1</span>)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> alpha&lt;<span class=\"number\">0</span>:</span><br><span class=\"line\">            alpha = self.alpha</span><br><span class=\"line\">        self.camera.start_preview(alpha=alpha)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">close</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.camera.stop_preview()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">review</span><span class=\"params\">(self, time)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        检视</span></span><br><span class=\"line\"><span class=\"string\">        params:</span></span><br><span class=\"line\"><span class=\"string\">            time: sleep time</span></span><br><span class=\"line\"><span class=\"string\">            rot: rotation angle, within [0, 90, 180, 270, 360]</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        sleep(time)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">capture</span><span class=\"params\">(self, time, name)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        拍摄单张图片</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        sleep(time)</span><br><span class=\"line\">        self.camera.capture(self.path+<span class=\"string\">f'images/<span class=\"subst\">&#123;name&#125;</span>.jpg'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">capture_batch</span><span class=\"params\">(self, time, name, n)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        连续拍照</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">            self.capture(time, name=name+<span class=\"string\">f'-<span class=\"subst\">&#123;i&#125;</span>'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">record</span><span class=\"params\">(self, time, name)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        录制视频</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        self.camera.start_recording(self.path+<span class=\"string\">f'vedios/<span class=\"subst\">&#123;name&#125;</span>.h264'</span>)</span><br><span class=\"line\">        sleep(time)</span><br><span class=\"line\">        self.camera.stop_recording()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_camera_attrs</span><span class=\"params\">(self, d)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        批量设置相机属性</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"comment\"># self.close()</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> d.items():</span><br><span class=\"line\">            self.set_camera_attr(k, v)</span><br><span class=\"line\">        <span class=\"comment\"># self.start()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_camera_attr</span><span class=\"params\">(self, k, v)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        设置相机某个属性</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        setattr(self.camera, k, v)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">traverse_effects</span><span class=\"params\">(self, time, name)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        遍历图像特效</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> effect <span class=\"keyword\">in</span> self.camera.IMAGE_EFFECTS:</span><br><span class=\"line\">            self.camera.image_effect = effect</span><br><span class=\"line\">            self.camera.annotate_text = <span class=\"string\">\"Effect: %s\"</span> % effect</span><br><span class=\"line\">            self.capture(time, name+<span class=\"string\">'-'</span>+str(effect))</span><br><span class=\"line\">        self.camera.image_effect = <span class=\"string\">'none'</span></span><br><span class=\"line\">        self.camera.annotate_text = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">traverse_exposure_mode</span><span class=\"params\">(self, time, name)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        遍历曝光模式</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> exposure_mode <span class=\"keyword\">in</span> self.camera.EXPOSURE_MODES:</span><br><span class=\"line\">            self.camera.exposure_mode = exposure_mode</span><br><span class=\"line\">            self.camera.annotate_text = <span class=\"string\">\"Exposure Mode: %s\"</span> % exposure_mode</span><br><span class=\"line\">            self.capture(time, name+<span class=\"string\">'-'</span>+str(exposure_mode))</span><br><span class=\"line\">        self.camera.exposure_mode = <span class=\"string\">'auto'</span></span><br><span class=\"line\">        self.camera.annotate_text = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">traverse_white_balance</span><span class=\"params\">(self, time, name)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        遍历白平衡模式</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> awb_mode <span class=\"keyword\">in</span> self.camera.AWB_MODES:</span><br><span class=\"line\">            self.camera.awb_mode = awb_mode</span><br><span class=\"line\">            self.camera.annotate_text = <span class=\"string\">\"Write Balamce: %s\"</span> % awb_mode</span><br><span class=\"line\">            self.capture(time, name+<span class=\"string\">'-'</span>+str(awb_mode))</span><br><span class=\"line\">        self.camera.awb_mode = <span class=\"string\">'auto'</span></span><br><span class=\"line\">        self.camera.annotate_text = <span class=\"string\">''</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    camera_config=&#123;</span><br><span class=\"line\">        <span class=\"string\">'rotation'</span>: <span class=\"number\">180</span>,    <span class=\"comment\"># rotation angle, within [0, 90, 180, 270, 360]</span></span><br><span class=\"line\">        <span class=\"string\">'resolution'</span>: (<span class=\"number\">800</span>, <span class=\"number\">600</span>), <span class=\"comment\"># The maximum resolution is 2592×1944 for still photos, and 1920×1080 for video recording. The minimum resolution is 64×64.</span></span><br><span class=\"line\">        <span class=\"string\">'framerate'</span>: <span class=\"number\">15</span>,</span><br><span class=\"line\">        <span class=\"string\">'annotate_text'</span>: <span class=\"string\">\"Hello world!\"</span>, </span><br><span class=\"line\">        <span class=\"string\">'annotate_text_size'</span>: <span class=\"number\">50</span>,   <span class=\"comment\">#[6, 160], default 32</span></span><br><span class=\"line\">        <span class=\"string\">'annotate_background'</span>: Color(<span class=\"string\">'blue'</span>),</span><br><span class=\"line\">        <span class=\"string\">'annotate_foreground'</span>: Color(<span class=\"string\">'red'</span>),</span><br><span class=\"line\">        <span class=\"string\">'brightness'</span>: <span class=\"number\">50</span>,   <span class=\"comment\"># 亮度  [0, 100], default 50</span></span><br><span class=\"line\">        <span class=\"string\">'contrast'</span>: <span class=\"number\">0</span>   <span class=\"comment\"># 对比度</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    camera = Cam(PiCamera(), path=BASE_FOLD)</span><br><span class=\"line\">    camera.set_camera_attrs(camera_config)</span><br><span class=\"line\">    camera.review(<span class=\"number\">2</span>)</span><br><span class=\"line\">    camera.capture(<span class=\"number\">2</span>, <span class=\"string\">'test_capture'</span>)</span><br><span class=\"line\">    camera.capture_batch(<span class=\"number\">2</span>, <span class=\"string\">'test_capture_batch'</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">    camera.record(<span class=\"number\">2</span>, <span class=\"string\">'test_record'</span>)</span><br><span class=\"line\">    camera.traverse_effects(<span class=\"number\">2</span>, <span class=\"string\">'test_traverse_effects'</span>)</span><br><span class=\"line\">    camera.traverse_exposure_mode(<span class=\"number\">2</span>, <span class=\"string\">'test_traverse_exposure_mode'</span>)</span><br><span class=\"line\">    camera.traverse_white_balance(<span class=\"number\">2</span>, <span class=\"string\">'test_traverse_white_balance'</span>)</span><br><span class=\"line\">    camera.close()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    run()</span><br></pre></td></tr></table></figure>\n<p>更多复杂操作，请看官方<a href=\"https://picamera.readthedocs.io/en/release-1.13/recipes1.html\" rel=\"external nofollow\" target=\"_blank\">API文档</a>。</p>\n<h1 id=\"GPIO\"><a href=\"#GPIO\" class=\"headerlink\" title=\"GPIO\"></a>GPIO</h1><p>这个库好像是用来与树莓派的引脚进行交互的。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li><a href=\"https://blog.csdn.net/xuzhexing/article/details/99404943\" rel=\"external nofollow\" target=\"_blank\">树莓派 更换国内源，安装vim，berryconda，opencv</a></li>\n</ol>"},{"title":"《Reinforcement Learning: An Introduction》阅读笔记","copyright":true,"mathjax":true,"top":1,"date":"2020-04-02T13:29:07.000Z","keywords":null,"description":null,"_content":"\n学习RL至今(2020年04月02日21:30:19)，一直没有系统地看过这本被誉为RL界“圣经”的教科书，也没有对从该书中学到的知识点进行整理与记录，本文将记录重读《Reinforcement Learning: An Introduction》这本书时所学到的关键知识点和受到的启发。\n\n<!--more-->\n\n# Introduction\n\n## Chapter 1 Introduction\n\n### Reinforcement Learning\n\n### Examples\n\n### Elements of Reinforcement Learning\n\n### Limitations and Scope\n\n### An Extended Example: Tic-Tac-Toe\n\n### Summary\n\n### Early History of Reinforcement Learning\n\n# Tabular Solution Methods\n\n## Chapter 2 Multi-armed Bandits\n\n### A k-armed Bandit Problem\n\n### Action-value Methods\n\n### The 10-armed Testbed\n\n### Incremental Implementation\n\n### Tracking a Nonstationary Problem\n\n### Optimistic Initial Values\n\n### Upper-Confidence-Bound ActionSelection\n\n### Gradient Bandit Algorithms\n\n### Associative Search(Contextual Bandits)\n\n### Summary\n\n## Chapter 3 Finite Markov Decision Processes\n\n### The Agent-Environment Interface\n\n### Goals and Rewards\n\n### Returns and Episodes\n\n### Unified Nation for Episodic and Continuing Tasks\n\n### Policies and Value Functions\n\n### Optimial Policies and Optimal Value Functions\n\n### Optimality and Approximation\n\n### Summary\n\n## Chapter 4 Dynamic Programming\n\n### Policy Evaluation(Prediction)\n\n### Policy Improvement\n\n### Policy Iteration\n\n### Value Iteration\n\n### Asynchronous Dynamic Programming\n\n### Generalized Policy Iteration\n\n### Efficiency of Dynamic Programming\n\n### Summary\n\n## Chapter 5 Monte Carlo Methods\n\n### Monte Carlo Prediction\n\n### Monte Carlo Estimation of Action Values\n\n### Monte Carlo Control\n\n### Monte Carlo Control without Exploring Starts\n\n### Off-policy Prediction via Improtance Sampling\n\n### Incremental Implementation\n\n### Off-policy Monte Carlo Control\n\n### Discounting-aware Importance Sampling\n\n### Per-decision Importance Sampling\n\n### Summary\n\n## Chapter 6 Temporal-Difference Learning\n\n### TD Prediction\n\n### Advantages of TD Prediction Methods\n\n### Optimality of TD(0)\n\n### Sarsa: On-policy TD Control\n\n### Q-learning: Off-policy TD Control\n\n### Expected Sarsa\n\n### Maximization Bias and Double Learning\n\n### Games, Afterstates, and Other Special Cases\n\n### Summary\n\n## Chapter 7 n-step Bootstrapping\n\n### n-step TD Prediction\n\n### n-step Sarsa\n\n### n-step Off-policy Learning\n\n### Per-decision Methods with Control Variates\n\n### Off-policy Learning Without Importance Sampling: The n-step Tree Backup Algorithm\n\n### A Unifying Algorithm: n-step $Q(\\sigma)$\n\n### Summary\n\n## Chapter 8 Planning and Learning with Tabular Methods\n\n### Models and Planning\n\n### Dyna: Integrated Planning, Acting, and Learning\n\n### When the Model Is Wrong\n\n### Prioritized Sweeping\n\n### Expected vs. Sample Updates\n\n### Trajectory Sampling\n\n### Real-time Dynamic Programming\n\n### Planning at Decision Time\n\n### Heuristic Search\n\n### Rollout Algorithms\n\n### Monte Carlo Tree Search\n\n### Summary\n\n# Approximate Solution Methods\n\n## Chapter 9 On-policy Prediction with Approximation\n\n### Value-function Approximation\n\n### The Prediction Objective(VE)\n\n### Stochastic-gradient and Semi-gradient Methods\n\n### Linear Methods\n\n### Feature Construction for Linear Methods\n\n#### Polynomials\n\n#### Fourier Basis\n\n#### Coarse Coding\n\n#### Tile Coding\n\n#### Radial Basis Functions\n\n### Selecting Step-size Parameters Manually\n\n### Nonlinear Function Approximation: Artiﬁcial Neural Networks\n\n### Least-Squares TD\n\n### Memory-based Function Approximation\n\n### Kernel-based Function Approximation\n\n### Looking Deeper at On-policy Learning: Interest and Emphasis\n\n### Summary\n\n## Chapter 10 On-policy Control with Approximation\n\n### Episodic Semi-gradient Control\n\n### Semi-gradient n-step Sarsa\n\n### Average Reward: A New Problem Setting for Continuing Tasks\n\n### Deprecating the Discounted Setting\n\n### Differential Semi-gradient n-step Sarsa\n\n### Summary\n\n## Chapter 11 Off-policy Methods with Approximation\n\n### Semi-gradient Methods\n\n### Examples of Off-policy Divergence\n\n### The Deadly Triad\n\n### Linear Value-function Geometry\n\n### Gradient Descent in the Bellman Error\n\n### The Bellman Error is Not Learnable\n\n### Gradient-TD Methods\n\n### Emphatic-TD Methods\n\n### Reducing Variance\n\n### Summary\n\n## Chapter 12 Eligibility Traces\n\n### The $\\lambda$-return\n\n### TD($\\lambda$)\n\n### n-step Truncated $\\lambda$-return Methods\n\n### Redoing Updates: Online $\\lambda$-return Algorithm\n\n### True Online TD($\\lambda$)\n\n### Dutch Traces in Monte Carlo Learning\n\n### Sarsa($\\lambda$)\n\n### Variable $\\lambda$ and $\\gamma$\n\n### Off-policy Traces with Control Variates\n\n### Watkins’s Q($\\lambda$) to Tree-Backup( $\\lambda$)\n\n### Stable Off-policy Methods with Traces\n\n### Implementation Issues\n\n### Conclusions\n\n## Chapter 13 Policy Gradient Methods\n\n### Policy Approximation and its Advantages\n\n### The Policy Gradient Theorem\n\n### REINFORCE: Monte Carlo Policy Gradient\n\n### REINFORCE with Baseline\n\n### Actor–Critic Methods\n\n### Policy Gradient for Continuing Problems\n\n### Policy Parameterization for Continuous Actions\n\n### Summary\n\n# Looking Deeper\n\n## Chapter 14 Psychology\n\n### Prediction and Control\n\n### Classical Conditioning\n\n#### Blocking and Higher-order Conditioning\n\n#### The Rescorla–Wagner Model\n\n#### The TD Model\n\n#### TD Model Simulations\n\n### Instrumental Conditioning\n\n### Delayed Reinforcement\n\n### Cognitive Maps\n\n### Habitual and Goal-directed Behavior\n\n### Summary\n\n## Chapter 15 Neuroscience\n\n### Neuroscience Basics\n\n### Reward Signals, Reinforcement Signals, Values, and Prediction Errors\n\n### The Reward Prediction Error Hypothesis\n\n### Dopamine\n\n### Experimental Support for the Reward Prediction Error Hypothesis\n\n### TD Error/Dopamine Correspondence\n\n### Neural Actor–Critic\n\n### Actor and Critic Learning Rules\n\n### Hedonistic Neurons\n\n### Collective Reinforcement Learning\n\n### Model-based Methods in the Brain\n\n### Addiction\n\n### Summary\n\n## Chapter 16 Applications and Case Studies\n\n### TD-Gammon\n\n### Samuel’s Checkers Player\n\n### Watson’s Daily-Double Wagering\n\n### Optimizing Memory Control\n\n### Human-level Video Game Play\n\n### Mastering the Game of Go\n\n#### AlphaGo\n\n#### AlphaGo Zero\n\n### Personalized Web Services\n\n### Thermal Soaring\n\n## Chapter 17 Frontiers\n\n### General Value Functions and Auxiliary Tasks\n\n### Temporal Abstraction via Options\n\n### Observations and State\n\n### Designing Reward Signals\n\n### Remaining Issues\n\n### The Future of Artiﬁcial Intelligence","source":"_posts/rl-an-introduction.md","raw":"---\ntitle: \"《Reinforcement Learning: An Introduction》阅读笔记\"\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-04-02 21:29:07\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n学习RL至今(2020年04月02日21:30:19)，一直没有系统地看过这本被誉为RL界“圣经”的教科书，也没有对从该书中学到的知识点进行整理与记录，本文将记录重读《Reinforcement Learning: An Introduction》这本书时所学到的关键知识点和受到的启发。\n\n<!--more-->\n\n# Introduction\n\n## Chapter 1 Introduction\n\n### Reinforcement Learning\n\n### Examples\n\n### Elements of Reinforcement Learning\n\n### Limitations and Scope\n\n### An Extended Example: Tic-Tac-Toe\n\n### Summary\n\n### Early History of Reinforcement Learning\n\n# Tabular Solution Methods\n\n## Chapter 2 Multi-armed Bandits\n\n### A k-armed Bandit Problem\n\n### Action-value Methods\n\n### The 10-armed Testbed\n\n### Incremental Implementation\n\n### Tracking a Nonstationary Problem\n\n### Optimistic Initial Values\n\n### Upper-Confidence-Bound ActionSelection\n\n### Gradient Bandit Algorithms\n\n### Associative Search(Contextual Bandits)\n\n### Summary\n\n## Chapter 3 Finite Markov Decision Processes\n\n### The Agent-Environment Interface\n\n### Goals and Rewards\n\n### Returns and Episodes\n\n### Unified Nation for Episodic and Continuing Tasks\n\n### Policies and Value Functions\n\n### Optimial Policies and Optimal Value Functions\n\n### Optimality and Approximation\n\n### Summary\n\n## Chapter 4 Dynamic Programming\n\n### Policy Evaluation(Prediction)\n\n### Policy Improvement\n\n### Policy Iteration\n\n### Value Iteration\n\n### Asynchronous Dynamic Programming\n\n### Generalized Policy Iteration\n\n### Efficiency of Dynamic Programming\n\n### Summary\n\n## Chapter 5 Monte Carlo Methods\n\n### Monte Carlo Prediction\n\n### Monte Carlo Estimation of Action Values\n\n### Monte Carlo Control\n\n### Monte Carlo Control without Exploring Starts\n\n### Off-policy Prediction via Improtance Sampling\n\n### Incremental Implementation\n\n### Off-policy Monte Carlo Control\n\n### Discounting-aware Importance Sampling\n\n### Per-decision Importance Sampling\n\n### Summary\n\n## Chapter 6 Temporal-Difference Learning\n\n### TD Prediction\n\n### Advantages of TD Prediction Methods\n\n### Optimality of TD(0)\n\n### Sarsa: On-policy TD Control\n\n### Q-learning: Off-policy TD Control\n\n### Expected Sarsa\n\n### Maximization Bias and Double Learning\n\n### Games, Afterstates, and Other Special Cases\n\n### Summary\n\n## Chapter 7 n-step Bootstrapping\n\n### n-step TD Prediction\n\n### n-step Sarsa\n\n### n-step Off-policy Learning\n\n### Per-decision Methods with Control Variates\n\n### Off-policy Learning Without Importance Sampling: The n-step Tree Backup Algorithm\n\n### A Unifying Algorithm: n-step $Q(\\sigma)$\n\n### Summary\n\n## Chapter 8 Planning and Learning with Tabular Methods\n\n### Models and Planning\n\n### Dyna: Integrated Planning, Acting, and Learning\n\n### When the Model Is Wrong\n\n### Prioritized Sweeping\n\n### Expected vs. Sample Updates\n\n### Trajectory Sampling\n\n### Real-time Dynamic Programming\n\n### Planning at Decision Time\n\n### Heuristic Search\n\n### Rollout Algorithms\n\n### Monte Carlo Tree Search\n\n### Summary\n\n# Approximate Solution Methods\n\n## Chapter 9 On-policy Prediction with Approximation\n\n### Value-function Approximation\n\n### The Prediction Objective(VE)\n\n### Stochastic-gradient and Semi-gradient Methods\n\n### Linear Methods\n\n### Feature Construction for Linear Methods\n\n#### Polynomials\n\n#### Fourier Basis\n\n#### Coarse Coding\n\n#### Tile Coding\n\n#### Radial Basis Functions\n\n### Selecting Step-size Parameters Manually\n\n### Nonlinear Function Approximation: Artiﬁcial Neural Networks\n\n### Least-Squares TD\n\n### Memory-based Function Approximation\n\n### Kernel-based Function Approximation\n\n### Looking Deeper at On-policy Learning: Interest and Emphasis\n\n### Summary\n\n## Chapter 10 On-policy Control with Approximation\n\n### Episodic Semi-gradient Control\n\n### Semi-gradient n-step Sarsa\n\n### Average Reward: A New Problem Setting for Continuing Tasks\n\n### Deprecating the Discounted Setting\n\n### Differential Semi-gradient n-step Sarsa\n\n### Summary\n\n## Chapter 11 Off-policy Methods with Approximation\n\n### Semi-gradient Methods\n\n### Examples of Off-policy Divergence\n\n### The Deadly Triad\n\n### Linear Value-function Geometry\n\n### Gradient Descent in the Bellman Error\n\n### The Bellman Error is Not Learnable\n\n### Gradient-TD Methods\n\n### Emphatic-TD Methods\n\n### Reducing Variance\n\n### Summary\n\n## Chapter 12 Eligibility Traces\n\n### The $\\lambda$-return\n\n### TD($\\lambda$)\n\n### n-step Truncated $\\lambda$-return Methods\n\n### Redoing Updates: Online $\\lambda$-return Algorithm\n\n### True Online TD($\\lambda$)\n\n### Dutch Traces in Monte Carlo Learning\n\n### Sarsa($\\lambda$)\n\n### Variable $\\lambda$ and $\\gamma$\n\n### Off-policy Traces with Control Variates\n\n### Watkins’s Q($\\lambda$) to Tree-Backup( $\\lambda$)\n\n### Stable Off-policy Methods with Traces\n\n### Implementation Issues\n\n### Conclusions\n\n## Chapter 13 Policy Gradient Methods\n\n### Policy Approximation and its Advantages\n\n### The Policy Gradient Theorem\n\n### REINFORCE: Monte Carlo Policy Gradient\n\n### REINFORCE with Baseline\n\n### Actor–Critic Methods\n\n### Policy Gradient for Continuing Problems\n\n### Policy Parameterization for Continuous Actions\n\n### Summary\n\n# Looking Deeper\n\n## Chapter 14 Psychology\n\n### Prediction and Control\n\n### Classical Conditioning\n\n#### Blocking and Higher-order Conditioning\n\n#### The Rescorla–Wagner Model\n\n#### The TD Model\n\n#### TD Model Simulations\n\n### Instrumental Conditioning\n\n### Delayed Reinforcement\n\n### Cognitive Maps\n\n### Habitual and Goal-directed Behavior\n\n### Summary\n\n## Chapter 15 Neuroscience\n\n### Neuroscience Basics\n\n### Reward Signals, Reinforcement Signals, Values, and Prediction Errors\n\n### The Reward Prediction Error Hypothesis\n\n### Dopamine\n\n### Experimental Support for the Reward Prediction Error Hypothesis\n\n### TD Error/Dopamine Correspondence\n\n### Neural Actor–Critic\n\n### Actor and Critic Learning Rules\n\n### Hedonistic Neurons\n\n### Collective Reinforcement Learning\n\n### Model-based Methods in the Brain\n\n### Addiction\n\n### Summary\n\n## Chapter 16 Applications and Case Studies\n\n### TD-Gammon\n\n### Samuel’s Checkers Player\n\n### Watson’s Daily-Double Wagering\n\n### Optimizing Memory Control\n\n### Human-level Video Game Play\n\n### Mastering the Game of Go\n\n#### AlphaGo\n\n#### AlphaGo Zero\n\n### Personalized Web Services\n\n### Thermal Soaring\n\n## Chapter 17 Frontiers\n\n### General Value Functions and Auxiliary Tasks\n\n### Temporal Abstraction via Options\n\n### Observations and State\n\n### Designing Reward Signals\n\n### Remaining Issues\n\n### The Future of Artiﬁcial Intelligence","slug":"rl-an-introduction","published":1,"updated":"2020-04-08T10:53:25.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusyf001d20cdfuqs3mec","content":"<p>学习RL至今(2020年04月02日21:30:19)，一直没有系统地看过这本被誉为RL界“圣经”的教科书，也没有对从该书中学到的知识点进行整理与记录，本文将记录重读《Reinforcement Learning: An Introduction》这本书时所学到的关键知识点和受到的启发。</p>\n<a id=\"more\"></a>\n<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><h2 id=\"Chapter-1-Introduction\"><a href=\"#Chapter-1-Introduction\" class=\"headerlink\" title=\"Chapter 1 Introduction\"></a>Chapter 1 Introduction</h2><h3 id=\"Reinforcement-Learning\"><a href=\"#Reinforcement-Learning\" class=\"headerlink\" title=\"Reinforcement Learning\"></a>Reinforcement Learning</h3><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h3><h3 id=\"Elements-of-Reinforcement-Learning\"><a href=\"#Elements-of-Reinforcement-Learning\" class=\"headerlink\" title=\"Elements of Reinforcement Learning\"></a>Elements of Reinforcement Learning</h3><h3 id=\"Limitations-and-Scope\"><a href=\"#Limitations-and-Scope\" class=\"headerlink\" title=\"Limitations and Scope\"></a>Limitations and Scope</h3><h3 id=\"An-Extended-Example-Tic-Tac-Toe\"><a href=\"#An-Extended-Example-Tic-Tac-Toe\" class=\"headerlink\" title=\"An Extended Example: Tic-Tac-Toe\"></a>An Extended Example: Tic-Tac-Toe</h3><h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h3 id=\"Early-History-of-Reinforcement-Learning\"><a href=\"#Early-History-of-Reinforcement-Learning\" class=\"headerlink\" title=\"Early History of Reinforcement Learning\"></a>Early History of Reinforcement Learning</h3><h1 id=\"Tabular-Solution-Methods\"><a href=\"#Tabular-Solution-Methods\" class=\"headerlink\" title=\"Tabular Solution Methods\"></a>Tabular Solution Methods</h1><h2 id=\"Chapter-2-Multi-armed-Bandits\"><a href=\"#Chapter-2-Multi-armed-Bandits\" class=\"headerlink\" title=\"Chapter 2 Multi-armed Bandits\"></a>Chapter 2 Multi-armed Bandits</h2><h3 id=\"A-k-armed-Bandit-Problem\"><a href=\"#A-k-armed-Bandit-Problem\" class=\"headerlink\" title=\"A k-armed Bandit Problem\"></a>A k-armed Bandit Problem</h3><h3 id=\"Action-value-Methods\"><a href=\"#Action-value-Methods\" class=\"headerlink\" title=\"Action-value Methods\"></a>Action-value Methods</h3><h3 id=\"The-10-armed-Testbed\"><a href=\"#The-10-armed-Testbed\" class=\"headerlink\" title=\"The 10-armed Testbed\"></a>The 10-armed Testbed</h3><h3 id=\"Incremental-Implementation\"><a href=\"#Incremental-Implementation\" class=\"headerlink\" title=\"Incremental Implementation\"></a>Incremental Implementation</h3><h3 id=\"Tracking-a-Nonstationary-Problem\"><a href=\"#Tracking-a-Nonstationary-Problem\" class=\"headerlink\" title=\"Tracking a Nonstationary Problem\"></a>Tracking a Nonstationary Problem</h3><h3 id=\"Optimistic-Initial-Values\"><a href=\"#Optimistic-Initial-Values\" class=\"headerlink\" title=\"Optimistic Initial Values\"></a>Optimistic Initial Values</h3><h3 id=\"Upper-Confidence-Bound-ActionSelection\"><a href=\"#Upper-Confidence-Bound-ActionSelection\" class=\"headerlink\" title=\"Upper-Confidence-Bound ActionSelection\"></a>Upper-Confidence-Bound ActionSelection</h3><h3 id=\"Gradient-Bandit-Algorithms\"><a href=\"#Gradient-Bandit-Algorithms\" class=\"headerlink\" title=\"Gradient Bandit Algorithms\"></a>Gradient Bandit Algorithms</h3><h3 id=\"Associative-Search-Contextual-Bandits\"><a href=\"#Associative-Search-Contextual-Bandits\" class=\"headerlink\" title=\"Associative Search(Contextual Bandits)\"></a>Associative Search(Contextual Bandits)</h3><h3 id=\"Summary-1\"><a href=\"#Summary-1\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-3-Finite-Markov-Decision-Processes\"><a href=\"#Chapter-3-Finite-Markov-Decision-Processes\" class=\"headerlink\" title=\"Chapter 3 Finite Markov Decision Processes\"></a>Chapter 3 Finite Markov Decision Processes</h2><h3 id=\"The-Agent-Environment-Interface\"><a href=\"#The-Agent-Environment-Interface\" class=\"headerlink\" title=\"The Agent-Environment Interface\"></a>The Agent-Environment Interface</h3><h3 id=\"Goals-and-Rewards\"><a href=\"#Goals-and-Rewards\" class=\"headerlink\" title=\"Goals and Rewards\"></a>Goals and Rewards</h3><h3 id=\"Returns-and-Episodes\"><a href=\"#Returns-and-Episodes\" class=\"headerlink\" title=\"Returns and Episodes\"></a>Returns and Episodes</h3><h3 id=\"Unified-Nation-for-Episodic-and-Continuing-Tasks\"><a href=\"#Unified-Nation-for-Episodic-and-Continuing-Tasks\" class=\"headerlink\" title=\"Unified Nation for Episodic and Continuing Tasks\"></a>Unified Nation for Episodic and Continuing Tasks</h3><h3 id=\"Policies-and-Value-Functions\"><a href=\"#Policies-and-Value-Functions\" class=\"headerlink\" title=\"Policies and Value Functions\"></a>Policies and Value Functions</h3><h3 id=\"Optimial-Policies-and-Optimal-Value-Functions\"><a href=\"#Optimial-Policies-and-Optimal-Value-Functions\" class=\"headerlink\" title=\"Optimial Policies and Optimal Value Functions\"></a>Optimial Policies and Optimal Value Functions</h3><h3 id=\"Optimality-and-Approximation\"><a href=\"#Optimality-and-Approximation\" class=\"headerlink\" title=\"Optimality and Approximation\"></a>Optimality and Approximation</h3><h3 id=\"Summary-2\"><a href=\"#Summary-2\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-4-Dynamic-Programming\"><a href=\"#Chapter-4-Dynamic-Programming\" class=\"headerlink\" title=\"Chapter 4 Dynamic Programming\"></a>Chapter 4 Dynamic Programming</h2><h3 id=\"Policy-Evaluation-Prediction\"><a href=\"#Policy-Evaluation-Prediction\" class=\"headerlink\" title=\"Policy Evaluation(Prediction)\"></a>Policy Evaluation(Prediction)</h3><h3 id=\"Policy-Improvement\"><a href=\"#Policy-Improvement\" class=\"headerlink\" title=\"Policy Improvement\"></a>Policy Improvement</h3><h3 id=\"Policy-Iteration\"><a href=\"#Policy-Iteration\" class=\"headerlink\" title=\"Policy Iteration\"></a>Policy Iteration</h3><h3 id=\"Value-Iteration\"><a href=\"#Value-Iteration\" class=\"headerlink\" title=\"Value Iteration\"></a>Value Iteration</h3><h3 id=\"Asynchronous-Dynamic-Programming\"><a href=\"#Asynchronous-Dynamic-Programming\" class=\"headerlink\" title=\"Asynchronous Dynamic Programming\"></a>Asynchronous Dynamic Programming</h3><h3 id=\"Generalized-Policy-Iteration\"><a href=\"#Generalized-Policy-Iteration\" class=\"headerlink\" title=\"Generalized Policy Iteration\"></a>Generalized Policy Iteration</h3><h3 id=\"Efficiency-of-Dynamic-Programming\"><a href=\"#Efficiency-of-Dynamic-Programming\" class=\"headerlink\" title=\"Efficiency of Dynamic Programming\"></a>Efficiency of Dynamic Programming</h3><h3 id=\"Summary-3\"><a href=\"#Summary-3\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-5-Monte-Carlo-Methods\"><a href=\"#Chapter-5-Monte-Carlo-Methods\" class=\"headerlink\" title=\"Chapter 5 Monte Carlo Methods\"></a>Chapter 5 Monte Carlo Methods</h2><h3 id=\"Monte-Carlo-Prediction\"><a href=\"#Monte-Carlo-Prediction\" class=\"headerlink\" title=\"Monte Carlo Prediction\"></a>Monte Carlo Prediction</h3><h3 id=\"Monte-Carlo-Estimation-of-Action-Values\"><a href=\"#Monte-Carlo-Estimation-of-Action-Values\" class=\"headerlink\" title=\"Monte Carlo Estimation of Action Values\"></a>Monte Carlo Estimation of Action Values</h3><h3 id=\"Monte-Carlo-Control\"><a href=\"#Monte-Carlo-Control\" class=\"headerlink\" title=\"Monte Carlo Control\"></a>Monte Carlo Control</h3><h3 id=\"Monte-Carlo-Control-without-Exploring-Starts\"><a href=\"#Monte-Carlo-Control-without-Exploring-Starts\" class=\"headerlink\" title=\"Monte Carlo Control without Exploring Starts\"></a>Monte Carlo Control without Exploring Starts</h3><h3 id=\"Off-policy-Prediction-via-Improtance-Sampling\"><a href=\"#Off-policy-Prediction-via-Improtance-Sampling\" class=\"headerlink\" title=\"Off-policy Prediction via Improtance Sampling\"></a>Off-policy Prediction via Improtance Sampling</h3><h3 id=\"Incremental-Implementation-1\"><a href=\"#Incremental-Implementation-1\" class=\"headerlink\" title=\"Incremental Implementation\"></a>Incremental Implementation</h3><h3 id=\"Off-policy-Monte-Carlo-Control\"><a href=\"#Off-policy-Monte-Carlo-Control\" class=\"headerlink\" title=\"Off-policy Monte Carlo Control\"></a>Off-policy Monte Carlo Control</h3><h3 id=\"Discounting-aware-Importance-Sampling\"><a href=\"#Discounting-aware-Importance-Sampling\" class=\"headerlink\" title=\"Discounting-aware Importance Sampling\"></a>Discounting-aware Importance Sampling</h3><h3 id=\"Per-decision-Importance-Sampling\"><a href=\"#Per-decision-Importance-Sampling\" class=\"headerlink\" title=\"Per-decision Importance Sampling\"></a>Per-decision Importance Sampling</h3><h3 id=\"Summary-4\"><a href=\"#Summary-4\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-6-Temporal-Difference-Learning\"><a href=\"#Chapter-6-Temporal-Difference-Learning\" class=\"headerlink\" title=\"Chapter 6 Temporal-Difference Learning\"></a>Chapter 6 Temporal-Difference Learning</h2><h3 id=\"TD-Prediction\"><a href=\"#TD-Prediction\" class=\"headerlink\" title=\"TD Prediction\"></a>TD Prediction</h3><h3 id=\"Advantages-of-TD-Prediction-Methods\"><a href=\"#Advantages-of-TD-Prediction-Methods\" class=\"headerlink\" title=\"Advantages of TD Prediction Methods\"></a>Advantages of TD Prediction Methods</h3><h3 id=\"Optimality-of-TD-0\"><a href=\"#Optimality-of-TD-0\" class=\"headerlink\" title=\"Optimality of TD(0)\"></a>Optimality of TD(0)</h3><h3 id=\"Sarsa-On-policy-TD-Control\"><a href=\"#Sarsa-On-policy-TD-Control\" class=\"headerlink\" title=\"Sarsa: On-policy TD Control\"></a>Sarsa: On-policy TD Control</h3><h3 id=\"Q-learning-Off-policy-TD-Control\"><a href=\"#Q-learning-Off-policy-TD-Control\" class=\"headerlink\" title=\"Q-learning: Off-policy TD Control\"></a>Q-learning: Off-policy TD Control</h3><h3 id=\"Expected-Sarsa\"><a href=\"#Expected-Sarsa\" class=\"headerlink\" title=\"Expected Sarsa\"></a>Expected Sarsa</h3><h3 id=\"Maximization-Bias-and-Double-Learning\"><a href=\"#Maximization-Bias-and-Double-Learning\" class=\"headerlink\" title=\"Maximization Bias and Double Learning\"></a>Maximization Bias and Double Learning</h3><h3 id=\"Games-Afterstates-and-Other-Special-Cases\"><a href=\"#Games-Afterstates-and-Other-Special-Cases\" class=\"headerlink\" title=\"Games, Afterstates, and Other Special Cases\"></a>Games, Afterstates, and Other Special Cases</h3><h3 id=\"Summary-5\"><a href=\"#Summary-5\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-7-n-step-Bootstrapping\"><a href=\"#Chapter-7-n-step-Bootstrapping\" class=\"headerlink\" title=\"Chapter 7 n-step Bootstrapping\"></a>Chapter 7 n-step Bootstrapping</h2><h3 id=\"n-step-TD-Prediction\"><a href=\"#n-step-TD-Prediction\" class=\"headerlink\" title=\"n-step TD Prediction\"></a>n-step TD Prediction</h3><h3 id=\"n-step-Sarsa\"><a href=\"#n-step-Sarsa\" class=\"headerlink\" title=\"n-step Sarsa\"></a>n-step Sarsa</h3><h3 id=\"n-step-Off-policy-Learning\"><a href=\"#n-step-Off-policy-Learning\" class=\"headerlink\" title=\"n-step Off-policy Learning\"></a>n-step Off-policy Learning</h3><h3 id=\"Per-decision-Methods-with-Control-Variates\"><a href=\"#Per-decision-Methods-with-Control-Variates\" class=\"headerlink\" title=\"Per-decision Methods with Control Variates\"></a>Per-decision Methods with Control Variates</h3><h3 id=\"Off-policy-Learning-Without-Importance-Sampling-The-n-step-Tree-Backup-Algorithm\"><a href=\"#Off-policy-Learning-Without-Importance-Sampling-The-n-step-Tree-Backup-Algorithm\" class=\"headerlink\" title=\"Off-policy Learning Without Importance Sampling: The n-step Tree Backup Algorithm\"></a>Off-policy Learning Without Importance Sampling: The n-step Tree Backup Algorithm</h3><h3 id=\"A-Unifying-Algorithm-n-step-Q-sigma\"><a href=\"#A-Unifying-Algorithm-n-step-Q-sigma\" class=\"headerlink\" title=\"A Unifying Algorithm: n-step $Q(\\sigma)$\"></a>A Unifying Algorithm: n-step $Q(\\sigma)$</h3><h3 id=\"Summary-6\"><a href=\"#Summary-6\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-8-Planning-and-Learning-with-Tabular-Methods\"><a href=\"#Chapter-8-Planning-and-Learning-with-Tabular-Methods\" class=\"headerlink\" title=\"Chapter 8 Planning and Learning with Tabular Methods\"></a>Chapter 8 Planning and Learning with Tabular Methods</h2><h3 id=\"Models-and-Planning\"><a href=\"#Models-and-Planning\" class=\"headerlink\" title=\"Models and Planning\"></a>Models and Planning</h3><h3 id=\"Dyna-Integrated-Planning-Acting-and-Learning\"><a href=\"#Dyna-Integrated-Planning-Acting-and-Learning\" class=\"headerlink\" title=\"Dyna: Integrated Planning, Acting, and Learning\"></a>Dyna: Integrated Planning, Acting, and Learning</h3><h3 id=\"When-the-Model-Is-Wrong\"><a href=\"#When-the-Model-Is-Wrong\" class=\"headerlink\" title=\"When the Model Is Wrong\"></a>When the Model Is Wrong</h3><h3 id=\"Prioritized-Sweeping\"><a href=\"#Prioritized-Sweeping\" class=\"headerlink\" title=\"Prioritized Sweeping\"></a>Prioritized Sweeping</h3><h3 id=\"Expected-vs-Sample-Updates\"><a href=\"#Expected-vs-Sample-Updates\" class=\"headerlink\" title=\"Expected vs. Sample Updates\"></a>Expected vs. Sample Updates</h3><h3 id=\"Trajectory-Sampling\"><a href=\"#Trajectory-Sampling\" class=\"headerlink\" title=\"Trajectory Sampling\"></a>Trajectory Sampling</h3><h3 id=\"Real-time-Dynamic-Programming\"><a href=\"#Real-time-Dynamic-Programming\" class=\"headerlink\" title=\"Real-time Dynamic Programming\"></a>Real-time Dynamic Programming</h3><h3 id=\"Planning-at-Decision-Time\"><a href=\"#Planning-at-Decision-Time\" class=\"headerlink\" title=\"Planning at Decision Time\"></a>Planning at Decision Time</h3><h3 id=\"Heuristic-Search\"><a href=\"#Heuristic-Search\" class=\"headerlink\" title=\"Heuristic Search\"></a>Heuristic Search</h3><h3 id=\"Rollout-Algorithms\"><a href=\"#Rollout-Algorithms\" class=\"headerlink\" title=\"Rollout Algorithms\"></a>Rollout Algorithms</h3><h3 id=\"Monte-Carlo-Tree-Search\"><a href=\"#Monte-Carlo-Tree-Search\" class=\"headerlink\" title=\"Monte Carlo Tree Search\"></a>Monte Carlo Tree Search</h3><h3 id=\"Summary-7\"><a href=\"#Summary-7\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h1 id=\"Approximate-Solution-Methods\"><a href=\"#Approximate-Solution-Methods\" class=\"headerlink\" title=\"Approximate Solution Methods\"></a>Approximate Solution Methods</h1><h2 id=\"Chapter-9-On-policy-Prediction-with-Approximation\"><a href=\"#Chapter-9-On-policy-Prediction-with-Approximation\" class=\"headerlink\" title=\"Chapter 9 On-policy Prediction with Approximation\"></a>Chapter 9 On-policy Prediction with Approximation</h2><h3 id=\"Value-function-Approximation\"><a href=\"#Value-function-Approximation\" class=\"headerlink\" title=\"Value-function Approximation\"></a>Value-function Approximation</h3><h3 id=\"The-Prediction-Objective-VE\"><a href=\"#The-Prediction-Objective-VE\" class=\"headerlink\" title=\"The Prediction Objective(VE)\"></a>The Prediction Objective(VE)</h3><h3 id=\"Stochastic-gradient-and-Semi-gradient-Methods\"><a href=\"#Stochastic-gradient-and-Semi-gradient-Methods\" class=\"headerlink\" title=\"Stochastic-gradient and Semi-gradient Methods\"></a>Stochastic-gradient and Semi-gradient Methods</h3><h3 id=\"Linear-Methods\"><a href=\"#Linear-Methods\" class=\"headerlink\" title=\"Linear Methods\"></a>Linear Methods</h3><h3 id=\"Feature-Construction-for-Linear-Methods\"><a href=\"#Feature-Construction-for-Linear-Methods\" class=\"headerlink\" title=\"Feature Construction for Linear Methods\"></a>Feature Construction for Linear Methods</h3><h4 id=\"Polynomials\"><a href=\"#Polynomials\" class=\"headerlink\" title=\"Polynomials\"></a>Polynomials</h4><h4 id=\"Fourier-Basis\"><a href=\"#Fourier-Basis\" class=\"headerlink\" title=\"Fourier Basis\"></a>Fourier Basis</h4><h4 id=\"Coarse-Coding\"><a href=\"#Coarse-Coding\" class=\"headerlink\" title=\"Coarse Coding\"></a>Coarse Coding</h4><h4 id=\"Tile-Coding\"><a href=\"#Tile-Coding\" class=\"headerlink\" title=\"Tile Coding\"></a>Tile Coding</h4><h4 id=\"Radial-Basis-Functions\"><a href=\"#Radial-Basis-Functions\" class=\"headerlink\" title=\"Radial Basis Functions\"></a>Radial Basis Functions</h4><h3 id=\"Selecting-Step-size-Parameters-Manually\"><a href=\"#Selecting-Step-size-Parameters-Manually\" class=\"headerlink\" title=\"Selecting Step-size Parameters Manually\"></a>Selecting Step-size Parameters Manually</h3><h3 id=\"Nonlinear-Function-Approximation-Artiﬁcial-Neural-Networks\"><a href=\"#Nonlinear-Function-Approximation-Artiﬁcial-Neural-Networks\" class=\"headerlink\" title=\"Nonlinear Function Approximation: Artiﬁcial Neural Networks\"></a>Nonlinear Function Approximation: Artiﬁcial Neural Networks</h3><h3 id=\"Least-Squares-TD\"><a href=\"#Least-Squares-TD\" class=\"headerlink\" title=\"Least-Squares TD\"></a>Least-Squares TD</h3><h3 id=\"Memory-based-Function-Approximation\"><a href=\"#Memory-based-Function-Approximation\" class=\"headerlink\" title=\"Memory-based Function Approximation\"></a>Memory-based Function Approximation</h3><h3 id=\"Kernel-based-Function-Approximation\"><a href=\"#Kernel-based-Function-Approximation\" class=\"headerlink\" title=\"Kernel-based Function Approximation\"></a>Kernel-based Function Approximation</h3><h3 id=\"Looking-Deeper-at-On-policy-Learning-Interest-and-Emphasis\"><a href=\"#Looking-Deeper-at-On-policy-Learning-Interest-and-Emphasis\" class=\"headerlink\" title=\"Looking Deeper at On-policy Learning: Interest and Emphasis\"></a>Looking Deeper at On-policy Learning: Interest and Emphasis</h3><h3 id=\"Summary-8\"><a href=\"#Summary-8\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-10-On-policy-Control-with-Approximation\"><a href=\"#Chapter-10-On-policy-Control-with-Approximation\" class=\"headerlink\" title=\"Chapter 10 On-policy Control with Approximation\"></a>Chapter 10 On-policy Control with Approximation</h2><h3 id=\"Episodic-Semi-gradient-Control\"><a href=\"#Episodic-Semi-gradient-Control\" class=\"headerlink\" title=\"Episodic Semi-gradient Control\"></a>Episodic Semi-gradient Control</h3><h3 id=\"Semi-gradient-n-step-Sarsa\"><a href=\"#Semi-gradient-n-step-Sarsa\" class=\"headerlink\" title=\"Semi-gradient n-step Sarsa\"></a>Semi-gradient n-step Sarsa</h3><h3 id=\"Average-Reward-A-New-Problem-Setting-for-Continuing-Tasks\"><a href=\"#Average-Reward-A-New-Problem-Setting-for-Continuing-Tasks\" class=\"headerlink\" title=\"Average Reward: A New Problem Setting for Continuing Tasks\"></a>Average Reward: A New Problem Setting for Continuing Tasks</h3><h3 id=\"Deprecating-the-Discounted-Setting\"><a href=\"#Deprecating-the-Discounted-Setting\" class=\"headerlink\" title=\"Deprecating the Discounted Setting\"></a>Deprecating the Discounted Setting</h3><h3 id=\"Differential-Semi-gradient-n-step-Sarsa\"><a href=\"#Differential-Semi-gradient-n-step-Sarsa\" class=\"headerlink\" title=\"Differential Semi-gradient n-step Sarsa\"></a>Differential Semi-gradient n-step Sarsa</h3><h3 id=\"Summary-9\"><a href=\"#Summary-9\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-11-Off-policy-Methods-with-Approximation\"><a href=\"#Chapter-11-Off-policy-Methods-with-Approximation\" class=\"headerlink\" title=\"Chapter 11 Off-policy Methods with Approximation\"></a>Chapter 11 Off-policy Methods with Approximation</h2><h3 id=\"Semi-gradient-Methods\"><a href=\"#Semi-gradient-Methods\" class=\"headerlink\" title=\"Semi-gradient Methods\"></a>Semi-gradient Methods</h3><h3 id=\"Examples-of-Off-policy-Divergence\"><a href=\"#Examples-of-Off-policy-Divergence\" class=\"headerlink\" title=\"Examples of Off-policy Divergence\"></a>Examples of Off-policy Divergence</h3><h3 id=\"The-Deadly-Triad\"><a href=\"#The-Deadly-Triad\" class=\"headerlink\" title=\"The Deadly Triad\"></a>The Deadly Triad</h3><h3 id=\"Linear-Value-function-Geometry\"><a href=\"#Linear-Value-function-Geometry\" class=\"headerlink\" title=\"Linear Value-function Geometry\"></a>Linear Value-function Geometry</h3><h3 id=\"Gradient-Descent-in-the-Bellman-Error\"><a href=\"#Gradient-Descent-in-the-Bellman-Error\" class=\"headerlink\" title=\"Gradient Descent in the Bellman Error\"></a>Gradient Descent in the Bellman Error</h3><h3 id=\"The-Bellman-Error-is-Not-Learnable\"><a href=\"#The-Bellman-Error-is-Not-Learnable\" class=\"headerlink\" title=\"The Bellman Error is Not Learnable\"></a>The Bellman Error is Not Learnable</h3><h3 id=\"Gradient-TD-Methods\"><a href=\"#Gradient-TD-Methods\" class=\"headerlink\" title=\"Gradient-TD Methods\"></a>Gradient-TD Methods</h3><h3 id=\"Emphatic-TD-Methods\"><a href=\"#Emphatic-TD-Methods\" class=\"headerlink\" title=\"Emphatic-TD Methods\"></a>Emphatic-TD Methods</h3><h3 id=\"Reducing-Variance\"><a href=\"#Reducing-Variance\" class=\"headerlink\" title=\"Reducing Variance\"></a>Reducing Variance</h3><h3 id=\"Summary-10\"><a href=\"#Summary-10\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-12-Eligibility-Traces\"><a href=\"#Chapter-12-Eligibility-Traces\" class=\"headerlink\" title=\"Chapter 12 Eligibility Traces\"></a>Chapter 12 Eligibility Traces</h2><h3 id=\"The-lambda-return\"><a href=\"#The-lambda-return\" class=\"headerlink\" title=\"The $\\lambda$-return\"></a>The $\\lambda$-return</h3><h3 id=\"TD-lambda\"><a href=\"#TD-lambda\" class=\"headerlink\" title=\"TD($\\lambda$)\"></a>TD($\\lambda$)</h3><h3 id=\"n-step-Truncated-lambda-return-Methods\"><a href=\"#n-step-Truncated-lambda-return-Methods\" class=\"headerlink\" title=\"n-step Truncated $\\lambda$-return Methods\"></a>n-step Truncated $\\lambda$-return Methods</h3><h3 id=\"Redoing-Updates-Online-lambda-return-Algorithm\"><a href=\"#Redoing-Updates-Online-lambda-return-Algorithm\" class=\"headerlink\" title=\"Redoing Updates: Online $\\lambda$-return Algorithm\"></a>Redoing Updates: Online $\\lambda$-return Algorithm</h3><h3 id=\"True-Online-TD-lambda\"><a href=\"#True-Online-TD-lambda\" class=\"headerlink\" title=\"True Online TD($\\lambda$)\"></a>True Online TD($\\lambda$)</h3><h3 id=\"Dutch-Traces-in-Monte-Carlo-Learning\"><a href=\"#Dutch-Traces-in-Monte-Carlo-Learning\" class=\"headerlink\" title=\"Dutch Traces in Monte Carlo Learning\"></a>Dutch Traces in Monte Carlo Learning</h3><h3 id=\"Sarsa-lambda\"><a href=\"#Sarsa-lambda\" class=\"headerlink\" title=\"Sarsa($\\lambda$)\"></a>Sarsa($\\lambda$)</h3><h3 id=\"Variable-lambda-and-gamma\"><a href=\"#Variable-lambda-and-gamma\" class=\"headerlink\" title=\"Variable $\\lambda$ and $\\gamma$\"></a>Variable $\\lambda$ and $\\gamma$</h3><h3 id=\"Off-policy-Traces-with-Control-Variates\"><a href=\"#Off-policy-Traces-with-Control-Variates\" class=\"headerlink\" title=\"Off-policy Traces with Control Variates\"></a>Off-policy Traces with Control Variates</h3><h3 id=\"Watkins’s-Q-lambda-to-Tree-Backup-lambda\"><a href=\"#Watkins’s-Q-lambda-to-Tree-Backup-lambda\" class=\"headerlink\" title=\"Watkins’s Q($\\lambda$) to Tree-Backup( $\\lambda$)\"></a>Watkins’s Q($\\lambda$) to Tree-Backup( $\\lambda$)</h3><h3 id=\"Stable-Off-policy-Methods-with-Traces\"><a href=\"#Stable-Off-policy-Methods-with-Traces\" class=\"headerlink\" title=\"Stable Off-policy Methods with Traces\"></a>Stable Off-policy Methods with Traces</h3><h3 id=\"Implementation-Issues\"><a href=\"#Implementation-Issues\" class=\"headerlink\" title=\"Implementation Issues\"></a>Implementation Issues</h3><h3 id=\"Conclusions\"><a href=\"#Conclusions\" class=\"headerlink\" title=\"Conclusions\"></a>Conclusions</h3><h2 id=\"Chapter-13-Policy-Gradient-Methods\"><a href=\"#Chapter-13-Policy-Gradient-Methods\" class=\"headerlink\" title=\"Chapter 13 Policy Gradient Methods\"></a>Chapter 13 Policy Gradient Methods</h2><h3 id=\"Policy-Approximation-and-its-Advantages\"><a href=\"#Policy-Approximation-and-its-Advantages\" class=\"headerlink\" title=\"Policy Approximation and its Advantages\"></a>Policy Approximation and its Advantages</h3><h3 id=\"The-Policy-Gradient-Theorem\"><a href=\"#The-Policy-Gradient-Theorem\" class=\"headerlink\" title=\"The Policy Gradient Theorem\"></a>The Policy Gradient Theorem</h3><h3 id=\"REINFORCE-Monte-Carlo-Policy-Gradient\"><a href=\"#REINFORCE-Monte-Carlo-Policy-Gradient\" class=\"headerlink\" title=\"REINFORCE: Monte Carlo Policy Gradient\"></a>REINFORCE: Monte Carlo Policy Gradient</h3><h3 id=\"REINFORCE-with-Baseline\"><a href=\"#REINFORCE-with-Baseline\" class=\"headerlink\" title=\"REINFORCE with Baseline\"></a>REINFORCE with Baseline</h3><h3 id=\"Actor–Critic-Methods\"><a href=\"#Actor–Critic-Methods\" class=\"headerlink\" title=\"Actor–Critic Methods\"></a>Actor–Critic Methods</h3><h3 id=\"Policy-Gradient-for-Continuing-Problems\"><a href=\"#Policy-Gradient-for-Continuing-Problems\" class=\"headerlink\" title=\"Policy Gradient for Continuing Problems\"></a>Policy Gradient for Continuing Problems</h3><h3 id=\"Policy-Parameterization-for-Continuous-Actions\"><a href=\"#Policy-Parameterization-for-Continuous-Actions\" class=\"headerlink\" title=\"Policy Parameterization for Continuous Actions\"></a>Policy Parameterization for Continuous Actions</h3><h3 id=\"Summary-11\"><a href=\"#Summary-11\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h1 id=\"Looking-Deeper\"><a href=\"#Looking-Deeper\" class=\"headerlink\" title=\"Looking Deeper\"></a>Looking Deeper</h1><h2 id=\"Chapter-14-Psychology\"><a href=\"#Chapter-14-Psychology\" class=\"headerlink\" title=\"Chapter 14 Psychology\"></a>Chapter 14 Psychology</h2><h3 id=\"Prediction-and-Control\"><a href=\"#Prediction-and-Control\" class=\"headerlink\" title=\"Prediction and Control\"></a>Prediction and Control</h3><h3 id=\"Classical-Conditioning\"><a href=\"#Classical-Conditioning\" class=\"headerlink\" title=\"Classical Conditioning\"></a>Classical Conditioning</h3><h4 id=\"Blocking-and-Higher-order-Conditioning\"><a href=\"#Blocking-and-Higher-order-Conditioning\" class=\"headerlink\" title=\"Blocking and Higher-order Conditioning\"></a>Blocking and Higher-order Conditioning</h4><h4 id=\"The-Rescorla–Wagner-Model\"><a href=\"#The-Rescorla–Wagner-Model\" class=\"headerlink\" title=\"The Rescorla–Wagner Model\"></a>The Rescorla–Wagner Model</h4><h4 id=\"The-TD-Model\"><a href=\"#The-TD-Model\" class=\"headerlink\" title=\"The TD Model\"></a>The TD Model</h4><h4 id=\"TD-Model-Simulations\"><a href=\"#TD-Model-Simulations\" class=\"headerlink\" title=\"TD Model Simulations\"></a>TD Model Simulations</h4><h3 id=\"Instrumental-Conditioning\"><a href=\"#Instrumental-Conditioning\" class=\"headerlink\" title=\"Instrumental Conditioning\"></a>Instrumental Conditioning</h3><h3 id=\"Delayed-Reinforcement\"><a href=\"#Delayed-Reinforcement\" class=\"headerlink\" title=\"Delayed Reinforcement\"></a>Delayed Reinforcement</h3><h3 id=\"Cognitive-Maps\"><a href=\"#Cognitive-Maps\" class=\"headerlink\" title=\"Cognitive Maps\"></a>Cognitive Maps</h3><h3 id=\"Habitual-and-Goal-directed-Behavior\"><a href=\"#Habitual-and-Goal-directed-Behavior\" class=\"headerlink\" title=\"Habitual and Goal-directed Behavior\"></a>Habitual and Goal-directed Behavior</h3><h3 id=\"Summary-12\"><a href=\"#Summary-12\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-15-Neuroscience\"><a href=\"#Chapter-15-Neuroscience\" class=\"headerlink\" title=\"Chapter 15 Neuroscience\"></a>Chapter 15 Neuroscience</h2><h3 id=\"Neuroscience-Basics\"><a href=\"#Neuroscience-Basics\" class=\"headerlink\" title=\"Neuroscience Basics\"></a>Neuroscience Basics</h3><h3 id=\"Reward-Signals-Reinforcement-Signals-Values-and-Prediction-Errors\"><a href=\"#Reward-Signals-Reinforcement-Signals-Values-and-Prediction-Errors\" class=\"headerlink\" title=\"Reward Signals, Reinforcement Signals, Values, and Prediction Errors\"></a>Reward Signals, Reinforcement Signals, Values, and Prediction Errors</h3><h3 id=\"The-Reward-Prediction-Error-Hypothesis\"><a href=\"#The-Reward-Prediction-Error-Hypothesis\" class=\"headerlink\" title=\"The Reward Prediction Error Hypothesis\"></a>The Reward Prediction Error Hypothesis</h3><h3 id=\"Dopamine\"><a href=\"#Dopamine\" class=\"headerlink\" title=\"Dopamine\"></a>Dopamine</h3><h3 id=\"Experimental-Support-for-the-Reward-Prediction-Error-Hypothesis\"><a href=\"#Experimental-Support-for-the-Reward-Prediction-Error-Hypothesis\" class=\"headerlink\" title=\"Experimental Support for the Reward Prediction Error Hypothesis\"></a>Experimental Support for the Reward Prediction Error Hypothesis</h3><h3 id=\"TD-Error-Dopamine-Correspondence\"><a href=\"#TD-Error-Dopamine-Correspondence\" class=\"headerlink\" title=\"TD Error/Dopamine Correspondence\"></a>TD Error/Dopamine Correspondence</h3><h3 id=\"Neural-Actor–Critic\"><a href=\"#Neural-Actor–Critic\" class=\"headerlink\" title=\"Neural Actor–Critic\"></a>Neural Actor–Critic</h3><h3 id=\"Actor-and-Critic-Learning-Rules\"><a href=\"#Actor-and-Critic-Learning-Rules\" class=\"headerlink\" title=\"Actor and Critic Learning Rules\"></a>Actor and Critic Learning Rules</h3><h3 id=\"Hedonistic-Neurons\"><a href=\"#Hedonistic-Neurons\" class=\"headerlink\" title=\"Hedonistic Neurons\"></a>Hedonistic Neurons</h3><h3 id=\"Collective-Reinforcement-Learning\"><a href=\"#Collective-Reinforcement-Learning\" class=\"headerlink\" title=\"Collective Reinforcement Learning\"></a>Collective Reinforcement Learning</h3><h3 id=\"Model-based-Methods-in-the-Brain\"><a href=\"#Model-based-Methods-in-the-Brain\" class=\"headerlink\" title=\"Model-based Methods in the Brain\"></a>Model-based Methods in the Brain</h3><h3 id=\"Addiction\"><a href=\"#Addiction\" class=\"headerlink\" title=\"Addiction\"></a>Addiction</h3><h3 id=\"Summary-13\"><a href=\"#Summary-13\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-16-Applications-and-Case-Studies\"><a href=\"#Chapter-16-Applications-and-Case-Studies\" class=\"headerlink\" title=\"Chapter 16 Applications and Case Studies\"></a>Chapter 16 Applications and Case Studies</h2><h3 id=\"TD-Gammon\"><a href=\"#TD-Gammon\" class=\"headerlink\" title=\"TD-Gammon\"></a>TD-Gammon</h3><h3 id=\"Samuel’s-Checkers-Player\"><a href=\"#Samuel’s-Checkers-Player\" class=\"headerlink\" title=\"Samuel’s Checkers Player\"></a>Samuel’s Checkers Player</h3><h3 id=\"Watson’s-Daily-Double-Wagering\"><a href=\"#Watson’s-Daily-Double-Wagering\" class=\"headerlink\" title=\"Watson’s Daily-Double Wagering\"></a>Watson’s Daily-Double Wagering</h3><h3 id=\"Optimizing-Memory-Control\"><a href=\"#Optimizing-Memory-Control\" class=\"headerlink\" title=\"Optimizing Memory Control\"></a>Optimizing Memory Control</h3><h3 id=\"Human-level-Video-Game-Play\"><a href=\"#Human-level-Video-Game-Play\" class=\"headerlink\" title=\"Human-level Video Game Play\"></a>Human-level Video Game Play</h3><h3 id=\"Mastering-the-Game-of-Go\"><a href=\"#Mastering-the-Game-of-Go\" class=\"headerlink\" title=\"Mastering the Game of Go\"></a>Mastering the Game of Go</h3><h4 id=\"AlphaGo\"><a href=\"#AlphaGo\" class=\"headerlink\" title=\"AlphaGo\"></a>AlphaGo</h4><h4 id=\"AlphaGo-Zero\"><a href=\"#AlphaGo-Zero\" class=\"headerlink\" title=\"AlphaGo Zero\"></a>AlphaGo Zero</h4><h3 id=\"Personalized-Web-Services\"><a href=\"#Personalized-Web-Services\" class=\"headerlink\" title=\"Personalized Web Services\"></a>Personalized Web Services</h3><h3 id=\"Thermal-Soaring\"><a href=\"#Thermal-Soaring\" class=\"headerlink\" title=\"Thermal Soaring\"></a>Thermal Soaring</h3><h2 id=\"Chapter-17-Frontiers\"><a href=\"#Chapter-17-Frontiers\" class=\"headerlink\" title=\"Chapter 17 Frontiers\"></a>Chapter 17 Frontiers</h2><h3 id=\"General-Value-Functions-and-Auxiliary-Tasks\"><a href=\"#General-Value-Functions-and-Auxiliary-Tasks\" class=\"headerlink\" title=\"General Value Functions and Auxiliary Tasks\"></a>General Value Functions and Auxiliary Tasks</h3><h3 id=\"Temporal-Abstraction-via-Options\"><a href=\"#Temporal-Abstraction-via-Options\" class=\"headerlink\" title=\"Temporal Abstraction via Options\"></a>Temporal Abstraction via Options</h3><h3 id=\"Observations-and-State\"><a href=\"#Observations-and-State\" class=\"headerlink\" title=\"Observations and State\"></a>Observations and State</h3><h3 id=\"Designing-Reward-Signals\"><a href=\"#Designing-Reward-Signals\" class=\"headerlink\" title=\"Designing Reward Signals\"></a>Designing Reward Signals</h3><h3 id=\"Remaining-Issues\"><a href=\"#Remaining-Issues\" class=\"headerlink\" title=\"Remaining Issues\"></a>Remaining Issues</h3><h3 id=\"The-Future-of-Artiﬁcial-Intelligence\"><a href=\"#The-Future-of-Artiﬁcial-Intelligence\" class=\"headerlink\" title=\"The Future of Artiﬁcial Intelligence\"></a>The Future of Artiﬁcial Intelligence</h3>","site":{"data":{}},"excerpt":"<p>学习RL至今(2020年04月02日21:30:19)，一直没有系统地看过这本被誉为RL界“圣经”的教科书，也没有对从该书中学到的知识点进行整理与记录，本文将记录重读《Reinforcement Learning: An Introduction》这本书时所学到的关键知识点和受到的启发。</p>","more":"<h1 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h1><h2 id=\"Chapter-1-Introduction\"><a href=\"#Chapter-1-Introduction\" class=\"headerlink\" title=\"Chapter 1 Introduction\"></a>Chapter 1 Introduction</h2><h3 id=\"Reinforcement-Learning\"><a href=\"#Reinforcement-Learning\" class=\"headerlink\" title=\"Reinforcement Learning\"></a>Reinforcement Learning</h3><h3 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h3><h3 id=\"Elements-of-Reinforcement-Learning\"><a href=\"#Elements-of-Reinforcement-Learning\" class=\"headerlink\" title=\"Elements of Reinforcement Learning\"></a>Elements of Reinforcement Learning</h3><h3 id=\"Limitations-and-Scope\"><a href=\"#Limitations-and-Scope\" class=\"headerlink\" title=\"Limitations and Scope\"></a>Limitations and Scope</h3><h3 id=\"An-Extended-Example-Tic-Tac-Toe\"><a href=\"#An-Extended-Example-Tic-Tac-Toe\" class=\"headerlink\" title=\"An Extended Example: Tic-Tac-Toe\"></a>An Extended Example: Tic-Tac-Toe</h3><h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h3 id=\"Early-History-of-Reinforcement-Learning\"><a href=\"#Early-History-of-Reinforcement-Learning\" class=\"headerlink\" title=\"Early History of Reinforcement Learning\"></a>Early History of Reinforcement Learning</h3><h1 id=\"Tabular-Solution-Methods\"><a href=\"#Tabular-Solution-Methods\" class=\"headerlink\" title=\"Tabular Solution Methods\"></a>Tabular Solution Methods</h1><h2 id=\"Chapter-2-Multi-armed-Bandits\"><a href=\"#Chapter-2-Multi-armed-Bandits\" class=\"headerlink\" title=\"Chapter 2 Multi-armed Bandits\"></a>Chapter 2 Multi-armed Bandits</h2><h3 id=\"A-k-armed-Bandit-Problem\"><a href=\"#A-k-armed-Bandit-Problem\" class=\"headerlink\" title=\"A k-armed Bandit Problem\"></a>A k-armed Bandit Problem</h3><h3 id=\"Action-value-Methods\"><a href=\"#Action-value-Methods\" class=\"headerlink\" title=\"Action-value Methods\"></a>Action-value Methods</h3><h3 id=\"The-10-armed-Testbed\"><a href=\"#The-10-armed-Testbed\" class=\"headerlink\" title=\"The 10-armed Testbed\"></a>The 10-armed Testbed</h3><h3 id=\"Incremental-Implementation\"><a href=\"#Incremental-Implementation\" class=\"headerlink\" title=\"Incremental Implementation\"></a>Incremental Implementation</h3><h3 id=\"Tracking-a-Nonstationary-Problem\"><a href=\"#Tracking-a-Nonstationary-Problem\" class=\"headerlink\" title=\"Tracking a Nonstationary Problem\"></a>Tracking a Nonstationary Problem</h3><h3 id=\"Optimistic-Initial-Values\"><a href=\"#Optimistic-Initial-Values\" class=\"headerlink\" title=\"Optimistic Initial Values\"></a>Optimistic Initial Values</h3><h3 id=\"Upper-Confidence-Bound-ActionSelection\"><a href=\"#Upper-Confidence-Bound-ActionSelection\" class=\"headerlink\" title=\"Upper-Confidence-Bound ActionSelection\"></a>Upper-Confidence-Bound ActionSelection</h3><h3 id=\"Gradient-Bandit-Algorithms\"><a href=\"#Gradient-Bandit-Algorithms\" class=\"headerlink\" title=\"Gradient Bandit Algorithms\"></a>Gradient Bandit Algorithms</h3><h3 id=\"Associative-Search-Contextual-Bandits\"><a href=\"#Associative-Search-Contextual-Bandits\" class=\"headerlink\" title=\"Associative Search(Contextual Bandits)\"></a>Associative Search(Contextual Bandits)</h3><h3 id=\"Summary-1\"><a href=\"#Summary-1\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-3-Finite-Markov-Decision-Processes\"><a href=\"#Chapter-3-Finite-Markov-Decision-Processes\" class=\"headerlink\" title=\"Chapter 3 Finite Markov Decision Processes\"></a>Chapter 3 Finite Markov Decision Processes</h2><h3 id=\"The-Agent-Environment-Interface\"><a href=\"#The-Agent-Environment-Interface\" class=\"headerlink\" title=\"The Agent-Environment Interface\"></a>The Agent-Environment Interface</h3><h3 id=\"Goals-and-Rewards\"><a href=\"#Goals-and-Rewards\" class=\"headerlink\" title=\"Goals and Rewards\"></a>Goals and Rewards</h3><h3 id=\"Returns-and-Episodes\"><a href=\"#Returns-and-Episodes\" class=\"headerlink\" title=\"Returns and Episodes\"></a>Returns and Episodes</h3><h3 id=\"Unified-Nation-for-Episodic-and-Continuing-Tasks\"><a href=\"#Unified-Nation-for-Episodic-and-Continuing-Tasks\" class=\"headerlink\" title=\"Unified Nation for Episodic and Continuing Tasks\"></a>Unified Nation for Episodic and Continuing Tasks</h3><h3 id=\"Policies-and-Value-Functions\"><a href=\"#Policies-and-Value-Functions\" class=\"headerlink\" title=\"Policies and Value Functions\"></a>Policies and Value Functions</h3><h3 id=\"Optimial-Policies-and-Optimal-Value-Functions\"><a href=\"#Optimial-Policies-and-Optimal-Value-Functions\" class=\"headerlink\" title=\"Optimial Policies and Optimal Value Functions\"></a>Optimial Policies and Optimal Value Functions</h3><h3 id=\"Optimality-and-Approximation\"><a href=\"#Optimality-and-Approximation\" class=\"headerlink\" title=\"Optimality and Approximation\"></a>Optimality and Approximation</h3><h3 id=\"Summary-2\"><a href=\"#Summary-2\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-4-Dynamic-Programming\"><a href=\"#Chapter-4-Dynamic-Programming\" class=\"headerlink\" title=\"Chapter 4 Dynamic Programming\"></a>Chapter 4 Dynamic Programming</h2><h3 id=\"Policy-Evaluation-Prediction\"><a href=\"#Policy-Evaluation-Prediction\" class=\"headerlink\" title=\"Policy Evaluation(Prediction)\"></a>Policy Evaluation(Prediction)</h3><h3 id=\"Policy-Improvement\"><a href=\"#Policy-Improvement\" class=\"headerlink\" title=\"Policy Improvement\"></a>Policy Improvement</h3><h3 id=\"Policy-Iteration\"><a href=\"#Policy-Iteration\" class=\"headerlink\" title=\"Policy Iteration\"></a>Policy Iteration</h3><h3 id=\"Value-Iteration\"><a href=\"#Value-Iteration\" class=\"headerlink\" title=\"Value Iteration\"></a>Value Iteration</h3><h3 id=\"Asynchronous-Dynamic-Programming\"><a href=\"#Asynchronous-Dynamic-Programming\" class=\"headerlink\" title=\"Asynchronous Dynamic Programming\"></a>Asynchronous Dynamic Programming</h3><h3 id=\"Generalized-Policy-Iteration\"><a href=\"#Generalized-Policy-Iteration\" class=\"headerlink\" title=\"Generalized Policy Iteration\"></a>Generalized Policy Iteration</h3><h3 id=\"Efficiency-of-Dynamic-Programming\"><a href=\"#Efficiency-of-Dynamic-Programming\" class=\"headerlink\" title=\"Efficiency of Dynamic Programming\"></a>Efficiency of Dynamic Programming</h3><h3 id=\"Summary-3\"><a href=\"#Summary-3\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-5-Monte-Carlo-Methods\"><a href=\"#Chapter-5-Monte-Carlo-Methods\" class=\"headerlink\" title=\"Chapter 5 Monte Carlo Methods\"></a>Chapter 5 Monte Carlo Methods</h2><h3 id=\"Monte-Carlo-Prediction\"><a href=\"#Monte-Carlo-Prediction\" class=\"headerlink\" title=\"Monte Carlo Prediction\"></a>Monte Carlo Prediction</h3><h3 id=\"Monte-Carlo-Estimation-of-Action-Values\"><a href=\"#Monte-Carlo-Estimation-of-Action-Values\" class=\"headerlink\" title=\"Monte Carlo Estimation of Action Values\"></a>Monte Carlo Estimation of Action Values</h3><h3 id=\"Monte-Carlo-Control\"><a href=\"#Monte-Carlo-Control\" class=\"headerlink\" title=\"Monte Carlo Control\"></a>Monte Carlo Control</h3><h3 id=\"Monte-Carlo-Control-without-Exploring-Starts\"><a href=\"#Monte-Carlo-Control-without-Exploring-Starts\" class=\"headerlink\" title=\"Monte Carlo Control without Exploring Starts\"></a>Monte Carlo Control without Exploring Starts</h3><h3 id=\"Off-policy-Prediction-via-Improtance-Sampling\"><a href=\"#Off-policy-Prediction-via-Improtance-Sampling\" class=\"headerlink\" title=\"Off-policy Prediction via Improtance Sampling\"></a>Off-policy Prediction via Improtance Sampling</h3><h3 id=\"Incremental-Implementation-1\"><a href=\"#Incremental-Implementation-1\" class=\"headerlink\" title=\"Incremental Implementation\"></a>Incremental Implementation</h3><h3 id=\"Off-policy-Monte-Carlo-Control\"><a href=\"#Off-policy-Monte-Carlo-Control\" class=\"headerlink\" title=\"Off-policy Monte Carlo Control\"></a>Off-policy Monte Carlo Control</h3><h3 id=\"Discounting-aware-Importance-Sampling\"><a href=\"#Discounting-aware-Importance-Sampling\" class=\"headerlink\" title=\"Discounting-aware Importance Sampling\"></a>Discounting-aware Importance Sampling</h3><h3 id=\"Per-decision-Importance-Sampling\"><a href=\"#Per-decision-Importance-Sampling\" class=\"headerlink\" title=\"Per-decision Importance Sampling\"></a>Per-decision Importance Sampling</h3><h3 id=\"Summary-4\"><a href=\"#Summary-4\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-6-Temporal-Difference-Learning\"><a href=\"#Chapter-6-Temporal-Difference-Learning\" class=\"headerlink\" title=\"Chapter 6 Temporal-Difference Learning\"></a>Chapter 6 Temporal-Difference Learning</h2><h3 id=\"TD-Prediction\"><a href=\"#TD-Prediction\" class=\"headerlink\" title=\"TD Prediction\"></a>TD Prediction</h3><h3 id=\"Advantages-of-TD-Prediction-Methods\"><a href=\"#Advantages-of-TD-Prediction-Methods\" class=\"headerlink\" title=\"Advantages of TD Prediction Methods\"></a>Advantages of TD Prediction Methods</h3><h3 id=\"Optimality-of-TD-0\"><a href=\"#Optimality-of-TD-0\" class=\"headerlink\" title=\"Optimality of TD(0)\"></a>Optimality of TD(0)</h3><h3 id=\"Sarsa-On-policy-TD-Control\"><a href=\"#Sarsa-On-policy-TD-Control\" class=\"headerlink\" title=\"Sarsa: On-policy TD Control\"></a>Sarsa: On-policy TD Control</h3><h3 id=\"Q-learning-Off-policy-TD-Control\"><a href=\"#Q-learning-Off-policy-TD-Control\" class=\"headerlink\" title=\"Q-learning: Off-policy TD Control\"></a>Q-learning: Off-policy TD Control</h3><h3 id=\"Expected-Sarsa\"><a href=\"#Expected-Sarsa\" class=\"headerlink\" title=\"Expected Sarsa\"></a>Expected Sarsa</h3><h3 id=\"Maximization-Bias-and-Double-Learning\"><a href=\"#Maximization-Bias-and-Double-Learning\" class=\"headerlink\" title=\"Maximization Bias and Double Learning\"></a>Maximization Bias and Double Learning</h3><h3 id=\"Games-Afterstates-and-Other-Special-Cases\"><a href=\"#Games-Afterstates-and-Other-Special-Cases\" class=\"headerlink\" title=\"Games, Afterstates, and Other Special Cases\"></a>Games, Afterstates, and Other Special Cases</h3><h3 id=\"Summary-5\"><a href=\"#Summary-5\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-7-n-step-Bootstrapping\"><a href=\"#Chapter-7-n-step-Bootstrapping\" class=\"headerlink\" title=\"Chapter 7 n-step Bootstrapping\"></a>Chapter 7 n-step Bootstrapping</h2><h3 id=\"n-step-TD-Prediction\"><a href=\"#n-step-TD-Prediction\" class=\"headerlink\" title=\"n-step TD Prediction\"></a>n-step TD Prediction</h3><h3 id=\"n-step-Sarsa\"><a href=\"#n-step-Sarsa\" class=\"headerlink\" title=\"n-step Sarsa\"></a>n-step Sarsa</h3><h3 id=\"n-step-Off-policy-Learning\"><a href=\"#n-step-Off-policy-Learning\" class=\"headerlink\" title=\"n-step Off-policy Learning\"></a>n-step Off-policy Learning</h3><h3 id=\"Per-decision-Methods-with-Control-Variates\"><a href=\"#Per-decision-Methods-with-Control-Variates\" class=\"headerlink\" title=\"Per-decision Methods with Control Variates\"></a>Per-decision Methods with Control Variates</h3><h3 id=\"Off-policy-Learning-Without-Importance-Sampling-The-n-step-Tree-Backup-Algorithm\"><a href=\"#Off-policy-Learning-Without-Importance-Sampling-The-n-step-Tree-Backup-Algorithm\" class=\"headerlink\" title=\"Off-policy Learning Without Importance Sampling: The n-step Tree Backup Algorithm\"></a>Off-policy Learning Without Importance Sampling: The n-step Tree Backup Algorithm</h3><h3 id=\"A-Unifying-Algorithm-n-step-Q-sigma\"><a href=\"#A-Unifying-Algorithm-n-step-Q-sigma\" class=\"headerlink\" title=\"A Unifying Algorithm: n-step $Q(\\sigma)$\"></a>A Unifying Algorithm: n-step $Q(\\sigma)$</h3><h3 id=\"Summary-6\"><a href=\"#Summary-6\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-8-Planning-and-Learning-with-Tabular-Methods\"><a href=\"#Chapter-8-Planning-and-Learning-with-Tabular-Methods\" class=\"headerlink\" title=\"Chapter 8 Planning and Learning with Tabular Methods\"></a>Chapter 8 Planning and Learning with Tabular Methods</h2><h3 id=\"Models-and-Planning\"><a href=\"#Models-and-Planning\" class=\"headerlink\" title=\"Models and Planning\"></a>Models and Planning</h3><h3 id=\"Dyna-Integrated-Planning-Acting-and-Learning\"><a href=\"#Dyna-Integrated-Planning-Acting-and-Learning\" class=\"headerlink\" title=\"Dyna: Integrated Planning, Acting, and Learning\"></a>Dyna: Integrated Planning, Acting, and Learning</h3><h3 id=\"When-the-Model-Is-Wrong\"><a href=\"#When-the-Model-Is-Wrong\" class=\"headerlink\" title=\"When the Model Is Wrong\"></a>When the Model Is Wrong</h3><h3 id=\"Prioritized-Sweeping\"><a href=\"#Prioritized-Sweeping\" class=\"headerlink\" title=\"Prioritized Sweeping\"></a>Prioritized Sweeping</h3><h3 id=\"Expected-vs-Sample-Updates\"><a href=\"#Expected-vs-Sample-Updates\" class=\"headerlink\" title=\"Expected vs. Sample Updates\"></a>Expected vs. Sample Updates</h3><h3 id=\"Trajectory-Sampling\"><a href=\"#Trajectory-Sampling\" class=\"headerlink\" title=\"Trajectory Sampling\"></a>Trajectory Sampling</h3><h3 id=\"Real-time-Dynamic-Programming\"><a href=\"#Real-time-Dynamic-Programming\" class=\"headerlink\" title=\"Real-time Dynamic Programming\"></a>Real-time Dynamic Programming</h3><h3 id=\"Planning-at-Decision-Time\"><a href=\"#Planning-at-Decision-Time\" class=\"headerlink\" title=\"Planning at Decision Time\"></a>Planning at Decision Time</h3><h3 id=\"Heuristic-Search\"><a href=\"#Heuristic-Search\" class=\"headerlink\" title=\"Heuristic Search\"></a>Heuristic Search</h3><h3 id=\"Rollout-Algorithms\"><a href=\"#Rollout-Algorithms\" class=\"headerlink\" title=\"Rollout Algorithms\"></a>Rollout Algorithms</h3><h3 id=\"Monte-Carlo-Tree-Search\"><a href=\"#Monte-Carlo-Tree-Search\" class=\"headerlink\" title=\"Monte Carlo Tree Search\"></a>Monte Carlo Tree Search</h3><h3 id=\"Summary-7\"><a href=\"#Summary-7\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h1 id=\"Approximate-Solution-Methods\"><a href=\"#Approximate-Solution-Methods\" class=\"headerlink\" title=\"Approximate Solution Methods\"></a>Approximate Solution Methods</h1><h2 id=\"Chapter-9-On-policy-Prediction-with-Approximation\"><a href=\"#Chapter-9-On-policy-Prediction-with-Approximation\" class=\"headerlink\" title=\"Chapter 9 On-policy Prediction with Approximation\"></a>Chapter 9 On-policy Prediction with Approximation</h2><h3 id=\"Value-function-Approximation\"><a href=\"#Value-function-Approximation\" class=\"headerlink\" title=\"Value-function Approximation\"></a>Value-function Approximation</h3><h3 id=\"The-Prediction-Objective-VE\"><a href=\"#The-Prediction-Objective-VE\" class=\"headerlink\" title=\"The Prediction Objective(VE)\"></a>The Prediction Objective(VE)</h3><h3 id=\"Stochastic-gradient-and-Semi-gradient-Methods\"><a href=\"#Stochastic-gradient-and-Semi-gradient-Methods\" class=\"headerlink\" title=\"Stochastic-gradient and Semi-gradient Methods\"></a>Stochastic-gradient and Semi-gradient Methods</h3><h3 id=\"Linear-Methods\"><a href=\"#Linear-Methods\" class=\"headerlink\" title=\"Linear Methods\"></a>Linear Methods</h3><h3 id=\"Feature-Construction-for-Linear-Methods\"><a href=\"#Feature-Construction-for-Linear-Methods\" class=\"headerlink\" title=\"Feature Construction for Linear Methods\"></a>Feature Construction for Linear Methods</h3><h4 id=\"Polynomials\"><a href=\"#Polynomials\" class=\"headerlink\" title=\"Polynomials\"></a>Polynomials</h4><h4 id=\"Fourier-Basis\"><a href=\"#Fourier-Basis\" class=\"headerlink\" title=\"Fourier Basis\"></a>Fourier Basis</h4><h4 id=\"Coarse-Coding\"><a href=\"#Coarse-Coding\" class=\"headerlink\" title=\"Coarse Coding\"></a>Coarse Coding</h4><h4 id=\"Tile-Coding\"><a href=\"#Tile-Coding\" class=\"headerlink\" title=\"Tile Coding\"></a>Tile Coding</h4><h4 id=\"Radial-Basis-Functions\"><a href=\"#Radial-Basis-Functions\" class=\"headerlink\" title=\"Radial Basis Functions\"></a>Radial Basis Functions</h4><h3 id=\"Selecting-Step-size-Parameters-Manually\"><a href=\"#Selecting-Step-size-Parameters-Manually\" class=\"headerlink\" title=\"Selecting Step-size Parameters Manually\"></a>Selecting Step-size Parameters Manually</h3><h3 id=\"Nonlinear-Function-Approximation-Artiﬁcial-Neural-Networks\"><a href=\"#Nonlinear-Function-Approximation-Artiﬁcial-Neural-Networks\" class=\"headerlink\" title=\"Nonlinear Function Approximation: Artiﬁcial Neural Networks\"></a>Nonlinear Function Approximation: Artiﬁcial Neural Networks</h3><h3 id=\"Least-Squares-TD\"><a href=\"#Least-Squares-TD\" class=\"headerlink\" title=\"Least-Squares TD\"></a>Least-Squares TD</h3><h3 id=\"Memory-based-Function-Approximation\"><a href=\"#Memory-based-Function-Approximation\" class=\"headerlink\" title=\"Memory-based Function Approximation\"></a>Memory-based Function Approximation</h3><h3 id=\"Kernel-based-Function-Approximation\"><a href=\"#Kernel-based-Function-Approximation\" class=\"headerlink\" title=\"Kernel-based Function Approximation\"></a>Kernel-based Function Approximation</h3><h3 id=\"Looking-Deeper-at-On-policy-Learning-Interest-and-Emphasis\"><a href=\"#Looking-Deeper-at-On-policy-Learning-Interest-and-Emphasis\" class=\"headerlink\" title=\"Looking Deeper at On-policy Learning: Interest and Emphasis\"></a>Looking Deeper at On-policy Learning: Interest and Emphasis</h3><h3 id=\"Summary-8\"><a href=\"#Summary-8\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-10-On-policy-Control-with-Approximation\"><a href=\"#Chapter-10-On-policy-Control-with-Approximation\" class=\"headerlink\" title=\"Chapter 10 On-policy Control with Approximation\"></a>Chapter 10 On-policy Control with Approximation</h2><h3 id=\"Episodic-Semi-gradient-Control\"><a href=\"#Episodic-Semi-gradient-Control\" class=\"headerlink\" title=\"Episodic Semi-gradient Control\"></a>Episodic Semi-gradient Control</h3><h3 id=\"Semi-gradient-n-step-Sarsa\"><a href=\"#Semi-gradient-n-step-Sarsa\" class=\"headerlink\" title=\"Semi-gradient n-step Sarsa\"></a>Semi-gradient n-step Sarsa</h3><h3 id=\"Average-Reward-A-New-Problem-Setting-for-Continuing-Tasks\"><a href=\"#Average-Reward-A-New-Problem-Setting-for-Continuing-Tasks\" class=\"headerlink\" title=\"Average Reward: A New Problem Setting for Continuing Tasks\"></a>Average Reward: A New Problem Setting for Continuing Tasks</h3><h3 id=\"Deprecating-the-Discounted-Setting\"><a href=\"#Deprecating-the-Discounted-Setting\" class=\"headerlink\" title=\"Deprecating the Discounted Setting\"></a>Deprecating the Discounted Setting</h3><h3 id=\"Differential-Semi-gradient-n-step-Sarsa\"><a href=\"#Differential-Semi-gradient-n-step-Sarsa\" class=\"headerlink\" title=\"Differential Semi-gradient n-step Sarsa\"></a>Differential Semi-gradient n-step Sarsa</h3><h3 id=\"Summary-9\"><a href=\"#Summary-9\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-11-Off-policy-Methods-with-Approximation\"><a href=\"#Chapter-11-Off-policy-Methods-with-Approximation\" class=\"headerlink\" title=\"Chapter 11 Off-policy Methods with Approximation\"></a>Chapter 11 Off-policy Methods with Approximation</h2><h3 id=\"Semi-gradient-Methods\"><a href=\"#Semi-gradient-Methods\" class=\"headerlink\" title=\"Semi-gradient Methods\"></a>Semi-gradient Methods</h3><h3 id=\"Examples-of-Off-policy-Divergence\"><a href=\"#Examples-of-Off-policy-Divergence\" class=\"headerlink\" title=\"Examples of Off-policy Divergence\"></a>Examples of Off-policy Divergence</h3><h3 id=\"The-Deadly-Triad\"><a href=\"#The-Deadly-Triad\" class=\"headerlink\" title=\"The Deadly Triad\"></a>The Deadly Triad</h3><h3 id=\"Linear-Value-function-Geometry\"><a href=\"#Linear-Value-function-Geometry\" class=\"headerlink\" title=\"Linear Value-function Geometry\"></a>Linear Value-function Geometry</h3><h3 id=\"Gradient-Descent-in-the-Bellman-Error\"><a href=\"#Gradient-Descent-in-the-Bellman-Error\" class=\"headerlink\" title=\"Gradient Descent in the Bellman Error\"></a>Gradient Descent in the Bellman Error</h3><h3 id=\"The-Bellman-Error-is-Not-Learnable\"><a href=\"#The-Bellman-Error-is-Not-Learnable\" class=\"headerlink\" title=\"The Bellman Error is Not Learnable\"></a>The Bellman Error is Not Learnable</h3><h3 id=\"Gradient-TD-Methods\"><a href=\"#Gradient-TD-Methods\" class=\"headerlink\" title=\"Gradient-TD Methods\"></a>Gradient-TD Methods</h3><h3 id=\"Emphatic-TD-Methods\"><a href=\"#Emphatic-TD-Methods\" class=\"headerlink\" title=\"Emphatic-TD Methods\"></a>Emphatic-TD Methods</h3><h3 id=\"Reducing-Variance\"><a href=\"#Reducing-Variance\" class=\"headerlink\" title=\"Reducing Variance\"></a>Reducing Variance</h3><h3 id=\"Summary-10\"><a href=\"#Summary-10\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-12-Eligibility-Traces\"><a href=\"#Chapter-12-Eligibility-Traces\" class=\"headerlink\" title=\"Chapter 12 Eligibility Traces\"></a>Chapter 12 Eligibility Traces</h2><h3 id=\"The-lambda-return\"><a href=\"#The-lambda-return\" class=\"headerlink\" title=\"The $\\lambda$-return\"></a>The $\\lambda$-return</h3><h3 id=\"TD-lambda\"><a href=\"#TD-lambda\" class=\"headerlink\" title=\"TD($\\lambda$)\"></a>TD($\\lambda$)</h3><h3 id=\"n-step-Truncated-lambda-return-Methods\"><a href=\"#n-step-Truncated-lambda-return-Methods\" class=\"headerlink\" title=\"n-step Truncated $\\lambda$-return Methods\"></a>n-step Truncated $\\lambda$-return Methods</h3><h3 id=\"Redoing-Updates-Online-lambda-return-Algorithm\"><a href=\"#Redoing-Updates-Online-lambda-return-Algorithm\" class=\"headerlink\" title=\"Redoing Updates: Online $\\lambda$-return Algorithm\"></a>Redoing Updates: Online $\\lambda$-return Algorithm</h3><h3 id=\"True-Online-TD-lambda\"><a href=\"#True-Online-TD-lambda\" class=\"headerlink\" title=\"True Online TD($\\lambda$)\"></a>True Online TD($\\lambda$)</h3><h3 id=\"Dutch-Traces-in-Monte-Carlo-Learning\"><a href=\"#Dutch-Traces-in-Monte-Carlo-Learning\" class=\"headerlink\" title=\"Dutch Traces in Monte Carlo Learning\"></a>Dutch Traces in Monte Carlo Learning</h3><h3 id=\"Sarsa-lambda\"><a href=\"#Sarsa-lambda\" class=\"headerlink\" title=\"Sarsa($\\lambda$)\"></a>Sarsa($\\lambda$)</h3><h3 id=\"Variable-lambda-and-gamma\"><a href=\"#Variable-lambda-and-gamma\" class=\"headerlink\" title=\"Variable $\\lambda$ and $\\gamma$\"></a>Variable $\\lambda$ and $\\gamma$</h3><h3 id=\"Off-policy-Traces-with-Control-Variates\"><a href=\"#Off-policy-Traces-with-Control-Variates\" class=\"headerlink\" title=\"Off-policy Traces with Control Variates\"></a>Off-policy Traces with Control Variates</h3><h3 id=\"Watkins’s-Q-lambda-to-Tree-Backup-lambda\"><a href=\"#Watkins’s-Q-lambda-to-Tree-Backup-lambda\" class=\"headerlink\" title=\"Watkins’s Q($\\lambda$) to Tree-Backup( $\\lambda$)\"></a>Watkins’s Q($\\lambda$) to Tree-Backup( $\\lambda$)</h3><h3 id=\"Stable-Off-policy-Methods-with-Traces\"><a href=\"#Stable-Off-policy-Methods-with-Traces\" class=\"headerlink\" title=\"Stable Off-policy Methods with Traces\"></a>Stable Off-policy Methods with Traces</h3><h3 id=\"Implementation-Issues\"><a href=\"#Implementation-Issues\" class=\"headerlink\" title=\"Implementation Issues\"></a>Implementation Issues</h3><h3 id=\"Conclusions\"><a href=\"#Conclusions\" class=\"headerlink\" title=\"Conclusions\"></a>Conclusions</h3><h2 id=\"Chapter-13-Policy-Gradient-Methods\"><a href=\"#Chapter-13-Policy-Gradient-Methods\" class=\"headerlink\" title=\"Chapter 13 Policy Gradient Methods\"></a>Chapter 13 Policy Gradient Methods</h2><h3 id=\"Policy-Approximation-and-its-Advantages\"><a href=\"#Policy-Approximation-and-its-Advantages\" class=\"headerlink\" title=\"Policy Approximation and its Advantages\"></a>Policy Approximation and its Advantages</h3><h3 id=\"The-Policy-Gradient-Theorem\"><a href=\"#The-Policy-Gradient-Theorem\" class=\"headerlink\" title=\"The Policy Gradient Theorem\"></a>The Policy Gradient Theorem</h3><h3 id=\"REINFORCE-Monte-Carlo-Policy-Gradient\"><a href=\"#REINFORCE-Monte-Carlo-Policy-Gradient\" class=\"headerlink\" title=\"REINFORCE: Monte Carlo Policy Gradient\"></a>REINFORCE: Monte Carlo Policy Gradient</h3><h3 id=\"REINFORCE-with-Baseline\"><a href=\"#REINFORCE-with-Baseline\" class=\"headerlink\" title=\"REINFORCE with Baseline\"></a>REINFORCE with Baseline</h3><h3 id=\"Actor–Critic-Methods\"><a href=\"#Actor–Critic-Methods\" class=\"headerlink\" title=\"Actor–Critic Methods\"></a>Actor–Critic Methods</h3><h3 id=\"Policy-Gradient-for-Continuing-Problems\"><a href=\"#Policy-Gradient-for-Continuing-Problems\" class=\"headerlink\" title=\"Policy Gradient for Continuing Problems\"></a>Policy Gradient for Continuing Problems</h3><h3 id=\"Policy-Parameterization-for-Continuous-Actions\"><a href=\"#Policy-Parameterization-for-Continuous-Actions\" class=\"headerlink\" title=\"Policy Parameterization for Continuous Actions\"></a>Policy Parameterization for Continuous Actions</h3><h3 id=\"Summary-11\"><a href=\"#Summary-11\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h1 id=\"Looking-Deeper\"><a href=\"#Looking-Deeper\" class=\"headerlink\" title=\"Looking Deeper\"></a>Looking Deeper</h1><h2 id=\"Chapter-14-Psychology\"><a href=\"#Chapter-14-Psychology\" class=\"headerlink\" title=\"Chapter 14 Psychology\"></a>Chapter 14 Psychology</h2><h3 id=\"Prediction-and-Control\"><a href=\"#Prediction-and-Control\" class=\"headerlink\" title=\"Prediction and Control\"></a>Prediction and Control</h3><h3 id=\"Classical-Conditioning\"><a href=\"#Classical-Conditioning\" class=\"headerlink\" title=\"Classical Conditioning\"></a>Classical Conditioning</h3><h4 id=\"Blocking-and-Higher-order-Conditioning\"><a href=\"#Blocking-and-Higher-order-Conditioning\" class=\"headerlink\" title=\"Blocking and Higher-order Conditioning\"></a>Blocking and Higher-order Conditioning</h4><h4 id=\"The-Rescorla–Wagner-Model\"><a href=\"#The-Rescorla–Wagner-Model\" class=\"headerlink\" title=\"The Rescorla–Wagner Model\"></a>The Rescorla–Wagner Model</h4><h4 id=\"The-TD-Model\"><a href=\"#The-TD-Model\" class=\"headerlink\" title=\"The TD Model\"></a>The TD Model</h4><h4 id=\"TD-Model-Simulations\"><a href=\"#TD-Model-Simulations\" class=\"headerlink\" title=\"TD Model Simulations\"></a>TD Model Simulations</h4><h3 id=\"Instrumental-Conditioning\"><a href=\"#Instrumental-Conditioning\" class=\"headerlink\" title=\"Instrumental Conditioning\"></a>Instrumental Conditioning</h3><h3 id=\"Delayed-Reinforcement\"><a href=\"#Delayed-Reinforcement\" class=\"headerlink\" title=\"Delayed Reinforcement\"></a>Delayed Reinforcement</h3><h3 id=\"Cognitive-Maps\"><a href=\"#Cognitive-Maps\" class=\"headerlink\" title=\"Cognitive Maps\"></a>Cognitive Maps</h3><h3 id=\"Habitual-and-Goal-directed-Behavior\"><a href=\"#Habitual-and-Goal-directed-Behavior\" class=\"headerlink\" title=\"Habitual and Goal-directed Behavior\"></a>Habitual and Goal-directed Behavior</h3><h3 id=\"Summary-12\"><a href=\"#Summary-12\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-15-Neuroscience\"><a href=\"#Chapter-15-Neuroscience\" class=\"headerlink\" title=\"Chapter 15 Neuroscience\"></a>Chapter 15 Neuroscience</h2><h3 id=\"Neuroscience-Basics\"><a href=\"#Neuroscience-Basics\" class=\"headerlink\" title=\"Neuroscience Basics\"></a>Neuroscience Basics</h3><h3 id=\"Reward-Signals-Reinforcement-Signals-Values-and-Prediction-Errors\"><a href=\"#Reward-Signals-Reinforcement-Signals-Values-and-Prediction-Errors\" class=\"headerlink\" title=\"Reward Signals, Reinforcement Signals, Values, and Prediction Errors\"></a>Reward Signals, Reinforcement Signals, Values, and Prediction Errors</h3><h3 id=\"The-Reward-Prediction-Error-Hypothesis\"><a href=\"#The-Reward-Prediction-Error-Hypothesis\" class=\"headerlink\" title=\"The Reward Prediction Error Hypothesis\"></a>The Reward Prediction Error Hypothesis</h3><h3 id=\"Dopamine\"><a href=\"#Dopamine\" class=\"headerlink\" title=\"Dopamine\"></a>Dopamine</h3><h3 id=\"Experimental-Support-for-the-Reward-Prediction-Error-Hypothesis\"><a href=\"#Experimental-Support-for-the-Reward-Prediction-Error-Hypothesis\" class=\"headerlink\" title=\"Experimental Support for the Reward Prediction Error Hypothesis\"></a>Experimental Support for the Reward Prediction Error Hypothesis</h3><h3 id=\"TD-Error-Dopamine-Correspondence\"><a href=\"#TD-Error-Dopamine-Correspondence\" class=\"headerlink\" title=\"TD Error/Dopamine Correspondence\"></a>TD Error/Dopamine Correspondence</h3><h3 id=\"Neural-Actor–Critic\"><a href=\"#Neural-Actor–Critic\" class=\"headerlink\" title=\"Neural Actor–Critic\"></a>Neural Actor–Critic</h3><h3 id=\"Actor-and-Critic-Learning-Rules\"><a href=\"#Actor-and-Critic-Learning-Rules\" class=\"headerlink\" title=\"Actor and Critic Learning Rules\"></a>Actor and Critic Learning Rules</h3><h3 id=\"Hedonistic-Neurons\"><a href=\"#Hedonistic-Neurons\" class=\"headerlink\" title=\"Hedonistic Neurons\"></a>Hedonistic Neurons</h3><h3 id=\"Collective-Reinforcement-Learning\"><a href=\"#Collective-Reinforcement-Learning\" class=\"headerlink\" title=\"Collective Reinforcement Learning\"></a>Collective Reinforcement Learning</h3><h3 id=\"Model-based-Methods-in-the-Brain\"><a href=\"#Model-based-Methods-in-the-Brain\" class=\"headerlink\" title=\"Model-based Methods in the Brain\"></a>Model-based Methods in the Brain</h3><h3 id=\"Addiction\"><a href=\"#Addiction\" class=\"headerlink\" title=\"Addiction\"></a>Addiction</h3><h3 id=\"Summary-13\"><a href=\"#Summary-13\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><h2 id=\"Chapter-16-Applications-and-Case-Studies\"><a href=\"#Chapter-16-Applications-and-Case-Studies\" class=\"headerlink\" title=\"Chapter 16 Applications and Case Studies\"></a>Chapter 16 Applications and Case Studies</h2><h3 id=\"TD-Gammon\"><a href=\"#TD-Gammon\" class=\"headerlink\" title=\"TD-Gammon\"></a>TD-Gammon</h3><h3 id=\"Samuel’s-Checkers-Player\"><a href=\"#Samuel’s-Checkers-Player\" class=\"headerlink\" title=\"Samuel’s Checkers Player\"></a>Samuel’s Checkers Player</h3><h3 id=\"Watson’s-Daily-Double-Wagering\"><a href=\"#Watson’s-Daily-Double-Wagering\" class=\"headerlink\" title=\"Watson’s Daily-Double Wagering\"></a>Watson’s Daily-Double Wagering</h3><h3 id=\"Optimizing-Memory-Control\"><a href=\"#Optimizing-Memory-Control\" class=\"headerlink\" title=\"Optimizing Memory Control\"></a>Optimizing Memory Control</h3><h3 id=\"Human-level-Video-Game-Play\"><a href=\"#Human-level-Video-Game-Play\" class=\"headerlink\" title=\"Human-level Video Game Play\"></a>Human-level Video Game Play</h3><h3 id=\"Mastering-the-Game-of-Go\"><a href=\"#Mastering-the-Game-of-Go\" class=\"headerlink\" title=\"Mastering the Game of Go\"></a>Mastering the Game of Go</h3><h4 id=\"AlphaGo\"><a href=\"#AlphaGo\" class=\"headerlink\" title=\"AlphaGo\"></a>AlphaGo</h4><h4 id=\"AlphaGo-Zero\"><a href=\"#AlphaGo-Zero\" class=\"headerlink\" title=\"AlphaGo Zero\"></a>AlphaGo Zero</h4><h3 id=\"Personalized-Web-Services\"><a href=\"#Personalized-Web-Services\" class=\"headerlink\" title=\"Personalized Web Services\"></a>Personalized Web Services</h3><h3 id=\"Thermal-Soaring\"><a href=\"#Thermal-Soaring\" class=\"headerlink\" title=\"Thermal Soaring\"></a>Thermal Soaring</h3><h2 id=\"Chapter-17-Frontiers\"><a href=\"#Chapter-17-Frontiers\" class=\"headerlink\" title=\"Chapter 17 Frontiers\"></a>Chapter 17 Frontiers</h2><h3 id=\"General-Value-Functions-and-Auxiliary-Tasks\"><a href=\"#General-Value-Functions-and-Auxiliary-Tasks\" class=\"headerlink\" title=\"General Value Functions and Auxiliary Tasks\"></a>General Value Functions and Auxiliary Tasks</h3><h3 id=\"Temporal-Abstraction-via-Options\"><a href=\"#Temporal-Abstraction-via-Options\" class=\"headerlink\" title=\"Temporal Abstraction via Options\"></a>Temporal Abstraction via Options</h3><h3 id=\"Observations-and-State\"><a href=\"#Observations-and-State\" class=\"headerlink\" title=\"Observations and State\"></a>Observations and State</h3><h3 id=\"Designing-Reward-Signals\"><a href=\"#Designing-Reward-Signals\" class=\"headerlink\" title=\"Designing Reward Signals\"></a>Designing Reward Signals</h3><h3 id=\"Remaining-Issues\"><a href=\"#Remaining-Issues\" class=\"headerlink\" title=\"Remaining Issues\"></a>Remaining Issues</h3><h3 id=\"The-Future-of-Artiﬁcial-Intelligence\"><a href=\"#The-Future-of-Artiﬁcial-Intelligence\" class=\"headerlink\" title=\"The Future of Artiﬁcial Intelligence\"></a>The Future of Artiﬁcial Intelligence</h3>"},{"title":"强化学习的类别","copyright":true,"top":1,"date":"2019-05-10T07:18:23.000Z","mathjax":true,"keywords":null,"description":null,"_content":"\n本文讲述了强化学习中各种算法、问题的分类规则。\n\n<!--more-->\n\n# Stationary or not\n\n根据环境十分稳定、可以将强化学习问题分为stationary、non-stationary。\n\n如果状态转移**和**奖励函数是确定的，即选择动作$a$后执行它的结果是确定的，那么这个环境就是stationary。\n\n![](./rl-classification/stationary.png)\n\n如果状态转移**或**奖励函数是不确定的，即选择动作$a$后执行它的结果是不确定的，那么这个环境就是non-stationary。\n\n![](./rl-classification/non-stationary.png)\n\n# Model Based-or-Free\n\n一直对这个问题的认识不清晰，直到最近（2019年5月12日19:13:53）才有了清晰的认识。\n\n需要注意的是，无论是Model-Based还是Model-Free都不是对强化学习问题的分类，而是对算法的分类。之前一直理解的是状态空间$\\mathcal{S}$、动作空间$\\mathcal{A}$的都是离散的，转移概率矩阵$\\mathcal{P}$是确定的，这样即是Model-Based，如果状态空间$\\mathcal{S}$、动作空间$\\mathcal{A}$或转移概率矩阵$\\mathcal{P}$是不确定的，则是Model-Free，其实这只是对Model的分类，并不是Model-Based与Model-Free的真实含义，Model-Based与Model-Free是对算法求解过程的分类，理解这个可以在阅读国外文献、实验环境时更清晰，提升自己对强化学习算法的理解深度。\n\nModel-Based：\n\n- 智能体Agent在已知模型（$\\mathcal{S,A,R,P}$有限且确定）或者先学习一个模型（使用有监督对状态转移、奖励函数进行学习而得到），并在这个模型中使用**planning**（预测所有状态转移可能）方法来计算解决方案\n\n> Now if we know what all those elements of an MDP are, we can just compute the solution before ever actually executing an action in the environment. In AI, we typically call computing the solution to a decision-making problem before executing an actual decision *planning*. Some classic planning algorithms for MDPs include Value Iteration, Policy Iteration, and whole lot more.\n\nModel-Free:\n\n- 智能体在模型（$\\mathcal{S,A,R,P}$可能确定但没有使用planning方式解决，也可能不确定）中试错，并且使用**learning**（不预测全部可能性）方法来产生最佳策略\n\n> But the RL problem isn’t so kind to us. What makes a problem an RL problem, rather than a planning problem, is the agent does *not* know all the elements of the MDP, precluding it from being able to plan a solution. Specifically, the agent does not know how the world will change in response to its actions (the transition function TT), nor what immediate reward it will receive for doing so (the reward function RR). The agent will simply have to try taking actions in the environment, observe what happens, and somehow, find a good policy from doing so.\n\n根据Model-Based、Model-Free对算法、解决方法进行分类：\n\nModel-Based：DP、Policy Iteration、Value Iteration……\n\nModel-Free：SARSA、Q-Learning、PG……\n\n---\n\n> if you want a way to check if an RL algorithm is model-based or model-free, ask yourself this question: after learning, can the agent make predictions about what the next state and reward will be before it takes each action? If it can, then it’s a model-based RL algorithm. if it cannot, it’s a model-free algorithm.\n\n**使用算法学成策略之后，智能体可以在执行动作前判断该动作的后果，即是Model-Based，反之则是Model-Free**\n\n---\n\n根据Model-Based和Model-Free可以将强化学习算法分类，图片摘自OpenAI Spinning Up，如图所示：\n\n![](./rl-classification/model-classification.png)\n\n>[What is the difference between model-based and model-free reinforcement learning?](https://www.quora.com/What-is-the-difference-between-model-based-and-model-free-reinforcement-learning)\n>\n>[OpenAI Spinning Up : A Taxonomy of RL Algorithms](https://spinningup.openai.com/en/latest/spinningup/rl_intro2.html#a-taxonomy-of-rl-algorithms)\n\n# Policy or Value\n\n强化学习的目的是找到最优策略使得累积期望回报最大化，获得最优策略的方法有直接与间接之分。直接获取策略的图示为：\n\n![](./rl-classification/policy-based.png)\n\n间接获得策略为从值函数中提取最优策略，图示为：\n\n![](./rl-classification/value-based.png)\n\n直接获取策略的方式即为Policy-Based，常见的算法有：\n\n- Policy Gradient\n- PPO\n- SAC\n- ……\n\n间接获得策略的方式即为Value-Based，常见的算法有：\n\n- SARSA\n- Q-Learning\n- DQN\n- ……\n\n# On-policy or Off-policy\n\n在机器学习中，提到On跟Off这两个词我们最容易想到的是On-line Learning与Off-line Learning，那么强化学习与On-line、Off-line有什么关系呢？\n\n---\n\n网上对于On-line Learning与Off-line Learning有不同的解释，按热度排序为下面三种：\n\n对于On-line Learning：\n\n1. 单样本学习，样本用完即丢，样本连续不断输入，非数据集，而是数据流\n2. 单样本的（SGD）\n3. 单样本或批样本学习，样本连续不断输入，非数据集，而是数据流\n\n相应对于Off-line Learning：\n\n1. 批样本或全样本学习多次，静态样本集\n2. 批样本学习\n3. 全样本学习，静态数据集\n\n对于这三种方式，强化学习可以怎样融入呢？\n\n1. 对于第一种，强化学习不属于On-line Learning也不属于Off-line Learning，不属于Off-line Learning是因为样本非静态、非固定，不属于On-line Learning是因为对于Q-Learning、Sarsa、PG、PPO等算法样本用完即丢，对于DQN、TD3等算法样本重复利用。\n2. 对于第二种，强化学习包括On-line Learning及On-line Learning\n3. 低于第三种，强化学习属于On-line Learning\n\n---\n\nOn-policy、Off-policy与On-line、Off-line之间有关系吗？\n\n好像没有关系。虽然它们都是关于样本进行的划分，不过On-Off line learning针对的是样本的使用，而On-Off policy针对的是样本的生成。\n\n---\n\n学习On-policy、Off-policy之前首先需要理解什么是行为策略与目标策略。\n\n行为策略$\\mathcal{Behavior Policy}$：\n\n- 采样时间序列$S_{0},A_{0},R_{0},S_{1},A_{1},R_{2},...,S_{n},A_{n},R_{n}$的策略\n- 官话：指导个体产生与环境进行实际交互行为的策略\n- 未必由一个模型表示\n\n目标策略$\\mathcal{TargetPolicy}$:\n\n- 待优化的策略\n- 官话：用来评价状态或行为价值的策略或者待优化的策略称为目标策略\n\n\n\n同步策略学习$\\mathcal{On-Policy}$:\n\n- 简言之，边采样边学习\n- 官话：如果个体在学习过程中优化的策略与自己的行为策略是同一个策略时，这种学习方式称为**同步策略学习（on-policy learning）**\n- 行为策略与目标策略是同一个\n\n异步策略学习$\\mathcal{Off-Policy}$:\n\n- 简言之，你采样我学习\n- 官话：如果个体在学习过程中优化的策略与自己的行为策略是不同的策略时，这种学习方式称为**异步策略学习（off-policy learning）**\n- 行为策略与目标策略不同，行为策略可能是目标策略的“分身”（双网络结构），或者完全是另一个采样的策略\n\n两者的区别简而言之：如果需要估计一个值，用于估计的额外信息和当前信息出自同一策略则为on-policy，否则为off-policy。以SARSA和Q-Learning算法为例，对于Q值的估计，SARSA中$s_{t+1}$的动作由当前策略产生，故为on-policy算法，而Q-Learning中$s_{t+1}$的动作由贪心策略产生，故为off-policy。\n\n例如：\n\n\n\n\n\n|             | SARSA | Q-learning |\n|:-----------:|:-----:|:----------:|\n| Choosing A' |   π   |      π     |\n| Updating Q  |   π   |      μ     |\n\n\n\n> [一个以Q-Learning和Sarsa算法做比较的解释](https://stackoverflow.com/a/41420616)\n\n# Stochastic or Deterministic","source":"_posts/rl-classification.md","raw":"---\ntitle: 强化学习的类别\ncopyright: true\ntop: 1\ndate: 2019-05-10 15:18:23\nmathjax: true\nkeywords: \ndescription: \ncategories: ReinforcementLearning\ntags:\n- rl\n---\n\n本文讲述了强化学习中各种算法、问题的分类规则。\n\n<!--more-->\n\n# Stationary or not\n\n根据环境十分稳定、可以将强化学习问题分为stationary、non-stationary。\n\n如果状态转移**和**奖励函数是确定的，即选择动作$a$后执行它的结果是确定的，那么这个环境就是stationary。\n\n![](./rl-classification/stationary.png)\n\n如果状态转移**或**奖励函数是不确定的，即选择动作$a$后执行它的结果是不确定的，那么这个环境就是non-stationary。\n\n![](./rl-classification/non-stationary.png)\n\n# Model Based-or-Free\n\n一直对这个问题的认识不清晰，直到最近（2019年5月12日19:13:53）才有了清晰的认识。\n\n需要注意的是，无论是Model-Based还是Model-Free都不是对强化学习问题的分类，而是对算法的分类。之前一直理解的是状态空间$\\mathcal{S}$、动作空间$\\mathcal{A}$的都是离散的，转移概率矩阵$\\mathcal{P}$是确定的，这样即是Model-Based，如果状态空间$\\mathcal{S}$、动作空间$\\mathcal{A}$或转移概率矩阵$\\mathcal{P}$是不确定的，则是Model-Free，其实这只是对Model的分类，并不是Model-Based与Model-Free的真实含义，Model-Based与Model-Free是对算法求解过程的分类，理解这个可以在阅读国外文献、实验环境时更清晰，提升自己对强化学习算法的理解深度。\n\nModel-Based：\n\n- 智能体Agent在已知模型（$\\mathcal{S,A,R,P}$有限且确定）或者先学习一个模型（使用有监督对状态转移、奖励函数进行学习而得到），并在这个模型中使用**planning**（预测所有状态转移可能）方法来计算解决方案\n\n> Now if we know what all those elements of an MDP are, we can just compute the solution before ever actually executing an action in the environment. In AI, we typically call computing the solution to a decision-making problem before executing an actual decision *planning*. Some classic planning algorithms for MDPs include Value Iteration, Policy Iteration, and whole lot more.\n\nModel-Free:\n\n- 智能体在模型（$\\mathcal{S,A,R,P}$可能确定但没有使用planning方式解决，也可能不确定）中试错，并且使用**learning**（不预测全部可能性）方法来产生最佳策略\n\n> But the RL problem isn’t so kind to us. What makes a problem an RL problem, rather than a planning problem, is the agent does *not* know all the elements of the MDP, precluding it from being able to plan a solution. Specifically, the agent does not know how the world will change in response to its actions (the transition function TT), nor what immediate reward it will receive for doing so (the reward function RR). The agent will simply have to try taking actions in the environment, observe what happens, and somehow, find a good policy from doing so.\n\n根据Model-Based、Model-Free对算法、解决方法进行分类：\n\nModel-Based：DP、Policy Iteration、Value Iteration……\n\nModel-Free：SARSA、Q-Learning、PG……\n\n---\n\n> if you want a way to check if an RL algorithm is model-based or model-free, ask yourself this question: after learning, can the agent make predictions about what the next state and reward will be before it takes each action? If it can, then it’s a model-based RL algorithm. if it cannot, it’s a model-free algorithm.\n\n**使用算法学成策略之后，智能体可以在执行动作前判断该动作的后果，即是Model-Based，反之则是Model-Free**\n\n---\n\n根据Model-Based和Model-Free可以将强化学习算法分类，图片摘自OpenAI Spinning Up，如图所示：\n\n![](./rl-classification/model-classification.png)\n\n>[What is the difference between model-based and model-free reinforcement learning?](https://www.quora.com/What-is-the-difference-between-model-based-and-model-free-reinforcement-learning)\n>\n>[OpenAI Spinning Up : A Taxonomy of RL Algorithms](https://spinningup.openai.com/en/latest/spinningup/rl_intro2.html#a-taxonomy-of-rl-algorithms)\n\n# Policy or Value\n\n强化学习的目的是找到最优策略使得累积期望回报最大化，获得最优策略的方法有直接与间接之分。直接获取策略的图示为：\n\n![](./rl-classification/policy-based.png)\n\n间接获得策略为从值函数中提取最优策略，图示为：\n\n![](./rl-classification/value-based.png)\n\n直接获取策略的方式即为Policy-Based，常见的算法有：\n\n- Policy Gradient\n- PPO\n- SAC\n- ……\n\n间接获得策略的方式即为Value-Based，常见的算法有：\n\n- SARSA\n- Q-Learning\n- DQN\n- ……\n\n# On-policy or Off-policy\n\n在机器学习中，提到On跟Off这两个词我们最容易想到的是On-line Learning与Off-line Learning，那么强化学习与On-line、Off-line有什么关系呢？\n\n---\n\n网上对于On-line Learning与Off-line Learning有不同的解释，按热度排序为下面三种：\n\n对于On-line Learning：\n\n1. 单样本学习，样本用完即丢，样本连续不断输入，非数据集，而是数据流\n2. 单样本的（SGD）\n3. 单样本或批样本学习，样本连续不断输入，非数据集，而是数据流\n\n相应对于Off-line Learning：\n\n1. 批样本或全样本学习多次，静态样本集\n2. 批样本学习\n3. 全样本学习，静态数据集\n\n对于这三种方式，强化学习可以怎样融入呢？\n\n1. 对于第一种，强化学习不属于On-line Learning也不属于Off-line Learning，不属于Off-line Learning是因为样本非静态、非固定，不属于On-line Learning是因为对于Q-Learning、Sarsa、PG、PPO等算法样本用完即丢，对于DQN、TD3等算法样本重复利用。\n2. 对于第二种，强化学习包括On-line Learning及On-line Learning\n3. 低于第三种，强化学习属于On-line Learning\n\n---\n\nOn-policy、Off-policy与On-line、Off-line之间有关系吗？\n\n好像没有关系。虽然它们都是关于样本进行的划分，不过On-Off line learning针对的是样本的使用，而On-Off policy针对的是样本的生成。\n\n---\n\n学习On-policy、Off-policy之前首先需要理解什么是行为策略与目标策略。\n\n行为策略$\\mathcal{Behavior Policy}$：\n\n- 采样时间序列$S_{0},A_{0},R_{0},S_{1},A_{1},R_{2},...,S_{n},A_{n},R_{n}$的策略\n- 官话：指导个体产生与环境进行实际交互行为的策略\n- 未必由一个模型表示\n\n目标策略$\\mathcal{TargetPolicy}$:\n\n- 待优化的策略\n- 官话：用来评价状态或行为价值的策略或者待优化的策略称为目标策略\n\n\n\n同步策略学习$\\mathcal{On-Policy}$:\n\n- 简言之，边采样边学习\n- 官话：如果个体在学习过程中优化的策略与自己的行为策略是同一个策略时，这种学习方式称为**同步策略学习（on-policy learning）**\n- 行为策略与目标策略是同一个\n\n异步策略学习$\\mathcal{Off-Policy}$:\n\n- 简言之，你采样我学习\n- 官话：如果个体在学习过程中优化的策略与自己的行为策略是不同的策略时，这种学习方式称为**异步策略学习（off-policy learning）**\n- 行为策略与目标策略不同，行为策略可能是目标策略的“分身”（双网络结构），或者完全是另一个采样的策略\n\n两者的区别简而言之：如果需要估计一个值，用于估计的额外信息和当前信息出自同一策略则为on-policy，否则为off-policy。以SARSA和Q-Learning算法为例，对于Q值的估计，SARSA中$s_{t+1}$的动作由当前策略产生，故为on-policy算法，而Q-Learning中$s_{t+1}$的动作由贪心策略产生，故为off-policy。\n\n例如：\n\n\n\n\n\n|             | SARSA | Q-learning |\n|:-----------:|:-----:|:----------:|\n| Choosing A' |   π   |      π     |\n| Updating Q  |   π   |      μ     |\n\n\n\n> [一个以Q-Learning和Sarsa算法做比较的解释](https://stackoverflow.com/a/41420616)\n\n# Stochastic or Deterministic","slug":"rl-classification","published":1,"updated":"2019-09-03T10:27:17.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusyh001g20cdqhc7jg7s","content":"<p>本文讲述了强化学习中各种算法、问题的分类规则。</p>\n<a id=\"more\"></a>\n<h1 id=\"Stationary-or-not\"><a href=\"#Stationary-or-not\" class=\"headerlink\" title=\"Stationary or not\"></a>Stationary or not</h1><p>根据环境十分稳定、可以将强化学习问题分为stationary、non-stationary。</p>\n<p>如果状态转移<strong>和</strong>奖励函数是确定的，即选择动作$a$后执行它的结果是确定的，那么这个环境就是stationary。</p>\n<p><img src=\"./rl-classification/stationary.png\" alt=\"\"></p>\n<p>如果状态转移<strong>或</strong>奖励函数是不确定的，即选择动作$a$后执行它的结果是不确定的，那么这个环境就是non-stationary。</p>\n<p><img src=\"./rl-classification/non-stationary.png\" alt=\"\"></p>\n<h1 id=\"Model-Based-or-Free\"><a href=\"#Model-Based-or-Free\" class=\"headerlink\" title=\"Model Based-or-Free\"></a>Model Based-or-Free</h1><p>一直对这个问题的认识不清晰，直到最近（2019年5月12日19:13:53）才有了清晰的认识。</p>\n<p>需要注意的是，无论是Model-Based还是Model-Free都不是对强化学习问题的分类，而是对算法的分类。之前一直理解的是状态空间$\\mathcal{S}$、动作空间$\\mathcal{A}$的都是离散的，转移概率矩阵$\\mathcal{P}$是确定的，这样即是Model-Based，如果状态空间$\\mathcal{S}$、动作空间$\\mathcal{A}$或转移概率矩阵$\\mathcal{P}$是不确定的，则是Model-Free，其实这只是对Model的分类，并不是Model-Based与Model-Free的真实含义，Model-Based与Model-Free是对算法求解过程的分类，理解这个可以在阅读国外文献、实验环境时更清晰，提升自己对强化学习算法的理解深度。</p>\n<p>Model-Based：</p>\n<ul>\n<li>智能体Agent在已知模型（$\\mathcal{S,A,R,P}$有限且确定）或者先学习一个模型（使用有监督对状态转移、奖励函数进行学习而得到），并在这个模型中使用<strong>planning</strong>（预测所有状态转移可能）方法来计算解决方案</li>\n</ul>\n<blockquote>\n<p>Now if we know what all those elements of an MDP are, we can just compute the solution before ever actually executing an action in the environment. In AI, we typically call computing the solution to a decision-making problem before executing an actual decision <em>planning</em>. Some classic planning algorithms for MDPs include Value Iteration, Policy Iteration, and whole lot more.</p>\n</blockquote>\n<p>Model-Free:</p>\n<ul>\n<li>智能体在模型（$\\mathcal{S,A,R,P}$可能确定但没有使用planning方式解决，也可能不确定）中试错，并且使用<strong>learning</strong>（不预测全部可能性）方法来产生最佳策略</li>\n</ul>\n<blockquote>\n<p>But the RL problem isn’t so kind to us. What makes a problem an RL problem, rather than a planning problem, is the agent does <em>not</em> know all the elements of the MDP, precluding it from being able to plan a solution. Specifically, the agent does not know how the world will change in response to its actions (the transition function TT), nor what immediate reward it will receive for doing so (the reward function RR). The agent will simply have to try taking actions in the environment, observe what happens, and somehow, find a good policy from doing so.</p>\n</blockquote>\n<p>根据Model-Based、Model-Free对算法、解决方法进行分类：</p>\n<p>Model-Based：DP、Policy Iteration、Value Iteration……</p>\n<p>Model-Free：SARSA、Q-Learning、PG……</p>\n<hr>\n<blockquote>\n<p>if you want a way to check if an RL algorithm is model-based or model-free, ask yourself this question: after learning, can the agent make predictions about what the next state and reward will be before it takes each action? If it can, then it’s a model-based RL algorithm. if it cannot, it’s a model-free algorithm.</p>\n</blockquote>\n<p><strong>使用算法学成策略之后，智能体可以在执行动作前判断该动作的后果，即是Model-Based，反之则是Model-Free</strong></p>\n<hr>\n<p>根据Model-Based和Model-Free可以将强化学习算法分类，图片摘自OpenAI Spinning Up，如图所示：</p>\n<p><img src=\"./rl-classification/model-classification.png\" alt=\"\"></p>\n<blockquote>\n<p><a href=\"https://www.quora.com/What-is-the-difference-between-model-based-and-model-free-reinforcement-learning\" rel=\"external nofollow\" target=\"_blank\">What is the difference between model-based and model-free reinforcement learning?</a></p>\n<p><a href=\"https://spinningup.openai.com/en/latest/spinningup/rl_intro2.html#a-taxonomy-of-rl-algorithms\" rel=\"external nofollow\" target=\"_blank\">OpenAI Spinning Up : A Taxonomy of RL Algorithms</a></p>\n</blockquote>\n<h1 id=\"Policy-or-Value\"><a href=\"#Policy-or-Value\" class=\"headerlink\" title=\"Policy or Value\"></a>Policy or Value</h1><p>强化学习的目的是找到最优策略使得累积期望回报最大化，获得最优策略的方法有直接与间接之分。直接获取策略的图示为：</p>\n<p><img src=\"./rl-classification/policy-based.png\" alt=\"\"></p>\n<p>间接获得策略为从值函数中提取最优策略，图示为：</p>\n<p><img src=\"./rl-classification/value-based.png\" alt=\"\"></p>\n<p>直接获取策略的方式即为Policy-Based，常见的算法有：</p>\n<ul>\n<li>Policy Gradient</li>\n<li>PPO</li>\n<li>SAC</li>\n<li>……</li>\n</ul>\n<p>间接获得策略的方式即为Value-Based，常见的算法有：</p>\n<ul>\n<li>SARSA</li>\n<li>Q-Learning</li>\n<li>DQN</li>\n<li>……</li>\n</ul>\n<h1 id=\"On-policy-or-Off-policy\"><a href=\"#On-policy-or-Off-policy\" class=\"headerlink\" title=\"On-policy or Off-policy\"></a>On-policy or Off-policy</h1><p>在机器学习中，提到On跟Off这两个词我们最容易想到的是On-line Learning与Off-line Learning，那么强化学习与On-line、Off-line有什么关系呢？</p>\n<hr>\n<p>网上对于On-line Learning与Off-line Learning有不同的解释，按热度排序为下面三种：</p>\n<p>对于On-line Learning：</p>\n<ol>\n<li>单样本学习，样本用完即丢，样本连续不断输入，非数据集，而是数据流</li>\n<li>单样本的（SGD）</li>\n<li>单样本或批样本学习，样本连续不断输入，非数据集，而是数据流</li>\n</ol>\n<p>相应对于Off-line Learning：</p>\n<ol>\n<li>批样本或全样本学习多次，静态样本集</li>\n<li>批样本学习</li>\n<li>全样本学习，静态数据集</li>\n</ol>\n<p>对于这三种方式，强化学习可以怎样融入呢？</p>\n<ol>\n<li>对于第一种，强化学习不属于On-line Learning也不属于Off-line Learning，不属于Off-line Learning是因为样本非静态、非固定，不属于On-line Learning是因为对于Q-Learning、Sarsa、PG、PPO等算法样本用完即丢，对于DQN、TD3等算法样本重复利用。</li>\n<li>对于第二种，强化学习包括On-line Learning及On-line Learning</li>\n<li>低于第三种，强化学习属于On-line Learning</li>\n</ol>\n<hr>\n<p>On-policy、Off-policy与On-line、Off-line之间有关系吗？</p>\n<p>好像没有关系。虽然它们都是关于样本进行的划分，不过On-Off line learning针对的是样本的使用，而On-Off policy针对的是样本的生成。</p>\n<hr>\n<p>学习On-policy、Off-policy之前首先需要理解什么是行为策略与目标策略。</p>\n<p>行为策略$\\mathcal{Behavior Policy}$：</p>\n<ul>\n<li>采样时间序列$S_{0},A_{0},R_{0},S_{1},A_{1},R_{2},…,S_{n},A_{n},R_{n}$的策略</li>\n<li>官话：指导个体产生与环境进行实际交互行为的策略</li>\n<li>未必由一个模型表示</li>\n</ul>\n<p>目标策略$\\mathcal{TargetPolicy}$:</p>\n<ul>\n<li>待优化的策略</li>\n<li>官话：用来评价状态或行为价值的策略或者待优化的策略称为目标策略</li>\n</ul>\n<p>同步策略学习$\\mathcal{On-Policy}$:</p>\n<ul>\n<li>简言之，边采样边学习</li>\n<li>官话：如果个体在学习过程中优化的策略与自己的行为策略是同一个策略时，这种学习方式称为<strong>同步策略学习（on-policy learning）</strong></li>\n<li>行为策略与目标策略是同一个</li>\n</ul>\n<p>异步策略学习$\\mathcal{Off-Policy}$:</p>\n<ul>\n<li>简言之，你采样我学习</li>\n<li>官话：如果个体在学习过程中优化的策略与自己的行为策略是不同的策略时，这种学习方式称为<strong>异步策略学习（off-policy learning）</strong></li>\n<li>行为策略与目标策略不同，行为策略可能是目标策略的“分身”（双网络结构），或者完全是另一个采样的策略</li>\n</ul>\n<p>两者的区别简而言之：如果需要估计一个值，用于估计的额外信息和当前信息出自同一策略则为on-policy，否则为off-policy。以SARSA和Q-Learning算法为例，对于Q值的估计，SARSA中$s_{t+1}$的动作由当前策略产生，故为on-policy算法，而Q-Learning中$s_{t+1}$的动作由贪心策略产生，故为off-policy。</p>\n<p>例如：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">SARSA</th>\n<th style=\"text-align:center\">Q-learning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Choosing A’</td>\n<td style=\"text-align:center\">π</td>\n<td style=\"text-align:center\">π</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Updating Q</td>\n<td style=\"text-align:center\">π</td>\n<td style=\"text-align:center\">μ</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/a/41420616\" rel=\"external nofollow\" target=\"_blank\">一个以Q-Learning和Sarsa算法做比较的解释</a></p>\n</blockquote>\n<h1 id=\"Stochastic-or-Deterministic\"><a href=\"#Stochastic-or-Deterministic\" class=\"headerlink\" title=\"Stochastic or Deterministic\"></a>Stochastic or Deterministic</h1>","site":{"data":{}},"excerpt":"<p>本文讲述了强化学习中各种算法、问题的分类规则。</p>","more":"<h1 id=\"Stationary-or-not\"><a href=\"#Stationary-or-not\" class=\"headerlink\" title=\"Stationary or not\"></a>Stationary or not</h1><p>根据环境十分稳定、可以将强化学习问题分为stationary、non-stationary。</p>\n<p>如果状态转移<strong>和</strong>奖励函数是确定的，即选择动作$a$后执行它的结果是确定的，那么这个环境就是stationary。</p>\n<p><img src=\"./rl-classification/stationary.png\" alt=\"\"></p>\n<p>如果状态转移<strong>或</strong>奖励函数是不确定的，即选择动作$a$后执行它的结果是不确定的，那么这个环境就是non-stationary。</p>\n<p><img src=\"./rl-classification/non-stationary.png\" alt=\"\"></p>\n<h1 id=\"Model-Based-or-Free\"><a href=\"#Model-Based-or-Free\" class=\"headerlink\" title=\"Model Based-or-Free\"></a>Model Based-or-Free</h1><p>一直对这个问题的认识不清晰，直到最近（2019年5月12日19:13:53）才有了清晰的认识。</p>\n<p>需要注意的是，无论是Model-Based还是Model-Free都不是对强化学习问题的分类，而是对算法的分类。之前一直理解的是状态空间$\\mathcal{S}$、动作空间$\\mathcal{A}$的都是离散的，转移概率矩阵$\\mathcal{P}$是确定的，这样即是Model-Based，如果状态空间$\\mathcal{S}$、动作空间$\\mathcal{A}$或转移概率矩阵$\\mathcal{P}$是不确定的，则是Model-Free，其实这只是对Model的分类，并不是Model-Based与Model-Free的真实含义，Model-Based与Model-Free是对算法求解过程的分类，理解这个可以在阅读国外文献、实验环境时更清晰，提升自己对强化学习算法的理解深度。</p>\n<p>Model-Based：</p>\n<ul>\n<li>智能体Agent在已知模型（$\\mathcal{S,A,R,P}$有限且确定）或者先学习一个模型（使用有监督对状态转移、奖励函数进行学习而得到），并在这个模型中使用<strong>planning</strong>（预测所有状态转移可能）方法来计算解决方案</li>\n</ul>\n<blockquote>\n<p>Now if we know what all those elements of an MDP are, we can just compute the solution before ever actually executing an action in the environment. In AI, we typically call computing the solution to a decision-making problem before executing an actual decision <em>planning</em>. Some classic planning algorithms for MDPs include Value Iteration, Policy Iteration, and whole lot more.</p>\n</blockquote>\n<p>Model-Free:</p>\n<ul>\n<li>智能体在模型（$\\mathcal{S,A,R,P}$可能确定但没有使用planning方式解决，也可能不确定）中试错，并且使用<strong>learning</strong>（不预测全部可能性）方法来产生最佳策略</li>\n</ul>\n<blockquote>\n<p>But the RL problem isn’t so kind to us. What makes a problem an RL problem, rather than a planning problem, is the agent does <em>not</em> know all the elements of the MDP, precluding it from being able to plan a solution. Specifically, the agent does not know how the world will change in response to its actions (the transition function TT), nor what immediate reward it will receive for doing so (the reward function RR). The agent will simply have to try taking actions in the environment, observe what happens, and somehow, find a good policy from doing so.</p>\n</blockquote>\n<p>根据Model-Based、Model-Free对算法、解决方法进行分类：</p>\n<p>Model-Based：DP、Policy Iteration、Value Iteration……</p>\n<p>Model-Free：SARSA、Q-Learning、PG……</p>\n<hr>\n<blockquote>\n<p>if you want a way to check if an RL algorithm is model-based or model-free, ask yourself this question: after learning, can the agent make predictions about what the next state and reward will be before it takes each action? If it can, then it’s a model-based RL algorithm. if it cannot, it’s a model-free algorithm.</p>\n</blockquote>\n<p><strong>使用算法学成策略之后，智能体可以在执行动作前判断该动作的后果，即是Model-Based，反之则是Model-Free</strong></p>\n<hr>\n<p>根据Model-Based和Model-Free可以将强化学习算法分类，图片摘自OpenAI Spinning Up，如图所示：</p>\n<p><img src=\"./rl-classification/model-classification.png\" alt=\"\"></p>\n<blockquote>\n<p><a href=\"https://www.quora.com/What-is-the-difference-between-model-based-and-model-free-reinforcement-learning\" rel=\"external nofollow\" target=\"_blank\">What is the difference between model-based and model-free reinforcement learning?</a></p>\n<p><a href=\"https://spinningup.openai.com/en/latest/spinningup/rl_intro2.html#a-taxonomy-of-rl-algorithms\" rel=\"external nofollow\" target=\"_blank\">OpenAI Spinning Up : A Taxonomy of RL Algorithms</a></p>\n</blockquote>\n<h1 id=\"Policy-or-Value\"><a href=\"#Policy-or-Value\" class=\"headerlink\" title=\"Policy or Value\"></a>Policy or Value</h1><p>强化学习的目的是找到最优策略使得累积期望回报最大化，获得最优策略的方法有直接与间接之分。直接获取策略的图示为：</p>\n<p><img src=\"./rl-classification/policy-based.png\" alt=\"\"></p>\n<p>间接获得策略为从值函数中提取最优策略，图示为：</p>\n<p><img src=\"./rl-classification/value-based.png\" alt=\"\"></p>\n<p>直接获取策略的方式即为Policy-Based，常见的算法有：</p>\n<ul>\n<li>Policy Gradient</li>\n<li>PPO</li>\n<li>SAC</li>\n<li>……</li>\n</ul>\n<p>间接获得策略的方式即为Value-Based，常见的算法有：</p>\n<ul>\n<li>SARSA</li>\n<li>Q-Learning</li>\n<li>DQN</li>\n<li>……</li>\n</ul>\n<h1 id=\"On-policy-or-Off-policy\"><a href=\"#On-policy-or-Off-policy\" class=\"headerlink\" title=\"On-policy or Off-policy\"></a>On-policy or Off-policy</h1><p>在机器学习中，提到On跟Off这两个词我们最容易想到的是On-line Learning与Off-line Learning，那么强化学习与On-line、Off-line有什么关系呢？</p>\n<hr>\n<p>网上对于On-line Learning与Off-line Learning有不同的解释，按热度排序为下面三种：</p>\n<p>对于On-line Learning：</p>\n<ol>\n<li>单样本学习，样本用完即丢，样本连续不断输入，非数据集，而是数据流</li>\n<li>单样本的（SGD）</li>\n<li>单样本或批样本学习，样本连续不断输入，非数据集，而是数据流</li>\n</ol>\n<p>相应对于Off-line Learning：</p>\n<ol>\n<li>批样本或全样本学习多次，静态样本集</li>\n<li>批样本学习</li>\n<li>全样本学习，静态数据集</li>\n</ol>\n<p>对于这三种方式，强化学习可以怎样融入呢？</p>\n<ol>\n<li>对于第一种，强化学习不属于On-line Learning也不属于Off-line Learning，不属于Off-line Learning是因为样本非静态、非固定，不属于On-line Learning是因为对于Q-Learning、Sarsa、PG、PPO等算法样本用完即丢，对于DQN、TD3等算法样本重复利用。</li>\n<li>对于第二种，强化学习包括On-line Learning及On-line Learning</li>\n<li>低于第三种，强化学习属于On-line Learning</li>\n</ol>\n<hr>\n<p>On-policy、Off-policy与On-line、Off-line之间有关系吗？</p>\n<p>好像没有关系。虽然它们都是关于样本进行的划分，不过On-Off line learning针对的是样本的使用，而On-Off policy针对的是样本的生成。</p>\n<hr>\n<p>学习On-policy、Off-policy之前首先需要理解什么是行为策略与目标策略。</p>\n<p>行为策略$\\mathcal{Behavior Policy}$：</p>\n<ul>\n<li>采样时间序列$S_{0},A_{0},R_{0},S_{1},A_{1},R_{2},…,S_{n},A_{n},R_{n}$的策略</li>\n<li>官话：指导个体产生与环境进行实际交互行为的策略</li>\n<li>未必由一个模型表示</li>\n</ul>\n<p>目标策略$\\mathcal{TargetPolicy}$:</p>\n<ul>\n<li>待优化的策略</li>\n<li>官话：用来评价状态或行为价值的策略或者待优化的策略称为目标策略</li>\n</ul>\n<p>同步策略学习$\\mathcal{On-Policy}$:</p>\n<ul>\n<li>简言之，边采样边学习</li>\n<li>官话：如果个体在学习过程中优化的策略与自己的行为策略是同一个策略时，这种学习方式称为<strong>同步策略学习（on-policy learning）</strong></li>\n<li>行为策略与目标策略是同一个</li>\n</ul>\n<p>异步策略学习$\\mathcal{Off-Policy}$:</p>\n<ul>\n<li>简言之，你采样我学习</li>\n<li>官话：如果个体在学习过程中优化的策略与自己的行为策略是不同的策略时，这种学习方式称为<strong>异步策略学习（off-policy learning）</strong></li>\n<li>行为策略与目标策略不同，行为策略可能是目标策略的“分身”（双网络结构），或者完全是另一个采样的策略</li>\n</ul>\n<p>两者的区别简而言之：如果需要估计一个值，用于估计的额外信息和当前信息出自同一策略则为on-policy，否则为off-policy。以SARSA和Q-Learning算法为例，对于Q值的估计，SARSA中$s_{t+1}$的动作由当前策略产生，故为on-policy算法，而Q-Learning中$s_{t+1}$的动作由贪心策略产生，故为off-policy。</p>\n<p>例如：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">SARSA</th>\n<th style=\"text-align:center\">Q-learning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Choosing A’</td>\n<td style=\"text-align:center\">π</td>\n<td style=\"text-align:center\">π</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Updating Q</td>\n<td style=\"text-align:center\">π</td>\n<td style=\"text-align:center\">μ</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/a/41420616\" rel=\"external nofollow\" target=\"_blank\">一个以Q-Learning和Sarsa算法做比较的解释</a></p>\n</blockquote>\n<h1 id=\"Stochastic-or-Deterministic\"><a href=\"#Stochastic-or-Deterministic\" class=\"headerlink\" title=\"Stochastic or Deterministic\"></a>Stochastic or Deterministic</h1>"},{"title":"在DRL路上踩过的坑","copyright":true,"mathjax":true,"top":1,"date":"2020-05-21T09:31:45.000Z","keywords":null,"description":null,"_content":"\n本博客用于记录在RL学习过程中踩过的坑点。\n\n<!--more-->\n\n---\n\n\n\n1. 确定性策略梯度算法如DPG、DDPG、TD3等在优化Actor网络时是否引入动作噪声\n\n   **通过大量实验发现，在重新选择动作优化Actor网络时不需要引入噪声，直接使用确定性动作即可，引入噪声会影响算法的性能，甚至导致策略不收敛，这是当我在调试分层强化学习算法HIRO时发现的。**\n\n   之前的版本是：\n\n   ```python\n   if self.is_continuous:\n       mu = self.actor_net(feat)\n       pi = tf.clip_by_value(mu + self.action_noise(), -1, 1)\n   else:\n       logits = self.actor_net(feat)\n       logp_all = tf.nn.log_softmax(logits)\n       gumbel_noise = tf.cast(self.gumbel_dist.sample([batch_size, self.a_counts]), dtype=tf.float32)\n       _pi = tf.nn.softmax((logp_all + gumbel_noise) / self.discrete_tau)\n       _pi_true_one_hot = tf.one_hot(tf.argmax(_pi, axis=-1), self.a_counts)\n       _pi_diff = tf.stop_gradient(_pi_true_one_hot - _pi)\n       pi = _pi_diff + _pi\n   q_actor = self.q_net(feat, pi)\n   ```\n\n   现在的版本是：\n\n   ```python\n   if self.is_continuous:\n       mu = self.actor_net(feat)\n   else:\n       logits = self.actor_net(feat)\n       _pi = tf.nn.softmax(logits)\n       _pi_true_one_hot = tf.one_hot(tf.argmax(logits, axis=-1), self.a_counts, dtype=tf.float32)\n       _pi_diff = tf.stop_gradient(_pi_true_one_hot - _pi)\n       mu = _pi_diff + _pi\n   q_actor = self.q_net(feat, mu)\n   ```\n\n   \n\n2. ","source":"_posts/rl-code-pit.md","raw":"---\ntitle: 在DRL路上踩过的坑\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-05-21 17:31:45\ncategories: ReinforcementLearning\ntags:\n- RL\nkeywords:\ndescription:\n---\n\n本博客用于记录在RL学习过程中踩过的坑点。\n\n<!--more-->\n\n---\n\n\n\n1. 确定性策略梯度算法如DPG、DDPG、TD3等在优化Actor网络时是否引入动作噪声\n\n   **通过大量实验发现，在重新选择动作优化Actor网络时不需要引入噪声，直接使用确定性动作即可，引入噪声会影响算法的性能，甚至导致策略不收敛，这是当我在调试分层强化学习算法HIRO时发现的。**\n\n   之前的版本是：\n\n   ```python\n   if self.is_continuous:\n       mu = self.actor_net(feat)\n       pi = tf.clip_by_value(mu + self.action_noise(), -1, 1)\n   else:\n       logits = self.actor_net(feat)\n       logp_all = tf.nn.log_softmax(logits)\n       gumbel_noise = tf.cast(self.gumbel_dist.sample([batch_size, self.a_counts]), dtype=tf.float32)\n       _pi = tf.nn.softmax((logp_all + gumbel_noise) / self.discrete_tau)\n       _pi_true_one_hot = tf.one_hot(tf.argmax(_pi, axis=-1), self.a_counts)\n       _pi_diff = tf.stop_gradient(_pi_true_one_hot - _pi)\n       pi = _pi_diff + _pi\n   q_actor = self.q_net(feat, pi)\n   ```\n\n   现在的版本是：\n\n   ```python\n   if self.is_continuous:\n       mu = self.actor_net(feat)\n   else:\n       logits = self.actor_net(feat)\n       _pi = tf.nn.softmax(logits)\n       _pi_true_one_hot = tf.one_hot(tf.argmax(logits, axis=-1), self.a_counts, dtype=tf.float32)\n       _pi_diff = tf.stop_gradient(_pi_true_one_hot - _pi)\n       mu = _pi_diff + _pi\n   q_actor = self.q_net(feat, mu)\n   ```\n\n   \n\n2. ","slug":"rl-code-pit","published":1,"updated":"2020-05-21T09:38:42.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusyk001l20cdizuekyjq","content":"<p>本博客用于记录在RL学习过程中踩过的坑点。</p>\n<a id=\"more\"></a>\n<hr>\n<ol>\n<li><p>确定性策略梯度算法如DPG、DDPG、TD3等在优化Actor网络时是否引入动作噪声</p>\n<p><strong>通过大量实验发现，在重新选择动作优化Actor网络时不需要引入噪声，直接使用确定性动作即可，引入噪声会影响算法的性能，甚至导致策略不收敛，这是当我在调试分层强化学习算法HIRO时发现的。</strong></p>\n<p>之前的版本是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> self.is_continuous:</span><br><span class=\"line\">    mu = self.actor_net(feat)</span><br><span class=\"line\">    pi = tf.clip_by_value(mu + self.action_noise(), <span class=\"number\">-1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    logits = self.actor_net(feat)</span><br><span class=\"line\">    logp_all = tf.nn.log_softmax(logits)</span><br><span class=\"line\">    gumbel_noise = tf.cast(self.gumbel_dist.sample([batch_size, self.a_counts]), dtype=tf.float32)</span><br><span class=\"line\">    _pi = tf.nn.softmax((logp_all + gumbel_noise) / self.discrete_tau)</span><br><span class=\"line\">    _pi_true_one_hot = tf.one_hot(tf.argmax(_pi, axis=<span class=\"number\">-1</span>), self.a_counts)</span><br><span class=\"line\">    _pi_diff = tf.stop_gradient(_pi_true_one_hot - _pi)</span><br><span class=\"line\">    pi = _pi_diff + _pi</span><br><span class=\"line\">q_actor = self.q_net(feat, pi)</span><br></pre></td></tr></table></figure>\n<p>现在的版本是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> self.is_continuous:</span><br><span class=\"line\">    mu = self.actor_net(feat)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    logits = self.actor_net(feat)</span><br><span class=\"line\">    _pi = tf.nn.softmax(logits)</span><br><span class=\"line\">    _pi_true_one_hot = tf.one_hot(tf.argmax(logits, axis=<span class=\"number\">-1</span>), self.a_counts, dtype=tf.float32)</span><br><span class=\"line\">    _pi_diff = tf.stop_gradient(_pi_true_one_hot - _pi)</span><br><span class=\"line\">    mu = _pi_diff + _pi</span><br><span class=\"line\">q_actor = self.q_net(feat, mu)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>2. </p>\n","site":{"data":{}},"excerpt":"<p>本博客用于记录在RL学习过程中踩过的坑点。</p>","more":"<hr>\n<ol>\n<li><p>确定性策略梯度算法如DPG、DDPG、TD3等在优化Actor网络时是否引入动作噪声</p>\n<p><strong>通过大量实验发现，在重新选择动作优化Actor网络时不需要引入噪声，直接使用确定性动作即可，引入噪声会影响算法的性能，甚至导致策略不收敛，这是当我在调试分层强化学习算法HIRO时发现的。</strong></p>\n<p>之前的版本是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> self.is_continuous:</span><br><span class=\"line\">    mu = self.actor_net(feat)</span><br><span class=\"line\">    pi = tf.clip_by_value(mu + self.action_noise(), <span class=\"number\">-1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    logits = self.actor_net(feat)</span><br><span class=\"line\">    logp_all = tf.nn.log_softmax(logits)</span><br><span class=\"line\">    gumbel_noise = tf.cast(self.gumbel_dist.sample([batch_size, self.a_counts]), dtype=tf.float32)</span><br><span class=\"line\">    _pi = tf.nn.softmax((logp_all + gumbel_noise) / self.discrete_tau)</span><br><span class=\"line\">    _pi_true_one_hot = tf.one_hot(tf.argmax(_pi, axis=<span class=\"number\">-1</span>), self.a_counts)</span><br><span class=\"line\">    _pi_diff = tf.stop_gradient(_pi_true_one_hot - _pi)</span><br><span class=\"line\">    pi = _pi_diff + _pi</span><br><span class=\"line\">q_actor = self.q_net(feat, pi)</span><br></pre></td></tr></table></figure>\n<p>现在的版本是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> self.is_continuous:</span><br><span class=\"line\">    mu = self.actor_net(feat)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    logits = self.actor_net(feat)</span><br><span class=\"line\">    _pi = tf.nn.softmax(logits)</span><br><span class=\"line\">    _pi_true_one_hot = tf.one_hot(tf.argmax(logits, axis=<span class=\"number\">-1</span>), self.a_counts, dtype=tf.float32)</span><br><span class=\"line\">    _pi_diff = tf.stop_gradient(_pi_true_one_hot - _pi)</span><br><span class=\"line\">    mu = _pi_diff + _pi</span><br><span class=\"line\">q_actor = self.q_net(feat, mu)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>2. </p>"},{"title":"RL^2|Fast Reinforcement Learning vis Slow Reinforcement Learning","copyright":true,"mathjax":true,"top":1,"date":"2019-05-31T03:26:39.000Z","keywords":null,"description":null,"_content":"\n本文引用了元学习在深度学习领域的思想，在多任务中训练一个通用模型——slow，用这个通用模型拓展到其他任务进行训练就会快很多，得到新模型——fast。本文中的模型使用RNN作为训练模型。\n\n推荐程度：中等偏下\n\n- 可以拓宽知识面，了解众家思想\n- 我个人认为，这样的元学习并没有达到让机器”学会如何学习的学习方法“的目的，即“learning to learn”\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1611.02779.pdf](https://arxiv.org/pdf/1611.02779.pdf)\n\n深度强化学习被成功运用在许多复杂行为学习当中，但是需要很多很多很多试错才能得出一个较好的模型，但是动物学习知识只需要一小会儿，就像骑自行车和骑电瓶车，人可能学会骑自行车后5分钟就可以学会骑电瓶车，但是机器却要重头学起，1小时也未必学得会、学得好，这就是因为动物具有先验知识指导，而且可以利用先验知识，机器却不可以。\n\n把先验知识融入到强化学习算法中过去已经被探索了很多次，而且也有几种不同的形式：\n\n- 自动调超参数，学习率等\n- 使用分层贝叶斯方法在动力学模型上保持后验，并根据后验应用Thompson采样\n- 许多分层强化学习的工作都提出从以前的任务中提取可重用的技能，以加快对新任务的探索\n\n本文中的RNN即充当智能体的元学习者，也充当决策者，即生成策略\n\n以往强化学习算法把学习一个策略当成要解决的问题，本文却把学习强化学习算法当成要解决的问题。很绕对吧，其实本质上就是使用RNN表示策略，加了点深度学习中元学习的思想。\n\n本文提出的方法是：\n\n>we view the learning process of the agent itself as an objective, which can be optimized using standard reinforcement learning algorithms. The objective is averaged across all possible MDPs according to a specific distribution, which reflects the prior that we would like to distill into the agent.  \n\n即，智能体的学习过程看做目标，用标准强化学习算法进行优化。然后使用RNN处理多个MDP问题，提取先验知识到智能体。\n\n*注：我个人觉得这根本不能算是真正意义上的元学习，机器还是个傻子。*\n\n# 正文\n\n训练的流程图如下：\n\n![](./rl2/meta.png)\n\n解析：\n\n- 在这种训练方式下，需要来回切换任务，即切换MDP过程\n- 每个trail代表一个MDP过程\n- MDP需要从MDPs分布$\\rho_{\\mathcal{M}} : \\mathcal{M} \\rightarrow \\mathbb{R}_{+}$中采样，至于$\\mathbb{R}_{+}$是什么，我不知道\n- 在每个trial中训练多个episode，个数用$n$表示，图示表示$n=2$\n- $h$代表RNN网络中的知识参数\n- 同一个trial中$h$可以传承，**但是**，当切换MDP问题，即进行下一个trail时，参数$h$需要重新初始化\n- 输入不是单纯的状态$s$，而是$\\left ( s_{t+1},a_{t},r_{t},d_{t} \\right )$，其中，$d_{t}$代表episode结束的标志，输出为动作$a_{t+1}$。（输入往往需要embed为$\\phi(s, a, r, d)$）\n- 训练过程的目标**不是最大化一个episode的累计奖励，而是最大化一个trial的累计奖励**\n\n深度学习中元学习有K-shot N-class问题，即N个类，每类K个样本，（本文）强化学习中元学习可以表示为N-episode M-MDPs问题，即共有M个trial，每个trial训练N个episode\n\n---\n\n策略表示：\n\n- RNN使用GRUs（Gated Recurrent Units）\n- 输入为$\\phi(s, a, r, d)$\n\n策略优化：\n\n- TRPO，原因：性能出色，不需要大量调参\n- 使用baseline减小方差\n- 考虑使用了GAE\n\n测试结果：\n\n- MDP问题：在多臂老虎机和网格MDPs任务中，与理论上合理的算法（没有指出是哪些算法）性能相当\n- POMDP问题：图像输入的导航任务中，实验表明，智能体能够有效地利用学习到的视觉信息和以往情景中获得的短期信息。实验结果视频：[https://goo.gl/rDDBpb](https://goo.gl/rDDBpb)\n\n# 个人见解\n\n我认为这样的元强化学习根本不能实现提出元学习的初衷。说到底，这种方式只是让一个“一面白纸”的模型可以学习成多种任务的通用基础模型（slow），然后在使用这个基础模型对其他任务进行训练时可以快速训练出结果（fast）。这种方式可以加速学习，但是却并不能使机器学会去学习，学会如何进行学习的方法，虽然意义上说让智能体学到了强化学习算法的过程，其实本质上是使智能体学到了多种MDP任务中的经验，寻找一个易于根据MDP任务最优化的通用模型，并把它转换为“记忆，而没有教会机器”记忆“这个过程。\n\n（WTF？RNN训练智能体+多任务切换+更改网络输入+任务级目标函数 这就是元强化学习啦？？？）\n\n![](./rl2/meta-rl.png)\n\n","source":"_posts/rl2.md","raw":"---\ntitle: RL^2|Fast Reinforcement Learning vis Slow Reinforcement Learning\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2019-05-31 11:26:39\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n本文引用了元学习在深度学习领域的思想，在多任务中训练一个通用模型——slow，用这个通用模型拓展到其他任务进行训练就会快很多，得到新模型——fast。本文中的模型使用RNN作为训练模型。\n\n推荐程度：中等偏下\n\n- 可以拓宽知识面，了解众家思想\n- 我个人认为，这样的元学习并没有达到让机器”学会如何学习的学习方法“的目的，即“learning to learn”\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1611.02779.pdf](https://arxiv.org/pdf/1611.02779.pdf)\n\n深度强化学习被成功运用在许多复杂行为学习当中，但是需要很多很多很多试错才能得出一个较好的模型，但是动物学习知识只需要一小会儿，就像骑自行车和骑电瓶车，人可能学会骑自行车后5分钟就可以学会骑电瓶车，但是机器却要重头学起，1小时也未必学得会、学得好，这就是因为动物具有先验知识指导，而且可以利用先验知识，机器却不可以。\n\n把先验知识融入到强化学习算法中过去已经被探索了很多次，而且也有几种不同的形式：\n\n- 自动调超参数，学习率等\n- 使用分层贝叶斯方法在动力学模型上保持后验，并根据后验应用Thompson采样\n- 许多分层强化学习的工作都提出从以前的任务中提取可重用的技能，以加快对新任务的探索\n\n本文中的RNN即充当智能体的元学习者，也充当决策者，即生成策略\n\n以往强化学习算法把学习一个策略当成要解决的问题，本文却把学习强化学习算法当成要解决的问题。很绕对吧，其实本质上就是使用RNN表示策略，加了点深度学习中元学习的思想。\n\n本文提出的方法是：\n\n>we view the learning process of the agent itself as an objective, which can be optimized using standard reinforcement learning algorithms. The objective is averaged across all possible MDPs according to a specific distribution, which reflects the prior that we would like to distill into the agent.  \n\n即，智能体的学习过程看做目标，用标准强化学习算法进行优化。然后使用RNN处理多个MDP问题，提取先验知识到智能体。\n\n*注：我个人觉得这根本不能算是真正意义上的元学习，机器还是个傻子。*\n\n# 正文\n\n训练的流程图如下：\n\n![](./rl2/meta.png)\n\n解析：\n\n- 在这种训练方式下，需要来回切换任务，即切换MDP过程\n- 每个trail代表一个MDP过程\n- MDP需要从MDPs分布$\\rho_{\\mathcal{M}} : \\mathcal{M} \\rightarrow \\mathbb{R}_{+}$中采样，至于$\\mathbb{R}_{+}$是什么，我不知道\n- 在每个trial中训练多个episode，个数用$n$表示，图示表示$n=2$\n- $h$代表RNN网络中的知识参数\n- 同一个trial中$h$可以传承，**但是**，当切换MDP问题，即进行下一个trail时，参数$h$需要重新初始化\n- 输入不是单纯的状态$s$，而是$\\left ( s_{t+1},a_{t},r_{t},d_{t} \\right )$，其中，$d_{t}$代表episode结束的标志，输出为动作$a_{t+1}$。（输入往往需要embed为$\\phi(s, a, r, d)$）\n- 训练过程的目标**不是最大化一个episode的累计奖励，而是最大化一个trial的累计奖励**\n\n深度学习中元学习有K-shot N-class问题，即N个类，每类K个样本，（本文）强化学习中元学习可以表示为N-episode M-MDPs问题，即共有M个trial，每个trial训练N个episode\n\n---\n\n策略表示：\n\n- RNN使用GRUs（Gated Recurrent Units）\n- 输入为$\\phi(s, a, r, d)$\n\n策略优化：\n\n- TRPO，原因：性能出色，不需要大量调参\n- 使用baseline减小方差\n- 考虑使用了GAE\n\n测试结果：\n\n- MDP问题：在多臂老虎机和网格MDPs任务中，与理论上合理的算法（没有指出是哪些算法）性能相当\n- POMDP问题：图像输入的导航任务中，实验表明，智能体能够有效地利用学习到的视觉信息和以往情景中获得的短期信息。实验结果视频：[https://goo.gl/rDDBpb](https://goo.gl/rDDBpb)\n\n# 个人见解\n\n我认为这样的元强化学习根本不能实现提出元学习的初衷。说到底，这种方式只是让一个“一面白纸”的模型可以学习成多种任务的通用基础模型（slow），然后在使用这个基础模型对其他任务进行训练时可以快速训练出结果（fast）。这种方式可以加速学习，但是却并不能使机器学会去学习，学会如何进行学习的方法，虽然意义上说让智能体学到了强化学习算法的过程，其实本质上是使智能体学到了多种MDP任务中的经验，寻找一个易于根据MDP任务最优化的通用模型，并把它转换为“记忆，而没有教会机器”记忆“这个过程。\n\n（WTF？RNN训练智能体+多任务切换+更改网络输入+任务级目标函数 这就是元强化学习啦？？？）\n\n![](./rl2/meta-rl.png)\n\n","slug":"rl2","published":1,"updated":"2019-06-02T01:19:23.071Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusym001o20cdsq43wi4f","content":"<p>本文引用了元学习在深度学习领域的思想，在多任务中训练一个通用模型——slow，用这个通用模型拓展到其他任务进行训练就会快很多，得到新模型——fast。本文中的模型使用RNN作为训练模型。</p>\n<p>推荐程度：中等偏下</p>\n<ul>\n<li>可以拓宽知识面，了解众家思想</li>\n<li>我个人认为，这样的元学习并没有达到让机器”学会如何学习的学习方法“的目的，即“learning to learn”</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1611.02779.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1611.02779.pdf</a></p>\n<p>深度强化学习被成功运用在许多复杂行为学习当中，但是需要很多很多很多试错才能得出一个较好的模型，但是动物学习知识只需要一小会儿，就像骑自行车和骑电瓶车，人可能学会骑自行车后5分钟就可以学会骑电瓶车，但是机器却要重头学起，1小时也未必学得会、学得好，这就是因为动物具有先验知识指导，而且可以利用先验知识，机器却不可以。</p>\n<p>把先验知识融入到强化学习算法中过去已经被探索了很多次，而且也有几种不同的形式：</p>\n<ul>\n<li>自动调超参数，学习率等</li>\n<li>使用分层贝叶斯方法在动力学模型上保持后验，并根据后验应用Thompson采样</li>\n<li>许多分层强化学习的工作都提出从以前的任务中提取可重用的技能，以加快对新任务的探索</li>\n</ul>\n<p>本文中的RNN即充当智能体的元学习者，也充当决策者，即生成策略</p>\n<p>以往强化学习算法把学习一个策略当成要解决的问题，本文却把学习强化学习算法当成要解决的问题。很绕对吧，其实本质上就是使用RNN表示策略，加了点深度学习中元学习的思想。</p>\n<p>本文提出的方法是：</p>\n<blockquote>\n<p>we view the learning process of the agent itself as an objective, which can be optimized using standard reinforcement learning algorithms. The objective is averaged across all possible MDPs according to a specific distribution, which reflects the prior that we would like to distill into the agent.  </p>\n</blockquote>\n<p>即，智能体的学习过程看做目标，用标准强化学习算法进行优化。然后使用RNN处理多个MDP问题，提取先验知识到智能体。</p>\n<p><em>注：我个人觉得这根本不能算是真正意义上的元学习，机器还是个傻子。</em></p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><p>训练的流程图如下：</p>\n<p><img src=\"./rl2/meta.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>在这种训练方式下，需要来回切换任务，即切换MDP过程</li>\n<li>每个trail代表一个MDP过程</li>\n<li>MDP需要从MDPs分布$\\rho_{\\mathcal{M}} : \\mathcal{M} \\rightarrow \\mathbb{R}_{+}$中采样，至于$\\mathbb{R}_{+}$是什么，我不知道</li>\n<li>在每个trial中训练多个episode，个数用$n$表示，图示表示$n=2$</li>\n<li>$h$代表RNN网络中的知识参数</li>\n<li>同一个trial中$h$可以传承，<strong>但是</strong>，当切换MDP问题，即进行下一个trail时，参数$h$需要重新初始化</li>\n<li>输入不是单纯的状态$s$，而是$\\left ( s_{t+1},a_{t},r_{t},d_{t} \\right )$，其中，$d_{t}$代表episode结束的标志，输出为动作$a_{t+1}$。（输入往往需要embed为$\\phi(s, a, r, d)$）</li>\n<li>训练过程的目标<strong>不是最大化一个episode的累计奖励，而是最大化一个trial的累计奖励</strong></li>\n</ul>\n<p>深度学习中元学习有K-shot N-class问题，即N个类，每类K个样本，（本文）强化学习中元学习可以表示为N-episode M-MDPs问题，即共有M个trial，每个trial训练N个episode</p>\n<hr>\n<p>策略表示：</p>\n<ul>\n<li>RNN使用GRUs（Gated Recurrent Units）</li>\n<li>输入为$\\phi(s, a, r, d)$</li>\n</ul>\n<p>策略优化：</p>\n<ul>\n<li>TRPO，原因：性能出色，不需要大量调参</li>\n<li>使用baseline减小方差</li>\n<li>考虑使用了GAE</li>\n</ul>\n<p>测试结果：</p>\n<ul>\n<li>MDP问题：在多臂老虎机和网格MDPs任务中，与理论上合理的算法（没有指出是哪些算法）性能相当</li>\n<li>POMDP问题：图像输入的导航任务中，实验表明，智能体能够有效地利用学习到的视觉信息和以往情景中获得的短期信息。实验结果视频：<a href=\"https://goo.gl/rDDBpb\" rel=\"external nofollow\" target=\"_blank\">https://goo.gl/rDDBpb</a></li>\n</ul>\n<h1 id=\"个人见解\"><a href=\"#个人见解\" class=\"headerlink\" title=\"个人见解\"></a>个人见解</h1><p>我认为这样的元强化学习根本不能实现提出元学习的初衷。说到底，这种方式只是让一个“一面白纸”的模型可以学习成多种任务的通用基础模型（slow），然后在使用这个基础模型对其他任务进行训练时可以快速训练出结果（fast）。这种方式可以加速学习，但是却并不能使机器学会去学习，学会如何进行学习的方法，虽然意义上说让智能体学到了强化学习算法的过程，其实本质上是使智能体学到了多种MDP任务中的经验，寻找一个易于根据MDP任务最优化的通用模型，并把它转换为“记忆，而没有教会机器”记忆“这个过程。</p>\n<p>（WTF？RNN训练智能体+多任务切换+更改网络输入+任务级目标函数 这就是元强化学习啦？？？）</p>\n<p><img src=\"./rl2/meta-rl.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>本文引用了元学习在深度学习领域的思想，在多任务中训练一个通用模型——slow，用这个通用模型拓展到其他任务进行训练就会快很多，得到新模型——fast。本文中的模型使用RNN作为训练模型。</p>\n<p>推荐程度：中等偏下</p>\n<ul>\n<li>可以拓宽知识面，了解众家思想</li>\n<li>我个人认为，这样的元学习并没有达到让机器”学会如何学习的学习方法“的目的，即“learning to learn”</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1611.02779.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1611.02779.pdf</a></p>\n<p>深度强化学习被成功运用在许多复杂行为学习当中，但是需要很多很多很多试错才能得出一个较好的模型，但是动物学习知识只需要一小会儿，就像骑自行车和骑电瓶车，人可能学会骑自行车后5分钟就可以学会骑电瓶车，但是机器却要重头学起，1小时也未必学得会、学得好，这就是因为动物具有先验知识指导，而且可以利用先验知识，机器却不可以。</p>\n<p>把先验知识融入到强化学习算法中过去已经被探索了很多次，而且也有几种不同的形式：</p>\n<ul>\n<li>自动调超参数，学习率等</li>\n<li>使用分层贝叶斯方法在动力学模型上保持后验，并根据后验应用Thompson采样</li>\n<li>许多分层强化学习的工作都提出从以前的任务中提取可重用的技能，以加快对新任务的探索</li>\n</ul>\n<p>本文中的RNN即充当智能体的元学习者，也充当决策者，即生成策略</p>\n<p>以往强化学习算法把学习一个策略当成要解决的问题，本文却把学习强化学习算法当成要解决的问题。很绕对吧，其实本质上就是使用RNN表示策略，加了点深度学习中元学习的思想。</p>\n<p>本文提出的方法是：</p>\n<blockquote>\n<p>we view the learning process of the agent itself as an objective, which can be optimized using standard reinforcement learning algorithms. The objective is averaged across all possible MDPs according to a specific distribution, which reflects the prior that we would like to distill into the agent.  </p>\n</blockquote>\n<p>即，智能体的学习过程看做目标，用标准强化学习算法进行优化。然后使用RNN处理多个MDP问题，提取先验知识到智能体。</p>\n<p><em>注：我个人觉得这根本不能算是真正意义上的元学习，机器还是个傻子。</em></p>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><p>训练的流程图如下：</p>\n<p><img src=\"./rl2/meta.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>在这种训练方式下，需要来回切换任务，即切换MDP过程</li>\n<li>每个trail代表一个MDP过程</li>\n<li>MDP需要从MDPs分布$\\rho_{\\mathcal{M}} : \\mathcal{M} \\rightarrow \\mathbb{R}_{+}$中采样，至于$\\mathbb{R}_{+}$是什么，我不知道</li>\n<li>在每个trial中训练多个episode，个数用$n$表示，图示表示$n=2$</li>\n<li>$h$代表RNN网络中的知识参数</li>\n<li>同一个trial中$h$可以传承，<strong>但是</strong>，当切换MDP问题，即进行下一个trail时，参数$h$需要重新初始化</li>\n<li>输入不是单纯的状态$s$，而是$\\left ( s_{t+1},a_{t},r_{t},d_{t} \\right )$，其中，$d_{t}$代表episode结束的标志，输出为动作$a_{t+1}$。（输入往往需要embed为$\\phi(s, a, r, d)$）</li>\n<li>训练过程的目标<strong>不是最大化一个episode的累计奖励，而是最大化一个trial的累计奖励</strong></li>\n</ul>\n<p>深度学习中元学习有K-shot N-class问题，即N个类，每类K个样本，（本文）强化学习中元学习可以表示为N-episode M-MDPs问题，即共有M个trial，每个trial训练N个episode</p>\n<hr>\n<p>策略表示：</p>\n<ul>\n<li>RNN使用GRUs（Gated Recurrent Units）</li>\n<li>输入为$\\phi(s, a, r, d)$</li>\n</ul>\n<p>策略优化：</p>\n<ul>\n<li>TRPO，原因：性能出色，不需要大量调参</li>\n<li>使用baseline减小方差</li>\n<li>考虑使用了GAE</li>\n</ul>\n<p>测试结果：</p>\n<ul>\n<li>MDP问题：在多臂老虎机和网格MDPs任务中，与理论上合理的算法（没有指出是哪些算法）性能相当</li>\n<li>POMDP问题：图像输入的导航任务中，实验表明，智能体能够有效地利用学习到的视觉信息和以往情景中获得的短期信息。实验结果视频：<a href=\"https://goo.gl/rDDBpb\" rel=\"external nofollow\" target=\"_blank\">https://goo.gl/rDDBpb</a></li>\n</ul>\n<h1 id=\"个人见解\"><a href=\"#个人见解\" class=\"headerlink\" title=\"个人见解\"></a>个人见解</h1><p>我认为这样的元强化学习根本不能实现提出元学习的初衷。说到底，这种方式只是让一个“一面白纸”的模型可以学习成多种任务的通用基础模型（slow），然后在使用这个基础模型对其他任务进行训练时可以快速训练出结果（fast）。这种方式可以加速学习，但是却并不能使机器学会去学习，学会如何进行学习的方法，虽然意义上说让智能体学到了强化学习算法的过程，其实本质上是使智能体学到了多种MDP任务中的经验，寻找一个易于根据MDP任务最优化的通用模型，并把它转换为“记忆，而没有教会机器”记忆“这个过程。</p>\n<p>（WTF？RNN训练智能体+多任务切换+更改网络输入+任务级目标函数 这就是元强化学习啦？？？）</p>\n<p><img src=\"./rl2/meta-rl.png\" alt=\"\"></p>"},{"title":"蓝猫淘气三千问","copyright":true,"mathjax":true,"top":1,"date":"2020-04-12T10:31:27.000Z","keywords":null,"description":null,"_content":"\n此篇博文用于记录学习RL或者实现RL方法过程中遇到疑难杂症及相应解决思路。\n\n<!--more-->\n\n# 待解决\n\n1. 如果场景中存在多个图像输入，而且维度不一致，该如何处理呢？假设有汽车有前后两个摄像头，分辨率分别是$Vis_1=10\\times10\\times3$和$Vis_2=15\\times5\\times3$，那么该如何设计图像处理过程呢？是表示成$(CNN_1(Vis_1), CNN_2(Vis_2))$呢？还是表示成$CNN(Concat(Vis_1, Resize(Vis_2)))$呢？\n2. 如果智能体的动作既包括离散的也包括连续的，该如何处理？\n3. 在DQN系列中，经常提及过估计(over-estimation)问题，这个过估计究竟指的是什么过估计？怎样过估计？为何过估计？过估计有什么后果？\n\n# 已解决\n\n1. 什么是Semi-Markov Decision Process(SMDP)？\n\n   [原链接](https://zhuanlan.zhihu.com/p/47051292)。分层强化学习里面，这里的上层策略其实是定义在一个SMDP上的，引用一下俞扬老师文章里面的一句话来解释一下。\n\n   > 马尔可夫决策过程中，选择一个动作后，agent 会立刻根据状态转移方程$P$跳转到下一个状态，而在半马尔可夫决策过程(SMDP)中，当前状态到下一个状态的步数是个随机变量 $\\tau$ ， 即在某个状态$s$下选择一个动作$a$后，经过$\\tau$步才会以一个概率转移到下一个状态$s'$。 此时的状态转移概率是$s$和$\\tau$的联合概率$P\\left(s^{\\prime}, \\tau | s, a\\right)$。\n\n   文献：周文吉, and 俞扬. \"分层强化学习综述.\"*智能系统学报*12.5 (2017): 590-594.\n\n","source":"_posts/rl3000questions.md","raw":"---\ntitle: 蓝猫淘气三千问\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-04-12 18:31:27\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n此篇博文用于记录学习RL或者实现RL方法过程中遇到疑难杂症及相应解决思路。\n\n<!--more-->\n\n# 待解决\n\n1. 如果场景中存在多个图像输入，而且维度不一致，该如何处理呢？假设有汽车有前后两个摄像头，分辨率分别是$Vis_1=10\\times10\\times3$和$Vis_2=15\\times5\\times3$，那么该如何设计图像处理过程呢？是表示成$(CNN_1(Vis_1), CNN_2(Vis_2))$呢？还是表示成$CNN(Concat(Vis_1, Resize(Vis_2)))$呢？\n2. 如果智能体的动作既包括离散的也包括连续的，该如何处理？\n3. 在DQN系列中，经常提及过估计(over-estimation)问题，这个过估计究竟指的是什么过估计？怎样过估计？为何过估计？过估计有什么后果？\n\n# 已解决\n\n1. 什么是Semi-Markov Decision Process(SMDP)？\n\n   [原链接](https://zhuanlan.zhihu.com/p/47051292)。分层强化学习里面，这里的上层策略其实是定义在一个SMDP上的，引用一下俞扬老师文章里面的一句话来解释一下。\n\n   > 马尔可夫决策过程中，选择一个动作后，agent 会立刻根据状态转移方程$P$跳转到下一个状态，而在半马尔可夫决策过程(SMDP)中，当前状态到下一个状态的步数是个随机变量 $\\tau$ ， 即在某个状态$s$下选择一个动作$a$后，经过$\\tau$步才会以一个概率转移到下一个状态$s'$。 此时的状态转移概率是$s$和$\\tau$的联合概率$P\\left(s^{\\prime}, \\tau | s, a\\right)$。\n\n   文献：周文吉, and 俞扬. \"分层强化学习综述.\"*智能系统学报*12.5 (2017): 590-594.\n\n","slug":"rl3000questions","published":1,"updated":"2020-04-27T13:29:04.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusyn001r20cd1dhnffyg","content":"<p>此篇博文用于记录学习RL或者实现RL方法过程中遇到疑难杂症及相应解决思路。</p>\n<a id=\"more\"></a>\n<h1 id=\"待解决\"><a href=\"#待解决\" class=\"headerlink\" title=\"待解决\"></a>待解决</h1><ol>\n<li>如果场景中存在多个图像输入，而且维度不一致，该如何处理呢？假设有汽车有前后两个摄像头，分辨率分别是$Vis_1=10\\times10\\times3$和$Vis_2=15\\times5\\times3$，那么该如何设计图像处理过程呢？是表示成$(CNN_1(Vis_1), CNN_2(Vis_2))$呢？还是表示成$CNN(Concat(Vis_1, Resize(Vis_2)))$呢？</li>\n<li>如果智能体的动作既包括离散的也包括连续的，该如何处理？</li>\n<li>在DQN系列中，经常提及过估计(over-estimation)问题，这个过估计究竟指的是什么过估计？怎样过估计？为何过估计？过估计有什么后果？</li>\n</ol>\n<h1 id=\"已解决\"><a href=\"#已解决\" class=\"headerlink\" title=\"已解决\"></a>已解决</h1><ol>\n<li><p>什么是Semi-Markov Decision Process(SMDP)？</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/47051292\" rel=\"external nofollow\" target=\"_blank\">原链接</a>。分层强化学习里面，这里的上层策略其实是定义在一个SMDP上的，引用一下俞扬老师文章里面的一句话来解释一下。</p>\n<blockquote>\n<p>马尔可夫决策过程中，选择一个动作后，agent 会立刻根据状态转移方程$P$跳转到下一个状态，而在半马尔可夫决策过程(SMDP)中，当前状态到下一个状态的步数是个随机变量 $\\tau$ ， 即在某个状态$s$下选择一个动作$a$后，经过$\\tau$步才会以一个概率转移到下一个状态$s’$。 此时的状态转移概率是$s$和$\\tau$的联合概率$P\\left(s^{\\prime}, \\tau | s, a\\right)$。</p>\n</blockquote>\n<p>文献：周文吉, and 俞扬. “分层强化学习综述.”<em>智能系统学报</em>12.5 (2017): 590-594.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>此篇博文用于记录学习RL或者实现RL方法过程中遇到疑难杂症及相应解决思路。</p>","more":"<h1 id=\"待解决\"><a href=\"#待解决\" class=\"headerlink\" title=\"待解决\"></a>待解决</h1><ol>\n<li>如果场景中存在多个图像输入，而且维度不一致，该如何处理呢？假设有汽车有前后两个摄像头，分辨率分别是$Vis_1=10\\times10\\times3$和$Vis_2=15\\times5\\times3$，那么该如何设计图像处理过程呢？是表示成$(CNN_1(Vis_1), CNN_2(Vis_2))$呢？还是表示成$CNN(Concat(Vis_1, Resize(Vis_2)))$呢？</li>\n<li>如果智能体的动作既包括离散的也包括连续的，该如何处理？</li>\n<li>在DQN系列中，经常提及过估计(over-estimation)问题，这个过估计究竟指的是什么过估计？怎样过估计？为何过估计？过估计有什么后果？</li>\n</ol>\n<h1 id=\"已解决\"><a href=\"#已解决\" class=\"headerlink\" title=\"已解决\"></a>已解决</h1><ol>\n<li><p>什么是Semi-Markov Decision Process(SMDP)？</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/47051292\" rel=\"external nofollow\" target=\"_blank\">原链接</a>。分层强化学习里面，这里的上层策略其实是定义在一个SMDP上的，引用一下俞扬老师文章里面的一句话来解释一下。</p>\n<blockquote>\n<p>马尔可夫决策过程中，选择一个动作后，agent 会立刻根据状态转移方程$P$跳转到下一个状态，而在半马尔可夫决策过程(SMDP)中，当前状态到下一个状态的步数是个随机变量 $\\tau$ ， 即在某个状态$s$下选择一个动作$a$后，经过$\\tau$步才会以一个概率转移到下一个状态$s’$。 此时的状态转移概率是$s$和$\\tau$的联合概率$P\\left(s^{\\prime}, \\tau | s, a\\right)$。</p>\n</blockquote>\n<p>文献：周文吉, and 俞扬. “分层强化学习综述.”<em>智能系统学报</em>12.5 (2017): 590-594.</p>\n</li>\n</ol>"},{"title":"SARSA and Q-Learning","copyright":true,"mathjax":true,"password":123,"top":1,"date":"2019-05-13T12:44:45.000Z","keywords":null,"description":null,"_content":"\n本文介绍了两个强化学习中解决Model-Free问题的最经典算法：SARSA和Q-Learning，这两个算法也是On-Policy与Off-Policy的分水岭。\n\n<!--more-->\n\n","source":"_posts/sarsa-and-q-learning.md","raw":"---\ntitle: SARSA and Q-Learning\ncopyright: true\nmathjax: true\npassword: 123\ntop: 1\ndate: 2019-05-13 20:44:45\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n本文介绍了两个强化学习中解决Model-Free问题的最经典算法：SARSA和Q-Learning，这两个算法也是On-Policy与Off-Policy的分水岭。\n\n<!--more-->\n\n","slug":"sarsa-and-q-learning","published":1,"updated":"2019-05-13T14:27:05.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusyr001v20cdtpd25hkh","content":"<p>本文介绍了两个强化学习中解决Model-Free问题的最经典算法：SARSA和Q-Learning，这两个算法也是On-Policy与Off-Policy的分水岭。</p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<p>本文介绍了两个强化学习中解决Model-Free问题的最经典算法：SARSA和Q-Learning，这两个算法也是On-Policy与Off-Policy的分水岭。</p>","more":""},{"title":"一些在Docker中比较难以安装的库(整理)","copyright":true,"top":1,"date":"2019-03-24T10:57:50.000Z","_content":"\n本文记录了一些在Docker中比较难以安装、频繁报错的库，如cuda、cudnn。\n\n<!--more-->\n\n# 前言\n在配置镜像时, **强烈建议将源更改为国内镜像站**, 因为国外有些镜像站链接速度很慢, 更新也很慢, 很多库无法正确安装\n\n我所使用的镜像站为`sources.list`:\n\n```\ndeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties\ndeb http://archive.canonical.com/ubuntu xenial partner\ndeb-src http://archive.canonical.com/ubuntu xenial partner\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse\n```\n在`Dockerfile`或者在容器内使用命令\n```\nRUN cp /etc/apt/sources.list /etc/apt/sources.list.bak\nCOPY sources.list /etc/apt/sources.list\n```\n将源替换.\n\n# CUDA 9.0 开发者版\n`dockerfile`如下:\n```\nFROM nvidia/cuda:9.0-runtime-ubuntu16.04\nLABEL maintainer \"Keavnn <https://stepneverstop.github.io>\"\n\nRUN apt-get update && apt-get install -y --allow-unauthenticated --no-install-recommends \\\n        cuda-libraries-dev-$CUDA_PKG_VERSION \\\n        cuda-nvml-dev-$CUDA_PKG_VERSION \\\n        cuda-minimal-build-$CUDA_PKG_VERSION \\\n        cuda-command-line-tools-$CUDA_PKG_VERSION \\\n        cuda-core-9-0=9.0.176.3-1 \\\n        cuda-cublas-dev-9-0=9.0.176.4-1 \\\n        libnccl-dev=$NCCL_VERSION-1+cuda9.0 && \\\n    rm -rf /var/lib/apt/lists/*\n\nENV LIBRARY_PATH /usr/local/cuda/lib64/stubs\n```\n**--allow-unauthenticated** 这句命令很重要, 不使用的话很有可能安装失败\n\n# cudnn 7.0.5\n- [https://developer.nvidia.com/rdp/cudnn-archive](https://developer.nvidia.com/rdp/cudnn-archive) 下载cuDNN Libraries for Linux,不要下载 Power 8\n- 把下载好的包上传到FTP服务器, 或者传输到容器内, 或者直接在容器中下载好\n- `cd`到包位置\n- `cp cudnn-9.0-linux-x64-v7.solitairetheme8 cudnn-9.0-linux-x64-v7.tgz`\n- `tar -xvf cudnn-9.0-linux-x64-v7.tgz`\n- `cp include/* /usr/local/cuda-9.0/include`\n- `cp lib64/* /usr/local/cuda-9.0/lib64`\n- `chmod a+r /usr/local/cuda-9.0/include/cudnn.h /usr/local/cuda-9.0/lib64/libcudnn*` **这一步如果cuda是base版本,则没有include文件夹,需要手动创建后再执行**\n- `export PATH=/usr/local/cuda-9.0/bin:$PATH`\n- `cd`到`/usr/local/cuda-9.0/lib64`\n- `nano ~/.bashrc`,关联环境变量\n- 在最后一行加入`export LD_LIBRARY_PATH=/home/cuda/lib64:$LD_LIBRARY_PATH`\n- `source ~/.bashrc`\n- `ldconfig -v`\n- 使用`cat /usr/local/cuda-9.0/include/cudnn.h | grep CUDNN_MAJOR -A 2` 查看cudnn版本\n![](./create-sniper-docker-image/Snipaste_2019-01-03_10-56-08.png)\n\n# jemalloc\n选择安装`jemalloc`,这个工具可以加速编译,碎片整理,具体请自行谷歌\n- `apt-get install autoconf`\n- `apt-get install automake`\n- `apt-get install libtool`\n- `git clone https://github.com/jemalloc/jemalloc.git`\n- `cd jemalloc`\n- `git checkout 4.5.0`安装4.5.0版本的jemalloc,5.x版本的有坑,深坑\n- `./autogen.sh`\n- `make`\n- `make install_bin install_include install_lib`,之所以不使用`make install`是因为会报错,如下: ![](./create-sniper-docker-image/Snipaste_2019-01-03_09-56-41.png)\n\n# Python3.6\n记得`sudo`\n- `apt-get install software-properties-common`\n- `add-apt-repository ppa:jonathonf/python-3.6`, 按`ENTER`\n- `apt-get update && apt-get install python3.6 -y`\n- 修改系统默认的`python`版本为3.6\n- `cd /usr/bin`, 保险起见,建议分两步\n- `rm python`\n- `ln -s python3.6m python`\n- 如需更新,`pip3 install --upgrade pip`, 8.1.1->19.0.3\n- `python -V`\n![](./something-hard-install-docker/1.png)\n\n","source":"_posts/something-hard-install-docker.md","raw":"---\ntitle: 一些在Docker中比较难以安装的库(整理)\ncopyright: true\ntop: 1\ndate: 2019-03-24 18:57:50\ncategories: Docker\ntags:\n- docker\n---\n\n本文记录了一些在Docker中比较难以安装、频繁报错的库，如cuda、cudnn。\n\n<!--more-->\n\n# 前言\n在配置镜像时, **强烈建议将源更改为国内镜像站**, 因为国外有些镜像站链接速度很慢, 更新也很慢, 很多库无法正确安装\n\n我所使用的镜像站为`sources.list`:\n\n```\ndeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties\ndeb http://archive.canonical.com/ubuntu xenial partner\ndeb-src http://archive.canonical.com/ubuntu xenial partner\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse\n```\n在`Dockerfile`或者在容器内使用命令\n```\nRUN cp /etc/apt/sources.list /etc/apt/sources.list.bak\nCOPY sources.list /etc/apt/sources.list\n```\n将源替换.\n\n# CUDA 9.0 开发者版\n`dockerfile`如下:\n```\nFROM nvidia/cuda:9.0-runtime-ubuntu16.04\nLABEL maintainer \"Keavnn <https://stepneverstop.github.io>\"\n\nRUN apt-get update && apt-get install -y --allow-unauthenticated --no-install-recommends \\\n        cuda-libraries-dev-$CUDA_PKG_VERSION \\\n        cuda-nvml-dev-$CUDA_PKG_VERSION \\\n        cuda-minimal-build-$CUDA_PKG_VERSION \\\n        cuda-command-line-tools-$CUDA_PKG_VERSION \\\n        cuda-core-9-0=9.0.176.3-1 \\\n        cuda-cublas-dev-9-0=9.0.176.4-1 \\\n        libnccl-dev=$NCCL_VERSION-1+cuda9.0 && \\\n    rm -rf /var/lib/apt/lists/*\n\nENV LIBRARY_PATH /usr/local/cuda/lib64/stubs\n```\n**--allow-unauthenticated** 这句命令很重要, 不使用的话很有可能安装失败\n\n# cudnn 7.0.5\n- [https://developer.nvidia.com/rdp/cudnn-archive](https://developer.nvidia.com/rdp/cudnn-archive) 下载cuDNN Libraries for Linux,不要下载 Power 8\n- 把下载好的包上传到FTP服务器, 或者传输到容器内, 或者直接在容器中下载好\n- `cd`到包位置\n- `cp cudnn-9.0-linux-x64-v7.solitairetheme8 cudnn-9.0-linux-x64-v7.tgz`\n- `tar -xvf cudnn-9.0-linux-x64-v7.tgz`\n- `cp include/* /usr/local/cuda-9.0/include`\n- `cp lib64/* /usr/local/cuda-9.0/lib64`\n- `chmod a+r /usr/local/cuda-9.0/include/cudnn.h /usr/local/cuda-9.0/lib64/libcudnn*` **这一步如果cuda是base版本,则没有include文件夹,需要手动创建后再执行**\n- `export PATH=/usr/local/cuda-9.0/bin:$PATH`\n- `cd`到`/usr/local/cuda-9.0/lib64`\n- `nano ~/.bashrc`,关联环境变量\n- 在最后一行加入`export LD_LIBRARY_PATH=/home/cuda/lib64:$LD_LIBRARY_PATH`\n- `source ~/.bashrc`\n- `ldconfig -v`\n- 使用`cat /usr/local/cuda-9.0/include/cudnn.h | grep CUDNN_MAJOR -A 2` 查看cudnn版本\n![](./create-sniper-docker-image/Snipaste_2019-01-03_10-56-08.png)\n\n# jemalloc\n选择安装`jemalloc`,这个工具可以加速编译,碎片整理,具体请自行谷歌\n- `apt-get install autoconf`\n- `apt-get install automake`\n- `apt-get install libtool`\n- `git clone https://github.com/jemalloc/jemalloc.git`\n- `cd jemalloc`\n- `git checkout 4.5.0`安装4.5.0版本的jemalloc,5.x版本的有坑,深坑\n- `./autogen.sh`\n- `make`\n- `make install_bin install_include install_lib`,之所以不使用`make install`是因为会报错,如下: ![](./create-sniper-docker-image/Snipaste_2019-01-03_09-56-41.png)\n\n# Python3.6\n记得`sudo`\n- `apt-get install software-properties-common`\n- `add-apt-repository ppa:jonathonf/python-3.6`, 按`ENTER`\n- `apt-get update && apt-get install python3.6 -y`\n- 修改系统默认的`python`版本为3.6\n- `cd /usr/bin`, 保险起见,建议分两步\n- `rm python`\n- `ln -s python3.6m python`\n- 如需更新,`pip3 install --upgrade pip`, 8.1.1->19.0.3\n- `python -V`\n![](./something-hard-install-docker/1.png)\n\n","slug":"something-hard-install-docker","published":1,"updated":"2019-05-13T14:27:05.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusyu001z20cd0ska3mt0","content":"<p>本文记录了一些在Docker中比较难以安装、频繁报错的库，如cuda、cudnn。</p>\n<a id=\"more\"></a>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在配置镜像时, <strong>强烈建议将源更改为国内镜像站</strong>, 因为国外有些镜像站链接速度很慢, 更新也很慢, 很多库无法正确安装</p>\n<p>我所使用的镜像站为<code>sources.list</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class=\"line\">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure>\n<p>在<code>Dockerfile</code>或者在容器内使用命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class=\"line\">COPY sources.list /etc/apt/sources.list</span><br></pre></td></tr></table></figure></p>\n<p>将源替换.</p>\n<h1 id=\"CUDA-9-0-开发者版\"><a href=\"#CUDA-9-0-开发者版\" class=\"headerlink\" title=\"CUDA 9.0 开发者版\"></a>CUDA 9.0 开发者版</h1><p><code>dockerfile</code>如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nvidia/cuda:9.0-runtime-ubuntu16.04</span><br><span class=\"line\">LABEL maintainer &quot;Keavnn &lt;https://stepneverstop.github.io&gt;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y --allow-unauthenticated --no-install-recommends \\</span><br><span class=\"line\">        cuda-libraries-dev-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-nvml-dev-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-minimal-build-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-command-line-tools-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-core-9-0=9.0.176.3-1 \\</span><br><span class=\"line\">        cuda-cublas-dev-9-0=9.0.176.4-1 \\</span><br><span class=\"line\">        libnccl-dev=$NCCL_VERSION-1+cuda9.0 &amp;&amp; \\</span><br><span class=\"line\">    rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\">ENV LIBRARY_PATH /usr/local/cuda/lib64/stubs</span><br></pre></td></tr></table></figure></p>\n<p><strong>—allow-unauthenticated</strong> 这句命令很重要, 不使用的话很有可能安装失败</p>\n<h1 id=\"cudnn-7-0-5\"><a href=\"#cudnn-7-0-5\" class=\"headerlink\" title=\"cudnn 7.0.5\"></a>cudnn 7.0.5</h1><ul>\n<li><a href=\"https://developer.nvidia.com/rdp/cudnn-archive\" rel=\"external nofollow\" target=\"_blank\">https://developer.nvidia.com/rdp/cudnn-archive</a> 下载cuDNN Libraries for Linux,不要下载 Power 8</li>\n<li>把下载好的包上传到FTP服务器, 或者传输到容器内, 或者直接在容器中下载好</li>\n<li><code>cd</code>到包位置</li>\n<li><code>cp cudnn-9.0-linux-x64-v7.solitairetheme8 cudnn-9.0-linux-x64-v7.tgz</code></li>\n<li><code>tar -xvf cudnn-9.0-linux-x64-v7.tgz</code></li>\n<li><code>cp include/* /usr/local/cuda-9.0/include</code></li>\n<li><code>cp lib64/* /usr/local/cuda-9.0/lib64</code></li>\n<li><code>chmod a+r /usr/local/cuda-9.0/include/cudnn.h /usr/local/cuda-9.0/lib64/libcudnn*</code> <strong>这一步如果cuda是base版本,则没有include文件夹,需要手动创建后再执行</strong></li>\n<li><code>export PATH=/usr/local/cuda-9.0/bin:$PATH</code></li>\n<li><code>cd</code>到<code>/usr/local/cuda-9.0/lib64</code></li>\n<li><code>nano ~/.bashrc</code>,关联环境变量</li>\n<li>在最后一行加入<code>export LD_LIBRARY_PATH=/home/cuda/lib64:$LD_LIBRARY_PATH</code></li>\n<li><code>source ~/.bashrc</code></li>\n<li><code>ldconfig -v</code></li>\n<li>使用<code>cat /usr/local/cuda-9.0/include/cudnn.h | grep CUDNN_MAJOR -A 2</code> 查看cudnn版本<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_10-56-08.png\" alt=\"\"></li>\n</ul>\n<h1 id=\"jemalloc\"><a href=\"#jemalloc\" class=\"headerlink\" title=\"jemalloc\"></a>jemalloc</h1><p>选择安装<code>jemalloc</code>,这个工具可以加速编译,碎片整理,具体请自行谷歌</p>\n<ul>\n<li><code>apt-get install autoconf</code></li>\n<li><code>apt-get install automake</code></li>\n<li><code>apt-get install libtool</code></li>\n<li><code>git clone https://github.com/jemalloc/jemalloc.git</code></li>\n<li><code>cd jemalloc</code></li>\n<li><code>git checkout 4.5.0</code>安装4.5.0版本的jemalloc,5.x版本的有坑,深坑</li>\n<li><code>./autogen.sh</code></li>\n<li><code>make</code></li>\n<li><code>make install_bin install_include install_lib</code>,之所以不使用<code>make install</code>是因为会报错,如下: <img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_09-56-41.png\" alt=\"\"></li>\n</ul>\n<h1 id=\"Python3-6\"><a href=\"#Python3-6\" class=\"headerlink\" title=\"Python3.6\"></a>Python3.6</h1><p>记得<code>sudo</code></p>\n<ul>\n<li><code>apt-get install software-properties-common</code></li>\n<li><code>add-apt-repository ppa:jonathonf/python-3.6</code>, 按<code>ENTER</code></li>\n<li><code>apt-get update &amp;&amp; apt-get install python3.6 -y</code></li>\n<li>修改系统默认的<code>python</code>版本为3.6</li>\n<li><code>cd /usr/bin</code>, 保险起见,建议分两步</li>\n<li><code>rm python</code></li>\n<li><code>ln -s python3.6m python</code></li>\n<li>如需更新,<code>pip3 install --upgrade pip</code>, 8.1.1-&gt;19.0.3</li>\n<li><code>python -V</code><br><img src=\"./something-hard-install-docker/1.png\" alt=\"\"></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文记录了一些在Docker中比较难以安装、频繁报错的库，如cuda、cudnn。</p>","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在配置镜像时, <strong>强烈建议将源更改为国内镜像站</strong>, 因为国外有些镜像站链接速度很慢, 更新也很慢, 很多库无法正确安装</p>\n<p>我所使用的镜像站为<code>sources.list</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class=\"line\">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure>\n<p>在<code>Dockerfile</code>或者在容器内使用命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class=\"line\">COPY sources.list /etc/apt/sources.list</span><br></pre></td></tr></table></figure></p>\n<p>将源替换.</p>\n<h1 id=\"CUDA-9-0-开发者版\"><a href=\"#CUDA-9-0-开发者版\" class=\"headerlink\" title=\"CUDA 9.0 开发者版\"></a>CUDA 9.0 开发者版</h1><p><code>dockerfile</code>如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nvidia/cuda:9.0-runtime-ubuntu16.04</span><br><span class=\"line\">LABEL maintainer &quot;Keavnn &lt;https://stepneverstop.github.io&gt;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y --allow-unauthenticated --no-install-recommends \\</span><br><span class=\"line\">        cuda-libraries-dev-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-nvml-dev-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-minimal-build-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-command-line-tools-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-core-9-0=9.0.176.3-1 \\</span><br><span class=\"line\">        cuda-cublas-dev-9-0=9.0.176.4-1 \\</span><br><span class=\"line\">        libnccl-dev=$NCCL_VERSION-1+cuda9.0 &amp;&amp; \\</span><br><span class=\"line\">    rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\">ENV LIBRARY_PATH /usr/local/cuda/lib64/stubs</span><br></pre></td></tr></table></figure></p>\n<p><strong>—allow-unauthenticated</strong> 这句命令很重要, 不使用的话很有可能安装失败</p>\n<h1 id=\"cudnn-7-0-5\"><a href=\"#cudnn-7-0-5\" class=\"headerlink\" title=\"cudnn 7.0.5\"></a>cudnn 7.0.5</h1><ul>\n<li><a href=\"https://developer.nvidia.com/rdp/cudnn-archive\" rel=\"external nofollow\" target=\"_blank\">https://developer.nvidia.com/rdp/cudnn-archive</a> 下载cuDNN Libraries for Linux,不要下载 Power 8</li>\n<li>把下载好的包上传到FTP服务器, 或者传输到容器内, 或者直接在容器中下载好</li>\n<li><code>cd</code>到包位置</li>\n<li><code>cp cudnn-9.0-linux-x64-v7.solitairetheme8 cudnn-9.0-linux-x64-v7.tgz</code></li>\n<li><code>tar -xvf cudnn-9.0-linux-x64-v7.tgz</code></li>\n<li><code>cp include/* /usr/local/cuda-9.0/include</code></li>\n<li><code>cp lib64/* /usr/local/cuda-9.0/lib64</code></li>\n<li><code>chmod a+r /usr/local/cuda-9.0/include/cudnn.h /usr/local/cuda-9.0/lib64/libcudnn*</code> <strong>这一步如果cuda是base版本,则没有include文件夹,需要手动创建后再执行</strong></li>\n<li><code>export PATH=/usr/local/cuda-9.0/bin:$PATH</code></li>\n<li><code>cd</code>到<code>/usr/local/cuda-9.0/lib64</code></li>\n<li><code>nano ~/.bashrc</code>,关联环境变量</li>\n<li>在最后一行加入<code>export LD_LIBRARY_PATH=/home/cuda/lib64:$LD_LIBRARY_PATH</code></li>\n<li><code>source ~/.bashrc</code></li>\n<li><code>ldconfig -v</code></li>\n<li>使用<code>cat /usr/local/cuda-9.0/include/cudnn.h | grep CUDNN_MAJOR -A 2</code> 查看cudnn版本<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_10-56-08.png\" alt=\"\"></li>\n</ul>\n<h1 id=\"jemalloc\"><a href=\"#jemalloc\" class=\"headerlink\" title=\"jemalloc\"></a>jemalloc</h1><p>选择安装<code>jemalloc</code>,这个工具可以加速编译,碎片整理,具体请自行谷歌</p>\n<ul>\n<li><code>apt-get install autoconf</code></li>\n<li><code>apt-get install automake</code></li>\n<li><code>apt-get install libtool</code></li>\n<li><code>git clone https://github.com/jemalloc/jemalloc.git</code></li>\n<li><code>cd jemalloc</code></li>\n<li><code>git checkout 4.5.0</code>安装4.5.0版本的jemalloc,5.x版本的有坑,深坑</li>\n<li><code>./autogen.sh</code></li>\n<li><code>make</code></li>\n<li><code>make install_bin install_include install_lib</code>,之所以不使用<code>make install</code>是因为会报错,如下: <img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_09-56-41.png\" alt=\"\"></li>\n</ul>\n<h1 id=\"Python3-6\"><a href=\"#Python3-6\" class=\"headerlink\" title=\"Python3.6\"></a>Python3.6</h1><p>记得<code>sudo</code></p>\n<ul>\n<li><code>apt-get install software-properties-common</code></li>\n<li><code>add-apt-repository ppa:jonathonf/python-3.6</code>, 按<code>ENTER</code></li>\n<li><code>apt-get update &amp;&amp; apt-get install python3.6 -y</code></li>\n<li>修改系统默认的<code>python</code>版本为3.6</li>\n<li><code>cd /usr/bin</code>, 保险起见,建议分两步</li>\n<li><code>rm python</code></li>\n<li><code>ln -s python3.6m python</code></li>\n<li>如需更新,<code>pip3 install --upgrade pip</code>, 8.1.1-&gt;19.0.3</li>\n<li><code>python -V</code><br><img src=\"./something-hard-install-docker/1.png\" alt=\"\"></li>\n</ul>"},{"title":"关于安装一些库的问题","copyright":true,"mathjax":false,"top":1,"date":"2020-03-19T06:30:16.000Z","_content":"\n本篇博客主要用以记录在各种环境安装各种库可能会遇到的问题及其解决方案，以便以后应急查询。\n\n<!--more-->\n\n# pip\n\n## 由于网速不好，导致TimeOut\n\n这种情况一般是由于pip要安装的库的默认源在国外服务器，导致网速只有几kb。可以考虑使用国内镜像站来安装或更新库。\n\n比如`pip install tensorflow -i [国内镜像站的地址]`\n\n更新时也可以用`pip install --upgrade tensorflow -i [国内镜像站的地址]`\n\n常用的国内镜像站地址有：\n- 阿里云 https://mirrors.aliyun.com/pypi/simple/\n- 中科大 https://pypi.mirrors.ustc.edu.cn/simple/\n- 清华 https://pypi.tuna.tsinghua.edu.cn/simple/\n- 豆瓣 https://pypi.douban.com/simple/\n\n如果报错，可以试试如下命令：\n\n`pip install tensorflow -i [国内镜像站的地址] --trusted-host [国内镜像站官网]`\n\n比如：\n\n`pip install tensorflow -i http://pypi.douban.com/simple --trusted-host pypi.douban.com`","source":"_posts/some-issues-of-install-packages.md","raw":"---\ntitle: 关于安装一些库的问题\ncopyright: true\nmathjax: false\ntop: 1\ndate: 2020-03-19 14:30:16\ncategories: 小知识\ntags:\n- pip\n---\n\n本篇博客主要用以记录在各种环境安装各种库可能会遇到的问题及其解决方案，以便以后应急查询。\n\n<!--more-->\n\n# pip\n\n## 由于网速不好，导致TimeOut\n\n这种情况一般是由于pip要安装的库的默认源在国外服务器，导致网速只有几kb。可以考虑使用国内镜像站来安装或更新库。\n\n比如`pip install tensorflow -i [国内镜像站的地址]`\n\n更新时也可以用`pip install --upgrade tensorflow -i [国内镜像站的地址]`\n\n常用的国内镜像站地址有：\n- 阿里云 https://mirrors.aliyun.com/pypi/simple/\n- 中科大 https://pypi.mirrors.ustc.edu.cn/simple/\n- 清华 https://pypi.tuna.tsinghua.edu.cn/simple/\n- 豆瓣 https://pypi.douban.com/simple/\n\n如果报错，可以试试如下命令：\n\n`pip install tensorflow -i [国内镜像站的地址] --trusted-host [国内镜像站官网]`\n\n比如：\n\n`pip install tensorflow -i http://pypi.douban.com/simple --trusted-host pypi.douban.com`","slug":"some-issues-of-install-packages","published":1,"updated":"2020-03-19T06:39:10.648Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusyw002320cdzdw43r16","content":"<p>本篇博客主要用以记录在各种环境安装各种库可能会遇到的问题及其解决方案，以便以后应急查询。</p>\n<a id=\"more\"></a>\n<h1 id=\"pip\"><a href=\"#pip\" class=\"headerlink\" title=\"pip\"></a>pip</h1><h2 id=\"由于网速不好，导致TimeOut\"><a href=\"#由于网速不好，导致TimeOut\" class=\"headerlink\" title=\"由于网速不好，导致TimeOut\"></a>由于网速不好，导致TimeOut</h2><p>这种情况一般是由于pip要安装的库的默认源在国外服务器，导致网速只有几kb。可以考虑使用国内镜像站来安装或更新库。</p>\n<p>比如<code>pip install tensorflow -i [国内镜像站的地址]</code></p>\n<p>更新时也可以用<code>pip install --upgrade tensorflow -i [国内镜像站的地址]</code></p>\n<p>常用的国内镜像站地址有：</p>\n<ul>\n<li>阿里云 <a href=\"https://mirrors.aliyun.com/pypi/simple/\" rel=\"external nofollow\" target=\"_blank\">https://mirrors.aliyun.com/pypi/simple/</a></li>\n<li>中科大 <a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\" rel=\"external nofollow\" target=\"_blank\">https://pypi.mirrors.ustc.edu.cn/simple/</a></li>\n<li>清华 <a href=\"https://pypi.tuna.tsinghua.edu.cn/simple/\" rel=\"external nofollow\" target=\"_blank\">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li>\n<li>豆瓣 <a href=\"https://pypi.douban.com/simple/\" rel=\"external nofollow\" target=\"_blank\">https://pypi.douban.com/simple/</a></li>\n</ul>\n<p>如果报错，可以试试如下命令：</p>\n<p><code>pip install tensorflow -i [国内镜像站的地址] --trusted-host [国内镜像站官网]</code></p>\n<p>比如：</p>\n<p><code>pip install tensorflow -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</code></p>\n","site":{"data":{}},"excerpt":"<p>本篇博客主要用以记录在各种环境安装各种库可能会遇到的问题及其解决方案，以便以后应急查询。</p>","more":"<h1 id=\"pip\"><a href=\"#pip\" class=\"headerlink\" title=\"pip\"></a>pip</h1><h2 id=\"由于网速不好，导致TimeOut\"><a href=\"#由于网速不好，导致TimeOut\" class=\"headerlink\" title=\"由于网速不好，导致TimeOut\"></a>由于网速不好，导致TimeOut</h2><p>这种情况一般是由于pip要安装的库的默认源在国外服务器，导致网速只有几kb。可以考虑使用国内镜像站来安装或更新库。</p>\n<p>比如<code>pip install tensorflow -i [国内镜像站的地址]</code></p>\n<p>更新时也可以用<code>pip install --upgrade tensorflow -i [国内镜像站的地址]</code></p>\n<p>常用的国内镜像站地址有：</p>\n<ul>\n<li>阿里云 <a href=\"https://mirrors.aliyun.com/pypi/simple/\" rel=\"external nofollow\" target=\"_blank\">https://mirrors.aliyun.com/pypi/simple/</a></li>\n<li>中科大 <a href=\"https://pypi.mirrors.ustc.edu.cn/simple/\" rel=\"external nofollow\" target=\"_blank\">https://pypi.mirrors.ustc.edu.cn/simple/</a></li>\n<li>清华 <a href=\"https://pypi.tuna.tsinghua.edu.cn/simple/\" rel=\"external nofollow\" target=\"_blank\">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li>\n<li>豆瓣 <a href=\"https://pypi.douban.com/simple/\" rel=\"external nofollow\" target=\"_blank\">https://pypi.douban.com/simple/</a></li>\n</ul>\n<p>如果报错，可以试试如下命令：</p>\n<p><code>pip install tensorflow -i [国内镜像站的地址] --trusted-host [国内镜像站官网]</code></p>\n<p>比如：</p>\n<p><code>pip install tensorflow -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</code></p>"},{"title":"Ubuntu16.04配置Shadowsocks服务器","copyright":true,"mathjax":false,"top":1,"date":"2019-06-01T14:03:10.000Z","password":"ss","keywords":null,"description":null,"_content":"\n科学上网，你懂的。\n\n<!--more-->\n\n# 购买VPS\n\n[VULTR](https://www.vultr.com/)\n\n纽约节点，3.5$一个月，ubuntu 16.04，enable IPV6\n\n更改root密码\n\n```\nsudo passwd\n```\n\n# shadowsocks 服务器\n\n更新软件源\n\n```\nsudo apt-get update\n```\n\n安装PIP\n\n```\nsudo apt-get install python-pip\nsudo apt-get install python3-pip\n```\n\n安装shadowsocks\n\n```\npip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip\n```\n\n查看shadowsocks版本，显示\"Shadowsocks 3.0.0\"\n\n```\nsudo ssserver --version\n```\n\n创建配置文件夹及文件\n\n```\nsudo mkdir /etc/shadowsocks\nsudo nano /etc/shadowsocks/config.json\n```\n\n复制并修改配置内容，然后`ctrl+x`，`y`，回车，\n\n```\n{\n    \"server\":\"::\",\n    \"port_password\": {\n        \"端口1\": \"密码1\",\n        \"端口2\": \"密码2\"\n    },\n    \"timeout\":300,\n    \"method\":\"rc4-md5\",\n    \"fast_open\": false\n}\n```\n\n赋予权限\n\n```\nsudo chmod 755 /etc/shadowsocks/config.json\n```\n\n为了支持这些加密方式，也许需要安装\n\n```\nsudo apt-get install python-dev\nsudo apt-get install python–m2crypto\n```\n\n服务端后台启停\n\n```\nsudo ssserver -c /etc/shadowsocks/config.json -d start\nsudo ssserver -c /etc/shadowsocks/config.json -d stop\n```\n\n配置Systemd管理Shadowsocks，新建Shadowsocks管理文件\n\n```\nsudo nano /etc/systemd/system/shadowsocks-server.service\n```\n\n复制粘贴，`ctrl+x`，`y`，回车\n\n```\n[Unit]\nDescription=Shadowsocks Server\nAfter=network.target\n\n[Service]\nExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json\nRestart=on-abort\n\n[Install]\nWantedBy=multi-user.target\n```\n\n启动Shadowsocks\n\n```\nsudo systemctl start shadowsocks-server\n```\n\n设置开机自启动Shadowsocks\n\n```\nsudo systemctl enable shadowsocks-server\n```\n\n查看运行状态\n\n```\nsudo systemctl status shadowsocks-server\n```\n\n## 优化\n\n查看linux内核\n\n```\nuname -r\n如果其显示版本在4.9.0之下，则需要升级Linux内核，否则请忽略下文\n\nsudo apt update\n查看可用的Linux内核版本\nsudo apt-cache showpkg linux-image\n找到一个你想要升级的Linux内核版本，如“linux-image-4.10.0-22-generic”\nsudo apt install linux-image-4.10.0-22-generic\n重启\nsudo reboot\n删除旧的内核\nsudo purge-old-kernels\n```\n\n开启BBR\n\n```\nmodprobe tcp_bbr\necho \"tcp_bbr\" >> /etc/modules-load.d/modules.conf\necho \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\necho \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\nsysctl -p\n```\n\n运行下两句，均有\"bbr\"则开启BBR成功\n\n```\nsysctl net.ipv4.tcp_available_congestion_control\nsysctl net.ipv4.tcp_congestion_control\n```\n\n优化吞吐量，新建配置文件\n\n```\nsudo nano /etc/sysctl.d/local.conf\n```\n\n复制粘贴，`ctrl+x`，`y`，回车\n\n```\n# max open files\nfs.file-max = 51200\n# max read buffer\nnet.core.rmem_max = 67108864\n# max write buffer\nnet.core.wmem_max = 67108864\n# default read buffer\nnet.core.rmem_default = 65536\n# default write buffer\nnet.core.wmem_default = 65536\n# max processor input queue\nnet.core.netdev_max_backlog = 4096\n# max backlog\nnet.core.somaxconn = 4096\n\n# resist SYN flood attacks\nnet.ipv4.tcp_syncookies = 1\n# reuse timewait sockets when safe\nnet.ipv4.tcp_tw_reuse = 1\n# turn off fast timewait sockets recycling\nnet.ipv4.tcp_tw_recycle = 0\n# short FIN timeout\nnet.ipv4.tcp_fin_timeout = 30\n# short keepalive time\nnet.ipv4.tcp_keepalive_time = 1200\n# outbound port range\nnet.ipv4.ip_local_port_range = 10000 65000\n# max SYN backlog\nnet.ipv4.tcp_max_syn_backlog = 4096\n# max timewait sockets held by system simultaneously\nnet.ipv4.tcp_max_tw_buckets = 5000\n# turn on TCP Fast Open on both client and server side\nnet.ipv4.tcp_fastopen = 3\n# TCP receive buffer\nnet.ipv4.tcp_rmem = 4096 87380 67108864\n# TCP write buffer\nnet.ipv4.tcp_wmem = 4096 65536 67108864\n# turn on path MTU discovery\nnet.ipv4.tcp_mtu_probing = 1\n\nnet.ipv4.tcp_congestion_control = bbr\n```\n\n运行\n\n```\nsysctl --system\n```\n\n编辑之前的shadowsocks-server.service文件\n\n```\nsudo nano /etc/systemd/system/shadowsocks-server.service\n```\n\n在`ExecStart`前插入一行\n\n```\nExecStartPre=/bin/sh -c 'ulimit -n 51200'\n```\n\n重载shadowsocks-server.service\n\n```\nsudo systemctl daemon-reload\n```\n\n重启Shadowsocks\n\n```\nsudo systemctl restart shadowsocks-server\n```\n\n开启TCP Fast Open，降低Shadowsocks服务器和客户端的延迟，将`fast_open`的值由`false`修改为`true`\n\n```\nsudo nano /etc/shadowsocks/config.json\n```\n\n重启服务\n\n```\nsudo systemctl restart shadowsocks-server\n```\n\n","source":"_posts/ss.md","raw":"---\ntitle: Ubuntu16.04配置Shadowsocks服务器\ncopyright: true\nmathjax: false\ntop: 1\ndate: 2019-06-01 22:03:10\ncategories: 小知识\ntags:\n- ubuntu\n- note\npassword: ss\nkeywords:\ndescription:\n---\n\n科学上网，你懂的。\n\n<!--more-->\n\n# 购买VPS\n\n[VULTR](https://www.vultr.com/)\n\n纽约节点，3.5$一个月，ubuntu 16.04，enable IPV6\n\n更改root密码\n\n```\nsudo passwd\n```\n\n# shadowsocks 服务器\n\n更新软件源\n\n```\nsudo apt-get update\n```\n\n安装PIP\n\n```\nsudo apt-get install python-pip\nsudo apt-get install python3-pip\n```\n\n安装shadowsocks\n\n```\npip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip\n```\n\n查看shadowsocks版本，显示\"Shadowsocks 3.0.0\"\n\n```\nsudo ssserver --version\n```\n\n创建配置文件夹及文件\n\n```\nsudo mkdir /etc/shadowsocks\nsudo nano /etc/shadowsocks/config.json\n```\n\n复制并修改配置内容，然后`ctrl+x`，`y`，回车，\n\n```\n{\n    \"server\":\"::\",\n    \"port_password\": {\n        \"端口1\": \"密码1\",\n        \"端口2\": \"密码2\"\n    },\n    \"timeout\":300,\n    \"method\":\"rc4-md5\",\n    \"fast_open\": false\n}\n```\n\n赋予权限\n\n```\nsudo chmod 755 /etc/shadowsocks/config.json\n```\n\n为了支持这些加密方式，也许需要安装\n\n```\nsudo apt-get install python-dev\nsudo apt-get install python–m2crypto\n```\n\n服务端后台启停\n\n```\nsudo ssserver -c /etc/shadowsocks/config.json -d start\nsudo ssserver -c /etc/shadowsocks/config.json -d stop\n```\n\n配置Systemd管理Shadowsocks，新建Shadowsocks管理文件\n\n```\nsudo nano /etc/systemd/system/shadowsocks-server.service\n```\n\n复制粘贴，`ctrl+x`，`y`，回车\n\n```\n[Unit]\nDescription=Shadowsocks Server\nAfter=network.target\n\n[Service]\nExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json\nRestart=on-abort\n\n[Install]\nWantedBy=multi-user.target\n```\n\n启动Shadowsocks\n\n```\nsudo systemctl start shadowsocks-server\n```\n\n设置开机自启动Shadowsocks\n\n```\nsudo systemctl enable shadowsocks-server\n```\n\n查看运行状态\n\n```\nsudo systemctl status shadowsocks-server\n```\n\n## 优化\n\n查看linux内核\n\n```\nuname -r\n如果其显示版本在4.9.0之下，则需要升级Linux内核，否则请忽略下文\n\nsudo apt update\n查看可用的Linux内核版本\nsudo apt-cache showpkg linux-image\n找到一个你想要升级的Linux内核版本，如“linux-image-4.10.0-22-generic”\nsudo apt install linux-image-4.10.0-22-generic\n重启\nsudo reboot\n删除旧的内核\nsudo purge-old-kernels\n```\n\n开启BBR\n\n```\nmodprobe tcp_bbr\necho \"tcp_bbr\" >> /etc/modules-load.d/modules.conf\necho \"net.core.default_qdisc=fq\" >> /etc/sysctl.conf\necho \"net.ipv4.tcp_congestion_control=bbr\" >> /etc/sysctl.conf\nsysctl -p\n```\n\n运行下两句，均有\"bbr\"则开启BBR成功\n\n```\nsysctl net.ipv4.tcp_available_congestion_control\nsysctl net.ipv4.tcp_congestion_control\n```\n\n优化吞吐量，新建配置文件\n\n```\nsudo nano /etc/sysctl.d/local.conf\n```\n\n复制粘贴，`ctrl+x`，`y`，回车\n\n```\n# max open files\nfs.file-max = 51200\n# max read buffer\nnet.core.rmem_max = 67108864\n# max write buffer\nnet.core.wmem_max = 67108864\n# default read buffer\nnet.core.rmem_default = 65536\n# default write buffer\nnet.core.wmem_default = 65536\n# max processor input queue\nnet.core.netdev_max_backlog = 4096\n# max backlog\nnet.core.somaxconn = 4096\n\n# resist SYN flood attacks\nnet.ipv4.tcp_syncookies = 1\n# reuse timewait sockets when safe\nnet.ipv4.tcp_tw_reuse = 1\n# turn off fast timewait sockets recycling\nnet.ipv4.tcp_tw_recycle = 0\n# short FIN timeout\nnet.ipv4.tcp_fin_timeout = 30\n# short keepalive time\nnet.ipv4.tcp_keepalive_time = 1200\n# outbound port range\nnet.ipv4.ip_local_port_range = 10000 65000\n# max SYN backlog\nnet.ipv4.tcp_max_syn_backlog = 4096\n# max timewait sockets held by system simultaneously\nnet.ipv4.tcp_max_tw_buckets = 5000\n# turn on TCP Fast Open on both client and server side\nnet.ipv4.tcp_fastopen = 3\n# TCP receive buffer\nnet.ipv4.tcp_rmem = 4096 87380 67108864\n# TCP write buffer\nnet.ipv4.tcp_wmem = 4096 65536 67108864\n# turn on path MTU discovery\nnet.ipv4.tcp_mtu_probing = 1\n\nnet.ipv4.tcp_congestion_control = bbr\n```\n\n运行\n\n```\nsysctl --system\n```\n\n编辑之前的shadowsocks-server.service文件\n\n```\nsudo nano /etc/systemd/system/shadowsocks-server.service\n```\n\n在`ExecStart`前插入一行\n\n```\nExecStartPre=/bin/sh -c 'ulimit -n 51200'\n```\n\n重载shadowsocks-server.service\n\n```\nsudo systemctl daemon-reload\n```\n\n重启Shadowsocks\n\n```\nsudo systemctl restart shadowsocks-server\n```\n\n开启TCP Fast Open，降低Shadowsocks服务器和客户端的延迟，将`fast_open`的值由`false`修改为`true`\n\n```\nsudo nano /etc/shadowsocks/config.json\n```\n\n重启服务\n\n```\nsudo systemctl restart shadowsocks-server\n```\n\n","slug":"ss","published":1,"updated":"2019-06-01T15:00:01.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusyz002720cd0px2p6pt","content":"<p>科学上网，你懂的。</p>\n<a id=\"more\"></a>\n<h1 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h1><p><a href=\"https://www.vultr.com/\" rel=\"external nofollow\" target=\"_blank\">VULTR</a></p>\n<p>纽约节点，3.5$一个月，ubuntu 16.04，enable IPV6</p>\n<p>更改root密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo passwd</span><br></pre></td></tr></table></figure>\n<h1 id=\"shadowsocks-服务器\"><a href=\"#shadowsocks-服务器\" class=\"headerlink\" title=\"shadowsocks 服务器\"></a>shadowsocks 服务器</h1><p>更新软件源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n<p>安装PIP</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install python-pip</span><br><span class=\"line\">sudo apt-get install python3-pip</span><br></pre></td></tr></table></figure>\n<p>安装shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip</span><br></pre></td></tr></table></figure>\n<p>查看shadowsocks版本，显示”Shadowsocks 3.0.0”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ssserver --version</span><br></pre></td></tr></table></figure>\n<p>创建配置文件夹及文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir /etc/shadowsocks</span><br><span class=\"line\">sudo nano /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure>\n<p>复制并修改配置内容，然后<code>ctrl+x</code>，<code>y</code>，回车，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:&quot;::&quot;,</span><br><span class=\"line\">    &quot;port_password&quot;: &#123;</span><br><span class=\"line\">        &quot;端口1&quot;: &quot;密码1&quot;,</span><br><span class=\"line\">        &quot;端口2&quot;: &quot;密码2&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;timeout&quot;:300,</span><br><span class=\"line\">    &quot;method&quot;:&quot;rc4-md5&quot;,</span><br><span class=\"line\">    &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>赋予权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod 755 /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure>\n<p>为了支持这些加密方式，也许需要安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install python-dev</span><br><span class=\"line\">sudo apt-get install python–m2crypto</span><br></pre></td></tr></table></figure>\n<p>服务端后台启停</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ssserver -c /etc/shadowsocks/config.json -d start</span><br><span class=\"line\">sudo ssserver -c /etc/shadowsocks/config.json -d stop</span><br></pre></td></tr></table></figure>\n<p>配置Systemd管理Shadowsocks，新建Shadowsocks管理文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure>\n<p>复制粘贴，<code>ctrl+x</code>，<code>y</code>，回车</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Shadowsocks Server</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json</span><br><span class=\"line\">Restart=on-abort</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<p>启动Shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start shadowsocks-server</span><br></pre></td></tr></table></figure>\n<p>设置开机自启动Shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable shadowsocks-server</span><br></pre></td></tr></table></figure>\n<p>查看运行状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl status shadowsocks-server</span><br></pre></td></tr></table></figure>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>查看linux内核</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -r</span><br><span class=\"line\">如果其显示版本在4.9.0之下，则需要升级Linux内核，否则请忽略下文</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt update</span><br><span class=\"line\">查看可用的Linux内核版本</span><br><span class=\"line\">sudo apt-cache showpkg linux-image</span><br><span class=\"line\">找到一个你想要升级的Linux内核版本，如“linux-image-4.10.0-22-generic”</span><br><span class=\"line\">sudo apt install linux-image-4.10.0-22-generic</span><br><span class=\"line\">重启</span><br><span class=\"line\">sudo reboot</span><br><span class=\"line\">删除旧的内核</span><br><span class=\"line\">sudo purge-old-kernels</span><br></pre></td></tr></table></figure>\n<p>开启BBR</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modprobe tcp_bbr</span><br><span class=\"line\">echo &quot;tcp_bbr&quot; &gt;&gt; /etc/modules-load.d/modules.conf</span><br><span class=\"line\">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n<p>运行下两句，均有”bbr”则开启BBR成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class=\"line\">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure>\n<p>优化吞吐量，新建配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/sysctl.d/local.conf</span><br></pre></td></tr></table></figure>\n<p>复制粘贴，<code>ctrl+x</code>，<code>y</code>，回车</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># max open files</span><br><span class=\"line\">fs.file-max = 51200</span><br><span class=\"line\"># max read buffer</span><br><span class=\"line\">net.core.rmem_max = 67108864</span><br><span class=\"line\"># max write buffer</span><br><span class=\"line\">net.core.wmem_max = 67108864</span><br><span class=\"line\"># default read buffer</span><br><span class=\"line\">net.core.rmem_default = 65536</span><br><span class=\"line\"># default write buffer</span><br><span class=\"line\">net.core.wmem_default = 65536</span><br><span class=\"line\"># max processor input queue</span><br><span class=\"line\">net.core.netdev_max_backlog = 4096</span><br><span class=\"line\"># max backlog</span><br><span class=\"line\">net.core.somaxconn = 4096</span><br><span class=\"line\"></span><br><span class=\"line\"># resist SYN flood attacks</span><br><span class=\"line\">net.ipv4.tcp_syncookies = 1</span><br><span class=\"line\"># reuse timewait sockets when safe</span><br><span class=\"line\">net.ipv4.tcp_tw_reuse = 1</span><br><span class=\"line\"># turn off fast timewait sockets recycling</span><br><span class=\"line\">net.ipv4.tcp_tw_recycle = 0</span><br><span class=\"line\"># short FIN timeout</span><br><span class=\"line\">net.ipv4.tcp_fin_timeout = 30</span><br><span class=\"line\"># short keepalive time</span><br><span class=\"line\">net.ipv4.tcp_keepalive_time = 1200</span><br><span class=\"line\"># outbound port range</span><br><span class=\"line\">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class=\"line\"># max SYN backlog</span><br><span class=\"line\">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class=\"line\"># max timewait sockets held by system simultaneously</span><br><span class=\"line\">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class=\"line\"># turn on TCP Fast Open on both client and server side</span><br><span class=\"line\">net.ipv4.tcp_fastopen = 3</span><br><span class=\"line\"># TCP receive buffer</span><br><span class=\"line\">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class=\"line\"># TCP write buffer</span><br><span class=\"line\">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class=\"line\"># turn on path MTU discovery</span><br><span class=\"line\">net.ipv4.tcp_mtu_probing = 1</span><br><span class=\"line\"></span><br><span class=\"line\">net.ipv4.tcp_congestion_control = bbr</span><br></pre></td></tr></table></figure>\n<p>运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl --system</span><br></pre></td></tr></table></figure>\n<p>编辑之前的shadowsocks-server.service文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure>\n<p>在<code>ExecStart</code>前插入一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecStartPre=/bin/sh -c &apos;ulimit -n 51200&apos;</span><br></pre></td></tr></table></figure>\n<p>重载shadowsocks-server.service</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>\n<p>重启Shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart shadowsocks-server</span><br></pre></td></tr></table></figure>\n<p>开启TCP Fast Open，降低Shadowsocks服务器和客户端的延迟，将<code>fast_open</code>的值由<code>false</code>修改为<code>true</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure>\n<p>重启服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart shadowsocks-server</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>科学上网，你懂的。</p>","more":"<h1 id=\"购买VPS\"><a href=\"#购买VPS\" class=\"headerlink\" title=\"购买VPS\"></a>购买VPS</h1><p><a href=\"https://www.vultr.com/\" rel=\"external nofollow\" target=\"_blank\">VULTR</a></p>\n<p>纽约节点，3.5$一个月，ubuntu 16.04，enable IPV6</p>\n<p>更改root密码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo passwd</span><br></pre></td></tr></table></figure>\n<h1 id=\"shadowsocks-服务器\"><a href=\"#shadowsocks-服务器\" class=\"headerlink\" title=\"shadowsocks 服务器\"></a>shadowsocks 服务器</h1><p>更新软件源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure>\n<p>安装PIP</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install python-pip</span><br><span class=\"line\">sudo apt-get install python3-pip</span><br></pre></td></tr></table></figure>\n<p>安装shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip</span><br></pre></td></tr></table></figure>\n<p>查看shadowsocks版本，显示”Shadowsocks 3.0.0”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ssserver --version</span><br></pre></td></tr></table></figure>\n<p>创建配置文件夹及文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mkdir /etc/shadowsocks</span><br><span class=\"line\">sudo nano /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure>\n<p>复制并修改配置内容，然后<code>ctrl+x</code>，<code>y</code>，回车，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;server&quot;:&quot;::&quot;,</span><br><span class=\"line\">    &quot;port_password&quot;: &#123;</span><br><span class=\"line\">        &quot;端口1&quot;: &quot;密码1&quot;,</span><br><span class=\"line\">        &quot;端口2&quot;: &quot;密码2&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;timeout&quot;:300,</span><br><span class=\"line\">    &quot;method&quot;:&quot;rc4-md5&quot;,</span><br><span class=\"line\">    &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>赋予权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod 755 /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure>\n<p>为了支持这些加密方式，也许需要安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install python-dev</span><br><span class=\"line\">sudo apt-get install python–m2crypto</span><br></pre></td></tr></table></figure>\n<p>服务端后台启停</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ssserver -c /etc/shadowsocks/config.json -d start</span><br><span class=\"line\">sudo ssserver -c /etc/shadowsocks/config.json -d stop</span><br></pre></td></tr></table></figure>\n<p>配置Systemd管理Shadowsocks，新建Shadowsocks管理文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure>\n<p>复制粘贴，<code>ctrl+x</code>，<code>y</code>，回车</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Shadowsocks Server</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.json</span><br><span class=\"line\">Restart=on-abort</span><br><span class=\"line\"></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n<p>启动Shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl start shadowsocks-server</span><br></pre></td></tr></table></figure>\n<p>设置开机自启动Shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable shadowsocks-server</span><br></pre></td></tr></table></figure>\n<p>查看运行状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl status shadowsocks-server</span><br></pre></td></tr></table></figure>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>查看linux内核</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uname -r</span><br><span class=\"line\">如果其显示版本在4.9.0之下，则需要升级Linux内核，否则请忽略下文</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt update</span><br><span class=\"line\">查看可用的Linux内核版本</span><br><span class=\"line\">sudo apt-cache showpkg linux-image</span><br><span class=\"line\">找到一个你想要升级的Linux内核版本，如“linux-image-4.10.0-22-generic”</span><br><span class=\"line\">sudo apt install linux-image-4.10.0-22-generic</span><br><span class=\"line\">重启</span><br><span class=\"line\">sudo reboot</span><br><span class=\"line\">删除旧的内核</span><br><span class=\"line\">sudo purge-old-kernels</span><br></pre></td></tr></table></figure>\n<p>开启BBR</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modprobe tcp_bbr</span><br><span class=\"line\">echo &quot;tcp_bbr&quot; &gt;&gt; /etc/modules-load.d/modules.conf</span><br><span class=\"line\">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure>\n<p>运行下两句，均有”bbr”则开启BBR成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class=\"line\">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure>\n<p>优化吞吐量，新建配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/sysctl.d/local.conf</span><br></pre></td></tr></table></figure>\n<p>复制粘贴，<code>ctrl+x</code>，<code>y</code>，回车</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># max open files</span><br><span class=\"line\">fs.file-max = 51200</span><br><span class=\"line\"># max read buffer</span><br><span class=\"line\">net.core.rmem_max = 67108864</span><br><span class=\"line\"># max write buffer</span><br><span class=\"line\">net.core.wmem_max = 67108864</span><br><span class=\"line\"># default read buffer</span><br><span class=\"line\">net.core.rmem_default = 65536</span><br><span class=\"line\"># default write buffer</span><br><span class=\"line\">net.core.wmem_default = 65536</span><br><span class=\"line\"># max processor input queue</span><br><span class=\"line\">net.core.netdev_max_backlog = 4096</span><br><span class=\"line\"># max backlog</span><br><span class=\"line\">net.core.somaxconn = 4096</span><br><span class=\"line\"></span><br><span class=\"line\"># resist SYN flood attacks</span><br><span class=\"line\">net.ipv4.tcp_syncookies = 1</span><br><span class=\"line\"># reuse timewait sockets when safe</span><br><span class=\"line\">net.ipv4.tcp_tw_reuse = 1</span><br><span class=\"line\"># turn off fast timewait sockets recycling</span><br><span class=\"line\">net.ipv4.tcp_tw_recycle = 0</span><br><span class=\"line\"># short FIN timeout</span><br><span class=\"line\">net.ipv4.tcp_fin_timeout = 30</span><br><span class=\"line\"># short keepalive time</span><br><span class=\"line\">net.ipv4.tcp_keepalive_time = 1200</span><br><span class=\"line\"># outbound port range</span><br><span class=\"line\">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class=\"line\"># max SYN backlog</span><br><span class=\"line\">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class=\"line\"># max timewait sockets held by system simultaneously</span><br><span class=\"line\">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class=\"line\"># turn on TCP Fast Open on both client and server side</span><br><span class=\"line\">net.ipv4.tcp_fastopen = 3</span><br><span class=\"line\"># TCP receive buffer</span><br><span class=\"line\">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class=\"line\"># TCP write buffer</span><br><span class=\"line\">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class=\"line\"># turn on path MTU discovery</span><br><span class=\"line\">net.ipv4.tcp_mtu_probing = 1</span><br><span class=\"line\"></span><br><span class=\"line\">net.ipv4.tcp_congestion_control = bbr</span><br></pre></td></tr></table></figure>\n<p>运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl --system</span><br></pre></td></tr></table></figure>\n<p>编辑之前的shadowsocks-server.service文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure>\n<p>在<code>ExecStart</code>前插入一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecStartPre=/bin/sh -c &apos;ulimit -n 51200&apos;</span><br></pre></td></tr></table></figure>\n<p>重载shadowsocks-server.service</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>\n<p>重启Shadowsocks</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart shadowsocks-server</span><br></pre></td></tr></table></figure>\n<p>开启TCP Fast Open，降低Shadowsocks服务器和客户端的延迟，将<code>fast_open</code>的值由<code>false</code>修改为<code>true</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure>\n<p>重启服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart shadowsocks-server</span><br></pre></td></tr></table></figure>"},{"title":"Universal Value Function Approximators","copyright":true,"mathjax":true,"top":1,"date":"2019-06-02T01:47:47.000Z","keywords":null,"description":null,"_content":"\n本文中的方法简称UVFA，即通用值函数逼近器，主要是用于将只能表示同一任务单目标的值函数表示成通用的多目标值函数。很多论文如HER都引用了这篇论文中提出的方法。\n\n推荐程度中等：\n\n- 文中理论说明很多，很晦涩，可以不看，直接跳至正文部分即可\n- 思想简单，了解一下即可\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://proceedings.mlr.press/v37/schaul15.pdf](http://proceedings.mlr.press/v37/schaul15.pdf)\n\n> Our main idea is to represent a large set of optimal value functions by a single, unified function approximator that generalises over both states and goals.\n\n主要思想是通过一个统一的函数逼近器来表示一大组最优值函数，该函数逼近器可以概括状态和目标。\n\n单目标中值函数这么表示：\n$$\nV_{g, \\pi}(s) :=\\mathbb{E}\\left[\\sum_{t=0}^{\\infty} R_{g}\\left(s_{t+1}, a_{t}, s_{t}\\right) \\prod_{k=0}^{t} \\gamma_{g}\\left(s_{k}\\right) | s_{0}=s\\right]\n$$\n动作值函数这么表示：\n$$\nQ_{g, \\pi}(s, a) :=\\mathbb{E}_{s^{\\prime}}\\left[R_{g}\\left(s, a, s^{\\prime}\\right)+\\gamma_{g}\\left(s^{\\prime}\\right) \\cdot V_{g, \\pi}\\left(s^{\\prime}\\right)\\right]\n$$\n最优策略：\n$$\n\\pi_{g}^{*}(s) :=\\arg \\max _{a} Q_{\\pi, g}(s, a)\n$$\n相应的最优值函数：\n$$\nV_{g}^{*} :=V_{g, \\pi_{g}^{*}} \\ , \\ Q_{g}^{*} :=Q_{g, \\pi_{g}^{*}}\n$$\n本文中是想将一个单目标的最优值函数逼近改造成多目标的最优值函数表示，形象一点来说，就是把用向量表示状态值函数$V(s; \\theta)$变成矩阵表示$V(s, g ; \\theta)$，行列分别是状态$s$和目标$g$；把用矩阵表示动作值函数$Q(s, a; \\theta)$变成三维Tensor表示$Q(s, a, g ; \\theta)$，行列不变，增加维度-深度表示目标$g$。其中满足：\n$$\nV(s, g ; \\theta) \\approx V_{q}^{*}(s) \\ , \\ Q(s, a, g ; \\theta) \\approx Q_{a}^{*}(s, a)\n$$\n\n# 文中正文\n\n该方法拟解决的问题：\n\n- 如何通用表示各种问题的值函数逼近器？\n\n主要思想：\n\n- 用单个函数逼近器表示多目标的最优值函数\n\n实现方法：\n\n- 算法的输入由状态$s$扩展为状态-目标$\\lt s,g \\gt$，假设原状态表示向量$s$不包含目标信息\n\n有两种实现形式：\n\n- 直接用$||$连接，即$\\left ( s||g \\right )$，然后通过非线性函数逼近器(如MLPs)得到最终输出结果$V(s, g)$\n- 分别embedding，并将嵌入后的表示通过运算得到**最终输出结果**(文中使用的是点积)，$h : \\mathbb{R}^{n} \\times \\mathbb{R}^{n} \\mapsto \\mathbb{R}$，然后$V(s, g) :=h(\\phi(s), \\psi(g))$\n\n![](./universal-value-function-approximators/sg.png)\n\n左图为连结模式，中间图表示分别embedding并通过函数运算得到标量输出$h : \\mathbb{R}^{n} \\times \\mathbb{R}^{n} \\mapsto \\mathbb{R}$，右图为中间图的细化。\n\n文中指出，对于第二种形式，可以使$\\phi$网络和$\\psi$网络共享几层参数，因为一般来说，目标的向量表示形式与状态的向量表示形式相同，即$\\mathcal{G} \\subseteq \\mathcal{S}$。如果对于对称问题，即奖励函数是$s$和$g$的距离(平方差)等形式，那么有特点：\n$$\nV_{g}^{*}(s)=V_{s}^{*}(g) \\ , \\ \\forall s, g\n$$\n这个时候可以使$\\phi$网络和$\\psi$网络相同。\n\n***注：文中提到有使用低秩因式分解分别表示$\\hat{\\phi}_{t}$和$\\hat{\\psi}_{g}$，并使用有监督学习训练两个网络对$s$和$g$的embediing($\\phi_{t}$和$\\psi_{t}$)进行训练的方法，但是这需要假设问题可进行因式分解，即有限的状态和目标，但这在实际应用中往往是不成立的，所以不对这部分做过多的关注。***\n\n优点：\n\n- UVFA可用于同任务多目标的迁移学习中，可以比随机值初始化更快地学习解决新任务。*这是显而易见的作用，毕竟本身就是多目标的通用函数逼近器。*\n- 可以用于特征表示。*这也说，= =，强行增加字数。。。。。。*\n- UVFA有效地提供了一个通用决策模型，代表（近似）朝向任何目标$g \\in \\mathcal{G}$的最佳行为。*这个优点与现在提出的元强化学习中的slow部分如出一辙。*\n\n# 总结\n\nUVFA把$V(s)$变成$V(s,g)$，一个可表示**单任务、多目标**的通用值函数近似，扩展对任务的知识表达。(通用即知识，哈哈)","source":"_posts/universal-value-function-approximators.md","raw":"---\ntitle: Universal Value Function Approximators\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2019-06-02 09:47:47\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n本文中的方法简称UVFA，即通用值函数逼近器，主要是用于将只能表示同一任务单目标的值函数表示成通用的多目标值函数。很多论文如HER都引用了这篇论文中提出的方法。\n\n推荐程度中等：\n\n- 文中理论说明很多，很晦涩，可以不看，直接跳至正文部分即可\n- 思想简单，了解一下即可\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://proceedings.mlr.press/v37/schaul15.pdf](http://proceedings.mlr.press/v37/schaul15.pdf)\n\n> Our main idea is to represent a large set of optimal value functions by a single, unified function approximator that generalises over both states and goals.\n\n主要思想是通过一个统一的函数逼近器来表示一大组最优值函数，该函数逼近器可以概括状态和目标。\n\n单目标中值函数这么表示：\n$$\nV_{g, \\pi}(s) :=\\mathbb{E}\\left[\\sum_{t=0}^{\\infty} R_{g}\\left(s_{t+1}, a_{t}, s_{t}\\right) \\prod_{k=0}^{t} \\gamma_{g}\\left(s_{k}\\right) | s_{0}=s\\right]\n$$\n动作值函数这么表示：\n$$\nQ_{g, \\pi}(s, a) :=\\mathbb{E}_{s^{\\prime}}\\left[R_{g}\\left(s, a, s^{\\prime}\\right)+\\gamma_{g}\\left(s^{\\prime}\\right) \\cdot V_{g, \\pi}\\left(s^{\\prime}\\right)\\right]\n$$\n最优策略：\n$$\n\\pi_{g}^{*}(s) :=\\arg \\max _{a} Q_{\\pi, g}(s, a)\n$$\n相应的最优值函数：\n$$\nV_{g}^{*} :=V_{g, \\pi_{g}^{*}} \\ , \\ Q_{g}^{*} :=Q_{g, \\pi_{g}^{*}}\n$$\n本文中是想将一个单目标的最优值函数逼近改造成多目标的最优值函数表示，形象一点来说，就是把用向量表示状态值函数$V(s; \\theta)$变成矩阵表示$V(s, g ; \\theta)$，行列分别是状态$s$和目标$g$；把用矩阵表示动作值函数$Q(s, a; \\theta)$变成三维Tensor表示$Q(s, a, g ; \\theta)$，行列不变，增加维度-深度表示目标$g$。其中满足：\n$$\nV(s, g ; \\theta) \\approx V_{q}^{*}(s) \\ , \\ Q(s, a, g ; \\theta) \\approx Q_{a}^{*}(s, a)\n$$\n\n# 文中正文\n\n该方法拟解决的问题：\n\n- 如何通用表示各种问题的值函数逼近器？\n\n主要思想：\n\n- 用单个函数逼近器表示多目标的最优值函数\n\n实现方法：\n\n- 算法的输入由状态$s$扩展为状态-目标$\\lt s,g \\gt$，假设原状态表示向量$s$不包含目标信息\n\n有两种实现形式：\n\n- 直接用$||$连接，即$\\left ( s||g \\right )$，然后通过非线性函数逼近器(如MLPs)得到最终输出结果$V(s, g)$\n- 分别embedding，并将嵌入后的表示通过运算得到**最终输出结果**(文中使用的是点积)，$h : \\mathbb{R}^{n} \\times \\mathbb{R}^{n} \\mapsto \\mathbb{R}$，然后$V(s, g) :=h(\\phi(s), \\psi(g))$\n\n![](./universal-value-function-approximators/sg.png)\n\n左图为连结模式，中间图表示分别embedding并通过函数运算得到标量输出$h : \\mathbb{R}^{n} \\times \\mathbb{R}^{n} \\mapsto \\mathbb{R}$，右图为中间图的细化。\n\n文中指出，对于第二种形式，可以使$\\phi$网络和$\\psi$网络共享几层参数，因为一般来说，目标的向量表示形式与状态的向量表示形式相同，即$\\mathcal{G} \\subseteq \\mathcal{S}$。如果对于对称问题，即奖励函数是$s$和$g$的距离(平方差)等形式，那么有特点：\n$$\nV_{g}^{*}(s)=V_{s}^{*}(g) \\ , \\ \\forall s, g\n$$\n这个时候可以使$\\phi$网络和$\\psi$网络相同。\n\n***注：文中提到有使用低秩因式分解分别表示$\\hat{\\phi}_{t}$和$\\hat{\\psi}_{g}$，并使用有监督学习训练两个网络对$s$和$g$的embediing($\\phi_{t}$和$\\psi_{t}$)进行训练的方法，但是这需要假设问题可进行因式分解，即有限的状态和目标，但这在实际应用中往往是不成立的，所以不对这部分做过多的关注。***\n\n优点：\n\n- UVFA可用于同任务多目标的迁移学习中，可以比随机值初始化更快地学习解决新任务。*这是显而易见的作用，毕竟本身就是多目标的通用函数逼近器。*\n- 可以用于特征表示。*这也说，= =，强行增加字数。。。。。。*\n- UVFA有效地提供了一个通用决策模型，代表（近似）朝向任何目标$g \\in \\mathcal{G}$的最佳行为。*这个优点与现在提出的元强化学习中的slow部分如出一辙。*\n\n# 总结\n\nUVFA把$V(s)$变成$V(s,g)$，一个可表示**单任务、多目标**的通用值函数近似，扩展对任务的知识表达。(通用即知识，哈哈)","slug":"universal-value-function-approximators","published":1,"updated":"2019-06-02T03:15:27.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusz4002b20cd6e4j8yj9","content":"<p>本文中的方法简称UVFA，即通用值函数逼近器，主要是用于将只能表示同一任务单目标的值函数表示成通用的多目标值函数。很多论文如HER都引用了这篇论文中提出的方法。</p>\n<p>推荐程度中等：</p>\n<ul>\n<li>文中理论说明很多，很晦涩，可以不看，直接跳至正文部分即可</li>\n<li>思想简单，了解一下即可</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://proceedings.mlr.press/v37/schaul15.pdf\" rel=\"external nofollow\" target=\"_blank\">http://proceedings.mlr.press/v37/schaul15.pdf</a></p>\n<blockquote>\n<p>Our main idea is to represent a large set of optimal value functions by a single, unified function approximator that generalises over both states and goals.</p>\n</blockquote>\n<p>主要思想是通过一个统一的函数逼近器来表示一大组最优值函数，该函数逼近器可以概括状态和目标。</p>\n<p>单目标中值函数这么表示：</p>\n<script type=\"math/tex; mode=display\">\nV_{g, \\pi}(s) :=\\mathbb{E}\\left[\\sum_{t=0}^{\\infty} R_{g}\\left(s_{t+1}, a_{t}, s_{t}\\right) \\prod_{k=0}^{t} \\gamma_{g}\\left(s_{k}\\right) | s_{0}=s\\right]</script><p>动作值函数这么表示：</p>\n<script type=\"math/tex; mode=display\">\nQ_{g, \\pi}(s, a) :=\\mathbb{E}_{s^{\\prime}}\\left[R_{g}\\left(s, a, s^{\\prime}\\right)+\\gamma_{g}\\left(s^{\\prime}\\right) \\cdot V_{g, \\pi}\\left(s^{\\prime}\\right)\\right]</script><p>最优策略：</p>\n<script type=\"math/tex; mode=display\">\n\\pi_{g}^{*}(s) :=\\arg \\max _{a} Q_{\\pi, g}(s, a)</script><p>相应的最优值函数：</p>\n<script type=\"math/tex; mode=display\">\nV_{g}^{*} :=V_{g, \\pi_{g}^{*}} \\ , \\ Q_{g}^{*} :=Q_{g, \\pi_{g}^{*}}</script><p>本文中是想将一个单目标的最优值函数逼近改造成多目标的最优值函数表示，形象一点来说，就是把用向量表示状态值函数$V(s; \\theta)$变成矩阵表示$V(s, g ; \\theta)$，行列分别是状态$s$和目标$g$；把用矩阵表示动作值函数$Q(s, a; \\theta)$变成三维Tensor表示$Q(s, a, g ; \\theta)$，行列不变，增加维度-深度表示目标$g$。其中满足：</p>\n<script type=\"math/tex; mode=display\">\nV(s, g ; \\theta) \\approx V_{q}^{*}(s) \\ , \\ Q(s, a, g ; \\theta) \\approx Q_{a}^{*}(s, a)</script><h1 id=\"文中正文\"><a href=\"#文中正文\" class=\"headerlink\" title=\"文中正文\"></a>文中正文</h1><p>该方法拟解决的问题：</p>\n<ul>\n<li>如何通用表示各种问题的值函数逼近器？</li>\n</ul>\n<p>主要思想：</p>\n<ul>\n<li>用单个函数逼近器表示多目标的最优值函数</li>\n</ul>\n<p>实现方法：</p>\n<ul>\n<li>算法的输入由状态$s$扩展为状态-目标$\\lt s,g \\gt$，假设原状态表示向量$s$不包含目标信息</li>\n</ul>\n<p>有两种实现形式：</p>\n<ul>\n<li>直接用$||$连接，即$\\left ( s||g \\right )$，然后通过非线性函数逼近器(如MLPs)得到最终输出结果$V(s, g)$</li>\n<li>分别embedding，并将嵌入后的表示通过运算得到<strong>最终输出结果</strong>(文中使用的是点积)，$h : \\mathbb{R}^{n} \\times \\mathbb{R}^{n} \\mapsto \\mathbb{R}$，然后$V(s, g) :=h(\\phi(s), \\psi(g))$</li>\n</ul>\n<p><img src=\"./universal-value-function-approximators/sg.png\" alt=\"\"></p>\n<p>左图为连结模式，中间图表示分别embedding并通过函数运算得到标量输出$h : \\mathbb{R}^{n} \\times \\mathbb{R}^{n} \\mapsto \\mathbb{R}$，右图为中间图的细化。</p>\n<p>文中指出，对于第二种形式，可以使$\\phi$网络和$\\psi$网络共享几层参数，因为一般来说，目标的向量表示形式与状态的向量表示形式相同，即$\\mathcal{G} \\subseteq \\mathcal{S}$。如果对于对称问题，即奖励函数是$s$和$g$的距离(平方差)等形式，那么有特点：</p>\n<script type=\"math/tex; mode=display\">\nV_{g}^{*}(s)=V_{s}^{*}(g) \\ , \\ \\forall s, g</script><p>这个时候可以使$\\phi$网络和$\\psi$网络相同。</p>\n<p><strong><em>注：文中提到有使用低秩因式分解分别表示$\\hat{\\phi}_{t}$和$\\hat{\\psi}_{g}$，并使用有监督学习训练两个网络对$s$和$g$的embediing($\\phi_{t}$和$\\psi_{t}$)进行训练的方法，但是这需要假设问题可进行因式分解，即有限的状态和目标，但这在实际应用中往往是不成立的，所以不对这部分做过多的关注。</em></strong></p>\n<p>优点：</p>\n<ul>\n<li>UVFA可用于同任务多目标的迁移学习中，可以比随机值初始化更快地学习解决新任务。<em>这是显而易见的作用，毕竟本身就是多目标的通用函数逼近器。</em></li>\n<li>可以用于特征表示。<em>这也说，= =，强行增加字数。。。。。。</em></li>\n<li>UVFA有效地提供了一个通用决策模型，代表（近似）朝向任何目标$g \\in \\mathcal{G}$的最佳行为。<em>这个优点与现在提出的元强化学习中的slow部分如出一辙。</em></li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>UVFA把$V(s)$变成$V(s,g)$，一个可表示<strong>单任务、多目标</strong>的通用值函数近似，扩展对任务的知识表达。(通用即知识，哈哈)</p>\n","site":{"data":{}},"excerpt":"<p>本文中的方法简称UVFA，即通用值函数逼近器，主要是用于将只能表示同一任务单目标的值函数表示成通用的多目标值函数。很多论文如HER都引用了这篇论文中提出的方法。</p>\n<p>推荐程度中等：</p>\n<ul>\n<li>文中理论说明很多，很晦涩，可以不看，直接跳至正文部分即可</li>\n<li>思想简单，了解一下即可</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://proceedings.mlr.press/v37/schaul15.pdf\" rel=\"external nofollow\" target=\"_blank\">http://proceedings.mlr.press/v37/schaul15.pdf</a></p>\n<blockquote>\n<p>Our main idea is to represent a large set of optimal value functions by a single, unified function approximator that generalises over both states and goals.</p>\n</blockquote>\n<p>主要思想是通过一个统一的函数逼近器来表示一大组最优值函数，该函数逼近器可以概括状态和目标。</p>\n<p>单目标中值函数这么表示：</p>\n<script type=\"math/tex; mode=display\">\nV_{g, \\pi}(s) :=\\mathbb{E}\\left[\\sum_{t=0}^{\\infty} R_{g}\\left(s_{t+1}, a_{t}, s_{t}\\right) \\prod_{k=0}^{t} \\gamma_{g}\\left(s_{k}\\right) | s_{0}=s\\right]</script><p>动作值函数这么表示：</p>\n<script type=\"math/tex; mode=display\">\nQ_{g, \\pi}(s, a) :=\\mathbb{E}_{s^{\\prime}}\\left[R_{g}\\left(s, a, s^{\\prime}\\right)+\\gamma_{g}\\left(s^{\\prime}\\right) \\cdot V_{g, \\pi}\\left(s^{\\prime}\\right)\\right]</script><p>最优策略：</p>\n<script type=\"math/tex; mode=display\">\n\\pi_{g}^{*}(s) :=\\arg \\max _{a} Q_{\\pi, g}(s, a)</script><p>相应的最优值函数：</p>\n<script type=\"math/tex; mode=display\">\nV_{g}^{*} :=V_{g, \\pi_{g}^{*}} \\ , \\ Q_{g}^{*} :=Q_{g, \\pi_{g}^{*}}</script><p>本文中是想将一个单目标的最优值函数逼近改造成多目标的最优值函数表示，形象一点来说，就是把用向量表示状态值函数$V(s; \\theta)$变成矩阵表示$V(s, g ; \\theta)$，行列分别是状态$s$和目标$g$；把用矩阵表示动作值函数$Q(s, a; \\theta)$变成三维Tensor表示$Q(s, a, g ; \\theta)$，行列不变，增加维度-深度表示目标$g$。其中满足：</p>\n<script type=\"math/tex; mode=display\">\nV(s, g ; \\theta) \\approx V_{q}^{*}(s) \\ , \\ Q(s, a, g ; \\theta) \\approx Q_{a}^{*}(s, a)</script><h1 id=\"文中正文\"><a href=\"#文中正文\" class=\"headerlink\" title=\"文中正文\"></a>文中正文</h1><p>该方法拟解决的问题：</p>\n<ul>\n<li>如何通用表示各种问题的值函数逼近器？</li>\n</ul>\n<p>主要思想：</p>\n<ul>\n<li>用单个函数逼近器表示多目标的最优值函数</li>\n</ul>\n<p>实现方法：</p>\n<ul>\n<li>算法的输入由状态$s$扩展为状态-目标$\\lt s,g \\gt$，假设原状态表示向量$s$不包含目标信息</li>\n</ul>\n<p>有两种实现形式：</p>\n<ul>\n<li>直接用$||$连接，即$\\left ( s||g \\right )$，然后通过非线性函数逼近器(如MLPs)得到最终输出结果$V(s, g)$</li>\n<li>分别embedding，并将嵌入后的表示通过运算得到<strong>最终输出结果</strong>(文中使用的是点积)，$h : \\mathbb{R}^{n} \\times \\mathbb{R}^{n} \\mapsto \\mathbb{R}$，然后$V(s, g) :=h(\\phi(s), \\psi(g))$</li>\n</ul>\n<p><img src=\"./universal-value-function-approximators/sg.png\" alt=\"\"></p>\n<p>左图为连结模式，中间图表示分别embedding并通过函数运算得到标量输出$h : \\mathbb{R}^{n} \\times \\mathbb{R}^{n} \\mapsto \\mathbb{R}$，右图为中间图的细化。</p>\n<p>文中指出，对于第二种形式，可以使$\\phi$网络和$\\psi$网络共享几层参数，因为一般来说，目标的向量表示形式与状态的向量表示形式相同，即$\\mathcal{G} \\subseteq \\mathcal{S}$。如果对于对称问题，即奖励函数是$s$和$g$的距离(平方差)等形式，那么有特点：</p>\n<script type=\"math/tex; mode=display\">\nV_{g}^{*}(s)=V_{s}^{*}(g) \\ , \\ \\forall s, g</script><p>这个时候可以使$\\phi$网络和$\\psi$网络相同。</p>\n<p><strong><em>注：文中提到有使用低秩因式分解分别表示$\\hat{\\phi}_{t}$和$\\hat{\\psi}_{g}$，并使用有监督学习训练两个网络对$s$和$g$的embediing($\\phi_{t}$和$\\psi_{t}$)进行训练的方法，但是这需要假设问题可进行因式分解，即有限的状态和目标，但这在实际应用中往往是不成立的，所以不对这部分做过多的关注。</em></strong></p>\n<p>优点：</p>\n<ul>\n<li>UVFA可用于同任务多目标的迁移学习中，可以比随机值初始化更快地学习解决新任务。<em>这是显而易见的作用，毕竟本身就是多目标的通用函数逼近器。</em></li>\n<li>可以用于特征表示。<em>这也说，= =，强行增加字数。。。。。。</em></li>\n<li>UVFA有效地提供了一个通用决策模型，代表（近似）朝向任何目标$g \\in \\mathcal{G}$的最佳行为。<em>这个优点与现在提出的元强化学习中的slow部分如出一辙。</em></li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>UVFA把$V(s)$变成$V(s,g)$，一个可表示<strong>单任务、多目标</strong>的通用值函数近似，扩展对任务的知识表达。(通用即知识，哈哈)</p>"},{"title":"在Jupyter Notebook中使用本机的conda环境","copyright":true,"top":1,"date":"2019-03-22T05:16:02.000Z","_content":"\n本文介绍了如何在Jupyter Notebook中使用本机的conda环境进行开发\n\n<!--more-->\n\n# Jupyter下conda多环境管理\n\n## 1. 手撸命令\n\n1. 在`base`环境下安装内核管理工具\n    `pip install ipykernel`\n\n2. 将环境内核添加到`jupyter kernel`中\n    `python -m ipykernel install --user --name [env_name] --display-name \"[show name in jupyter]\"`\n\n3. 在各个环境中先`activate [env_name]`激活，再安装`ipykernel`\n`conda install ipykernel`\n\n4. 不用第二步，在各个环境内操作内核\n`python -m ipykernel install --name [show name in jupyter]`\n\n5. 查看已在`jupyter`中创建的虚拟环境内核\n    `jupyter kernelspec list`\n\n6. 删除内核\n    `jupyter kernelspec uninstall [env_name]`\n\n## 2. 使用插件\n\n简单粗暴, 在`base`环境下使用命令\n`conda install nb_conda`\n![](./use-conda-env-in-jupyter/1.png)\n![](./use-conda-env-in-jupyter/2.png)\n接下来, 看看jupyter中能不能显示`conda`环境\n`jupyter notebook`\n![](./use-conda-env-in-jupyter/3.png)\n在文件内部也可以很方便的切换环境\n![](./use-conda-env-in-jupyter/4.png)\n\n","source":"_posts/use-conda-env-in-jupyter.md","raw":"---\ntitle: 在Jupyter Notebook中使用本机的conda环境\ncopyright: true\ntop: 1\ndate: 2019-03-22 13:16:02\ncategories: Conda\ntags:\n- conda\n- jupyter notebook\n---\n\n本文介绍了如何在Jupyter Notebook中使用本机的conda环境进行开发\n\n<!--more-->\n\n# Jupyter下conda多环境管理\n\n## 1. 手撸命令\n\n1. 在`base`环境下安装内核管理工具\n    `pip install ipykernel`\n\n2. 将环境内核添加到`jupyter kernel`中\n    `python -m ipykernel install --user --name [env_name] --display-name \"[show name in jupyter]\"`\n\n3. 在各个环境中先`activate [env_name]`激活，再安装`ipykernel`\n`conda install ipykernel`\n\n4. 不用第二步，在各个环境内操作内核\n`python -m ipykernel install --name [show name in jupyter]`\n\n5. 查看已在`jupyter`中创建的虚拟环境内核\n    `jupyter kernelspec list`\n\n6. 删除内核\n    `jupyter kernelspec uninstall [env_name]`\n\n## 2. 使用插件\n\n简单粗暴, 在`base`环境下使用命令\n`conda install nb_conda`\n![](./use-conda-env-in-jupyter/1.png)\n![](./use-conda-env-in-jupyter/2.png)\n接下来, 看看jupyter中能不能显示`conda`环境\n`jupyter notebook`\n![](./use-conda-env-in-jupyter/3.png)\n在文件内部也可以很方便的切换环境\n![](./use-conda-env-in-jupyter/4.png)\n\n","slug":"use-conda-env-in-jupyter","published":1,"updated":"2019-08-06T00:42:07.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusz6002f20cdz0m5gez1","content":"<p>本文介绍了如何在Jupyter Notebook中使用本机的conda环境进行开发</p>\n<a id=\"more\"></a>\n<h1 id=\"Jupyter下conda多环境管理\"><a href=\"#Jupyter下conda多环境管理\" class=\"headerlink\" title=\"Jupyter下conda多环境管理\"></a>Jupyter下conda多环境管理</h1><h2 id=\"1-手撸命令\"><a href=\"#1-手撸命令\" class=\"headerlink\" title=\"1. 手撸命令\"></a>1. 手撸命令</h2><ol>\n<li><p>在<code>base</code>环境下安装内核管理工具<br> <code>pip install ipykernel</code></p>\n</li>\n<li><p>将环境内核添加到<code>jupyter kernel</code>中<br> <code>python -m ipykernel install --user --name [env_name] --display-name &quot;[show name in jupyter]&quot;</code></p>\n</li>\n<li><p>在各个环境中先<code>activate [env_name]</code>激活，再安装<code>ipykernel</code><br><code>conda install ipykernel</code></p>\n</li>\n<li><p>不用第二步，在各个环境内操作内核<br><code>python -m ipykernel install --name [show name in jupyter]</code></p>\n</li>\n<li><p>查看已在<code>jupyter</code>中创建的虚拟环境内核<br> <code>jupyter kernelspec list</code></p>\n</li>\n<li><p>删除内核<br> <code>jupyter kernelspec uninstall [env_name]</code></p>\n</li>\n</ol>\n<h2 id=\"2-使用插件\"><a href=\"#2-使用插件\" class=\"headerlink\" title=\"2. 使用插件\"></a>2. 使用插件</h2><p>简单粗暴, 在<code>base</code>环境下使用命令<br><code>conda install nb_conda</code><br><img src=\"./use-conda-env-in-jupyter/1.png\" alt=\"\"><br><img src=\"./use-conda-env-in-jupyter/2.png\" alt=\"\"><br>接下来, 看看jupyter中能不能显示<code>conda</code>环境<br><code>jupyter notebook</code><br><img src=\"./use-conda-env-in-jupyter/3.png\" alt=\"\"><br>在文件内部也可以很方便的切换环境<br><img src=\"./use-conda-env-in-jupyter/4.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>本文介绍了如何在Jupyter Notebook中使用本机的conda环境进行开发</p>","more":"<h1 id=\"Jupyter下conda多环境管理\"><a href=\"#Jupyter下conda多环境管理\" class=\"headerlink\" title=\"Jupyter下conda多环境管理\"></a>Jupyter下conda多环境管理</h1><h2 id=\"1-手撸命令\"><a href=\"#1-手撸命令\" class=\"headerlink\" title=\"1. 手撸命令\"></a>1. 手撸命令</h2><ol>\n<li><p>在<code>base</code>环境下安装内核管理工具<br> <code>pip install ipykernel</code></p>\n</li>\n<li><p>将环境内核添加到<code>jupyter kernel</code>中<br> <code>python -m ipykernel install --user --name [env_name] --display-name &quot;[show name in jupyter]&quot;</code></p>\n</li>\n<li><p>在各个环境中先<code>activate [env_name]</code>激活，再安装<code>ipykernel</code><br><code>conda install ipykernel</code></p>\n</li>\n<li><p>不用第二步，在各个环境内操作内核<br><code>python -m ipykernel install --name [show name in jupyter]</code></p>\n</li>\n<li><p>查看已在<code>jupyter</code>中创建的虚拟环境内核<br> <code>jupyter kernelspec list</code></p>\n</li>\n<li><p>删除内核<br> <code>jupyter kernelspec uninstall [env_name]</code></p>\n</li>\n</ol>\n<h2 id=\"2-使用插件\"><a href=\"#2-使用插件\" class=\"headerlink\" title=\"2. 使用插件\"></a>2. 使用插件</h2><p>简单粗暴, 在<code>base</code>环境下使用命令<br><code>conda install nb_conda</code><br><img src=\"./use-conda-env-in-jupyter/1.png\" alt=\"\"><br><img src=\"./use-conda-env-in-jupyter/2.png\" alt=\"\"><br>接下来, 看看jupyter中能不能显示<code>conda</code>环境<br><code>jupyter notebook</code><br><img src=\"./use-conda-env-in-jupyter/3.png\" alt=\"\"><br>在文件内部也可以很方便的切换环境<br><img src=\"./use-conda-env-in-jupyter/4.png\" alt=\"\"></p>"},{"title":"Windows下右键新建.md文件教程","date":"2018-12-28T16:00:00.000Z","copyright":true,"_content":"\n原本创建.md文件需要首先打开markdown文本编辑器，如Typora，或者新建.txt文件然后修改后缀名，本文介绍了如何在Windows操作系统中添加右键创建.md文件的方法。\n\n<!--more-->\n\n# 环境\n\nwindows10操作系统\nTypora编辑器\n\n# 效果图\n\n![](./win-rightclick-create-md/1546050455.jpg)\n\n# 步骤\n\n## 1. 打开注册表\n1. `CMD+R`，打开运行对话框\n2. 输入`regedit`，打开注册表编辑器\n\n## 2. 修改注册表\n1. 在`计算机>HKEY_CLASSES_ROOT`右键查找，输入`Typora`，勾选项，取消勾选值和数据\n\n![](./win-rightclick-create-md/20181229103503.png)\n\n2. 确认运行的程序名字，我的电脑如图所示，运行文件是`Typora.exe`\n\n![](./win-rightclick-create-md/20181229103752.png)\n如果使用的是markdownpad或者其他编辑器，同理\n\n3. 在磁盘任意位置新建一个文件，后缀为`.reg`\n4. 打开编辑刚刚创建好的注册表文件，写入以下内容：\n```\nWindows Registry Editor Version 5.00\n[HKEY_CLASSES_ROOT\\.md]\n@=\"Typora.exe\"\n[HKEY_CLASSES_ROOT\\.md\\ShellNew]\n\"NullFile\"=\"\"\n[HKEY_CLASSES_ROOT\\Typora.exe]\n@=\"Markdown\"\n```\n\n`@=\"Typora.exe\"` 代表的是指定.md文件的运行程序\n`@=\"Markdown\"` 代表的是右键时默认的文件名字，这样写新建为`新建Markdown.md`文件，而且右键菜单中显示`MarkDown`\n5. 编辑好之后,另存为,设置如图所示:\n\n![](./win-rightclick-create-md/20181229105408.png)\n\n文件名可以随便设置，但是后缀必须是`.reg`文件,保存类型一定要是`文本文档(*.txt)`,编码选择`Unicode`,非常重要!!!!!\n6. 保存文件后,双击运行,修改注册表即可,现在右键即可达到预期效果,如果不行,请重启一下.\n\n## 3. 编辑新建图标(非必须)\n1. 以`Typora`为例,在注册表`Typora.exe`下点击项`DefaultIcon`,右键修改\n2. 将属性修改为想要设置的Markdown文件图标\n\n![](./win-rightclick-create-md/20181229105300.png)\n\n文档有错或转载请联系邮箱`stepneverstop@qq.com`","source":"_posts/win-rightclick-create-md.md","raw":"---\ntitle:  Windows下右键新建.md文件教程\ndate:   2018-12-29 00:00:00\ncategories: 小知识\ntags: markdown\ncopyright: true\n---\n\n原本创建.md文件需要首先打开markdown文本编辑器，如Typora，或者新建.txt文件然后修改后缀名，本文介绍了如何在Windows操作系统中添加右键创建.md文件的方法。\n\n<!--more-->\n\n# 环境\n\nwindows10操作系统\nTypora编辑器\n\n# 效果图\n\n![](./win-rightclick-create-md/1546050455.jpg)\n\n# 步骤\n\n## 1. 打开注册表\n1. `CMD+R`，打开运行对话框\n2. 输入`regedit`，打开注册表编辑器\n\n## 2. 修改注册表\n1. 在`计算机>HKEY_CLASSES_ROOT`右键查找，输入`Typora`，勾选项，取消勾选值和数据\n\n![](./win-rightclick-create-md/20181229103503.png)\n\n2. 确认运行的程序名字，我的电脑如图所示，运行文件是`Typora.exe`\n\n![](./win-rightclick-create-md/20181229103752.png)\n如果使用的是markdownpad或者其他编辑器，同理\n\n3. 在磁盘任意位置新建一个文件，后缀为`.reg`\n4. 打开编辑刚刚创建好的注册表文件，写入以下内容：\n```\nWindows Registry Editor Version 5.00\n[HKEY_CLASSES_ROOT\\.md]\n@=\"Typora.exe\"\n[HKEY_CLASSES_ROOT\\.md\\ShellNew]\n\"NullFile\"=\"\"\n[HKEY_CLASSES_ROOT\\Typora.exe]\n@=\"Markdown\"\n```\n\n`@=\"Typora.exe\"` 代表的是指定.md文件的运行程序\n`@=\"Markdown\"` 代表的是右键时默认的文件名字，这样写新建为`新建Markdown.md`文件，而且右键菜单中显示`MarkDown`\n5. 编辑好之后,另存为,设置如图所示:\n\n![](./win-rightclick-create-md/20181229105408.png)\n\n文件名可以随便设置，但是后缀必须是`.reg`文件,保存类型一定要是`文本文档(*.txt)`,编码选择`Unicode`,非常重要!!!!!\n6. 保存文件后,双击运行,修改注册表即可,现在右键即可达到预期效果,如果不行,请重启一下.\n\n## 3. 编辑新建图标(非必须)\n1. 以`Typora`为例,在注册表`Typora.exe`下点击项`DefaultIcon`,右键修改\n2. 将属性修改为想要设置的Markdown文件图标\n\n![](./win-rightclick-create-md/20181229105300.png)\n\n文档有错或转载请联系邮箱`stepneverstop@qq.com`","slug":"win-rightclick-create-md","published":1,"updated":"2019-09-03T10:27:17.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzusz8002j20cdk6kvvttu","content":"<p>原本创建.md文件需要首先打开markdown文本编辑器，如Typora，或者新建.txt文件然后修改后缀名，本文介绍了如何在Windows操作系统中添加右键创建.md文件的方法。</p>\n<a id=\"more\"></a>\n<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><p>windows10操作系统<br>Typora编辑器</p>\n<h1 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h1><p><img src=\"./win-rightclick-create-md/1546050455.jpg\" alt=\"\"></p>\n<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><h2 id=\"1-打开注册表\"><a href=\"#1-打开注册表\" class=\"headerlink\" title=\"1. 打开注册表\"></a>1. 打开注册表</h2><ol>\n<li><code>CMD+R</code>，打开运行对话框</li>\n<li>输入<code>regedit</code>，打开注册表编辑器</li>\n</ol>\n<h2 id=\"2-修改注册表\"><a href=\"#2-修改注册表\" class=\"headerlink\" title=\"2. 修改注册表\"></a>2. 修改注册表</h2><ol>\n<li>在<code>计算机&gt;HKEY_CLASSES_ROOT</code>右键查找，输入<code>Typora</code>，勾选项，取消勾选值和数据</li>\n</ol>\n<p><img src=\"./win-rightclick-create-md/20181229103503.png\" alt=\"\"></p>\n<ol>\n<li>确认运行的程序名字，我的电脑如图所示，运行文件是<code>Typora.exe</code></li>\n</ol>\n<p><img src=\"./win-rightclick-create-md/20181229103752.png\" alt=\"\"><br>如果使用的是markdownpad或者其他编辑器，同理</p>\n<ol>\n<li>在磁盘任意位置新建一个文件，后缀为<code>.reg</code></li>\n<li>打开编辑刚刚创建好的注册表文件，写入以下内容：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows Registry Editor Version 5.00</span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\.md]</span><br><span class=\"line\">@=&quot;Typora.exe&quot;</span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\.md\\ShellNew]</span><br><span class=\"line\">&quot;NullFile&quot;=&quot;&quot;</span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Typora.exe]</span><br><span class=\"line\">@=&quot;Markdown&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>@=&quot;Typora.exe&quot;</code> 代表的是指定.md文件的运行程序<br><code>@=&quot;Markdown&quot;</code> 代表的是右键时默认的文件名字，这样写新建为<code>新建Markdown.md</code>文件，而且右键菜单中显示<code>MarkDown</code></p>\n<ol>\n<li>编辑好之后,另存为,设置如图所示:</li>\n</ol>\n<p><img src=\"./win-rightclick-create-md/20181229105408.png\" alt=\"\"></p>\n<p>文件名可以随便设置，但是后缀必须是<code>.reg</code>文件,保存类型一定要是<code>文本文档(*.txt)</code>,编码选择<code>Unicode</code>,非常重要!!!!!</p>\n<ol>\n<li>保存文件后,双击运行,修改注册表即可,现在右键即可达到预期效果,如果不行,请重启一下.</li>\n</ol>\n<h2 id=\"3-编辑新建图标-非必须\"><a href=\"#3-编辑新建图标-非必须\" class=\"headerlink\" title=\"3. 编辑新建图标(非必须)\"></a>3. 编辑新建图标(非必须)</h2><ol>\n<li>以<code>Typora</code>为例,在注册表<code>Typora.exe</code>下点击项<code>DefaultIcon</code>,右键修改</li>\n<li>将属性修改为想要设置的Markdown文件图标</li>\n</ol>\n<p><img src=\"./win-rightclick-create-md/20181229105300.png\" alt=\"\"></p>\n<p>文档有错或转载请联系邮箱<code>stepneverstop@qq.com</code></p>\n","site":{"data":{}},"excerpt":"<p>原本创建.md文件需要首先打开markdown文本编辑器，如Typora，或者新建.txt文件然后修改后缀名，本文介绍了如何在Windows操作系统中添加右键创建.md文件的方法。</p>","more":"<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><p>windows10操作系统<br>Typora编辑器</p>\n<h1 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h1><p><img src=\"./win-rightclick-create-md/1546050455.jpg\" alt=\"\"></p>\n<h1 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h1><h2 id=\"1-打开注册表\"><a href=\"#1-打开注册表\" class=\"headerlink\" title=\"1. 打开注册表\"></a>1. 打开注册表</h2><ol>\n<li><code>CMD+R</code>，打开运行对话框</li>\n<li>输入<code>regedit</code>，打开注册表编辑器</li>\n</ol>\n<h2 id=\"2-修改注册表\"><a href=\"#2-修改注册表\" class=\"headerlink\" title=\"2. 修改注册表\"></a>2. 修改注册表</h2><ol>\n<li>在<code>计算机&gt;HKEY_CLASSES_ROOT</code>右键查找，输入<code>Typora</code>，勾选项，取消勾选值和数据</li>\n</ol>\n<p><img src=\"./win-rightclick-create-md/20181229103503.png\" alt=\"\"></p>\n<ol>\n<li>确认运行的程序名字，我的电脑如图所示，运行文件是<code>Typora.exe</code></li>\n</ol>\n<p><img src=\"./win-rightclick-create-md/20181229103752.png\" alt=\"\"><br>如果使用的是markdownpad或者其他编辑器，同理</p>\n<ol>\n<li>在磁盘任意位置新建一个文件，后缀为<code>.reg</code></li>\n<li>打开编辑刚刚创建好的注册表文件，写入以下内容：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows Registry Editor Version 5.00</span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\.md]</span><br><span class=\"line\">@=&quot;Typora.exe&quot;</span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\.md\\ShellNew]</span><br><span class=\"line\">&quot;NullFile&quot;=&quot;&quot;</span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Typora.exe]</span><br><span class=\"line\">@=&quot;Markdown&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>@=&quot;Typora.exe&quot;</code> 代表的是指定.md文件的运行程序<br><code>@=&quot;Markdown&quot;</code> 代表的是右键时默认的文件名字，这样写新建为<code>新建Markdown.md</code>文件，而且右键菜单中显示<code>MarkDown</code></p>\n<ol>\n<li>编辑好之后,另存为,设置如图所示:</li>\n</ol>\n<p><img src=\"./win-rightclick-create-md/20181229105408.png\" alt=\"\"></p>\n<p>文件名可以随便设置，但是后缀必须是<code>.reg</code>文件,保存类型一定要是<code>文本文档(*.txt)</code>,编码选择<code>Unicode</code>,非常重要!!!!!</p>\n<ol>\n<li>保存文件后,双击运行,修改注册表即可,现在右键即可达到预期效果,如果不行,请重启一下.</li>\n</ol>\n<h2 id=\"3-编辑新建图标-非必须\"><a href=\"#3-编辑新建图标-非必须\" class=\"headerlink\" title=\"3. 编辑新建图标(非必须)\"></a>3. 编辑新建图标(非必须)</h2><ol>\n<li>以<code>Typora</code>为例,在注册表<code>Typora.exe</code>下点击项<code>DefaultIcon</code>,右键修改</li>\n<li>将属性修改为想要设置的Markdown文件图标</li>\n</ol>\n<p><img src=\"./win-rightclick-create-md/20181229105300.png\" alt=\"\"></p>\n<p>文档有错或转载请联系邮箱<code>stepneverstop@qq.com</code></p>"},{"title":"为远程Ubuntu服务器安装图像界面","copyright":true,"top":1,"date":"2019-01-09T06:25:43.000Z","_content":"\n# 为远程服务器Ubuntu系统安装图形界面\n\n<!--more-->\n\n## 资源\n\n- [X2GO](https://wiki.x2go.org/doku.php/doc:installation:x2goclient)\n\n## 在服务器上安装X2go服务器\n\n1. 安装这个`add-apt-repository`命令\n\n\t- `apt-get install -y python-software-properties software-properties-common`\n\n2. 添加PPA\n\n\t- `apt-add-repository -y ppa:x2go/stable`\n\t\n3. 更新包列表并安装`x2go`服务器端\n\t- `apt-get update`\n\t- `apt-get install x2goserver x2goserver-xsession`\n\n### 安装XFCE图像界面\n\n在安装`XFCE`桌面环境时，有可能会出错，原因是perl为系统使用`zh_CN.UTF-8`，但系统不知道`zh_CN.UTF-8`是什么东西，所以需要安装一个中文语言，系统就知道`zh_CN.UTF-8`了，这个时候perl就不会报错了\n​\t- `apt-get install language-pack-zh-hans `\n​\t- `apt-get install xfce4`\n\n### 安装GNOME图像界面\n\n`apt-get install -y gnome`\n*没有测试成功,似乎是不兼容的问题*\n\n### 安装MATE图像界面\n\n`apt-get install -y mate`\n![](./为远程Ubuntu服务器安装图像界面/9.png)\n\n### 安装LXDE图像界面\n\n`apt-get install -y xorg lxde`\n![](./为远程Ubuntu服务器安装图像界面/10.png)\n\n### **重要配置**\n开启远程连接时有可能会出现`mesg: ttyname failed: Inappropriate ioctl for device`错误，所以需要修改一下文件\n​\t- `nano /root/.profile`\n​\t- 把`mesg n` 替换成 `tty -s && mesg n`\n\n## 在客户端上安装X2go客户端\n\n### MAC\n\n1. 安装`Xquartz` [XQuartz](https://www.xquartz.org/)\n\n![](./为远程Ubuntu服务器安装图像界面/1.png)\n\n2. 输入命令\n\n`echo \"*VT100.translations: #override Meta <KeyPress> V: insert-selection(PRIMARY, CUT_BUFFER0) \\n\" > ~/.Xdefaults `\n\n3. 安装`X2Go Client` [X2Go Client](https://code.x2go.org/releases/binary-macosx/x2goclient/)\n\n4. 打开客户端，设置连接\n\n![](./为远程Ubuntu服务器安装图像界面/2.png)\n\n5. 检查客户端设置，确保X11被正确引导\n\n![](./为远程Ubuntu服务器安装图像界面/3.png)\n\n6. 开始连接\n\n![](./为远程Ubuntu服务器安装图像界面/4.png)\n\n7. 连接成功\n\n![](./为远程Ubuntu服务器安装图像界面/5.png)\n\n### Windows\n\n1. 安装`x2goclient` [x2goclient](https://code.x2go.org/releases/binary-win32/x2goclient/releases/4.1.2.0-2018.06.22/)\n\n![](./为远程Ubuntu服务器安装图像界面/6.png)\n\n2. 配置好之后连接成功\n\n![](./为远程Ubuntu服务器安装图像界面/7.png)\n\n## Linux下各种图像界面测评\n\n![](./为远程Ubuntu服务器安装图像界面/8.png)","source":"_posts/为远程Ubuntu服务器安装图像界面.md","raw":"---\ntitle: 为远程Ubuntu服务器安装图像界面\ncopyright: true\ntop: 1\ndate: 2019-01-09 14:25:43\ncategories: Ubuntu\ntags: \n- ubuntu\n- x2go\n\n---\n\n# 为远程服务器Ubuntu系统安装图形界面\n\n<!--more-->\n\n## 资源\n\n- [X2GO](https://wiki.x2go.org/doku.php/doc:installation:x2goclient)\n\n## 在服务器上安装X2go服务器\n\n1. 安装这个`add-apt-repository`命令\n\n\t- `apt-get install -y python-software-properties software-properties-common`\n\n2. 添加PPA\n\n\t- `apt-add-repository -y ppa:x2go/stable`\n\t\n3. 更新包列表并安装`x2go`服务器端\n\t- `apt-get update`\n\t- `apt-get install x2goserver x2goserver-xsession`\n\n### 安装XFCE图像界面\n\n在安装`XFCE`桌面环境时，有可能会出错，原因是perl为系统使用`zh_CN.UTF-8`，但系统不知道`zh_CN.UTF-8`是什么东西，所以需要安装一个中文语言，系统就知道`zh_CN.UTF-8`了，这个时候perl就不会报错了\n​\t- `apt-get install language-pack-zh-hans `\n​\t- `apt-get install xfce4`\n\n### 安装GNOME图像界面\n\n`apt-get install -y gnome`\n*没有测试成功,似乎是不兼容的问题*\n\n### 安装MATE图像界面\n\n`apt-get install -y mate`\n![](./为远程Ubuntu服务器安装图像界面/9.png)\n\n### 安装LXDE图像界面\n\n`apt-get install -y xorg lxde`\n![](./为远程Ubuntu服务器安装图像界面/10.png)\n\n### **重要配置**\n开启远程连接时有可能会出现`mesg: ttyname failed: Inappropriate ioctl for device`错误，所以需要修改一下文件\n​\t- `nano /root/.profile`\n​\t- 把`mesg n` 替换成 `tty -s && mesg n`\n\n## 在客户端上安装X2go客户端\n\n### MAC\n\n1. 安装`Xquartz` [XQuartz](https://www.xquartz.org/)\n\n![](./为远程Ubuntu服务器安装图像界面/1.png)\n\n2. 输入命令\n\n`echo \"*VT100.translations: #override Meta <KeyPress> V: insert-selection(PRIMARY, CUT_BUFFER0) \\n\" > ~/.Xdefaults `\n\n3. 安装`X2Go Client` [X2Go Client](https://code.x2go.org/releases/binary-macosx/x2goclient/)\n\n4. 打开客户端，设置连接\n\n![](./为远程Ubuntu服务器安装图像界面/2.png)\n\n5. 检查客户端设置，确保X11被正确引导\n\n![](./为远程Ubuntu服务器安装图像界面/3.png)\n\n6. 开始连接\n\n![](./为远程Ubuntu服务器安装图像界面/4.png)\n\n7. 连接成功\n\n![](./为远程Ubuntu服务器安装图像界面/5.png)\n\n### Windows\n\n1. 安装`x2goclient` [x2goclient](https://code.x2go.org/releases/binary-win32/x2goclient/releases/4.1.2.0-2018.06.22/)\n\n![](./为远程Ubuntu服务器安装图像界面/6.png)\n\n2. 配置好之后连接成功\n\n![](./为远程Ubuntu服务器安装图像界面/7.png)\n\n## Linux下各种图像界面测评\n\n![](./为远程Ubuntu服务器安装图像界面/8.png)","slug":"为远程Ubuntu服务器安装图像界面","published":1,"updated":"2019-05-10T12:39:30.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzuszb002m20cdk0cc17yi","content":"<h1 id=\"为远程服务器Ubuntu系统安装图形界面\"><a href=\"#为远程服务器Ubuntu系统安装图形界面\" class=\"headerlink\" title=\"为远程服务器Ubuntu系统安装图形界面\"></a>为远程服务器Ubuntu系统安装图形界面</h1><a id=\"more\"></a>\n<h2 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h2><ul>\n<li><a href=\"https://wiki.x2go.org/doku.php/doc:installation:x2goclient\" rel=\"external nofollow\" target=\"_blank\">X2GO</a></li>\n</ul>\n<h2 id=\"在服务器上安装X2go服务器\"><a href=\"#在服务器上安装X2go服务器\" class=\"headerlink\" title=\"在服务器上安装X2go服务器\"></a>在服务器上安装X2go服务器</h2><ol>\n<li><p>安装这个<code>add-apt-repository</code>命令</p>\n<ul>\n<li><code>apt-get install -y python-software-properties software-properties-common</code></li>\n</ul>\n</li>\n<li><p>添加PPA</p>\n<ul>\n<li><code>apt-add-repository -y ppa:x2go/stable</code></li>\n</ul>\n</li>\n<li><p>更新包列表并安装<code>x2go</code>服务器端</p>\n<ul>\n<li><code>apt-get update</code></li>\n<li><code>apt-get install x2goserver x2goserver-xsession</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"安装XFCE图像界面\"><a href=\"#安装XFCE图像界面\" class=\"headerlink\" title=\"安装XFCE图像界面\"></a>安装XFCE图像界面</h3><p>在安装<code>XFCE</code>桌面环境时，有可能会出错，原因是perl为系统使用<code>zh_CN.UTF-8</code>，但系统不知道<code>zh_CN.UTF-8</code>是什么东西，所以需要安装一个中文语言，系统就知道<code>zh_CN.UTF-8</code>了，这个时候perl就不会报错了<br>​    - <code>apt-get install language-pack-zh-hans</code><br>​    - <code>apt-get install xfce4</code></p>\n<h3 id=\"安装GNOME图像界面\"><a href=\"#安装GNOME图像界面\" class=\"headerlink\" title=\"安装GNOME图像界面\"></a>安装GNOME图像界面</h3><p><code>apt-get install -y gnome</code><br><em>没有测试成功,似乎是不兼容的问题</em></p>\n<h3 id=\"安装MATE图像界面\"><a href=\"#安装MATE图像界面\" class=\"headerlink\" title=\"安装MATE图像界面\"></a>安装MATE图像界面</h3><p><code>apt-get install -y mate</code><br><img src=\"./为远程Ubuntu服务器安装图像界面/9.png\" alt=\"\"></p>\n<h3 id=\"安装LXDE图像界面\"><a href=\"#安装LXDE图像界面\" class=\"headerlink\" title=\"安装LXDE图像界面\"></a>安装LXDE图像界面</h3><p><code>apt-get install -y xorg lxde</code><br><img src=\"./为远程Ubuntu服务器安装图像界面/10.png\" alt=\"\"></p>\n<h3 id=\"重要配置\"><a href=\"#重要配置\" class=\"headerlink\" title=\"重要配置\"></a><strong>重要配置</strong></h3><p>开启远程连接时有可能会出现<code>mesg: ttyname failed: Inappropriate ioctl for device</code>错误，所以需要修改一下文件<br>​    - <code>nano /root/.profile</code><br>​    - 把<code>mesg n</code> 替换成 <code>tty -s &amp;&amp; mesg n</code></p>\n<h2 id=\"在客户端上安装X2go客户端\"><a href=\"#在客户端上安装X2go客户端\" class=\"headerlink\" title=\"在客户端上安装X2go客户端\"></a>在客户端上安装X2go客户端</h2><h3 id=\"MAC\"><a href=\"#MAC\" class=\"headerlink\" title=\"MAC\"></a>MAC</h3><ol>\n<li>安装<code>Xquartz</code> <a href=\"https://www.xquartz.org/\" rel=\"external nofollow\" target=\"_blank\">XQuartz</a></li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/1.png\" alt=\"\"></p>\n<ol>\n<li>输入命令</li>\n</ol>\n<p><code>echo &quot;*VT100.translations: #override Meta &lt;KeyPress&gt; V: insert-selection(PRIMARY, CUT_BUFFER0) \\n&quot; &gt; ~/.Xdefaults</code></p>\n<ol>\n<li><p>安装<code>X2Go Client</code> <a href=\"https://code.x2go.org/releases/binary-macosx/x2goclient/\" rel=\"external nofollow\" target=\"_blank\">X2Go Client</a></p>\n</li>\n<li><p>打开客户端，设置连接</p>\n</li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/2.png\" alt=\"\"></p>\n<ol>\n<li>检查客户端设置，确保X11被正确引导</li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/3.png\" alt=\"\"></p>\n<ol>\n<li>开始连接</li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/4.png\" alt=\"\"></p>\n<ol>\n<li>连接成功</li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/5.png\" alt=\"\"></p>\n<h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><ol>\n<li>安装<code>x2goclient</code> <a href=\"https://code.x2go.org/releases/binary-win32/x2goclient/releases/4.1.2.0-2018.06.22/\" rel=\"external nofollow\" target=\"_blank\">x2goclient</a></li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/6.png\" alt=\"\"></p>\n<ol>\n<li>配置好之后连接成功</li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/7.png\" alt=\"\"></p>\n<h2 id=\"Linux下各种图像界面测评\"><a href=\"#Linux下各种图像界面测评\" class=\"headerlink\" title=\"Linux下各种图像界面测评\"></a>Linux下各种图像界面测评</h2><p><img src=\"./为远程Ubuntu服务器安装图像界面/8.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"为远程服务器Ubuntu系统安装图形界面\"><a href=\"#为远程服务器Ubuntu系统安装图形界面\" class=\"headerlink\" title=\"为远程服务器Ubuntu系统安装图形界面\"></a>为远程服务器Ubuntu系统安装图形界面</h1>","more":"<h2 id=\"资源\"><a href=\"#资源\" class=\"headerlink\" title=\"资源\"></a>资源</h2><ul>\n<li><a href=\"https://wiki.x2go.org/doku.php/doc:installation:x2goclient\" rel=\"external nofollow\" target=\"_blank\">X2GO</a></li>\n</ul>\n<h2 id=\"在服务器上安装X2go服务器\"><a href=\"#在服务器上安装X2go服务器\" class=\"headerlink\" title=\"在服务器上安装X2go服务器\"></a>在服务器上安装X2go服务器</h2><ol>\n<li><p>安装这个<code>add-apt-repository</code>命令</p>\n<ul>\n<li><code>apt-get install -y python-software-properties software-properties-common</code></li>\n</ul>\n</li>\n<li><p>添加PPA</p>\n<ul>\n<li><code>apt-add-repository -y ppa:x2go/stable</code></li>\n</ul>\n</li>\n<li><p>更新包列表并安装<code>x2go</code>服务器端</p>\n<ul>\n<li><code>apt-get update</code></li>\n<li><code>apt-get install x2goserver x2goserver-xsession</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"安装XFCE图像界面\"><a href=\"#安装XFCE图像界面\" class=\"headerlink\" title=\"安装XFCE图像界面\"></a>安装XFCE图像界面</h3><p>在安装<code>XFCE</code>桌面环境时，有可能会出错，原因是perl为系统使用<code>zh_CN.UTF-8</code>，但系统不知道<code>zh_CN.UTF-8</code>是什么东西，所以需要安装一个中文语言，系统就知道<code>zh_CN.UTF-8</code>了，这个时候perl就不会报错了<br>​    - <code>apt-get install language-pack-zh-hans</code><br>​    - <code>apt-get install xfce4</code></p>\n<h3 id=\"安装GNOME图像界面\"><a href=\"#安装GNOME图像界面\" class=\"headerlink\" title=\"安装GNOME图像界面\"></a>安装GNOME图像界面</h3><p><code>apt-get install -y gnome</code><br><em>没有测试成功,似乎是不兼容的问题</em></p>\n<h3 id=\"安装MATE图像界面\"><a href=\"#安装MATE图像界面\" class=\"headerlink\" title=\"安装MATE图像界面\"></a>安装MATE图像界面</h3><p><code>apt-get install -y mate</code><br><img src=\"./为远程Ubuntu服务器安装图像界面/9.png\" alt=\"\"></p>\n<h3 id=\"安装LXDE图像界面\"><a href=\"#安装LXDE图像界面\" class=\"headerlink\" title=\"安装LXDE图像界面\"></a>安装LXDE图像界面</h3><p><code>apt-get install -y xorg lxde</code><br><img src=\"./为远程Ubuntu服务器安装图像界面/10.png\" alt=\"\"></p>\n<h3 id=\"重要配置\"><a href=\"#重要配置\" class=\"headerlink\" title=\"重要配置\"></a><strong>重要配置</strong></h3><p>开启远程连接时有可能会出现<code>mesg: ttyname failed: Inappropriate ioctl for device</code>错误，所以需要修改一下文件<br>​    - <code>nano /root/.profile</code><br>​    - 把<code>mesg n</code> 替换成 <code>tty -s &amp;&amp; mesg n</code></p>\n<h2 id=\"在客户端上安装X2go客户端\"><a href=\"#在客户端上安装X2go客户端\" class=\"headerlink\" title=\"在客户端上安装X2go客户端\"></a>在客户端上安装X2go客户端</h2><h3 id=\"MAC\"><a href=\"#MAC\" class=\"headerlink\" title=\"MAC\"></a>MAC</h3><ol>\n<li>安装<code>Xquartz</code> <a href=\"https://www.xquartz.org/\" rel=\"external nofollow\" target=\"_blank\">XQuartz</a></li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/1.png\" alt=\"\"></p>\n<ol>\n<li>输入命令</li>\n</ol>\n<p><code>echo &quot;*VT100.translations: #override Meta &lt;KeyPress&gt; V: insert-selection(PRIMARY, CUT_BUFFER0) \\n&quot; &gt; ~/.Xdefaults</code></p>\n<ol>\n<li><p>安装<code>X2Go Client</code> <a href=\"https://code.x2go.org/releases/binary-macosx/x2goclient/\" rel=\"external nofollow\" target=\"_blank\">X2Go Client</a></p>\n</li>\n<li><p>打开客户端，设置连接</p>\n</li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/2.png\" alt=\"\"></p>\n<ol>\n<li>检查客户端设置，确保X11被正确引导</li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/3.png\" alt=\"\"></p>\n<ol>\n<li>开始连接</li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/4.png\" alt=\"\"></p>\n<ol>\n<li>连接成功</li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/5.png\" alt=\"\"></p>\n<h3 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h3><ol>\n<li>安装<code>x2goclient</code> <a href=\"https://code.x2go.org/releases/binary-win32/x2goclient/releases/4.1.2.0-2018.06.22/\" rel=\"external nofollow\" target=\"_blank\">x2goclient</a></li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/6.png\" alt=\"\"></p>\n<ol>\n<li>配置好之后连接成功</li>\n</ol>\n<p><img src=\"./为远程Ubuntu服务器安装图像界面/7.png\" alt=\"\"></p>\n<h2 id=\"Linux下各种图像界面测评\"><a href=\"#Linux下各种图像界面测评\" class=\"headerlink\" title=\"Linux下各种图像界面测评\"></a>Linux下各种图像界面测评</h2><p><img src=\"./为远程Ubuntu服务器安装图像界面/8.png\" alt=\"\"></p>"},{"title":"强化学习","copyright":true,"top":100,"date":"2019-05-09T08:24:54.000Z","_content":"\n# 基础知识\n\n- [强化学习基本概念](./强化学习基本概念.html)\n- [强化学习的类别](./rl-classification.html)\n- [强化学习之MDP马尔科夫决策过程](./强化学习之MDP马尔科夫决策过程.html)\n- [价值与贝尔曼方程](./价值与贝尔曼方程.html)\n- [动态规划 Dynamic Programming](./dynamic-programming.html)\n- [Monte Carlo and Temporal-Difference](./mc-td.html)\n- [SARSA and Q-Learning](./sarsa-and-q-learning.html)\n\n\n\n# 论文精读\n\n- [Energy-Based Hindsight Experience Prioritization](./energy-based-hindsight-experience-prioritization.html)\n- [Maximum Entropy-Regularized Multi-Goal Reinforcement-Learning](./maximum-entropy-regularized-multi-goal-reinforcement-learning.html)\n- [Reinforcement Learning with Deep Energy-Based Policies](./rl-with-deep-energy-based-policies.html)\n- [Keeping Your Distance: Solving Sparse Reward Tasks Using Self-Balancing Shaped Rewards](./keeping-your-distance-solving-sparse-reward-tasks.html)\n\n## Open AI\n\n- [Evolution Strategies as a Scalable Alternative to Reinforcement Learning](./Evolution-Strategies-2017.html)\n- [Hindsight Experience Replay](./Hindsight-Experience-Replay.html)\n- [RL<sup>2</sup>: Fast Reinforcement Learning via Slow Reinforcement Learning](./rl2.html)\n\n## Deep Mind\n\n- [Prioritized Experience Replay](./Prioritized-Experience-Replay.html)\n- [Universal Value Function Approximators](./universal-value-function-approximators.html)\n- [Asynchronous Methods for Deep Reinforcement Learning](./asynchronous-methods-for-drl.html)\n\n# [论文浅读](./rl-rough-reading.html)\n\n- [Massively Parallel Methods for Deep Reinforcement Learning](./rl-rough-reading.html#Gorila)\n- [Model-Based Reinforcement Learning via Meta-Policy Optimization](./rl-rough-reading.html#MB-MPO)\n- [Diversity is All Your Need: Learning Skills Without a Reward Function](./rl-rough-reading.html#DIAYN)\n- [Curiosity-Driven Experience Prioritization via Density Estimation](./rl-rough-reading.html#CDP)\n- [Continuous Deep Q-Learning with Model-based Acceleration](./rl-rough-reading.html#NAF)\n- [Boosting Soft Actor-Critic: Emphasizing Recent Experience without Forgetting the Past](./rl-rough-reading.html#ERE)\n- [Reinforcement Learning with Attention that Works: A Self-Supervised Approach](./rl-rough-reading.html#6SAN)\n- [Multi-focus Attention Network for Efficient Deep Reinforcement Learning](./rl-rough-reading.html#MANet)\n- [Emergence of Locomotion Behaviours in Rich Environments](./dppo.html)\n- [Deep Exploration via Bootstrapped DQN](./bootstrapped-dqn.html)\n- [Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation](./h-dqn.html)\n- [FeUdal Networks for Hierarchical Reinforcement Learning](./FuNs.html)\n- [Exploration By Random Network Distillation](./random-network-distillation.html)\n\n# 相关信息\n\n- [强化学习的里程碑](./强化学习的里程碑.html)\n- [蓝猫淘气三千问](./rl3000questions.html)\n- [那些年在RL路上踩过的坑](./rl-code-pit.html)\n\n# 学习资源\n\n- [《Reinforcement Learning : An Introduction 2nd Edition》——Sutton](http://incompleteideas.net/book/RLbook2018.pdf)\n  - 基础必读\n  - 通俗易懂\n  - 数学公式很多，虽然很多不太实用，但对理解RL的精髓很有帮助\n- [Reinforcement Learning Course by David Silver, 2015](https://www.youtube.com/playlist?list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ)\n  - 基础必看，讲述了强化学习的基础算法\n  - 有字幕，通俗易懂\n  - 有课件Slide\n- [OpenAI Spinning Up](https://spinningup.openai.com/en/latest/)\n  - 深度强化学习\n  - 算法很多，解析也很清晰\n  - 有代码仓库，可以查看源代码，方便复现\n- [Medium : Reinforcement Learning](https://medium.com/search?q=reinforcement learning)\n  - 博文质量不错，内容涵盖基础与进阶\n  - 缺点：更新少\n- [StackOverflow : Reinforcement Learning](https://stackoverflow.com/questions/tagged/reinforcement-learning)\n  - 进阶必备\n  - 多看多交流可以加深自己的理解\n\n# 不错的代码仓库\n\n- [TianShou](https://github.com/thu-ml/tianshou)——An elegant, flexible, and superfast PyTorch deep Reinforcement Learning platform.\n  - pytorch\n  - 清华开源，适合入门\n- [Rainy](https://github.com/kngwyu/Rainy)——☔ Deep RL agents with PyTorch☔\n  - 有一些比较难复现的算法，比如PPOC","source":"_posts/强化学习.md","raw":"---\ntitle: 强化学习\ncopyright: true\ntop: 100\ndate: 2019-05-09 16:24:54\ncategories: ReinforcementLearning\ntags:\n- rl\n---\n\n# 基础知识\n\n- [强化学习基本概念](./强化学习基本概念.html)\n- [强化学习的类别](./rl-classification.html)\n- [强化学习之MDP马尔科夫决策过程](./强化学习之MDP马尔科夫决策过程.html)\n- [价值与贝尔曼方程](./价值与贝尔曼方程.html)\n- [动态规划 Dynamic Programming](./dynamic-programming.html)\n- [Monte Carlo and Temporal-Difference](./mc-td.html)\n- [SARSA and Q-Learning](./sarsa-and-q-learning.html)\n\n\n\n# 论文精读\n\n- [Energy-Based Hindsight Experience Prioritization](./energy-based-hindsight-experience-prioritization.html)\n- [Maximum Entropy-Regularized Multi-Goal Reinforcement-Learning](./maximum-entropy-regularized-multi-goal-reinforcement-learning.html)\n- [Reinforcement Learning with Deep Energy-Based Policies](./rl-with-deep-energy-based-policies.html)\n- [Keeping Your Distance: Solving Sparse Reward Tasks Using Self-Balancing Shaped Rewards](./keeping-your-distance-solving-sparse-reward-tasks.html)\n\n## Open AI\n\n- [Evolution Strategies as a Scalable Alternative to Reinforcement Learning](./Evolution-Strategies-2017.html)\n- [Hindsight Experience Replay](./Hindsight-Experience-Replay.html)\n- [RL<sup>2</sup>: Fast Reinforcement Learning via Slow Reinforcement Learning](./rl2.html)\n\n## Deep Mind\n\n- [Prioritized Experience Replay](./Prioritized-Experience-Replay.html)\n- [Universal Value Function Approximators](./universal-value-function-approximators.html)\n- [Asynchronous Methods for Deep Reinforcement Learning](./asynchronous-methods-for-drl.html)\n\n# [论文浅读](./rl-rough-reading.html)\n\n- [Massively Parallel Methods for Deep Reinforcement Learning](./rl-rough-reading.html#Gorila)\n- [Model-Based Reinforcement Learning via Meta-Policy Optimization](./rl-rough-reading.html#MB-MPO)\n- [Diversity is All Your Need: Learning Skills Without a Reward Function](./rl-rough-reading.html#DIAYN)\n- [Curiosity-Driven Experience Prioritization via Density Estimation](./rl-rough-reading.html#CDP)\n- [Continuous Deep Q-Learning with Model-based Acceleration](./rl-rough-reading.html#NAF)\n- [Boosting Soft Actor-Critic: Emphasizing Recent Experience without Forgetting the Past](./rl-rough-reading.html#ERE)\n- [Reinforcement Learning with Attention that Works: A Self-Supervised Approach](./rl-rough-reading.html#6SAN)\n- [Multi-focus Attention Network for Efficient Deep Reinforcement Learning](./rl-rough-reading.html#MANet)\n- [Emergence of Locomotion Behaviours in Rich Environments](./dppo.html)\n- [Deep Exploration via Bootstrapped DQN](./bootstrapped-dqn.html)\n- [Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation](./h-dqn.html)\n- [FeUdal Networks for Hierarchical Reinforcement Learning](./FuNs.html)\n- [Exploration By Random Network Distillation](./random-network-distillation.html)\n\n# 相关信息\n\n- [强化学习的里程碑](./强化学习的里程碑.html)\n- [蓝猫淘气三千问](./rl3000questions.html)\n- [那些年在RL路上踩过的坑](./rl-code-pit.html)\n\n# 学习资源\n\n- [《Reinforcement Learning : An Introduction 2nd Edition》——Sutton](http://incompleteideas.net/book/RLbook2018.pdf)\n  - 基础必读\n  - 通俗易懂\n  - 数学公式很多，虽然很多不太实用，但对理解RL的精髓很有帮助\n- [Reinforcement Learning Course by David Silver, 2015](https://www.youtube.com/playlist?list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ)\n  - 基础必看，讲述了强化学习的基础算法\n  - 有字幕，通俗易懂\n  - 有课件Slide\n- [OpenAI Spinning Up](https://spinningup.openai.com/en/latest/)\n  - 深度强化学习\n  - 算法很多，解析也很清晰\n  - 有代码仓库，可以查看源代码，方便复现\n- [Medium : Reinforcement Learning](https://medium.com/search?q=reinforcement learning)\n  - 博文质量不错，内容涵盖基础与进阶\n  - 缺点：更新少\n- [StackOverflow : Reinforcement Learning](https://stackoverflow.com/questions/tagged/reinforcement-learning)\n  - 进阶必备\n  - 多看多交流可以加深自己的理解\n\n# 不错的代码仓库\n\n- [TianShou](https://github.com/thu-ml/tianshou)——An elegant, flexible, and superfast PyTorch deep Reinforcement Learning platform.\n  - pytorch\n  - 清华开源，适合入门\n- [Rainy](https://github.com/kngwyu/Rainy)——☔ Deep RL agents with PyTorch☔\n  - 有一些比较难复现的算法，比如PPOC","slug":"强化学习","published":1,"updated":"2020-06-23T13:58:08.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzuszd002q20cd3toq9wlg","content":"<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><ul>\n<li><a href=\"./强化学习基本概念.html\">强化学习基本概念</a></li>\n<li><a href=\"./rl-classification.html\">强化学习的类别</a></li>\n<li><a href=\"./强化学习之MDP马尔科夫决策过程.html\">强化学习之MDP马尔科夫决策过程</a></li>\n<li><a href=\"./价值与贝尔曼方程.html\">价值与贝尔曼方程</a></li>\n<li><a href=\"./dynamic-programming.html\">动态规划 Dynamic Programming</a></li>\n<li><a href=\"./mc-td.html\">Monte Carlo and Temporal-Difference</a></li>\n<li><a href=\"./sarsa-and-q-learning.html\">SARSA and Q-Learning</a></li>\n</ul>\n<h1 id=\"论文精读\"><a href=\"#论文精读\" class=\"headerlink\" title=\"论文精读\"></a>论文精读</h1><ul>\n<li><a href=\"./energy-based-hindsight-experience-prioritization.html\">Energy-Based Hindsight Experience Prioritization</a></li>\n<li><a href=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning.html\">Maximum Entropy-Regularized Multi-Goal Reinforcement-Learning</a></li>\n<li><a href=\"./rl-with-deep-energy-based-policies.html\">Reinforcement Learning with Deep Energy-Based Policies</a></li>\n<li><a href=\"./keeping-your-distance-solving-sparse-reward-tasks.html\">Keeping Your Distance: Solving Sparse Reward Tasks Using Self-Balancing Shaped Rewards</a></li>\n</ul>\n<h2 id=\"Open-AI\"><a href=\"#Open-AI\" class=\"headerlink\" title=\"Open AI\"></a>Open AI</h2><ul>\n<li><a href=\"./Evolution-Strategies-2017.html\">Evolution Strategies as a Scalable Alternative to Reinforcement Learning</a></li>\n<li><a href=\"./Hindsight-Experience-Replay.html\">Hindsight Experience Replay</a></li>\n<li><a href=\"./rl2.html\">RL<sup>2</sup>: Fast Reinforcement Learning via Slow Reinforcement Learning</a></li>\n</ul>\n<h2 id=\"Deep-Mind\"><a href=\"#Deep-Mind\" class=\"headerlink\" title=\"Deep Mind\"></a>Deep Mind</h2><ul>\n<li><a href=\"./Prioritized-Experience-Replay.html\">Prioritized Experience Replay</a></li>\n<li><a href=\"./universal-value-function-approximators.html\">Universal Value Function Approximators</a></li>\n<li><a href=\"./asynchronous-methods-for-drl.html\">Asynchronous Methods for Deep Reinforcement Learning</a></li>\n</ul>\n<h1 id=\"论文浅读\"><a href=\"#论文浅读\" class=\"headerlink\" title=\"论文浅读\"></a><a href=\"./rl-rough-reading.html\">论文浅读</a></h1><ul>\n<li><a href=\"./rl-rough-reading.html#Gorila\">Massively Parallel Methods for Deep Reinforcement Learning</a></li>\n<li><a href=\"./rl-rough-reading.html#MB-MPO\">Model-Based Reinforcement Learning via Meta-Policy Optimization</a></li>\n<li><a href=\"./rl-rough-reading.html#DIAYN\">Diversity is All Your Need: Learning Skills Without a Reward Function</a></li>\n<li><a href=\"./rl-rough-reading.html#CDP\">Curiosity-Driven Experience Prioritization via Density Estimation</a></li>\n<li><a href=\"./rl-rough-reading.html#NAF\">Continuous Deep Q-Learning with Model-based Acceleration</a></li>\n<li><a href=\"./rl-rough-reading.html#ERE\">Boosting Soft Actor-Critic: Emphasizing Recent Experience without Forgetting the Past</a></li>\n<li><a href=\"./rl-rough-reading.html#6SAN\">Reinforcement Learning with Attention that Works: A Self-Supervised Approach</a></li>\n<li><a href=\"./rl-rough-reading.html#MANet\">Multi-focus Attention Network for Efficient Deep Reinforcement Learning</a></li>\n<li><a href=\"./dppo.html\">Emergence of Locomotion Behaviours in Rich Environments</a></li>\n<li><a href=\"./bootstrapped-dqn.html\">Deep Exploration via Bootstrapped DQN</a></li>\n<li><a href=\"./h-dqn.html\">Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation</a></li>\n<li><a href=\"./FuNs.html\">FeUdal Networks for Hierarchical Reinforcement Learning</a></li>\n<li><a href=\"./random-network-distillation.html\">Exploration By Random Network Distillation</a></li>\n</ul>\n<h1 id=\"相关信息\"><a href=\"#相关信息\" class=\"headerlink\" title=\"相关信息\"></a>相关信息</h1><ul>\n<li><a href=\"./强化学习的里程碑.html\">强化学习的里程碑</a></li>\n<li><a href=\"./rl3000questions.html\">蓝猫淘气三千问</a></li>\n<li><a href=\"./rl-code-pit.html\">那些年在RL路上踩过的坑</a></li>\n</ul>\n<h1 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h1><ul>\n<li><a href=\"http://incompleteideas.net/book/RLbook2018.pdf\" rel=\"external nofollow\" target=\"_blank\">《Reinforcement Learning : An Introduction 2nd Edition》——Sutton</a><ul>\n<li>基础必读</li>\n<li>通俗易懂</li>\n<li>数学公式很多，虽然很多不太实用，但对理解RL的精髓很有帮助</li>\n</ul>\n</li>\n<li><a href=\"https://www.youtube.com/playlist?list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ\" rel=\"external nofollow\" target=\"_blank\">Reinforcement Learning Course by David Silver, 2015</a><ul>\n<li>基础必看，讲述了强化学习的基础算法</li>\n<li>有字幕，通俗易懂</li>\n<li>有课件Slide</li>\n</ul>\n</li>\n<li><a href=\"https://spinningup.openai.com/en/latest/\" rel=\"external nofollow\" target=\"_blank\">OpenAI Spinning Up</a><ul>\n<li>深度强化学习</li>\n<li>算法很多，解析也很清晰</li>\n<li>有代码仓库，可以查看源代码，方便复现</li>\n</ul>\n</li>\n<li><a href=\"https://medium.com/search?q=reinforcement learning\" rel=\"external nofollow\" target=\"_blank\">Medium : Reinforcement Learning</a><ul>\n<li>博文质量不错，内容涵盖基础与进阶</li>\n<li>缺点：更新少</li>\n</ul>\n</li>\n<li><a href=\"https://stackoverflow.com/questions/tagged/reinforcement-learning\" rel=\"external nofollow\" target=\"_blank\">StackOverflow : Reinforcement Learning</a><ul>\n<li>进阶必备</li>\n<li>多看多交流可以加深自己的理解</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"不错的代码仓库\"><a href=\"#不错的代码仓库\" class=\"headerlink\" title=\"不错的代码仓库\"></a>不错的代码仓库</h1><ul>\n<li><a href=\"https://github.com/thu-ml/tianshou\" rel=\"external nofollow\" target=\"_blank\">TianShou</a>——An elegant, flexible, and superfast PyTorch deep Reinforcement Learning platform.<ul>\n<li>pytorch</li>\n<li>清华开源，适合入门</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/kngwyu/Rainy\" rel=\"external nofollow\" target=\"_blank\">Rainy</a>——☔ Deep RL agents with PyTorch☔<ul>\n<li>有一些比较难复现的算法，比如PPOC</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><ul>\n<li><a href=\"./强化学习基本概念.html\">强化学习基本概念</a></li>\n<li><a href=\"./rl-classification.html\">强化学习的类别</a></li>\n<li><a href=\"./强化学习之MDP马尔科夫决策过程.html\">强化学习之MDP马尔科夫决策过程</a></li>\n<li><a href=\"./价值与贝尔曼方程.html\">价值与贝尔曼方程</a></li>\n<li><a href=\"./dynamic-programming.html\">动态规划 Dynamic Programming</a></li>\n<li><a href=\"./mc-td.html\">Monte Carlo and Temporal-Difference</a></li>\n<li><a href=\"./sarsa-and-q-learning.html\">SARSA and Q-Learning</a></li>\n</ul>\n<h1 id=\"论文精读\"><a href=\"#论文精读\" class=\"headerlink\" title=\"论文精读\"></a>论文精读</h1><ul>\n<li><a href=\"./energy-based-hindsight-experience-prioritization.html\">Energy-Based Hindsight Experience Prioritization</a></li>\n<li><a href=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning.html\">Maximum Entropy-Regularized Multi-Goal Reinforcement-Learning</a></li>\n<li><a href=\"./rl-with-deep-energy-based-policies.html\">Reinforcement Learning with Deep Energy-Based Policies</a></li>\n<li><a href=\"./keeping-your-distance-solving-sparse-reward-tasks.html\">Keeping Your Distance: Solving Sparse Reward Tasks Using Self-Balancing Shaped Rewards</a></li>\n</ul>\n<h2 id=\"Open-AI\"><a href=\"#Open-AI\" class=\"headerlink\" title=\"Open AI\"></a>Open AI</h2><ul>\n<li><a href=\"./Evolution-Strategies-2017.html\">Evolution Strategies as a Scalable Alternative to Reinforcement Learning</a></li>\n<li><a href=\"./Hindsight-Experience-Replay.html\">Hindsight Experience Replay</a></li>\n<li><a href=\"./rl2.html\">RL<sup>2</sup>: Fast Reinforcement Learning via Slow Reinforcement Learning</a></li>\n</ul>\n<h2 id=\"Deep-Mind\"><a href=\"#Deep-Mind\" class=\"headerlink\" title=\"Deep Mind\"></a>Deep Mind</h2><ul>\n<li><a href=\"./Prioritized-Experience-Replay.html\">Prioritized Experience Replay</a></li>\n<li><a href=\"./universal-value-function-approximators.html\">Universal Value Function Approximators</a></li>\n<li><a href=\"./asynchronous-methods-for-drl.html\">Asynchronous Methods for Deep Reinforcement Learning</a></li>\n</ul>\n<h1 id=\"论文浅读\"><a href=\"#论文浅读\" class=\"headerlink\" title=\"论文浅读\"></a><a href=\"./rl-rough-reading.html\">论文浅读</a></h1><ul>\n<li><a href=\"./rl-rough-reading.html#Gorila\">Massively Parallel Methods for Deep Reinforcement Learning</a></li>\n<li><a href=\"./rl-rough-reading.html#MB-MPO\">Model-Based Reinforcement Learning via Meta-Policy Optimization</a></li>\n<li><a href=\"./rl-rough-reading.html#DIAYN\">Diversity is All Your Need: Learning Skills Without a Reward Function</a></li>\n<li><a href=\"./rl-rough-reading.html#CDP\">Curiosity-Driven Experience Prioritization via Density Estimation</a></li>\n<li><a href=\"./rl-rough-reading.html#NAF\">Continuous Deep Q-Learning with Model-based Acceleration</a></li>\n<li><a href=\"./rl-rough-reading.html#ERE\">Boosting Soft Actor-Critic: Emphasizing Recent Experience without Forgetting the Past</a></li>\n<li><a href=\"./rl-rough-reading.html#6SAN\">Reinforcement Learning with Attention that Works: A Self-Supervised Approach</a></li>\n<li><a href=\"./rl-rough-reading.html#MANet\">Multi-focus Attention Network for Efficient Deep Reinforcement Learning</a></li>\n<li><a href=\"./dppo.html\">Emergence of Locomotion Behaviours in Rich Environments</a></li>\n<li><a href=\"./bootstrapped-dqn.html\">Deep Exploration via Bootstrapped DQN</a></li>\n<li><a href=\"./h-dqn.html\">Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation</a></li>\n<li><a href=\"./FuNs.html\">FeUdal Networks for Hierarchical Reinforcement Learning</a></li>\n<li><a href=\"./random-network-distillation.html\">Exploration By Random Network Distillation</a></li>\n</ul>\n<h1 id=\"相关信息\"><a href=\"#相关信息\" class=\"headerlink\" title=\"相关信息\"></a>相关信息</h1><ul>\n<li><a href=\"./强化学习的里程碑.html\">强化学习的里程碑</a></li>\n<li><a href=\"./rl3000questions.html\">蓝猫淘气三千问</a></li>\n<li><a href=\"./rl-code-pit.html\">那些年在RL路上踩过的坑</a></li>\n</ul>\n<h1 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h1><ul>\n<li><a href=\"http://incompleteideas.net/book/RLbook2018.pdf\" rel=\"external nofollow\" target=\"_blank\">《Reinforcement Learning : An Introduction 2nd Edition》——Sutton</a><ul>\n<li>基础必读</li>\n<li>通俗易懂</li>\n<li>数学公式很多，虽然很多不太实用，但对理解RL的精髓很有帮助</li>\n</ul>\n</li>\n<li><a href=\"https://www.youtube.com/playlist?list=PLqYmG7hTraZDM-OYHWgPebj2MfCFzFObQ\" rel=\"external nofollow\" target=\"_blank\">Reinforcement Learning Course by David Silver, 2015</a><ul>\n<li>基础必看，讲述了强化学习的基础算法</li>\n<li>有字幕，通俗易懂</li>\n<li>有课件Slide</li>\n</ul>\n</li>\n<li><a href=\"https://spinningup.openai.com/en/latest/\" rel=\"external nofollow\" target=\"_blank\">OpenAI Spinning Up</a><ul>\n<li>深度强化学习</li>\n<li>算法很多，解析也很清晰</li>\n<li>有代码仓库，可以查看源代码，方便复现</li>\n</ul>\n</li>\n<li><a href=\"https://medium.com/search?q=reinforcement learning\" rel=\"external nofollow\" target=\"_blank\">Medium : Reinforcement Learning</a><ul>\n<li>博文质量不错，内容涵盖基础与进阶</li>\n<li>缺点：更新少</li>\n</ul>\n</li>\n<li><a href=\"https://stackoverflow.com/questions/tagged/reinforcement-learning\" rel=\"external nofollow\" target=\"_blank\">StackOverflow : Reinforcement Learning</a><ul>\n<li>进阶必备</li>\n<li>多看多交流可以加深自己的理解</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"不错的代码仓库\"><a href=\"#不错的代码仓库\" class=\"headerlink\" title=\"不错的代码仓库\"></a>不错的代码仓库</h1><ul>\n<li><a href=\"https://github.com/thu-ml/tianshou\" rel=\"external nofollow\" target=\"_blank\">TianShou</a>——An elegant, flexible, and superfast PyTorch deep Reinforcement Learning platform.<ul>\n<li>pytorch</li>\n<li>清华开源，适合入门</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/kngwyu/Rainy\" rel=\"external nofollow\" target=\"_blank\">Rainy</a>——☔ Deep RL agents with PyTorch☔<ul>\n<li>有一些比较难复现的算法，比如PPOC</li>\n</ul>\n</li>\n</ul>\n"},{"title":"强化学习的里程碑","copyright":true,"top":1,"date":"2019-05-07T00:26:39.000Z","mathjax":true,"_content":"\n# 强化学习的里程碑\n\n<!--more-->\n\n## Alpha Go\n\n> 阿尔法围棋（AlphaGo）是第一个击败人类职业围棋选手、第一个战胜围棋世界冠军的人工智能机器人，由谷歌（Google）旗下**DeepMind**公司戴密斯·哈萨比斯领衔的团队开发。其主要工作原理是“深度学习”。\n\n>> 2016年3月，阿尔法围棋与围棋世界冠军、职业九段棋手李世石进行围棋人机大战，以4比1的总比分获胜；\n\n>> ![](./强化学习的里程碑/LeeSedolBattleWithAlphaGo.jpeg)\n\n>> 2016年末2017年初，该程序在中国棋类网站上以“大师”（Master）为注册账号与中日韩数十位围棋高手进行快棋对决，连续60局无一败绩；\n\n>> 2017年5月，在中国乌镇围棋峰会上，它与排名世界第一的世界围棋冠军柯洁对战，以3比0的总比分获胜。围棋界公认阿尔法围棋的棋力已经超过人类职业围棋顶尖水平，在GoRatings网站公布的世界职业围棋排名中，其等级分曾超过排名人类第一的棋手柯洁。\n\n>> ![](./强化学习的里程碑/KeJieBattleWithAlphaGo.jpeg)\n\n>> 2017年5月27日，在柯洁与阿尔法围棋的人机大战之后，阿尔法围棋团队宣布阿尔法围棋将不再参加围棋比赛。\n\n>> 2017年10月18日，DeepMind团队公布了最强版阿尔法围棋，代号AlphaGo Zero。\n\n2016年3月机器学习一个重要的时间就是：名为AlphaGo的计算机程序打败了围棋世界冠军李世石，比分4：1。按理来说我们对机器在某项比赛、某些运动中击败人类顶尖选手不会感到大惊小怪，最著名的就是97年IBM的“深蓝（Deep Blue）”计算机程序打败了世界象棋冠军Garry Kasparov。\n\n![](./强化学习的里程碑/GKBattleWithDeepBlue.jpeg)\n\n机器同样是使用强大的算力以数倍、数十倍、数百倍的训练时间去击败人类（通常人类训练十年的时间，机器可以模拟训练几百年），为什么Alpha Go的取胜这么重要、这么引人关注（世界各地媒体疯狂报道，一股狂潮如炒作一般）呢？\n\n原因有两个：\n\n1. AlphaGo解决的围棋问题比之前的都要复杂，西洋双陆棋只有$10^{20}$种不同的“棋位”空间配置，深蓝打败人类的国际象棋有$10^{43}$种不同的“棋位”空间配置，而围棋却有$10^{170}$种不同的“棋位”空间配置，这种量级的数字人类已经无法处理（意思是对于这么多种不同的状态，就是目前算力最强的计算机也无能为力）。举个例子，$10^{170}$这个数字比宇宙中存在的原子数还多。为什么AlphaGo可以在围棋上击败人类就如此重要呢？因为机器如果可以解决这个大的状态空间的问题，那么在机器学习也应该能解决很复杂的现实世界中的问题。这意味着机器真正融入我们的劳动力市场，为我们的日常生活提供便利的日子已经不远啦（真的吗？）！\n2. AlphaGo解决的围棋问题不可能通过纯粹的、暴力计算的方式来学习出很好的模型，这就需要为AlphaGo设计一个更加“智能、聪明”的算法。AlphaGo引起热潮的另一个原因就是，其训练算法是一个通用算法，而不是一个专门为解决某项任务特别设计的算法，这与97年IBM的深蓝计算机程序完全不同，因为深蓝只能用于学习下国际象棋，在中国象棋中就不适于训练。此前，AlphaGo的前身已经能够在Atari 49个不同规则、不同游戏模式中使用相同的通用训练算法训练出比人类还厉害的模型，AlphaGo的成功意味着不仅在虚拟环境可以使用这一套学习方法训练模型，而且可以在不同的现实世界问题中使用这一套学习方法、代码结构。\n\n**有能力解决状态空间非常大的问题**和**通用学习算法**是使AlphaGo警报一时的两个主要原因，这也解释了为什么这场比赛在媒体上引起了轰动。有些人认为李世石的失败是机器占据人类劳动力市场的先兆，也有些人认为这预示着人工智能迎来了黄金时代，实际上我们距离真正的人工智能还有很长的路要走，就算机器可以在某项非常复杂的任务中超过人类的表现能力，其也没有真正的思维方式，不会进行思考，说到底也只是曲线的拟合罢了，但是，只有基础做好了，才能向上研究人工智能。\n\n构建AlphaGo和其前身（应用于Atari游戏）的学习算法的设计思路、计算架构在一系列论文和视频中都可以获得，而没有被Google（收购了英国公司DeepMind）私藏。为什么他不私藏呢？这么厉害的代码、设计思路没必要公开出来嘛，因为Google想把自己打造为基于云的机器学习和大数据的领导者，而它在2016年是全球第三大云服务提供商，排在微软和亚马逊之后，它需要把客户从其他平台引流到自己的平台上。由此可见，大公司们之间的竞争反而可以使我们平民获益。\n\n\n> [The Algorithm Behind the Curtain: How DeepMind Built a Machine that Beat a Go Master (1 of 5)](https://randomant.net/the-algorithm-behind-the-curtain/)","source":"_posts/强化学习的里程碑.md","raw":"---\ntitle: 强化学习的里程碑\ncopyright: true\ntop: 1\ndate: 2019-05-07 08:26:39\nmathjax: true\ncategories: ReinforcementLearning\ntags: rl\n---\n\n# 强化学习的里程碑\n\n<!--more-->\n\n## Alpha Go\n\n> 阿尔法围棋（AlphaGo）是第一个击败人类职业围棋选手、第一个战胜围棋世界冠军的人工智能机器人，由谷歌（Google）旗下**DeepMind**公司戴密斯·哈萨比斯领衔的团队开发。其主要工作原理是“深度学习”。\n\n>> 2016年3月，阿尔法围棋与围棋世界冠军、职业九段棋手李世石进行围棋人机大战，以4比1的总比分获胜；\n\n>> ![](./强化学习的里程碑/LeeSedolBattleWithAlphaGo.jpeg)\n\n>> 2016年末2017年初，该程序在中国棋类网站上以“大师”（Master）为注册账号与中日韩数十位围棋高手进行快棋对决，连续60局无一败绩；\n\n>> 2017年5月，在中国乌镇围棋峰会上，它与排名世界第一的世界围棋冠军柯洁对战，以3比0的总比分获胜。围棋界公认阿尔法围棋的棋力已经超过人类职业围棋顶尖水平，在GoRatings网站公布的世界职业围棋排名中，其等级分曾超过排名人类第一的棋手柯洁。\n\n>> ![](./强化学习的里程碑/KeJieBattleWithAlphaGo.jpeg)\n\n>> 2017年5月27日，在柯洁与阿尔法围棋的人机大战之后，阿尔法围棋团队宣布阿尔法围棋将不再参加围棋比赛。\n\n>> 2017年10月18日，DeepMind团队公布了最强版阿尔法围棋，代号AlphaGo Zero。\n\n2016年3月机器学习一个重要的时间就是：名为AlphaGo的计算机程序打败了围棋世界冠军李世石，比分4：1。按理来说我们对机器在某项比赛、某些运动中击败人类顶尖选手不会感到大惊小怪，最著名的就是97年IBM的“深蓝（Deep Blue）”计算机程序打败了世界象棋冠军Garry Kasparov。\n\n![](./强化学习的里程碑/GKBattleWithDeepBlue.jpeg)\n\n机器同样是使用强大的算力以数倍、数十倍、数百倍的训练时间去击败人类（通常人类训练十年的时间，机器可以模拟训练几百年），为什么Alpha Go的取胜这么重要、这么引人关注（世界各地媒体疯狂报道，一股狂潮如炒作一般）呢？\n\n原因有两个：\n\n1. AlphaGo解决的围棋问题比之前的都要复杂，西洋双陆棋只有$10^{20}$种不同的“棋位”空间配置，深蓝打败人类的国际象棋有$10^{43}$种不同的“棋位”空间配置，而围棋却有$10^{170}$种不同的“棋位”空间配置，这种量级的数字人类已经无法处理（意思是对于这么多种不同的状态，就是目前算力最强的计算机也无能为力）。举个例子，$10^{170}$这个数字比宇宙中存在的原子数还多。为什么AlphaGo可以在围棋上击败人类就如此重要呢？因为机器如果可以解决这个大的状态空间的问题，那么在机器学习也应该能解决很复杂的现实世界中的问题。这意味着机器真正融入我们的劳动力市场，为我们的日常生活提供便利的日子已经不远啦（真的吗？）！\n2. AlphaGo解决的围棋问题不可能通过纯粹的、暴力计算的方式来学习出很好的模型，这就需要为AlphaGo设计一个更加“智能、聪明”的算法。AlphaGo引起热潮的另一个原因就是，其训练算法是一个通用算法，而不是一个专门为解决某项任务特别设计的算法，这与97年IBM的深蓝计算机程序完全不同，因为深蓝只能用于学习下国际象棋，在中国象棋中就不适于训练。此前，AlphaGo的前身已经能够在Atari 49个不同规则、不同游戏模式中使用相同的通用训练算法训练出比人类还厉害的模型，AlphaGo的成功意味着不仅在虚拟环境可以使用这一套学习方法训练模型，而且可以在不同的现实世界问题中使用这一套学习方法、代码结构。\n\n**有能力解决状态空间非常大的问题**和**通用学习算法**是使AlphaGo警报一时的两个主要原因，这也解释了为什么这场比赛在媒体上引起了轰动。有些人认为李世石的失败是机器占据人类劳动力市场的先兆，也有些人认为这预示着人工智能迎来了黄金时代，实际上我们距离真正的人工智能还有很长的路要走，就算机器可以在某项非常复杂的任务中超过人类的表现能力，其也没有真正的思维方式，不会进行思考，说到底也只是曲线的拟合罢了，但是，只有基础做好了，才能向上研究人工智能。\n\n构建AlphaGo和其前身（应用于Atari游戏）的学习算法的设计思路、计算架构在一系列论文和视频中都可以获得，而没有被Google（收购了英国公司DeepMind）私藏。为什么他不私藏呢？这么厉害的代码、设计思路没必要公开出来嘛，因为Google想把自己打造为基于云的机器学习和大数据的领导者，而它在2016年是全球第三大云服务提供商，排在微软和亚马逊之后，它需要把客户从其他平台引流到自己的平台上。由此可见，大公司们之间的竞争反而可以使我们平民获益。\n\n\n> [The Algorithm Behind the Curtain: How DeepMind Built a Machine that Beat a Go Master (1 of 5)](https://randomant.net/the-algorithm-behind-the-curtain/)","slug":"强化学习的里程碑","published":1,"updated":"2019-05-10T12:39:30.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut8d004820cd6hoog5wp","content":"<h1 id=\"强化学习的里程碑\"><a href=\"#强化学习的里程碑\" class=\"headerlink\" title=\"强化学习的里程碑\"></a>强化学习的里程碑</h1><a id=\"more\"></a>\n<h2 id=\"Alpha-Go\"><a href=\"#Alpha-Go\" class=\"headerlink\" title=\"Alpha Go\"></a>Alpha Go</h2><blockquote>\n<p>阿尔法围棋（AlphaGo）是第一个击败人类职业围棋选手、第一个战胜围棋世界冠军的人工智能机器人，由谷歌（Google）旗下<strong>DeepMind</strong>公司戴密斯·哈萨比斯领衔的团队开发。其主要工作原理是“深度学习”。</p>\n<blockquote>\n<p>2016年3月，阿尔法围棋与围棋世界冠军、职业九段棋手李世石进行围棋人机大战，以4比1的总比分获胜；</p>\n<p><img src=\"./强化学习的里程碑/LeeSedolBattleWithAlphaGo.jpeg\" alt=\"\"></p>\n<p>2016年末2017年初，该程序在中国棋类网站上以“大师”（Master）为注册账号与中日韩数十位围棋高手进行快棋对决，连续60局无一败绩；</p>\n<p>2017年5月，在中国乌镇围棋峰会上，它与排名世界第一的世界围棋冠军柯洁对战，以3比0的总比分获胜。围棋界公认阿尔法围棋的棋力已经超过人类职业围棋顶尖水平，在GoRatings网站公布的世界职业围棋排名中，其等级分曾超过排名人类第一的棋手柯洁。</p>\n<p><img src=\"./强化学习的里程碑/KeJieBattleWithAlphaGo.jpeg\" alt=\"\"></p>\n<p>2017年5月27日，在柯洁与阿尔法围棋的人机大战之后，阿尔法围棋团队宣布阿尔法围棋将不再参加围棋比赛。</p>\n<p>2017年10月18日，DeepMind团队公布了最强版阿尔法围棋，代号AlphaGo Zero。</p>\n</blockquote>\n</blockquote>\n<p>2016年3月机器学习一个重要的时间就是：名为AlphaGo的计算机程序打败了围棋世界冠军李世石，比分4：1。按理来说我们对机器在某项比赛、某些运动中击败人类顶尖选手不会感到大惊小怪，最著名的就是97年IBM的“深蓝（Deep Blue）”计算机程序打败了世界象棋冠军Garry Kasparov。</p>\n<p><img src=\"./强化学习的里程碑/GKBattleWithDeepBlue.jpeg\" alt=\"\"></p>\n<p>机器同样是使用强大的算力以数倍、数十倍、数百倍的训练时间去击败人类（通常人类训练十年的时间，机器可以模拟训练几百年），为什么Alpha Go的取胜这么重要、这么引人关注（世界各地媒体疯狂报道，一股狂潮如炒作一般）呢？</p>\n<p>原因有两个：</p>\n<ol>\n<li>AlphaGo解决的围棋问题比之前的都要复杂，西洋双陆棋只有$10^{20}$种不同的“棋位”空间配置，深蓝打败人类的国际象棋有$10^{43}$种不同的“棋位”空间配置，而围棋却有$10^{170}$种不同的“棋位”空间配置，这种量级的数字人类已经无法处理（意思是对于这么多种不同的状态，就是目前算力最强的计算机也无能为力）。举个例子，$10^{170}$这个数字比宇宙中存在的原子数还多。为什么AlphaGo可以在围棋上击败人类就如此重要呢？因为机器如果可以解决这个大的状态空间的问题，那么在机器学习也应该能解决很复杂的现实世界中的问题。这意味着机器真正融入我们的劳动力市场，为我们的日常生活提供便利的日子已经不远啦（真的吗？）！</li>\n<li>AlphaGo解决的围棋问题不可能通过纯粹的、暴力计算的方式来学习出很好的模型，这就需要为AlphaGo设计一个更加“智能、聪明”的算法。AlphaGo引起热潮的另一个原因就是，其训练算法是一个通用算法，而不是一个专门为解决某项任务特别设计的算法，这与97年IBM的深蓝计算机程序完全不同，因为深蓝只能用于学习下国际象棋，在中国象棋中就不适于训练。此前，AlphaGo的前身已经能够在Atari 49个不同规则、不同游戏模式中使用相同的通用训练算法训练出比人类还厉害的模型，AlphaGo的成功意味着不仅在虚拟环境可以使用这一套学习方法训练模型，而且可以在不同的现实世界问题中使用这一套学习方法、代码结构。</li>\n</ol>\n<p><strong>有能力解决状态空间非常大的问题</strong>和<strong>通用学习算法</strong>是使AlphaGo警报一时的两个主要原因，这也解释了为什么这场比赛在媒体上引起了轰动。有些人认为李世石的失败是机器占据人类劳动力市场的先兆，也有些人认为这预示着人工智能迎来了黄金时代，实际上我们距离真正的人工智能还有很长的路要走，就算机器可以在某项非常复杂的任务中超过人类的表现能力，其也没有真正的思维方式，不会进行思考，说到底也只是曲线的拟合罢了，但是，只有基础做好了，才能向上研究人工智能。</p>\n<p>构建AlphaGo和其前身（应用于Atari游戏）的学习算法的设计思路、计算架构在一系列论文和视频中都可以获得，而没有被Google（收购了英国公司DeepMind）私藏。为什么他不私藏呢？这么厉害的代码、设计思路没必要公开出来嘛，因为Google想把自己打造为基于云的机器学习和大数据的领导者，而它在2016年是全球第三大云服务提供商，排在微软和亚马逊之后，它需要把客户从其他平台引流到自己的平台上。由此可见，大公司们之间的竞争反而可以使我们平民获益。</p>\n<blockquote>\n<p><a href=\"https://randomant.net/the-algorithm-behind-the-curtain/\" rel=\"external nofollow\" target=\"_blank\">The Algorithm Behind the Curtain: How DeepMind Built a Machine that Beat a Go Master (1 of 5)</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"强化学习的里程碑\"><a href=\"#强化学习的里程碑\" class=\"headerlink\" title=\"强化学习的里程碑\"></a>强化学习的里程碑</h1>","more":"<h2 id=\"Alpha-Go\"><a href=\"#Alpha-Go\" class=\"headerlink\" title=\"Alpha Go\"></a>Alpha Go</h2><blockquote>\n<p>阿尔法围棋（AlphaGo）是第一个击败人类职业围棋选手、第一个战胜围棋世界冠军的人工智能机器人，由谷歌（Google）旗下<strong>DeepMind</strong>公司戴密斯·哈萨比斯领衔的团队开发。其主要工作原理是“深度学习”。</p>\n<blockquote>\n<p>2016年3月，阿尔法围棋与围棋世界冠军、职业九段棋手李世石进行围棋人机大战，以4比1的总比分获胜；</p>\n<p><img src=\"./强化学习的里程碑/LeeSedolBattleWithAlphaGo.jpeg\" alt=\"\"></p>\n<p>2016年末2017年初，该程序在中国棋类网站上以“大师”（Master）为注册账号与中日韩数十位围棋高手进行快棋对决，连续60局无一败绩；</p>\n<p>2017年5月，在中国乌镇围棋峰会上，它与排名世界第一的世界围棋冠军柯洁对战，以3比0的总比分获胜。围棋界公认阿尔法围棋的棋力已经超过人类职业围棋顶尖水平，在GoRatings网站公布的世界职业围棋排名中，其等级分曾超过排名人类第一的棋手柯洁。</p>\n<p><img src=\"./强化学习的里程碑/KeJieBattleWithAlphaGo.jpeg\" alt=\"\"></p>\n<p>2017年5月27日，在柯洁与阿尔法围棋的人机大战之后，阿尔法围棋团队宣布阿尔法围棋将不再参加围棋比赛。</p>\n<p>2017年10月18日，DeepMind团队公布了最强版阿尔法围棋，代号AlphaGo Zero。</p>\n</blockquote>\n</blockquote>\n<p>2016年3月机器学习一个重要的时间就是：名为AlphaGo的计算机程序打败了围棋世界冠军李世石，比分4：1。按理来说我们对机器在某项比赛、某些运动中击败人类顶尖选手不会感到大惊小怪，最著名的就是97年IBM的“深蓝（Deep Blue）”计算机程序打败了世界象棋冠军Garry Kasparov。</p>\n<p><img src=\"./强化学习的里程碑/GKBattleWithDeepBlue.jpeg\" alt=\"\"></p>\n<p>机器同样是使用强大的算力以数倍、数十倍、数百倍的训练时间去击败人类（通常人类训练十年的时间，机器可以模拟训练几百年），为什么Alpha Go的取胜这么重要、这么引人关注（世界各地媒体疯狂报道，一股狂潮如炒作一般）呢？</p>\n<p>原因有两个：</p>\n<ol>\n<li>AlphaGo解决的围棋问题比之前的都要复杂，西洋双陆棋只有$10^{20}$种不同的“棋位”空间配置，深蓝打败人类的国际象棋有$10^{43}$种不同的“棋位”空间配置，而围棋却有$10^{170}$种不同的“棋位”空间配置，这种量级的数字人类已经无法处理（意思是对于这么多种不同的状态，就是目前算力最强的计算机也无能为力）。举个例子，$10^{170}$这个数字比宇宙中存在的原子数还多。为什么AlphaGo可以在围棋上击败人类就如此重要呢？因为机器如果可以解决这个大的状态空间的问题，那么在机器学习也应该能解决很复杂的现实世界中的问题。这意味着机器真正融入我们的劳动力市场，为我们的日常生活提供便利的日子已经不远啦（真的吗？）！</li>\n<li>AlphaGo解决的围棋问题不可能通过纯粹的、暴力计算的方式来学习出很好的模型，这就需要为AlphaGo设计一个更加“智能、聪明”的算法。AlphaGo引起热潮的另一个原因就是，其训练算法是一个通用算法，而不是一个专门为解决某项任务特别设计的算法，这与97年IBM的深蓝计算机程序完全不同，因为深蓝只能用于学习下国际象棋，在中国象棋中就不适于训练。此前，AlphaGo的前身已经能够在Atari 49个不同规则、不同游戏模式中使用相同的通用训练算法训练出比人类还厉害的模型，AlphaGo的成功意味着不仅在虚拟环境可以使用这一套学习方法训练模型，而且可以在不同的现实世界问题中使用这一套学习方法、代码结构。</li>\n</ol>\n<p><strong>有能力解决状态空间非常大的问题</strong>和<strong>通用学习算法</strong>是使AlphaGo警报一时的两个主要原因，这也解释了为什么这场比赛在媒体上引起了轰动。有些人认为李世石的失败是机器占据人类劳动力市场的先兆，也有些人认为这预示着人工智能迎来了黄金时代，实际上我们距离真正的人工智能还有很长的路要走，就算机器可以在某项非常复杂的任务中超过人类的表现能力，其也没有真正的思维方式，不会进行思考，说到底也只是曲线的拟合罢了，但是，只有基础做好了，才能向上研究人工智能。</p>\n<p>构建AlphaGo和其前身（应用于Atari游戏）的学习算法的设计思路、计算架构在一系列论文和视频中都可以获得，而没有被Google（收购了英国公司DeepMind）私藏。为什么他不私藏呢？这么厉害的代码、设计思路没必要公开出来嘛，因为Google想把自己打造为基于云的机器学习和大数据的领导者，而它在2016年是全球第三大云服务提供商，排在微软和亚马逊之后，它需要把客户从其他平台引流到自己的平台上。由此可见，大公司们之间的竞争反而可以使我们平民获益。</p>\n<blockquote>\n<p><a href=\"https://randomant.net/the-algorithm-behind-the-curtain/\" rel=\"external nofollow\" target=\"_blank\">The Algorithm Behind the Curtain: How DeepMind Built a Machine that Beat a Go Master (1 of 5)</a></p>\n</blockquote>"},{"title":"Evolution Strategies as a Scalable Alternative to Reinforcement Learning","copyright":true,"mathjax":true,"top":1,"date":"2019-05-21T04:38:54.000Z","keywords":null,"description":null,"_content":"\n这一篇论文讲了强化学习算法的替代可解方案：进化策略。主要思想是对参数空间添加噪音而不是动作空间。\n\n不推荐这篇论文：\n\n- 公式没有详细推理，非常难懂\n- 文中进化策略其实跟强化学习并没有特别大的关系\n- 很多关于进化策略的性质、优势非常难懂，基本上都是文字解释，没有举例\n- 文中措辞不难，但想要理解其本质非常难\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1703.03864.pdf](https://arxiv.org/pdf/1703.03864.pdf)\n\n进化策略ES是一组/一类算法，而不是一个算法，它属于黑盒优化方法，它由自然进化中的启发式搜索过程而得来：每一代中都有突变的基因，环境对基因突变的效果给出适应性的判断，重组好的突变基因产生下一代，直到最优。\n\n进化策略算法的划分主要有三个依据：基因如何表示（神经网络参数）、突变如何产生（参数优化过程）、基因如何重组（参数重组）。\n\n进化策略ES这种方法通常分为[直接策略搜索](https://pdfs.semanticscholar.org/dd17/8d3f30d801922c98cec9c2d90db05395f244.pdf?_ga=2.257341323.183297583.1558416128-1251761365.1555224483)和[神经进化](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7307180&tag=1)，黑盒优化方法有很多很好的特性：\n\n1. 不关心奖励分布，奖励密集或稀疏都无所谓\n2. 不需要反向传播梯度\n3. tolerance of potentially arbitrarily long time horizons. 翻译为可以适应长期视野/回报，在长动作序列上有优势\n\n但是，进化策略ES往往不能解决像Q-Learning和PG这样可应用的难的强化学习问题，这篇论文旨在使进化策略可以解决DRL算法可解决的更难的问题。\n\n# 正文精要\n\n> A large source of difficulty in RL stems from the lack of informative gradients of policy performance: such gradients may not exist due to non-smoothness of the environment or policy, or may only be available as high-variance estimates because the environment usually can only be accessed via sampling.  \n\n指出强化学习的难题在于缺乏策略性能的有效梯度：梯度可能由于环境不光滑而不存在、可能由于只能采样环境而存在高方差。\n\n> For MDP-based reinforcement learning algorithms, on the other hand, it is well known that frameskip is a crucial parameter to get right for the optimization to succeed.\n\n对于基于MDP的强化学习算法，**跳帧**是算法优化的关键参数。\n\n> It is common practice in RL to have the agent decide on its actions in a lower frequency than is used in the simulator that runs the environment.\n\nRL通常使智能体在模拟环境中决策频率高于在实际环境中。\n\n---\n\n文中设定一个策略的期望奖励为：\n$$\n\\mathbb{E}_{\\epsilon \\sim N(0,I)}F(\\theta+\\sigma\\epsilon)\n$$\n关于网络参数$\\theta$的导数为：\n$$\n\\nabla_{\\theta}\\mathbb{E}_{\\epsilon \\sim N(0,I)}F(\\theta+\\sigma\\epsilon)=\\frac{1}{\\sigma}\\mathbb{E}_{\\epsilon \\sim N(0,I)} \\{F(\\theta+\\sigma\\epsilon)\\epsilon \\}\n$$\n其中，$\\theta$为网络参数，也可以认为是多变量高斯分布的均值，$\\sigma$为固定方差，$\\epsilon$为扰动向量，由各向同性、方差均为1的多变量高斯分布采样得到。**文中没有对该导数推导过程有介绍，好像是使用了Reinforce Trick的方法，但是却不知道具体如何推导出这个形式**。\n\n文中提到的算法1是对一个策略进行多次扰动，每扰动一次就与环境交互得到一个episode，最后只用各个扰动向量$\\epsilon_{i}$与对应的回报$F(\\theta)$相乘，根据该期望进行参数更新。\n\n![](./Evolution-Strategies-2017/algorithm1.png)\n\n算法2是对算法1的并行化处理，设置相同的随机种子，假设n个worker：\n\n1. 各个worker共用一个策略$\\pi$\n2. 每个worker根据高斯分布采样得到扰动向量$\\epsilon$\n3. 各个worker根据扰动后的策略参数采样一个episode\n4. 互相分发各自的回报\n5. **再采样n个扰动向量$\\epsilon$**，使用梯度上升更新参数，然后分发策略\n\n![](./Evolution-Strategies-2017/algorithm2.png)\n\n文中后边提到，其实不必每次都从高斯分布中采样出扰动向量$\\epsilon$，可以在开始训练前直接采样得到m个扰动向量，每次需要扰动向量时直接根据m的值生成一个随机数，取出以该随机数为下标的扰动向量即可。这么做可以减少更新时的时长消耗。\n\n---\n\n> Experiments on Atari and MuJoCo show that it is a viable option with some attractive features: it is invariant to action frequency and delayed rewards, and it does not need temporal discounting or value function approximation. Most importantly, ES is highly parallelizable, which allows us to make up for a decreased data efficiency by scaling to more parallel workers. \n\n文中使用的进化策略ES的优点：\n\n- 与决策间隔无关，也就是对于跳帧间隔的设置鲁棒性很高\n- 不关心延迟奖励\n- 不需要折扣计算回报\n- 不需要值函数近似\n- 可以高度并行化使，我们能够通过扩展到更多并行训练节点来弥补数据效率的下降。\n\n# 实验发现\n\n1. 使用[Virtual Batch Normalization](https://arxiv.org/pdf/1606.03498.pdf)和神经网络策略重参数（文中没有提到重参数的内容，只提到网络参数的影响）可以极大提升进化策略ES的可靠性。实验中，不使用这两种方法算法很“脆弱”，也就是不稳定。\n2. 进化策略ES可以高度并行化。通过引入一个基于通用随机数的新颖通讯策略，即是是1000个子节点也可以达到运行时间的线性加速。\n3. 进化策略ES的数据效率出奇的好。尽管相比A3C算法需要3-10倍的数据量，但是由于具有不需反向传播、没有值函数等特点，这些轻微的数据效率劣势可以被弥补。实验表明，相同计算量下，1小时ES与1天A3C的效果基本相同。\n4. 进化策略ES相比PG类算法的探索性更强。\n5. 进化策略ES的鲁棒性很好。多种不同训练环境可以使用同一组超参数。\n\n# 实验结果\n\n## MuJoCo\n\n与**高度优化**的TRPO算法相比，ES在离散动作更有优势，因为连续动作在参数扰动方面可能过于平滑并且可能妨碍探索。\n\nES和TRPO的网络结构都是：输入层→64，tanh→64，tanh→输出层。\n\n复杂环境如Hopper和Walker2d中，ES样本复杂性相比TRPO高不到10倍；简单场景中，相比低3倍。\n\nTRPO训练500W步，ES训练至TRPO训练过程中各阶段效果所需步长的比例如表所示：\n\n![](./Evolution-Strategies-2017/mujoco.png)\n\n虽然文中说是简单场景低三倍，其实根本就没有明确的低三倍，而且我对文中所提的简单场景复杂场景的划分也持怀疑态度。\n\n## Atari\n\n预处理、网络架构与Atari那篇论文的一模一样，用A3C使用3.2亿帧训练1天的结果与使用ES训练10亿帧的结果相同（保持计算量相同，因为ES不需要反向传播和值函数评估）。使用720块cpu，训练一个游戏只需1小时。\n\n最终，纯图像输入下，与A3C相比，23个游戏ES胜，28个游戏A3C胜。\n\n![](./Evolution-Strategies-2017/atari.png)\n\n## 并行化 Parallelization\n\nES特别适合并行化，因为其通讯低带宽特性（只需各个worker的回报和随机种子）。\n\n测试环境：3D Humanoid walking task\n\n结果：单机18核需11小时，与最先进的强化学习算法性能相当，80台机器1440个CPU核心只需10分钟。\n\n![](./Evolution-Strategies-2017/parallelization.png)\n\n随着核心数增加，训练性能线性加速。\n\n## “跳帧”测试\n\n将强化学习在模拟环境中训练出的模型用于实际环境中式，通常需要降低其决策频率，也就是加大决策间隔。\n\n如果跳帧设置过大，智能体所做的动作往往不够好，如果跳帧设置过小，会导致每个episode的步数过长，加大计算量，恶化训练过程（其实文中这么说并不严谨）。\n\nES的一个优势是梯度计算与回合长度无关，这间接增加了对跳帧间隔的鲁棒性。在Atari游戏Pong中使用四个不同跳帧间隔{1，2，3，4}的学习曲线如下：\n\n![](./Evolution-Strategies-2017/frame-skip.png)\n\n由曲线可以看出，不同的跳帧间隔，训练效果差不多。**但，我对该鲁棒性测试在复杂环境中的效果表示怀疑。我觉得前沿强化学习算法在该训练场景中使用不同的跳帧间隔也可以得到相同结果。**","source":"_posts/Evolution-Strategies-2017.md","raw":"---\ntitle: Evolution Strategies as a Scalable Alternative to Reinforcement Learning\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2019-05-21 12:38:54\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n这一篇论文讲了强化学习算法的替代可解方案：进化策略。主要思想是对参数空间添加噪音而不是动作空间。\n\n不推荐这篇论文：\n\n- 公式没有详细推理，非常难懂\n- 文中进化策略其实跟强化学习并没有特别大的关系\n- 很多关于进化策略的性质、优势非常难懂，基本上都是文字解释，没有举例\n- 文中措辞不难，但想要理解其本质非常难\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1703.03864.pdf](https://arxiv.org/pdf/1703.03864.pdf)\n\n进化策略ES是一组/一类算法，而不是一个算法，它属于黑盒优化方法，它由自然进化中的启发式搜索过程而得来：每一代中都有突变的基因，环境对基因突变的效果给出适应性的判断，重组好的突变基因产生下一代，直到最优。\n\n进化策略算法的划分主要有三个依据：基因如何表示（神经网络参数）、突变如何产生（参数优化过程）、基因如何重组（参数重组）。\n\n进化策略ES这种方法通常分为[直接策略搜索](https://pdfs.semanticscholar.org/dd17/8d3f30d801922c98cec9c2d90db05395f244.pdf?_ga=2.257341323.183297583.1558416128-1251761365.1555224483)和[神经进化](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7307180&tag=1)，黑盒优化方法有很多很好的特性：\n\n1. 不关心奖励分布，奖励密集或稀疏都无所谓\n2. 不需要反向传播梯度\n3. tolerance of potentially arbitrarily long time horizons. 翻译为可以适应长期视野/回报，在长动作序列上有优势\n\n但是，进化策略ES往往不能解决像Q-Learning和PG这样可应用的难的强化学习问题，这篇论文旨在使进化策略可以解决DRL算法可解决的更难的问题。\n\n# 正文精要\n\n> A large source of difficulty in RL stems from the lack of informative gradients of policy performance: such gradients may not exist due to non-smoothness of the environment or policy, or may only be available as high-variance estimates because the environment usually can only be accessed via sampling.  \n\n指出强化学习的难题在于缺乏策略性能的有效梯度：梯度可能由于环境不光滑而不存在、可能由于只能采样环境而存在高方差。\n\n> For MDP-based reinforcement learning algorithms, on the other hand, it is well known that frameskip is a crucial parameter to get right for the optimization to succeed.\n\n对于基于MDP的强化学习算法，**跳帧**是算法优化的关键参数。\n\n> It is common practice in RL to have the agent decide on its actions in a lower frequency than is used in the simulator that runs the environment.\n\nRL通常使智能体在模拟环境中决策频率高于在实际环境中。\n\n---\n\n文中设定一个策略的期望奖励为：\n$$\n\\mathbb{E}_{\\epsilon \\sim N(0,I)}F(\\theta+\\sigma\\epsilon)\n$$\n关于网络参数$\\theta$的导数为：\n$$\n\\nabla_{\\theta}\\mathbb{E}_{\\epsilon \\sim N(0,I)}F(\\theta+\\sigma\\epsilon)=\\frac{1}{\\sigma}\\mathbb{E}_{\\epsilon \\sim N(0,I)} \\{F(\\theta+\\sigma\\epsilon)\\epsilon \\}\n$$\n其中，$\\theta$为网络参数，也可以认为是多变量高斯分布的均值，$\\sigma$为固定方差，$\\epsilon$为扰动向量，由各向同性、方差均为1的多变量高斯分布采样得到。**文中没有对该导数推导过程有介绍，好像是使用了Reinforce Trick的方法，但是却不知道具体如何推导出这个形式**。\n\n文中提到的算法1是对一个策略进行多次扰动，每扰动一次就与环境交互得到一个episode，最后只用各个扰动向量$\\epsilon_{i}$与对应的回报$F(\\theta)$相乘，根据该期望进行参数更新。\n\n![](./Evolution-Strategies-2017/algorithm1.png)\n\n算法2是对算法1的并行化处理，设置相同的随机种子，假设n个worker：\n\n1. 各个worker共用一个策略$\\pi$\n2. 每个worker根据高斯分布采样得到扰动向量$\\epsilon$\n3. 各个worker根据扰动后的策略参数采样一个episode\n4. 互相分发各自的回报\n5. **再采样n个扰动向量$\\epsilon$**，使用梯度上升更新参数，然后分发策略\n\n![](./Evolution-Strategies-2017/algorithm2.png)\n\n文中后边提到，其实不必每次都从高斯分布中采样出扰动向量$\\epsilon$，可以在开始训练前直接采样得到m个扰动向量，每次需要扰动向量时直接根据m的值生成一个随机数，取出以该随机数为下标的扰动向量即可。这么做可以减少更新时的时长消耗。\n\n---\n\n> Experiments on Atari and MuJoCo show that it is a viable option with some attractive features: it is invariant to action frequency and delayed rewards, and it does not need temporal discounting or value function approximation. Most importantly, ES is highly parallelizable, which allows us to make up for a decreased data efficiency by scaling to more parallel workers. \n\n文中使用的进化策略ES的优点：\n\n- 与决策间隔无关，也就是对于跳帧间隔的设置鲁棒性很高\n- 不关心延迟奖励\n- 不需要折扣计算回报\n- 不需要值函数近似\n- 可以高度并行化使，我们能够通过扩展到更多并行训练节点来弥补数据效率的下降。\n\n# 实验发现\n\n1. 使用[Virtual Batch Normalization](https://arxiv.org/pdf/1606.03498.pdf)和神经网络策略重参数（文中没有提到重参数的内容，只提到网络参数的影响）可以极大提升进化策略ES的可靠性。实验中，不使用这两种方法算法很“脆弱”，也就是不稳定。\n2. 进化策略ES可以高度并行化。通过引入一个基于通用随机数的新颖通讯策略，即是是1000个子节点也可以达到运行时间的线性加速。\n3. 进化策略ES的数据效率出奇的好。尽管相比A3C算法需要3-10倍的数据量，但是由于具有不需反向传播、没有值函数等特点，这些轻微的数据效率劣势可以被弥补。实验表明，相同计算量下，1小时ES与1天A3C的效果基本相同。\n4. 进化策略ES相比PG类算法的探索性更强。\n5. 进化策略ES的鲁棒性很好。多种不同训练环境可以使用同一组超参数。\n\n# 实验结果\n\n## MuJoCo\n\n与**高度优化**的TRPO算法相比，ES在离散动作更有优势，因为连续动作在参数扰动方面可能过于平滑并且可能妨碍探索。\n\nES和TRPO的网络结构都是：输入层→64，tanh→64，tanh→输出层。\n\n复杂环境如Hopper和Walker2d中，ES样本复杂性相比TRPO高不到10倍；简单场景中，相比低3倍。\n\nTRPO训练500W步，ES训练至TRPO训练过程中各阶段效果所需步长的比例如表所示：\n\n![](./Evolution-Strategies-2017/mujoco.png)\n\n虽然文中说是简单场景低三倍，其实根本就没有明确的低三倍，而且我对文中所提的简单场景复杂场景的划分也持怀疑态度。\n\n## Atari\n\n预处理、网络架构与Atari那篇论文的一模一样，用A3C使用3.2亿帧训练1天的结果与使用ES训练10亿帧的结果相同（保持计算量相同，因为ES不需要反向传播和值函数评估）。使用720块cpu，训练一个游戏只需1小时。\n\n最终，纯图像输入下，与A3C相比，23个游戏ES胜，28个游戏A3C胜。\n\n![](./Evolution-Strategies-2017/atari.png)\n\n## 并行化 Parallelization\n\nES特别适合并行化，因为其通讯低带宽特性（只需各个worker的回报和随机种子）。\n\n测试环境：3D Humanoid walking task\n\n结果：单机18核需11小时，与最先进的强化学习算法性能相当，80台机器1440个CPU核心只需10分钟。\n\n![](./Evolution-Strategies-2017/parallelization.png)\n\n随着核心数增加，训练性能线性加速。\n\n## “跳帧”测试\n\n将强化学习在模拟环境中训练出的模型用于实际环境中式，通常需要降低其决策频率，也就是加大决策间隔。\n\n如果跳帧设置过大，智能体所做的动作往往不够好，如果跳帧设置过小，会导致每个episode的步数过长，加大计算量，恶化训练过程（其实文中这么说并不严谨）。\n\nES的一个优势是梯度计算与回合长度无关，这间接增加了对跳帧间隔的鲁棒性。在Atari游戏Pong中使用四个不同跳帧间隔{1，2，3，4}的学习曲线如下：\n\n![](./Evolution-Strategies-2017/frame-skip.png)\n\n由曲线可以看出，不同的跳帧间隔，训练效果差不多。**但，我对该鲁棒性测试在复杂环境中的效果表示怀疑。我觉得前沿强化学习算法在该训练场景中使用不同的跳帧间隔也可以得到相同结果。**","slug":"Evolution-Strategies-2017","published":1,"updated":"2019-05-23T15:32:27.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut8e004a20cdrstd6opy","content":"<p>这一篇论文讲了强化学习算法的替代可解方案：进化策略。主要思想是对参数空间添加噪音而不是动作空间。</p>\n<p>不推荐这篇论文：</p>\n<ul>\n<li>公式没有详细推理，非常难懂</li>\n<li>文中进化策略其实跟强化学习并没有特别大的关系</li>\n<li>很多关于进化策略的性质、优势非常难懂，基本上都是文字解释，没有举例</li>\n<li>文中措辞不难，但想要理解其本质非常难</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1703.03864.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1703.03864.pdf</a></p>\n<p>进化策略ES是一组/一类算法，而不是一个算法，它属于黑盒优化方法，它由自然进化中的启发式搜索过程而得来：每一代中都有突变的基因，环境对基因突变的效果给出适应性的判断，重组好的突变基因产生下一代，直到最优。</p>\n<p>进化策略算法的划分主要有三个依据：基因如何表示（神经网络参数）、突变如何产生（参数优化过程）、基因如何重组（参数重组）。</p>\n<p>进化策略ES这种方法通常分为<a href=\"https://pdfs.semanticscholar.org/dd17/8d3f30d801922c98cec9c2d90db05395f244.pdf?_ga=2.257341323.183297583.1558416128-1251761365.1555224483\" rel=\"external nofollow\" target=\"_blank\">直接策略搜索</a>和<a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7307180&amp;tag=1\" rel=\"external nofollow\" target=\"_blank\">神经进化</a>，黑盒优化方法有很多很好的特性：</p>\n<ol>\n<li>不关心奖励分布，奖励密集或稀疏都无所谓</li>\n<li>不需要反向传播梯度</li>\n<li>tolerance of potentially arbitrarily long time horizons. 翻译为可以适应长期视野/回报，在长动作序列上有优势</li>\n</ol>\n<p>但是，进化策略ES往往不能解决像Q-Learning和PG这样可应用的难的强化学习问题，这篇论文旨在使进化策略可以解决DRL算法可解决的更难的问题。</p>\n<h1 id=\"正文精要\"><a href=\"#正文精要\" class=\"headerlink\" title=\"正文精要\"></a>正文精要</h1><blockquote>\n<p>A large source of difficulty in RL stems from the lack of informative gradients of policy performance: such gradients may not exist due to non-smoothness of the environment or policy, or may only be available as high-variance estimates because the environment usually can only be accessed via sampling.  </p>\n</blockquote>\n<p>指出强化学习的难题在于缺乏策略性能的有效梯度：梯度可能由于环境不光滑而不存在、可能由于只能采样环境而存在高方差。</p>\n<blockquote>\n<p>For MDP-based reinforcement learning algorithms, on the other hand, it is well known that frameskip is a crucial parameter to get right for the optimization to succeed.</p>\n</blockquote>\n<p>对于基于MDP的强化学习算法，<strong>跳帧</strong>是算法优化的关键参数。</p>\n<blockquote>\n<p>It is common practice in RL to have the agent decide on its actions in a lower frequency than is used in the simulator that runs the environment.</p>\n</blockquote>\n<p>RL通常使智能体在模拟环境中决策频率高于在实际环境中。</p>\n<hr>\n<p>文中设定一个策略的期望奖励为：</p>\n<script type=\"math/tex; mode=display\">\n\\mathbb{E}_{\\epsilon \\sim N(0,I)}F(\\theta+\\sigma\\epsilon)</script><p>关于网络参数$\\theta$的导数为：</p>\n<script type=\"math/tex; mode=display\">\n\\nabla_{\\theta}\\mathbb{E}_{\\epsilon \\sim N(0,I)}F(\\theta+\\sigma\\epsilon)=\\frac{1}{\\sigma}\\mathbb{E}_{\\epsilon \\sim N(0,I)} \\{F(\\theta+\\sigma\\epsilon)\\epsilon \\}</script><p>其中，$\\theta$为网络参数，也可以认为是多变量高斯分布的均值，$\\sigma$为固定方差，$\\epsilon$为扰动向量，由各向同性、方差均为1的多变量高斯分布采样得到。<strong>文中没有对该导数推导过程有介绍，好像是使用了Reinforce Trick的方法，但是却不知道具体如何推导出这个形式</strong>。</p>\n<p>文中提到的算法1是对一个策略进行多次扰动，每扰动一次就与环境交互得到一个episode，最后只用各个扰动向量$\\epsilon_{i}$与对应的回报$F(\\theta)$相乘，根据该期望进行参数更新。</p>\n<p><img src=\"./Evolution-Strategies-2017/algorithm1.png\" alt=\"\"></p>\n<p>算法2是对算法1的并行化处理，设置相同的随机种子，假设n个worker：</p>\n<ol>\n<li>各个worker共用一个策略$\\pi$</li>\n<li>每个worker根据高斯分布采样得到扰动向量$\\epsilon$</li>\n<li>各个worker根据扰动后的策略参数采样一个episode</li>\n<li>互相分发各自的回报</li>\n<li><strong>再采样n个扰动向量$\\epsilon$</strong>，使用梯度上升更新参数，然后分发策略</li>\n</ol>\n<p><img src=\"./Evolution-Strategies-2017/algorithm2.png\" alt=\"\"></p>\n<p>文中后边提到，其实不必每次都从高斯分布中采样出扰动向量$\\epsilon$，可以在开始训练前直接采样得到m个扰动向量，每次需要扰动向量时直接根据m的值生成一个随机数，取出以该随机数为下标的扰动向量即可。这么做可以减少更新时的时长消耗。</p>\n<hr>\n<blockquote>\n<p>Experiments on Atari and MuJoCo show that it is a viable option with some attractive features: it is invariant to action frequency and delayed rewards, and it does not need temporal discounting or value function approximation. Most importantly, ES is highly parallelizable, which allows us to make up for a decreased data efficiency by scaling to more parallel workers. </p>\n</blockquote>\n<p>文中使用的进化策略ES的优点：</p>\n<ul>\n<li>与决策间隔无关，也就是对于跳帧间隔的设置鲁棒性很高</li>\n<li>不关心延迟奖励</li>\n<li>不需要折扣计算回报</li>\n<li>不需要值函数近似</li>\n<li>可以高度并行化使，我们能够通过扩展到更多并行训练节点来弥补数据效率的下降。</li>\n</ul>\n<h1 id=\"实验发现\"><a href=\"#实验发现\" class=\"headerlink\" title=\"实验发现\"></a>实验发现</h1><ol>\n<li>使用<a href=\"https://arxiv.org/pdf/1606.03498.pdf\" rel=\"external nofollow\" target=\"_blank\">Virtual Batch Normalization</a>和神经网络策略重参数（文中没有提到重参数的内容，只提到网络参数的影响）可以极大提升进化策略ES的可靠性。实验中，不使用这两种方法算法很“脆弱”，也就是不稳定。</li>\n<li>进化策略ES可以高度并行化。通过引入一个基于通用随机数的新颖通讯策略，即是是1000个子节点也可以达到运行时间的线性加速。</li>\n<li>进化策略ES的数据效率出奇的好。尽管相比A3C算法需要3-10倍的数据量，但是由于具有不需反向传播、没有值函数等特点，这些轻微的数据效率劣势可以被弥补。实验表明，相同计算量下，1小时ES与1天A3C的效果基本相同。</li>\n<li>进化策略ES相比PG类算法的探索性更强。</li>\n<li>进化策略ES的鲁棒性很好。多种不同训练环境可以使用同一组超参数。</li>\n</ol>\n<h1 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h1><h2 id=\"MuJoCo\"><a href=\"#MuJoCo\" class=\"headerlink\" title=\"MuJoCo\"></a>MuJoCo</h2><p>与<strong>高度优化</strong>的TRPO算法相比，ES在离散动作更有优势，因为连续动作在参数扰动方面可能过于平滑并且可能妨碍探索。</p>\n<p>ES和TRPO的网络结构都是：输入层→64，tanh→64，tanh→输出层。</p>\n<p>复杂环境如Hopper和Walker2d中，ES样本复杂性相比TRPO高不到10倍；简单场景中，相比低3倍。</p>\n<p>TRPO训练500W步，ES训练至TRPO训练过程中各阶段效果所需步长的比例如表所示：</p>\n<p><img src=\"./Evolution-Strategies-2017/mujoco.png\" alt=\"\"></p>\n<p>虽然文中说是简单场景低三倍，其实根本就没有明确的低三倍，而且我对文中所提的简单场景复杂场景的划分也持怀疑态度。</p>\n<h2 id=\"Atari\"><a href=\"#Atari\" class=\"headerlink\" title=\"Atari\"></a>Atari</h2><p>预处理、网络架构与Atari那篇论文的一模一样，用A3C使用3.2亿帧训练1天的结果与使用ES训练10亿帧的结果相同（保持计算量相同，因为ES不需要反向传播和值函数评估）。使用720块cpu，训练一个游戏只需1小时。</p>\n<p>最终，纯图像输入下，与A3C相比，23个游戏ES胜，28个游戏A3C胜。</p>\n<p><img src=\"./Evolution-Strategies-2017/atari.png\" alt=\"\"></p>\n<h2 id=\"并行化-Parallelization\"><a href=\"#并行化-Parallelization\" class=\"headerlink\" title=\"并行化 Parallelization\"></a>并行化 Parallelization</h2><p>ES特别适合并行化，因为其通讯低带宽特性（只需各个worker的回报和随机种子）。</p>\n<p>测试环境：3D Humanoid walking task</p>\n<p>结果：单机18核需11小时，与最先进的强化学习算法性能相当，80台机器1440个CPU核心只需10分钟。</p>\n<p><img src=\"./Evolution-Strategies-2017/parallelization.png\" alt=\"\"></p>\n<p>随着核心数增加，训练性能线性加速。</p>\n<h2 id=\"“跳帧”测试\"><a href=\"#“跳帧”测试\" class=\"headerlink\" title=\"“跳帧”测试\"></a>“跳帧”测试</h2><p>将强化学习在模拟环境中训练出的模型用于实际环境中式，通常需要降低其决策频率，也就是加大决策间隔。</p>\n<p>如果跳帧设置过大，智能体所做的动作往往不够好，如果跳帧设置过小，会导致每个episode的步数过长，加大计算量，恶化训练过程（其实文中这么说并不严谨）。</p>\n<p>ES的一个优势是梯度计算与回合长度无关，这间接增加了对跳帧间隔的鲁棒性。在Atari游戏Pong中使用四个不同跳帧间隔{1，2，3，4}的学习曲线如下：</p>\n<p><img src=\"./Evolution-Strategies-2017/frame-skip.png\" alt=\"\"></p>\n<p>由曲线可以看出，不同的跳帧间隔，训练效果差不多。<strong>但，我对该鲁棒性测试在复杂环境中的效果表示怀疑。我觉得前沿强化学习算法在该训练场景中使用不同的跳帧间隔也可以得到相同结果。</strong></p>\n","site":{"data":{}},"excerpt":"<p>这一篇论文讲了强化学习算法的替代可解方案：进化策略。主要思想是对参数空间添加噪音而不是动作空间。</p>\n<p>不推荐这篇论文：</p>\n<ul>\n<li>公式没有详细推理，非常难懂</li>\n<li>文中进化策略其实跟强化学习并没有特别大的关系</li>\n<li>很多关于进化策略的性质、优势非常难懂，基本上都是文字解释，没有举例</li>\n<li>文中措辞不难，但想要理解其本质非常难</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1703.03864.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1703.03864.pdf</a></p>\n<p>进化策略ES是一组/一类算法，而不是一个算法，它属于黑盒优化方法，它由自然进化中的启发式搜索过程而得来：每一代中都有突变的基因，环境对基因突变的效果给出适应性的判断，重组好的突变基因产生下一代，直到最优。</p>\n<p>进化策略算法的划分主要有三个依据：基因如何表示（神经网络参数）、突变如何产生（参数优化过程）、基因如何重组（参数重组）。</p>\n<p>进化策略ES这种方法通常分为<a href=\"https://pdfs.semanticscholar.org/dd17/8d3f30d801922c98cec9c2d90db05395f244.pdf?_ga=2.257341323.183297583.1558416128-1251761365.1555224483\" rel=\"external nofollow\" target=\"_blank\">直接策略搜索</a>和<a href=\"https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7307180&amp;tag=1\" rel=\"external nofollow\" target=\"_blank\">神经进化</a>，黑盒优化方法有很多很好的特性：</p>\n<ol>\n<li>不关心奖励分布，奖励密集或稀疏都无所谓</li>\n<li>不需要反向传播梯度</li>\n<li>tolerance of potentially arbitrarily long time horizons. 翻译为可以适应长期视野/回报，在长动作序列上有优势</li>\n</ol>\n<p>但是，进化策略ES往往不能解决像Q-Learning和PG这样可应用的难的强化学习问题，这篇论文旨在使进化策略可以解决DRL算法可解决的更难的问题。</p>\n<h1 id=\"正文精要\"><a href=\"#正文精要\" class=\"headerlink\" title=\"正文精要\"></a>正文精要</h1><blockquote>\n<p>A large source of difficulty in RL stems from the lack of informative gradients of policy performance: such gradients may not exist due to non-smoothness of the environment or policy, or may only be available as high-variance estimates because the environment usually can only be accessed via sampling.  </p>\n</blockquote>\n<p>指出强化学习的难题在于缺乏策略性能的有效梯度：梯度可能由于环境不光滑而不存在、可能由于只能采样环境而存在高方差。</p>\n<blockquote>\n<p>For MDP-based reinforcement learning algorithms, on the other hand, it is well known that frameskip is a crucial parameter to get right for the optimization to succeed.</p>\n</blockquote>\n<p>对于基于MDP的强化学习算法，<strong>跳帧</strong>是算法优化的关键参数。</p>\n<blockquote>\n<p>It is common practice in RL to have the agent decide on its actions in a lower frequency than is used in the simulator that runs the environment.</p>\n</blockquote>\n<p>RL通常使智能体在模拟环境中决策频率高于在实际环境中。</p>\n<hr>\n<p>文中设定一个策略的期望奖励为：</p>\n<script type=\"math/tex; mode=display\">\n\\mathbb{E}_{\\epsilon \\sim N(0,I)}F(\\theta+\\sigma\\epsilon)</script><p>关于网络参数$\\theta$的导数为：</p>\n<script type=\"math/tex; mode=display\">\n\\nabla_{\\theta}\\mathbb{E}_{\\epsilon \\sim N(0,I)}F(\\theta+\\sigma\\epsilon)=\\frac{1}{\\sigma}\\mathbb{E}_{\\epsilon \\sim N(0,I)} \\{F(\\theta+\\sigma\\epsilon)\\epsilon \\}</script><p>其中，$\\theta$为网络参数，也可以认为是多变量高斯分布的均值，$\\sigma$为固定方差，$\\epsilon$为扰动向量，由各向同性、方差均为1的多变量高斯分布采样得到。<strong>文中没有对该导数推导过程有介绍，好像是使用了Reinforce Trick的方法，但是却不知道具体如何推导出这个形式</strong>。</p>\n<p>文中提到的算法1是对一个策略进行多次扰动，每扰动一次就与环境交互得到一个episode，最后只用各个扰动向量$\\epsilon_{i}$与对应的回报$F(\\theta)$相乘，根据该期望进行参数更新。</p>\n<p><img src=\"./Evolution-Strategies-2017/algorithm1.png\" alt=\"\"></p>\n<p>算法2是对算法1的并行化处理，设置相同的随机种子，假设n个worker：</p>\n<ol>\n<li>各个worker共用一个策略$\\pi$</li>\n<li>每个worker根据高斯分布采样得到扰动向量$\\epsilon$</li>\n<li>各个worker根据扰动后的策略参数采样一个episode</li>\n<li>互相分发各自的回报</li>\n<li><strong>再采样n个扰动向量$\\epsilon$</strong>，使用梯度上升更新参数，然后分发策略</li>\n</ol>\n<p><img src=\"./Evolution-Strategies-2017/algorithm2.png\" alt=\"\"></p>\n<p>文中后边提到，其实不必每次都从高斯分布中采样出扰动向量$\\epsilon$，可以在开始训练前直接采样得到m个扰动向量，每次需要扰动向量时直接根据m的值生成一个随机数，取出以该随机数为下标的扰动向量即可。这么做可以减少更新时的时长消耗。</p>\n<hr>\n<blockquote>\n<p>Experiments on Atari and MuJoCo show that it is a viable option with some attractive features: it is invariant to action frequency and delayed rewards, and it does not need temporal discounting or value function approximation. Most importantly, ES is highly parallelizable, which allows us to make up for a decreased data efficiency by scaling to more parallel workers. </p>\n</blockquote>\n<p>文中使用的进化策略ES的优点：</p>\n<ul>\n<li>与决策间隔无关，也就是对于跳帧间隔的设置鲁棒性很高</li>\n<li>不关心延迟奖励</li>\n<li>不需要折扣计算回报</li>\n<li>不需要值函数近似</li>\n<li>可以高度并行化使，我们能够通过扩展到更多并行训练节点来弥补数据效率的下降。</li>\n</ul>\n<h1 id=\"实验发现\"><a href=\"#实验发现\" class=\"headerlink\" title=\"实验发现\"></a>实验发现</h1><ol>\n<li>使用<a href=\"https://arxiv.org/pdf/1606.03498.pdf\" rel=\"external nofollow\" target=\"_blank\">Virtual Batch Normalization</a>和神经网络策略重参数（文中没有提到重参数的内容，只提到网络参数的影响）可以极大提升进化策略ES的可靠性。实验中，不使用这两种方法算法很“脆弱”，也就是不稳定。</li>\n<li>进化策略ES可以高度并行化。通过引入一个基于通用随机数的新颖通讯策略，即是是1000个子节点也可以达到运行时间的线性加速。</li>\n<li>进化策略ES的数据效率出奇的好。尽管相比A3C算法需要3-10倍的数据量，但是由于具有不需反向传播、没有值函数等特点，这些轻微的数据效率劣势可以被弥补。实验表明，相同计算量下，1小时ES与1天A3C的效果基本相同。</li>\n<li>进化策略ES相比PG类算法的探索性更强。</li>\n<li>进化策略ES的鲁棒性很好。多种不同训练环境可以使用同一组超参数。</li>\n</ol>\n<h1 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h1><h2 id=\"MuJoCo\"><a href=\"#MuJoCo\" class=\"headerlink\" title=\"MuJoCo\"></a>MuJoCo</h2><p>与<strong>高度优化</strong>的TRPO算法相比，ES在离散动作更有优势，因为连续动作在参数扰动方面可能过于平滑并且可能妨碍探索。</p>\n<p>ES和TRPO的网络结构都是：输入层→64，tanh→64，tanh→输出层。</p>\n<p>复杂环境如Hopper和Walker2d中，ES样本复杂性相比TRPO高不到10倍；简单场景中，相比低3倍。</p>\n<p>TRPO训练500W步，ES训练至TRPO训练过程中各阶段效果所需步长的比例如表所示：</p>\n<p><img src=\"./Evolution-Strategies-2017/mujoco.png\" alt=\"\"></p>\n<p>虽然文中说是简单场景低三倍，其实根本就没有明确的低三倍，而且我对文中所提的简单场景复杂场景的划分也持怀疑态度。</p>\n<h2 id=\"Atari\"><a href=\"#Atari\" class=\"headerlink\" title=\"Atari\"></a>Atari</h2><p>预处理、网络架构与Atari那篇论文的一模一样，用A3C使用3.2亿帧训练1天的结果与使用ES训练10亿帧的结果相同（保持计算量相同，因为ES不需要反向传播和值函数评估）。使用720块cpu，训练一个游戏只需1小时。</p>\n<p>最终，纯图像输入下，与A3C相比，23个游戏ES胜，28个游戏A3C胜。</p>\n<p><img src=\"./Evolution-Strategies-2017/atari.png\" alt=\"\"></p>\n<h2 id=\"并行化-Parallelization\"><a href=\"#并行化-Parallelization\" class=\"headerlink\" title=\"并行化 Parallelization\"></a>并行化 Parallelization</h2><p>ES特别适合并行化，因为其通讯低带宽特性（只需各个worker的回报和随机种子）。</p>\n<p>测试环境：3D Humanoid walking task</p>\n<p>结果：单机18核需11小时，与最先进的强化学习算法性能相当，80台机器1440个CPU核心只需10分钟。</p>\n<p><img src=\"./Evolution-Strategies-2017/parallelization.png\" alt=\"\"></p>\n<p>随着核心数增加，训练性能线性加速。</p>\n<h2 id=\"“跳帧”测试\"><a href=\"#“跳帧”测试\" class=\"headerlink\" title=\"“跳帧”测试\"></a>“跳帧”测试</h2><p>将强化学习在模拟环境中训练出的模型用于实际环境中式，通常需要降低其决策频率，也就是加大决策间隔。</p>\n<p>如果跳帧设置过大，智能体所做的动作往往不够好，如果跳帧设置过小，会导致每个episode的步数过长，加大计算量，恶化训练过程（其实文中这么说并不严谨）。</p>\n<p>ES的一个优势是梯度计算与回合长度无关，这间接增加了对跳帧间隔的鲁棒性。在Atari游戏Pong中使用四个不同跳帧间隔{1，2，3，4}的学习曲线如下：</p>\n<p><img src=\"./Evolution-Strategies-2017/frame-skip.png\" alt=\"\"></p>\n<p>由曲线可以看出，不同的跳帧间隔，训练效果差不多。<strong>但，我对该鲁棒性测试在复杂环境中的效果表示怀疑。我觉得前沿强化学习算法在该训练场景中使用不同的跳帧间隔也可以得到相同结果。</strong></p>"},{"title":"FeUdal Networks for Hierarchical Reinforcement Learning","copyright":true,"mathjax":true,"top":1,"date":"2020-04-27T02:33:16.000Z","keywords":null,"description":null,"_content":"\n![](./FuNs/illustration.png)\n\n这篇论文提出了FuNs，将智能体决策分为两层——Manager产生子目标、Worker产生动作行为。两层均使用A2C方式进行优化，且梯度互不影响。\n\n推荐程度中等：\n\n- h-DQN式分层，PG式优化\n- 隐藏状态空间设置子目标，不需要先验知识\n- 上下两层策略均使用A2C的更新方式\n- 应用于离散动作空间\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1703.01161](http://arxiv.org/abs/1703.01161)\n\npytorch复现代码：[https://github.com/dnddnjs/feudal-montezuma](https://github.com/dnddnjs/feudal-montezuma)\n\n这篇论文引入了FeUdal Networks(FuNs)，它是一个新奇的强化学习分层决策结构，它将决策模型分为Manager和Worker：\n\n- Manager，在lower temporal resolution(低时间尺度)上做higher level决策，产生子目标。这个子目标是输入观察observation的隐状态空间上的方向向量，用于指定在$s_t$时刻之后$c$步应该朝着隐空间的什么方向移动；\n- Worker，在higher temporal resolution(更密级的时间尺度)上做lower level决策，产生执行的动作。\n\n## 关注点\n\n如何创建能够学习将其行为分解为有意义的原语，然后重用它们以更有效地获取新行为的智能体是一个长期存在的研究问题。\n\n> How to create agents that can learn to decompose their behaviour into meaningful primitives and then reuse them to more efﬁciently acquire new behaviours is a long standing research question. The solution to this question may be an important stepping stone towards agents with general intelligence and competence.\n\n## 主要贡献\n\n这篇论文的创新点和特点主要有以下几个：\n\n1. 提出一个一致的，端到端的，可微的模型，体现和概括了Feudal RL的原则\n2. 虽然上下两层都使用A2C的更新方式，但是上层策略的损失函数构造是根据自己提出的**Transition Policy Gradients**，利用了子目标的语义意义\n3. 提出了一个新奇的RNN结构，用在Manager模块中——**Dilated LSTM**，它增强了RNN的记忆能力，允许梯度在大的时间间隔内流动，允许在数百步长上进行有效的反向传播\n4. 上层控制器产生的子目标不再是显式的状态，而是隐状态空间上的方向向量\n\n## 优点/效果\n\n- FuNs大大提高了长期的信用分配和记忆。\n\n  > FuN signiﬁcantly improves long-term credit assignment and memorisation.\n\n- 鼓励与Manager设定的不同目标相关联的子策略的出现。\n\n  > encourages the emergence of sub-policies associated with different goals set by the Manager.\n\n# 文中精要\n\n下图为FuNs的整体框架示意图。\n\n![](./FuNs/illustration.png)\n\n解析：\n\n- 上图中的灰色部分均为可学习、可微分的网络变量，在Manager框中即由Manager梯度更新，反之亦然。上图中$f^{\\text {percept }}$既不属于Manager也不属于Worker，文中也没有提到它如何优化，我**猜想**它是通过Manager和Worker的Critic网络共享梯度更新优化的。\n\n- Manager使用Transition Policy Gradient进行优化，Worker使用Policy Gradient进行优化\n\n- $z_{t}=f^{\\text {percept }}\\left(x_{t}\\right)$是特征提取层，CNN之类的，将观测值转换为长度为d的向量\n\n- $s_{t}=f^{M s p a c e}\\left(z_{t}\\right)$是Manager模块中的特征变换层，由几层全连接组成，从图上看维度不变，还是d\n\n- $h_{t}^{M}, \\hat{g}_{t}=f^{M r n n}\\left(s_{t}, h_{t-1}^{M}\\right) ; g_{t}=\\hat{g}_{t} /\\left\\|\\hat{g}_{t}\\right\\|$是Manager模块的子目标输出层，子目标做了归一化操作，其中$f^{M r n n}$是论文中提出的Dilated LSTM\n\n- $w_{t}=\\phi\\left(\\sum_{i=t-c}^{t} g_{i}\\right)$是将子目标变换为一个可以与Worker动作表示矩阵相乘的向量，看形势上应该属于一个滑动窗口，窗口长度为$c$，在这个长度的一直做移动加和，每一个时间步都根据当前观测值输出子目标$g_i$，然后连续$c$个时间步的子目标加和之后通过$\\phi$进行线性变换。\n\n  > A linear transform $\\phi$ maps a goal $g_t$ into an embedding vector $w_t\\in R^k$ , which is then combined via product with matrix $U_t$ (Workers output) to produce policy $\\pi$.\n\n- $h^{W}, U_{t}=f^{W r n n}\\left(z_{t}, h_{t-1}^{W}\\right)$是Worker的LSTM层，这里没有使用Dilated LSTM\n\n- $\\pi_{t}=\\operatorname{SoftMax}\\left(U_{t} w_{t}\\right)$是Worker的最终动作概率分布输出层，从文章看起来，FuNs只能应用于离散动作空间，因为其下层策略要产生的矩阵为$\\mathrm{U}_{\\mathrm{t}} \\in \\mathrm{R}^{|\\mathrm{a}| \\mathrm{xk}}$，即需要了解动作的数量。\n\n- Worker中的$k$为每个动作embedding向量的长度\n\n## Manager损失\n\nManager的损失函数，或者说是优化目标的梯度是这样的：\n$$\n\\nabla g_{t}=A_{t}^{M} \\nabla_{\\theta} d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}(\\theta)\\right)\n$$\n\n$$\nA_{t}^{M}=R_{t}-V_{t}^{M}\\left(x_{t}, \\theta\\right)\n$$\n\n其中，$d_{\\cos }(\\alpha, \\beta)=\\alpha^{T} \\beta /(|\\alpha||\\beta|)$是余弦相似度。与传统的PG损失不同，这里没有使用$log$操作，而且使用余弦相似度。由Critic网络的输入是$x_t$我猜想到上面结构图中的percept部分是是由Critic网络的梯度优化的。\n\n注意，虽然$s_{t+c}$与$s_t$也是由Manager模块产生的，但是在优化中$s_{t+c}-s_{t}$并不传导梯度。\n\n传统的PG目标函数梯度应该是这样的：\n\n\n$$\n\\nabla_{\\theta} \\pi_{t}=\\mathbb{E}\\left[\\left(R_{t}-V\\left(s_{t}\\right)\\right) \\nabla_{\\theta} \\log p\\left(a_t | s_{t}\\right)\\right]\n$$\n\n作者根据分层强化学习中上层策略产生不是动作，而是子目标，将上边式子通过分析、推理改写成下边这种形式：\n\n$o_{t}=\\mu\\left(s_{t}, \\theta\\right)$选择子策略，$p\\left(s_{t+c} | s_{t}, o_{t}\\right)$表示在子策略条件下经过$c$步决策之后的隐状态分布，$\\pi^{T P}\\left(s_{t+c} | s_{t}\\right)=p\\left(s_{t+c} | s_{t}, \\mu\\left(s_{t}, \\theta\\right)\\right)$描述给定起始状态的结束状态的分布，$s_{t+c}=\\pi^{T P}\\left(s_{t}\\right)$是转移函数。\n$$\n\\nabla_{\\theta} \\pi_{t}^{T P}=\\mathbb{E}\\left[\\left(R_{t}-V\\left(s_{t}\\right)\\right) \\nabla_{\\theta} \\log p\\left(s_{t+c} | s_{t}, \\mu\\left(s_{t}, \\theta\\right)\\right)\\right]\n$$\n\n作者为了推导出$\\nabla_{\\theta} d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}(\\theta)\\right)$这种形式，假设转移模式是一种特殊的形式：$s_{t+c}-s_t$这个隐状态空间上的实际“运动”方向向量服从**[von Mises-Fisher](https://en.wikipedia.org/wiki/Von_Mises%E2%80%93Fisher_distribution)**分布，这个分布的均值即为上层策略产生的$g_t$，根据这个分布的性质，可以推导出如下公式：\n$$\np\\left(s_{t+c} | s_{t}, o_{t}\\right) \\propto e^{d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}\\right)}\n$$\n由此取对数可以推导出上边的梯度形式。\n\n> A naive application of policy gradients requires the agent to learn from samples of these trajectories. But if we know where these trajectories are likely to end up, by modelling the transitions, then we can skip directly over the Worker’s behaviour and instead follow the policy gradient of the predicted transition. FuN assumes a particular form for the transition model: that the direction in state-space, s t+c −s t , follows a von Mises-Fisher distribution. Speciﬁcally, if the mean direction of the von Mises-Fisher distribution is given by g(o t ) (which for compactness we write as g t ) we would have p(s t+c | s t , o t ) ∝ e d cos (s t+c −s t ,g t ) . If this functional form were indeed correct, then we see that our proposed update heuristic for the Manager, eqn.7, is in fact the proper form for the transition policy gradient arrived at in eqn.10.\n\n\n\n## Worker损失\n\nWorker的损失与传统的A2C一致：\n$$\n\\nabla \\pi_{t}=A_{t}^{D} \\nabla_{\\theta} \\log \\pi\\left(a_{t} | x_{t} ; \\theta\\right)\n$$\n\n$$\nA_{t}^{D}=\\left(R_{t}+\\alpha R_{t}^{I}-V_{t}^{D}\\left(x_{t} ; \\theta\\right)\\right)\n$$\n\n这里优势函数的target目标既包含外部奖励$R_t$，也包含内部奖励$R_t^I$，并用一个超参数$\\alpha$来控制内部奖励的影响程度。注意，这里的Critic输入同样为$x_t$，所以我**猜想**特征表示部分由Manager和Worker各自的Critic共享梯度进行优化。\n\n内部奖励是这么定义的：\n$$\nr_{t}^{I}=1 / c \\sum_{i=1}^{c} d_{\\cos }\\left(s_{t}-s_{t-i}, g_{t-i}\\right)\n$$\n从这个公式可以看出，每一步的内部奖励需要往前计算$c$步余弦相似度，因此，如果设置的子目标持续步长$c$很大，那么将会引入额外的轨迹长度倍的计算开销。\n\n作者使用方向向量，是因为与假设可以将智能体带到（可能）任意新的绝对位置相比，Worker能够更可靠地引起状态在隐空间上的方向转移。（真拗口）\n\n> We use directions because it is more feasible for the Worker to be able to reliably cause directional shifts in the latent state than it is to assume that the Worker can take us to (potentially) arbitrary new absolute locations.\n>\n> Note that the Worker’s intrinsic reward (eqn. 8) is based on the log-likelihood of state trajectory. Through that the FuN architecture actively encourages the functional form of the transition model to hold true. Because the Worker is learning to achieve the Manager’s direction, its transitions should, over time, closely follow a distribution around this direction, and hence our approximation for transition policy gradients should hold reasonably well.\n\n## Dilated LSTM\n\n说实话，这里没有完全理解。\n\n公式是这样的：\n$$\ng_{t}=L S T M\\left(s_{t}, \\hat{h}_{t-1}^{t \\% r} ; \\theta^{L S T M}\\right)\n$$\n其中$\\theta^{L S T M}$是共享的LSTM网络参数，cell_state是一个组，$h=\\left\\{\\hat{h}^{i}\\right\\}_{i=1}^{r}$。$r$是一个dilation radius，也就是说这个LSTM网络包含许多个cell_state，也就是core。式子中的百分号`%`是做一个模的操作。然后作者说他们在实验中radius的设置与horizon相同，即$c=r$。\n\n**我的猜想是这样的**：\n\n作者虽然想让上层策略在一个粗粒度的时间上进行决策，即产生子目标，但是下层策略的内部奖励依赖连续的子目标，也就是每一步的子目标。在这种情况下，上层策略必须每一步都产生子目标，那么既然产生了，不优化不就浪费了嘛，怎么利用呢？于是作者对每一时刻的子目标也做了平滑处理，即$w_{t}=\\phi\\left(\\sum_{i=t-c}^{t} g_{i}\\right)$。\n\n问题在于作者想让上层策略的子目标可以持续$c$个时间步，$c$个时间步之后便失效，也就是说，对于上层策略，它的经验序列应该是这样的$s_t, s_{t+c}, s_{t+2c} ... s_{t+nc}$，但是由于每一时间步都存在子目标，那么也存在这样的序列$s_{t+1}, s_{t+c+1}, s_{t+2c+1} ... s_{t+nc+1}$。针对这种情况，其实有两种处理手段：\n\n1. 将收集到的连续序列$s_t, s_{t+1}...$按时间步$c$切分成$c$条轨迹，然后分批次输入到LSTM中进行训练。其实相当于数据预处理过程\n2. 直接给LSTM输入收集到的连续序列$s_t, s_{t+1}...$，设置$r=c$组cell_state，也就是为$c$条轨迹设置$c$个不同的起始cell_state，由此来处理不切分的交叉时间尺度的经验序列，让梯度随着cell_state按不同轨迹自动传播。\n\n作者就是使用了第2种的处理方式。另外，作者在做对比实验的时候，给LSTM设置步长为40，给Dilated LSTM设置步长400，子目标持续步长$c=10$，也应该是这个道理，因为400/10=40，其实每个子目标序列的持续时间都是一直的，都是40个时间步。\n\n从这个角度分析，我觉得作者说“它促进了更长时间的信用分配以及增强了RNN记忆能力”是一个噱头，因为其实是它只是在共享了LSTM的参数的基础上，对$c$条连续上层子目标序列**分别**做了LSTM运算，本质上没有将长时间的记忆融合进去。\n\n\n\n# 与h-DQN和OC的比较\n\nFuNs可以视为是h-DQN与OC的部分结合，但又不尽相同。\n\n## h-DQN vs. FuNs\n\n相同：\n\n- 都是显式地将决策模型分为两层，上层决策子目标，下层决策具体动作\n- 上层都是最大化外部环境累计期望回报\n- 下层都使用了内在奖励\n- 两者都将子目标作为下层策略的输入\n\n不同：\n\n- FuNs上层产生的子目标是智能体的观测值在隐状态空间下的方向向量，而h-DQN上层产生的子目标是需要人为设计的，往往在原始观测状态空间上设置。\n- FuNs不需要先验知识\n- FuNs优化下层模型时，既使用了环境外部奖励，也使用了基于子目标产生的内部奖励，而h-DQN只使用了内部奖励\n- h-DQN是Q-Learning式的优化方式，即最小化均方误差，而FuNs是PG式的优化方式，即最大化累计期望奖励\n\n## OC vs. FuNs\n\n相同：\n\n- 两者都是用了PG式的更新方式\n- 两者都是端到端的\n\n不同：\n\n- OC需要判断option的终止条件，FuNs固定上层策略的步长$c$\n- OC需要指定option的数量（离散），而FuNs产生的子目标为方向向量（连续）\n- OC需要为每个option构造一个下层策略模型，而FuNs共同一个下层策略模型\n- OC的下层策略输入不包含option，只是根据option选到下层策略，而FuNs的下层策略需要包含子目标输入\n- OC没有引入内在奖励，FuNs使用了内在奖励\n- OC可以应用于连续动作空间，而FuNs用于离散动作空间\n\n","source":"_posts/FuNs.md","raw":"---\ntitle: FeUdal Networks for Hierarchical Reinforcement Learning\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-04-27 10:33:16\ncategories: ReinforcementLearning\ntags:\n- rl\n- hrl\nkeywords:\ndescription:\n---\n\n![](./FuNs/illustration.png)\n\n这篇论文提出了FuNs，将智能体决策分为两层——Manager产生子目标、Worker产生动作行为。两层均使用A2C方式进行优化，且梯度互不影响。\n\n推荐程度中等：\n\n- h-DQN式分层，PG式优化\n- 隐藏状态空间设置子目标，不需要先验知识\n- 上下两层策略均使用A2C的更新方式\n- 应用于离散动作空间\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1703.01161](http://arxiv.org/abs/1703.01161)\n\npytorch复现代码：[https://github.com/dnddnjs/feudal-montezuma](https://github.com/dnddnjs/feudal-montezuma)\n\n这篇论文引入了FeUdal Networks(FuNs)，它是一个新奇的强化学习分层决策结构，它将决策模型分为Manager和Worker：\n\n- Manager，在lower temporal resolution(低时间尺度)上做higher level决策，产生子目标。这个子目标是输入观察observation的隐状态空间上的方向向量，用于指定在$s_t$时刻之后$c$步应该朝着隐空间的什么方向移动；\n- Worker，在higher temporal resolution(更密级的时间尺度)上做lower level决策，产生执行的动作。\n\n## 关注点\n\n如何创建能够学习将其行为分解为有意义的原语，然后重用它们以更有效地获取新行为的智能体是一个长期存在的研究问题。\n\n> How to create agents that can learn to decompose their behaviour into meaningful primitives and then reuse them to more efﬁciently acquire new behaviours is a long standing research question. The solution to this question may be an important stepping stone towards agents with general intelligence and competence.\n\n## 主要贡献\n\n这篇论文的创新点和特点主要有以下几个：\n\n1. 提出一个一致的，端到端的，可微的模型，体现和概括了Feudal RL的原则\n2. 虽然上下两层都使用A2C的更新方式，但是上层策略的损失函数构造是根据自己提出的**Transition Policy Gradients**，利用了子目标的语义意义\n3. 提出了一个新奇的RNN结构，用在Manager模块中——**Dilated LSTM**，它增强了RNN的记忆能力，允许梯度在大的时间间隔内流动，允许在数百步长上进行有效的反向传播\n4. 上层控制器产生的子目标不再是显式的状态，而是隐状态空间上的方向向量\n\n## 优点/效果\n\n- FuNs大大提高了长期的信用分配和记忆。\n\n  > FuN signiﬁcantly improves long-term credit assignment and memorisation.\n\n- 鼓励与Manager设定的不同目标相关联的子策略的出现。\n\n  > encourages the emergence of sub-policies associated with different goals set by the Manager.\n\n# 文中精要\n\n下图为FuNs的整体框架示意图。\n\n![](./FuNs/illustration.png)\n\n解析：\n\n- 上图中的灰色部分均为可学习、可微分的网络变量，在Manager框中即由Manager梯度更新，反之亦然。上图中$f^{\\text {percept }}$既不属于Manager也不属于Worker，文中也没有提到它如何优化，我**猜想**它是通过Manager和Worker的Critic网络共享梯度更新优化的。\n\n- Manager使用Transition Policy Gradient进行优化，Worker使用Policy Gradient进行优化\n\n- $z_{t}=f^{\\text {percept }}\\left(x_{t}\\right)$是特征提取层，CNN之类的，将观测值转换为长度为d的向量\n\n- $s_{t}=f^{M s p a c e}\\left(z_{t}\\right)$是Manager模块中的特征变换层，由几层全连接组成，从图上看维度不变，还是d\n\n- $h_{t}^{M}, \\hat{g}_{t}=f^{M r n n}\\left(s_{t}, h_{t-1}^{M}\\right) ; g_{t}=\\hat{g}_{t} /\\left\\|\\hat{g}_{t}\\right\\|$是Manager模块的子目标输出层，子目标做了归一化操作，其中$f^{M r n n}$是论文中提出的Dilated LSTM\n\n- $w_{t}=\\phi\\left(\\sum_{i=t-c}^{t} g_{i}\\right)$是将子目标变换为一个可以与Worker动作表示矩阵相乘的向量，看形势上应该属于一个滑动窗口，窗口长度为$c$，在这个长度的一直做移动加和，每一个时间步都根据当前观测值输出子目标$g_i$，然后连续$c$个时间步的子目标加和之后通过$\\phi$进行线性变换。\n\n  > A linear transform $\\phi$ maps a goal $g_t$ into an embedding vector $w_t\\in R^k$ , which is then combined via product with matrix $U_t$ (Workers output) to produce policy $\\pi$.\n\n- $h^{W}, U_{t}=f^{W r n n}\\left(z_{t}, h_{t-1}^{W}\\right)$是Worker的LSTM层，这里没有使用Dilated LSTM\n\n- $\\pi_{t}=\\operatorname{SoftMax}\\left(U_{t} w_{t}\\right)$是Worker的最终动作概率分布输出层，从文章看起来，FuNs只能应用于离散动作空间，因为其下层策略要产生的矩阵为$\\mathrm{U}_{\\mathrm{t}} \\in \\mathrm{R}^{|\\mathrm{a}| \\mathrm{xk}}$，即需要了解动作的数量。\n\n- Worker中的$k$为每个动作embedding向量的长度\n\n## Manager损失\n\nManager的损失函数，或者说是优化目标的梯度是这样的：\n$$\n\\nabla g_{t}=A_{t}^{M} \\nabla_{\\theta} d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}(\\theta)\\right)\n$$\n\n$$\nA_{t}^{M}=R_{t}-V_{t}^{M}\\left(x_{t}, \\theta\\right)\n$$\n\n其中，$d_{\\cos }(\\alpha, \\beta)=\\alpha^{T} \\beta /(|\\alpha||\\beta|)$是余弦相似度。与传统的PG损失不同，这里没有使用$log$操作，而且使用余弦相似度。由Critic网络的输入是$x_t$我猜想到上面结构图中的percept部分是是由Critic网络的梯度优化的。\n\n注意，虽然$s_{t+c}$与$s_t$也是由Manager模块产生的，但是在优化中$s_{t+c}-s_{t}$并不传导梯度。\n\n传统的PG目标函数梯度应该是这样的：\n\n\n$$\n\\nabla_{\\theta} \\pi_{t}=\\mathbb{E}\\left[\\left(R_{t}-V\\left(s_{t}\\right)\\right) \\nabla_{\\theta} \\log p\\left(a_t | s_{t}\\right)\\right]\n$$\n\n作者根据分层强化学习中上层策略产生不是动作，而是子目标，将上边式子通过分析、推理改写成下边这种形式：\n\n$o_{t}=\\mu\\left(s_{t}, \\theta\\right)$选择子策略，$p\\left(s_{t+c} | s_{t}, o_{t}\\right)$表示在子策略条件下经过$c$步决策之后的隐状态分布，$\\pi^{T P}\\left(s_{t+c} | s_{t}\\right)=p\\left(s_{t+c} | s_{t}, \\mu\\left(s_{t}, \\theta\\right)\\right)$描述给定起始状态的结束状态的分布，$s_{t+c}=\\pi^{T P}\\left(s_{t}\\right)$是转移函数。\n$$\n\\nabla_{\\theta} \\pi_{t}^{T P}=\\mathbb{E}\\left[\\left(R_{t}-V\\left(s_{t}\\right)\\right) \\nabla_{\\theta} \\log p\\left(s_{t+c} | s_{t}, \\mu\\left(s_{t}, \\theta\\right)\\right)\\right]\n$$\n\n作者为了推导出$\\nabla_{\\theta} d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}(\\theta)\\right)$这种形式，假设转移模式是一种特殊的形式：$s_{t+c}-s_t$这个隐状态空间上的实际“运动”方向向量服从**[von Mises-Fisher](https://en.wikipedia.org/wiki/Von_Mises%E2%80%93Fisher_distribution)**分布，这个分布的均值即为上层策略产生的$g_t$，根据这个分布的性质，可以推导出如下公式：\n$$\np\\left(s_{t+c} | s_{t}, o_{t}\\right) \\propto e^{d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}\\right)}\n$$\n由此取对数可以推导出上边的梯度形式。\n\n> A naive application of policy gradients requires the agent to learn from samples of these trajectories. But if we know where these trajectories are likely to end up, by modelling the transitions, then we can skip directly over the Worker’s behaviour and instead follow the policy gradient of the predicted transition. FuN assumes a particular form for the transition model: that the direction in state-space, s t+c −s t , follows a von Mises-Fisher distribution. Speciﬁcally, if the mean direction of the von Mises-Fisher distribution is given by g(o t ) (which for compactness we write as g t ) we would have p(s t+c | s t , o t ) ∝ e d cos (s t+c −s t ,g t ) . If this functional form were indeed correct, then we see that our proposed update heuristic for the Manager, eqn.7, is in fact the proper form for the transition policy gradient arrived at in eqn.10.\n\n\n\n## Worker损失\n\nWorker的损失与传统的A2C一致：\n$$\n\\nabla \\pi_{t}=A_{t}^{D} \\nabla_{\\theta} \\log \\pi\\left(a_{t} | x_{t} ; \\theta\\right)\n$$\n\n$$\nA_{t}^{D}=\\left(R_{t}+\\alpha R_{t}^{I}-V_{t}^{D}\\left(x_{t} ; \\theta\\right)\\right)\n$$\n\n这里优势函数的target目标既包含外部奖励$R_t$，也包含内部奖励$R_t^I$，并用一个超参数$\\alpha$来控制内部奖励的影响程度。注意，这里的Critic输入同样为$x_t$，所以我**猜想**特征表示部分由Manager和Worker各自的Critic共享梯度进行优化。\n\n内部奖励是这么定义的：\n$$\nr_{t}^{I}=1 / c \\sum_{i=1}^{c} d_{\\cos }\\left(s_{t}-s_{t-i}, g_{t-i}\\right)\n$$\n从这个公式可以看出，每一步的内部奖励需要往前计算$c$步余弦相似度，因此，如果设置的子目标持续步长$c$很大，那么将会引入额外的轨迹长度倍的计算开销。\n\n作者使用方向向量，是因为与假设可以将智能体带到（可能）任意新的绝对位置相比，Worker能够更可靠地引起状态在隐空间上的方向转移。（真拗口）\n\n> We use directions because it is more feasible for the Worker to be able to reliably cause directional shifts in the latent state than it is to assume that the Worker can take us to (potentially) arbitrary new absolute locations.\n>\n> Note that the Worker’s intrinsic reward (eqn. 8) is based on the log-likelihood of state trajectory. Through that the FuN architecture actively encourages the functional form of the transition model to hold true. Because the Worker is learning to achieve the Manager’s direction, its transitions should, over time, closely follow a distribution around this direction, and hence our approximation for transition policy gradients should hold reasonably well.\n\n## Dilated LSTM\n\n说实话，这里没有完全理解。\n\n公式是这样的：\n$$\ng_{t}=L S T M\\left(s_{t}, \\hat{h}_{t-1}^{t \\% r} ; \\theta^{L S T M}\\right)\n$$\n其中$\\theta^{L S T M}$是共享的LSTM网络参数，cell_state是一个组，$h=\\left\\{\\hat{h}^{i}\\right\\}_{i=1}^{r}$。$r$是一个dilation radius，也就是说这个LSTM网络包含许多个cell_state，也就是core。式子中的百分号`%`是做一个模的操作。然后作者说他们在实验中radius的设置与horizon相同，即$c=r$。\n\n**我的猜想是这样的**：\n\n作者虽然想让上层策略在一个粗粒度的时间上进行决策，即产生子目标，但是下层策略的内部奖励依赖连续的子目标，也就是每一步的子目标。在这种情况下，上层策略必须每一步都产生子目标，那么既然产生了，不优化不就浪费了嘛，怎么利用呢？于是作者对每一时刻的子目标也做了平滑处理，即$w_{t}=\\phi\\left(\\sum_{i=t-c}^{t} g_{i}\\right)$。\n\n问题在于作者想让上层策略的子目标可以持续$c$个时间步，$c$个时间步之后便失效，也就是说，对于上层策略，它的经验序列应该是这样的$s_t, s_{t+c}, s_{t+2c} ... s_{t+nc}$，但是由于每一时间步都存在子目标，那么也存在这样的序列$s_{t+1}, s_{t+c+1}, s_{t+2c+1} ... s_{t+nc+1}$。针对这种情况，其实有两种处理手段：\n\n1. 将收集到的连续序列$s_t, s_{t+1}...$按时间步$c$切分成$c$条轨迹，然后分批次输入到LSTM中进行训练。其实相当于数据预处理过程\n2. 直接给LSTM输入收集到的连续序列$s_t, s_{t+1}...$，设置$r=c$组cell_state，也就是为$c$条轨迹设置$c$个不同的起始cell_state，由此来处理不切分的交叉时间尺度的经验序列，让梯度随着cell_state按不同轨迹自动传播。\n\n作者就是使用了第2种的处理方式。另外，作者在做对比实验的时候，给LSTM设置步长为40，给Dilated LSTM设置步长400，子目标持续步长$c=10$，也应该是这个道理，因为400/10=40，其实每个子目标序列的持续时间都是一直的，都是40个时间步。\n\n从这个角度分析，我觉得作者说“它促进了更长时间的信用分配以及增强了RNN记忆能力”是一个噱头，因为其实是它只是在共享了LSTM的参数的基础上，对$c$条连续上层子目标序列**分别**做了LSTM运算，本质上没有将长时间的记忆融合进去。\n\n\n\n# 与h-DQN和OC的比较\n\nFuNs可以视为是h-DQN与OC的部分结合，但又不尽相同。\n\n## h-DQN vs. FuNs\n\n相同：\n\n- 都是显式地将决策模型分为两层，上层决策子目标，下层决策具体动作\n- 上层都是最大化外部环境累计期望回报\n- 下层都使用了内在奖励\n- 两者都将子目标作为下层策略的输入\n\n不同：\n\n- FuNs上层产生的子目标是智能体的观测值在隐状态空间下的方向向量，而h-DQN上层产生的子目标是需要人为设计的，往往在原始观测状态空间上设置。\n- FuNs不需要先验知识\n- FuNs优化下层模型时，既使用了环境外部奖励，也使用了基于子目标产生的内部奖励，而h-DQN只使用了内部奖励\n- h-DQN是Q-Learning式的优化方式，即最小化均方误差，而FuNs是PG式的优化方式，即最大化累计期望奖励\n\n## OC vs. FuNs\n\n相同：\n\n- 两者都是用了PG式的更新方式\n- 两者都是端到端的\n\n不同：\n\n- OC需要判断option的终止条件，FuNs固定上层策略的步长$c$\n- OC需要指定option的数量（离散），而FuNs产生的子目标为方向向量（连续）\n- OC需要为每个option构造一个下层策略模型，而FuNs共同一个下层策略模型\n- OC的下层策略输入不包含option，只是根据option选到下层策略，而FuNs的下层策略需要包含子目标输入\n- OC没有引入内在奖励，FuNs使用了内在奖励\n- OC可以应用于连续动作空间，而FuNs用于离散动作空间\n\n","slug":"FuNs","published":1,"updated":"2020-04-27T04:46:44.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut8g004d20cduapyz616","content":"<p><img src=\"./FuNs/illustration.png\" alt=\"\"></p>\n<p>这篇论文提出了FuNs，将智能体决策分为两层——Manager产生子目标、Worker产生动作行为。两层均使用A2C方式进行优化，且梯度互不影响。</p>\n<p>推荐程度中等：</p>\n<ul>\n<li>h-DQN式分层，PG式优化</li>\n<li>隐藏状态空间设置子目标，不需要先验知识</li>\n<li>上下两层策略均使用A2C的更新方式</li>\n<li>应用于离散动作空间</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1703.01161\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1703.01161</a></p>\n<p>pytorch复现代码：<a href=\"https://github.com/dnddnjs/feudal-montezuma\" rel=\"external nofollow\" target=\"_blank\">https://github.com/dnddnjs/feudal-montezuma</a></p>\n<p>这篇论文引入了FeUdal Networks(FuNs)，它是一个新奇的强化学习分层决策结构，它将决策模型分为Manager和Worker：</p>\n<ul>\n<li>Manager，在lower temporal resolution(低时间尺度)上做higher level决策，产生子目标。这个子目标是输入观察observation的隐状态空间上的方向向量，用于指定在$s_t$时刻之后$c$步应该朝着隐空间的什么方向移动；</li>\n<li>Worker，在higher temporal resolution(更密级的时间尺度)上做lower level决策，产生执行的动作。</li>\n</ul>\n<h2 id=\"关注点\"><a href=\"#关注点\" class=\"headerlink\" title=\"关注点\"></a>关注点</h2><p>如何创建能够学习将其行为分解为有意义的原语，然后重用它们以更有效地获取新行为的智能体是一个长期存在的研究问题。</p>\n<blockquote>\n<p>How to create agents that can learn to decompose their behaviour into meaningful primitives and then reuse them to more efﬁciently acquire new behaviours is a long standing research question. The solution to this question may be an important stepping stone towards agents with general intelligence and competence.</p>\n</blockquote>\n<h2 id=\"主要贡献\"><a href=\"#主要贡献\" class=\"headerlink\" title=\"主要贡献\"></a>主要贡献</h2><p>这篇论文的创新点和特点主要有以下几个：</p>\n<ol>\n<li>提出一个一致的，端到端的，可微的模型，体现和概括了Feudal RL的原则</li>\n<li>虽然上下两层都使用A2C的更新方式，但是上层策略的损失函数构造是根据自己提出的<strong>Transition Policy Gradients</strong>，利用了子目标的语义意义</li>\n<li>提出了一个新奇的RNN结构，用在Manager模块中——<strong>Dilated LSTM</strong>，它增强了RNN的记忆能力，允许梯度在大的时间间隔内流动，允许在数百步长上进行有效的反向传播</li>\n<li>上层控制器产生的子目标不再是显式的状态，而是隐状态空间上的方向向量</li>\n</ol>\n<h2 id=\"优点-效果\"><a href=\"#优点-效果\" class=\"headerlink\" title=\"优点/效果\"></a>优点/效果</h2><ul>\n<li><p>FuNs大大提高了长期的信用分配和记忆。</p>\n<blockquote>\n<p>FuN signiﬁcantly improves long-term credit assignment and memorisation.</p>\n</blockquote>\n</li>\n<li><p>鼓励与Manager设定的不同目标相关联的子策略的出现。</p>\n<blockquote>\n<p>encourages the emergence of sub-policies associated with different goals set by the Manager.</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>下图为FuNs的整体框架示意图。</p>\n<p><img src=\"./FuNs/illustration.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li><p>上图中的灰色部分均为可学习、可微分的网络变量，在Manager框中即由Manager梯度更新，反之亦然。上图中$f^{\\text {percept }}$既不属于Manager也不属于Worker，文中也没有提到它如何优化，我<strong>猜想</strong>它是通过Manager和Worker的Critic网络共享梯度更新优化的。</p>\n</li>\n<li><p>Manager使用Transition Policy Gradient进行优化，Worker使用Policy Gradient进行优化</p>\n</li>\n<li><p>$z_{t}=f^{\\text {percept }}\\left(x_{t}\\right)$是特征提取层，CNN之类的，将观测值转换为长度为d的向量</p>\n</li>\n<li><p>$s_{t}=f^{M s p a c e}\\left(z_{t}\\right)$是Manager模块中的特征变换层，由几层全连接组成，从图上看维度不变，还是d</p>\n</li>\n<li><p>$h_{t}^{M}, \\hat{g}_{t}=f^{M r n n}\\left(s_{t}, h_{t-1}^{M}\\right) ; g_{t}=\\hat{g}_{t} /\\left|\\hat{g}_{t}\\right|$是Manager模块的子目标输出层，子目标做了归一化操作，其中$f^{M r n n}$是论文中提出的Dilated LSTM</p>\n</li>\n<li><p>$w_{t}=\\phi\\left(\\sum_{i=t-c}^{t} g_{i}\\right)$是将子目标变换为一个可以与Worker动作表示矩阵相乘的向量，看形势上应该属于一个滑动窗口，窗口长度为$c$，在这个长度的一直做移动加和，每一个时间步都根据当前观测值输出子目标$g_i$，然后连续$c$个时间步的子目标加和之后通过$\\phi$进行线性变换。</p>\n<blockquote>\n<p>A linear transform $\\phi$ maps a goal $g_t$ into an embedding vector $w_t\\in R^k$ , which is then combined via product with matrix $U_t$ (Workers output) to produce policy $\\pi$.</p>\n</blockquote>\n</li>\n<li><p>$h^{W}, U_{t}=f^{W r n n}\\left(z_{t}, h_{t-1}^{W}\\right)$是Worker的LSTM层，这里没有使用Dilated LSTM</p>\n</li>\n<li><p>$\\pi_{t}=\\operatorname{SoftMax}\\left(U_{t} w_{t}\\right)$是Worker的最终动作概率分布输出层，从文章看起来，FuNs只能应用于离散动作空间，因为其下层策略要产生的矩阵为$\\mathrm{U}_{\\mathrm{t}} \\in \\mathrm{R}^{|\\mathrm{a}| \\mathrm{xk}}$，即需要了解动作的数量。</p>\n</li>\n<li><p>Worker中的$k$为每个动作embedding向量的长度</p>\n</li>\n</ul>\n<h2 id=\"Manager损失\"><a href=\"#Manager损失\" class=\"headerlink\" title=\"Manager损失\"></a>Manager损失</h2><p>Manager的损失函数，或者说是优化目标的梯度是这样的：</p>\n<script type=\"math/tex; mode=display\">\n\\nabla g_{t}=A_{t}^{M} \\nabla_{\\theta} d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}(\\theta)\\right)</script><script type=\"math/tex; mode=display\">\nA_{t}^{M}=R_{t}-V_{t}^{M}\\left(x_{t}, \\theta\\right)</script><p>其中，$d_{\\cos }(\\alpha, \\beta)=\\alpha^{T} \\beta /(|\\alpha||\\beta|)$是余弦相似度。与传统的PG损失不同，这里没有使用$log$操作，而且使用余弦相似度。由Critic网络的输入是$x_t$我猜想到上面结构图中的percept部分是是由Critic网络的梯度优化的。</p>\n<p>注意，虽然$s_{t+c}$与$s_t$也是由Manager模块产生的，但是在优化中$s_{t+c}-s_{t}$并不传导梯度。</p>\n<p>传统的PG目标函数梯度应该是这样的：</p>\n<script type=\"math/tex; mode=display\">\n\\nabla_{\\theta} \\pi_{t}=\\mathbb{E}\\left[\\left(R_{t}-V\\left(s_{t}\\right)\\right) \\nabla_{\\theta} \\log p\\left(a_t | s_{t}\\right)\\right]</script><p>作者根据分层强化学习中上层策略产生不是动作，而是子目标，将上边式子通过分析、推理改写成下边这种形式：</p>\n<p>$o_{t}=\\mu\\left(s_{t}, \\theta\\right)$选择子策略，$p\\left(s_{t+c} | s_{t}, o_{t}\\right)$表示在子策略条件下经过$c$步决策之后的隐状态分布，$\\pi^{T P}\\left(s_{t+c} | s_{t}\\right)=p\\left(s_{t+c} | s_{t}, \\mu\\left(s_{t}, \\theta\\right)\\right)$描述给定起始状态的结束状态的分布，$s_{t+c}=\\pi^{T P}\\left(s_{t}\\right)$是转移函数。</p>\n<script type=\"math/tex; mode=display\">\n\\nabla_{\\theta} \\pi_{t}^{T P}=\\mathbb{E}\\left[\\left(R_{t}-V\\left(s_{t}\\right)\\right) \\nabla_{\\theta} \\log p\\left(s_{t+c} | s_{t}, \\mu\\left(s_{t}, \\theta\\right)\\right)\\right]</script><p>作者为了推导出$\\nabla_{\\theta} d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}(\\theta)\\right)$这种形式，假设转移模式是一种特殊的形式：$s_{t+c}-s_t$这个隐状态空间上的实际“运动”方向向量服从<strong><a href=\"https://en.wikipedia.org/wiki/Von_Mises%E2%80%93Fisher_distribution\" rel=\"external nofollow\" target=\"_blank\">von Mises-Fisher</a></strong>分布，这个分布的均值即为上层策略产生的$g_t$，根据这个分布的性质，可以推导出如下公式：</p>\n<script type=\"math/tex; mode=display\">\np\\left(s_{t+c} | s_{t}, o_{t}\\right) \\propto e^{d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}\\right)}</script><p>由此取对数可以推导出上边的梯度形式。</p>\n<blockquote>\n<p>A naive application of policy gradients requires the agent to learn from samples of these trajectories. But if we know where these trajectories are likely to end up, by modelling the transitions, then we can skip directly over the Worker’s behaviour and instead follow the policy gradient of the predicted transition. FuN assumes a particular form for the transition model: that the direction in state-space, s t+c −s t , follows a von Mises-Fisher distribution. Speciﬁcally, if the mean direction of the von Mises-Fisher distribution is given by g(o t ) (which for compactness we write as g t ) we would have p(s t+c | s t , o t ) ∝ e d cos (s t+c −s t ,g t ) . If this functional form were indeed correct, then we see that our proposed update heuristic for the Manager, eqn.7, is in fact the proper form for the transition policy gradient arrived at in eqn.10.</p>\n</blockquote>\n<h2 id=\"Worker损失\"><a href=\"#Worker损失\" class=\"headerlink\" title=\"Worker损失\"></a>Worker损失</h2><p>Worker的损失与传统的A2C一致：</p>\n<script type=\"math/tex; mode=display\">\n\\nabla \\pi_{t}=A_{t}^{D} \\nabla_{\\theta} \\log \\pi\\left(a_{t} | x_{t} ; \\theta\\right)</script><script type=\"math/tex; mode=display\">\nA_{t}^{D}=\\left(R_{t}+\\alpha R_{t}^{I}-V_{t}^{D}\\left(x_{t} ; \\theta\\right)\\right)</script><p>这里优势函数的target目标既包含外部奖励$R_t$，也包含内部奖励$R_t^I$，并用一个超参数$\\alpha$来控制内部奖励的影响程度。注意，这里的Critic输入同样为$x_t$，所以我<strong>猜想</strong>特征表示部分由Manager和Worker各自的Critic共享梯度进行优化。</p>\n<p>内部奖励是这么定义的：</p>\n<script type=\"math/tex; mode=display\">\nr_{t}^{I}=1 / c \\sum_{i=1}^{c} d_{\\cos }\\left(s_{t}-s_{t-i}, g_{t-i}\\right)</script><p>从这个公式可以看出，每一步的内部奖励需要往前计算$c$步余弦相似度，因此，如果设置的子目标持续步长$c$很大，那么将会引入额外的轨迹长度倍的计算开销。</p>\n<p>作者使用方向向量，是因为与假设可以将智能体带到（可能）任意新的绝对位置相比，Worker能够更可靠地引起状态在隐空间上的方向转移。（真拗口）</p>\n<blockquote>\n<p>We use directions because it is more feasible for the Worker to be able to reliably cause directional shifts in the latent state than it is to assume that the Worker can take us to (potentially) arbitrary new absolute locations.</p>\n<p>Note that the Worker’s intrinsic reward (eqn. 8) is based on the log-likelihood of state trajectory. Through that the FuN architecture actively encourages the functional form of the transition model to hold true. Because the Worker is learning to achieve the Manager’s direction, its transitions should, over time, closely follow a distribution around this direction, and hence our approximation for transition policy gradients should hold reasonably well.</p>\n</blockquote>\n<h2 id=\"Dilated-LSTM\"><a href=\"#Dilated-LSTM\" class=\"headerlink\" title=\"Dilated LSTM\"></a>Dilated LSTM</h2><p>说实话，这里没有完全理解。</p>\n<p>公式是这样的：</p>\n<script type=\"math/tex; mode=display\">\ng_{t}=L S T M\\left(s_{t}, \\hat{h}_{t-1}^{t \\% r} ; \\theta^{L S T M}\\right)</script><p>其中$\\theta^{L S T M}$是共享的LSTM网络参数，cell_state是一个组，$h=\\left\\{\\hat{h}^{i}\\right\\}_{i=1}^{r}$。$r$是一个dilation radius，也就是说这个LSTM网络包含许多个cell_state，也就是core。式子中的百分号<code>%</code>是做一个模的操作。然后作者说他们在实验中radius的设置与horizon相同，即$c=r$。</p>\n<p><strong>我的猜想是这样的</strong>：</p>\n<p>作者虽然想让上层策略在一个粗粒度的时间上进行决策，即产生子目标，但是下层策略的内部奖励依赖连续的子目标，也就是每一步的子目标。在这种情况下，上层策略必须每一步都产生子目标，那么既然产生了，不优化不就浪费了嘛，怎么利用呢？于是作者对每一时刻的子目标也做了平滑处理，即$w_{t}=\\phi\\left(\\sum_{i=t-c}^{t} g_{i}\\right)$。</p>\n<p>问题在于作者想让上层策略的子目标可以持续$c$个时间步，$c$个时间步之后便失效，也就是说，对于上层策略，它的经验序列应该是这样的$s_t, s_{t+c}, s_{t+2c} … s_{t+nc}$，但是由于每一时间步都存在子目标，那么也存在这样的序列$s_{t+1}, s_{t+c+1}, s_{t+2c+1} … s_{t+nc+1}$。针对这种情况，其实有两种处理手段：</p>\n<ol>\n<li>将收集到的连续序列$s_t, s_{t+1}…$按时间步$c$切分成$c$条轨迹，然后分批次输入到LSTM中进行训练。其实相当于数据预处理过程</li>\n<li>直接给LSTM输入收集到的连续序列$s_t, s_{t+1}…$，设置$r=c$组cell_state，也就是为$c$条轨迹设置$c$个不同的起始cell_state，由此来处理不切分的交叉时间尺度的经验序列，让梯度随着cell_state按不同轨迹自动传播。</li>\n</ol>\n<p>作者就是使用了第2种的处理方式。另外，作者在做对比实验的时候，给LSTM设置步长为40，给Dilated LSTM设置步长400，子目标持续步长$c=10$，也应该是这个道理，因为400/10=40，其实每个子目标序列的持续时间都是一直的，都是40个时间步。</p>\n<p>从这个角度分析，我觉得作者说“它促进了更长时间的信用分配以及增强了RNN记忆能力”是一个噱头，因为其实是它只是在共享了LSTM的参数的基础上，对$c$条连续上层子目标序列<strong>分别</strong>做了LSTM运算，本质上没有将长时间的记忆融合进去。</p>\n<h1 id=\"与h-DQN和OC的比较\"><a href=\"#与h-DQN和OC的比较\" class=\"headerlink\" title=\"与h-DQN和OC的比较\"></a>与h-DQN和OC的比较</h1><p>FuNs可以视为是h-DQN与OC的部分结合，但又不尽相同。</p>\n<h2 id=\"h-DQN-vs-FuNs\"><a href=\"#h-DQN-vs-FuNs\" class=\"headerlink\" title=\"h-DQN vs. FuNs\"></a>h-DQN vs. FuNs</h2><p>相同：</p>\n<ul>\n<li>都是显式地将决策模型分为两层，上层决策子目标，下层决策具体动作</li>\n<li>上层都是最大化外部环境累计期望回报</li>\n<li>下层都使用了内在奖励</li>\n<li>两者都将子目标作为下层策略的输入</li>\n</ul>\n<p>不同：</p>\n<ul>\n<li>FuNs上层产生的子目标是智能体的观测值在隐状态空间下的方向向量，而h-DQN上层产生的子目标是需要人为设计的，往往在原始观测状态空间上设置。</li>\n<li>FuNs不需要先验知识</li>\n<li>FuNs优化下层模型时，既使用了环境外部奖励，也使用了基于子目标产生的内部奖励，而h-DQN只使用了内部奖励</li>\n<li>h-DQN是Q-Learning式的优化方式，即最小化均方误差，而FuNs是PG式的优化方式，即最大化累计期望奖励</li>\n</ul>\n<h2 id=\"OC-vs-FuNs\"><a href=\"#OC-vs-FuNs\" class=\"headerlink\" title=\"OC vs. FuNs\"></a>OC vs. FuNs</h2><p>相同：</p>\n<ul>\n<li>两者都是用了PG式的更新方式</li>\n<li>两者都是端到端的</li>\n</ul>\n<p>不同：</p>\n<ul>\n<li>OC需要判断option的终止条件，FuNs固定上层策略的步长$c$</li>\n<li>OC需要指定option的数量（离散），而FuNs产生的子目标为方向向量（连续）</li>\n<li>OC需要为每个option构造一个下层策略模型，而FuNs共同一个下层策略模型</li>\n<li>OC的下层策略输入不包含option，只是根据option选到下层策略，而FuNs的下层策略需要包含子目标输入</li>\n<li>OC没有引入内在奖励，FuNs使用了内在奖励</li>\n<li>OC可以应用于连续动作空间，而FuNs用于离散动作空间</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"./FuNs/illustration.png\" alt=\"\"></p>\n<p>这篇论文提出了FuNs，将智能体决策分为两层——Manager产生子目标、Worker产生动作行为。两层均使用A2C方式进行优化，且梯度互不影响。</p>\n<p>推荐程度中等：</p>\n<ul>\n<li>h-DQN式分层，PG式优化</li>\n<li>隐藏状态空间设置子目标，不需要先验知识</li>\n<li>上下两层策略均使用A2C的更新方式</li>\n<li>应用于离散动作空间</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1703.01161\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1703.01161</a></p>\n<p>pytorch复现代码：<a href=\"https://github.com/dnddnjs/feudal-montezuma\" rel=\"external nofollow\" target=\"_blank\">https://github.com/dnddnjs/feudal-montezuma</a></p>\n<p>这篇论文引入了FeUdal Networks(FuNs)，它是一个新奇的强化学习分层决策结构，它将决策模型分为Manager和Worker：</p>\n<ul>\n<li>Manager，在lower temporal resolution(低时间尺度)上做higher level决策，产生子目标。这个子目标是输入观察observation的隐状态空间上的方向向量，用于指定在$s_t$时刻之后$c$步应该朝着隐空间的什么方向移动；</li>\n<li>Worker，在higher temporal resolution(更密级的时间尺度)上做lower level决策，产生执行的动作。</li>\n</ul>\n<h2 id=\"关注点\"><a href=\"#关注点\" class=\"headerlink\" title=\"关注点\"></a>关注点</h2><p>如何创建能够学习将其行为分解为有意义的原语，然后重用它们以更有效地获取新行为的智能体是一个长期存在的研究问题。</p>\n<blockquote>\n<p>How to create agents that can learn to decompose their behaviour into meaningful primitives and then reuse them to more efﬁciently acquire new behaviours is a long standing research question. The solution to this question may be an important stepping stone towards agents with general intelligence and competence.</p>\n</blockquote>\n<h2 id=\"主要贡献\"><a href=\"#主要贡献\" class=\"headerlink\" title=\"主要贡献\"></a>主要贡献</h2><p>这篇论文的创新点和特点主要有以下几个：</p>\n<ol>\n<li>提出一个一致的，端到端的，可微的模型，体现和概括了Feudal RL的原则</li>\n<li>虽然上下两层都使用A2C的更新方式，但是上层策略的损失函数构造是根据自己提出的<strong>Transition Policy Gradients</strong>，利用了子目标的语义意义</li>\n<li>提出了一个新奇的RNN结构，用在Manager模块中——<strong>Dilated LSTM</strong>，它增强了RNN的记忆能力，允许梯度在大的时间间隔内流动，允许在数百步长上进行有效的反向传播</li>\n<li>上层控制器产生的子目标不再是显式的状态，而是隐状态空间上的方向向量</li>\n</ol>\n<h2 id=\"优点-效果\"><a href=\"#优点-效果\" class=\"headerlink\" title=\"优点/效果\"></a>优点/效果</h2><ul>\n<li><p>FuNs大大提高了长期的信用分配和记忆。</p>\n<blockquote>\n<p>FuN signiﬁcantly improves long-term credit assignment and memorisation.</p>\n</blockquote>\n</li>\n<li><p>鼓励与Manager设定的不同目标相关联的子策略的出现。</p>\n<blockquote>\n<p>encourages the emergence of sub-policies associated with different goals set by the Manager.</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>下图为FuNs的整体框架示意图。</p>\n<p><img src=\"./FuNs/illustration.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li><p>上图中的灰色部分均为可学习、可微分的网络变量，在Manager框中即由Manager梯度更新，反之亦然。上图中$f^{\\text {percept }}$既不属于Manager也不属于Worker，文中也没有提到它如何优化，我<strong>猜想</strong>它是通过Manager和Worker的Critic网络共享梯度更新优化的。</p>\n</li>\n<li><p>Manager使用Transition Policy Gradient进行优化，Worker使用Policy Gradient进行优化</p>\n</li>\n<li><p>$z_{t}=f^{\\text {percept }}\\left(x_{t}\\right)$是特征提取层，CNN之类的，将观测值转换为长度为d的向量</p>\n</li>\n<li><p>$s_{t}=f^{M s p a c e}\\left(z_{t}\\right)$是Manager模块中的特征变换层，由几层全连接组成，从图上看维度不变，还是d</p>\n</li>\n<li><p>$h_{t}^{M}, \\hat{g}_{t}=f^{M r n n}\\left(s_{t}, h_{t-1}^{M}\\right) ; g_{t}=\\hat{g}_{t} /\\left|\\hat{g}_{t}\\right|$是Manager模块的子目标输出层，子目标做了归一化操作，其中$f^{M r n n}$是论文中提出的Dilated LSTM</p>\n</li>\n<li><p>$w_{t}=\\phi\\left(\\sum_{i=t-c}^{t} g_{i}\\right)$是将子目标变换为一个可以与Worker动作表示矩阵相乘的向量，看形势上应该属于一个滑动窗口，窗口长度为$c$，在这个长度的一直做移动加和，每一个时间步都根据当前观测值输出子目标$g_i$，然后连续$c$个时间步的子目标加和之后通过$\\phi$进行线性变换。</p>\n<blockquote>\n<p>A linear transform $\\phi$ maps a goal $g_t$ into an embedding vector $w_t\\in R^k$ , which is then combined via product with matrix $U_t$ (Workers output) to produce policy $\\pi$.</p>\n</blockquote>\n</li>\n<li><p>$h^{W}, U_{t}=f^{W r n n}\\left(z_{t}, h_{t-1}^{W}\\right)$是Worker的LSTM层，这里没有使用Dilated LSTM</p>\n</li>\n<li><p>$\\pi_{t}=\\operatorname{SoftMax}\\left(U_{t} w_{t}\\right)$是Worker的最终动作概率分布输出层，从文章看起来，FuNs只能应用于离散动作空间，因为其下层策略要产生的矩阵为$\\mathrm{U}_{\\mathrm{t}} \\in \\mathrm{R}^{|\\mathrm{a}| \\mathrm{xk}}$，即需要了解动作的数量。</p>\n</li>\n<li><p>Worker中的$k$为每个动作embedding向量的长度</p>\n</li>\n</ul>\n<h2 id=\"Manager损失\"><a href=\"#Manager损失\" class=\"headerlink\" title=\"Manager损失\"></a>Manager损失</h2><p>Manager的损失函数，或者说是优化目标的梯度是这样的：</p>\n<script type=\"math/tex; mode=display\">\n\\nabla g_{t}=A_{t}^{M} \\nabla_{\\theta} d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}(\\theta)\\right)</script><script type=\"math/tex; mode=display\">\nA_{t}^{M}=R_{t}-V_{t}^{M}\\left(x_{t}, \\theta\\right)</script><p>其中，$d_{\\cos }(\\alpha, \\beta)=\\alpha^{T} \\beta /(|\\alpha||\\beta|)$是余弦相似度。与传统的PG损失不同，这里没有使用$log$操作，而且使用余弦相似度。由Critic网络的输入是$x_t$我猜想到上面结构图中的percept部分是是由Critic网络的梯度优化的。</p>\n<p>注意，虽然$s_{t+c}$与$s_t$也是由Manager模块产生的，但是在优化中$s_{t+c}-s_{t}$并不传导梯度。</p>\n<p>传统的PG目标函数梯度应该是这样的：</p>\n<script type=\"math/tex; mode=display\">\n\\nabla_{\\theta} \\pi_{t}=\\mathbb{E}\\left[\\left(R_{t}-V\\left(s_{t}\\right)\\right) \\nabla_{\\theta} \\log p\\left(a_t | s_{t}\\right)\\right]</script><p>作者根据分层强化学习中上层策略产生不是动作，而是子目标，将上边式子通过分析、推理改写成下边这种形式：</p>\n<p>$o_{t}=\\mu\\left(s_{t}, \\theta\\right)$选择子策略，$p\\left(s_{t+c} | s_{t}, o_{t}\\right)$表示在子策略条件下经过$c$步决策之后的隐状态分布，$\\pi^{T P}\\left(s_{t+c} | s_{t}\\right)=p\\left(s_{t+c} | s_{t}, \\mu\\left(s_{t}, \\theta\\right)\\right)$描述给定起始状态的结束状态的分布，$s_{t+c}=\\pi^{T P}\\left(s_{t}\\right)$是转移函数。</p>\n<script type=\"math/tex; mode=display\">\n\\nabla_{\\theta} \\pi_{t}^{T P}=\\mathbb{E}\\left[\\left(R_{t}-V\\left(s_{t}\\right)\\right) \\nabla_{\\theta} \\log p\\left(s_{t+c} | s_{t}, \\mu\\left(s_{t}, \\theta\\right)\\right)\\right]</script><p>作者为了推导出$\\nabla_{\\theta} d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}(\\theta)\\right)$这种形式，假设转移模式是一种特殊的形式：$s_{t+c}-s_t$这个隐状态空间上的实际“运动”方向向量服从<strong><a href=\"https://en.wikipedia.org/wiki/Von_Mises%E2%80%93Fisher_distribution\" rel=\"external nofollow\" target=\"_blank\">von Mises-Fisher</a></strong>分布，这个分布的均值即为上层策略产生的$g_t$，根据这个分布的性质，可以推导出如下公式：</p>\n<script type=\"math/tex; mode=display\">\np\\left(s_{t+c} | s_{t}, o_{t}\\right) \\propto e^{d_{\\cos }\\left(s_{t+c}-s_{t}, g_{t}\\right)}</script><p>由此取对数可以推导出上边的梯度形式。</p>\n<blockquote>\n<p>A naive application of policy gradients requires the agent to learn from samples of these trajectories. But if we know where these trajectories are likely to end up, by modelling the transitions, then we can skip directly over the Worker’s behaviour and instead follow the policy gradient of the predicted transition. FuN assumes a particular form for the transition model: that the direction in state-space, s t+c −s t , follows a von Mises-Fisher distribution. Speciﬁcally, if the mean direction of the von Mises-Fisher distribution is given by g(o t ) (which for compactness we write as g t ) we would have p(s t+c | s t , o t ) ∝ e d cos (s t+c −s t ,g t ) . If this functional form were indeed correct, then we see that our proposed update heuristic for the Manager, eqn.7, is in fact the proper form for the transition policy gradient arrived at in eqn.10.</p>\n</blockquote>\n<h2 id=\"Worker损失\"><a href=\"#Worker损失\" class=\"headerlink\" title=\"Worker损失\"></a>Worker损失</h2><p>Worker的损失与传统的A2C一致：</p>\n<script type=\"math/tex; mode=display\">\n\\nabla \\pi_{t}=A_{t}^{D} \\nabla_{\\theta} \\log \\pi\\left(a_{t} | x_{t} ; \\theta\\right)</script><script type=\"math/tex; mode=display\">\nA_{t}^{D}=\\left(R_{t}+\\alpha R_{t}^{I}-V_{t}^{D}\\left(x_{t} ; \\theta\\right)\\right)</script><p>这里优势函数的target目标既包含外部奖励$R_t$，也包含内部奖励$R_t^I$，并用一个超参数$\\alpha$来控制内部奖励的影响程度。注意，这里的Critic输入同样为$x_t$，所以我<strong>猜想</strong>特征表示部分由Manager和Worker各自的Critic共享梯度进行优化。</p>\n<p>内部奖励是这么定义的：</p>\n<script type=\"math/tex; mode=display\">\nr_{t}^{I}=1 / c \\sum_{i=1}^{c} d_{\\cos }\\left(s_{t}-s_{t-i}, g_{t-i}\\right)</script><p>从这个公式可以看出，每一步的内部奖励需要往前计算$c$步余弦相似度，因此，如果设置的子目标持续步长$c$很大，那么将会引入额外的轨迹长度倍的计算开销。</p>\n<p>作者使用方向向量，是因为与假设可以将智能体带到（可能）任意新的绝对位置相比，Worker能够更可靠地引起状态在隐空间上的方向转移。（真拗口）</p>\n<blockquote>\n<p>We use directions because it is more feasible for the Worker to be able to reliably cause directional shifts in the latent state than it is to assume that the Worker can take us to (potentially) arbitrary new absolute locations.</p>\n<p>Note that the Worker’s intrinsic reward (eqn. 8) is based on the log-likelihood of state trajectory. Through that the FuN architecture actively encourages the functional form of the transition model to hold true. Because the Worker is learning to achieve the Manager’s direction, its transitions should, over time, closely follow a distribution around this direction, and hence our approximation for transition policy gradients should hold reasonably well.</p>\n</blockquote>\n<h2 id=\"Dilated-LSTM\"><a href=\"#Dilated-LSTM\" class=\"headerlink\" title=\"Dilated LSTM\"></a>Dilated LSTM</h2><p>说实话，这里没有完全理解。</p>\n<p>公式是这样的：</p>\n<script type=\"math/tex; mode=display\">\ng_{t}=L S T M\\left(s_{t}, \\hat{h}_{t-1}^{t \\% r} ; \\theta^{L S T M}\\right)</script><p>其中$\\theta^{L S T M}$是共享的LSTM网络参数，cell_state是一个组，$h=\\left\\{\\hat{h}^{i}\\right\\}_{i=1}^{r}$。$r$是一个dilation radius，也就是说这个LSTM网络包含许多个cell_state，也就是core。式子中的百分号<code>%</code>是做一个模的操作。然后作者说他们在实验中radius的设置与horizon相同，即$c=r$。</p>\n<p><strong>我的猜想是这样的</strong>：</p>\n<p>作者虽然想让上层策略在一个粗粒度的时间上进行决策，即产生子目标，但是下层策略的内部奖励依赖连续的子目标，也就是每一步的子目标。在这种情况下，上层策略必须每一步都产生子目标，那么既然产生了，不优化不就浪费了嘛，怎么利用呢？于是作者对每一时刻的子目标也做了平滑处理，即$w_{t}=\\phi\\left(\\sum_{i=t-c}^{t} g_{i}\\right)$。</p>\n<p>问题在于作者想让上层策略的子目标可以持续$c$个时间步，$c$个时间步之后便失效，也就是说，对于上层策略，它的经验序列应该是这样的$s_t, s_{t+c}, s_{t+2c} … s_{t+nc}$，但是由于每一时间步都存在子目标，那么也存在这样的序列$s_{t+1}, s_{t+c+1}, s_{t+2c+1} … s_{t+nc+1}$。针对这种情况，其实有两种处理手段：</p>\n<ol>\n<li>将收集到的连续序列$s_t, s_{t+1}…$按时间步$c$切分成$c$条轨迹，然后分批次输入到LSTM中进行训练。其实相当于数据预处理过程</li>\n<li>直接给LSTM输入收集到的连续序列$s_t, s_{t+1}…$，设置$r=c$组cell_state，也就是为$c$条轨迹设置$c$个不同的起始cell_state，由此来处理不切分的交叉时间尺度的经验序列，让梯度随着cell_state按不同轨迹自动传播。</li>\n</ol>\n<p>作者就是使用了第2种的处理方式。另外，作者在做对比实验的时候，给LSTM设置步长为40，给Dilated LSTM设置步长400，子目标持续步长$c=10$，也应该是这个道理，因为400/10=40，其实每个子目标序列的持续时间都是一直的，都是40个时间步。</p>\n<p>从这个角度分析，我觉得作者说“它促进了更长时间的信用分配以及增强了RNN记忆能力”是一个噱头，因为其实是它只是在共享了LSTM的参数的基础上，对$c$条连续上层子目标序列<strong>分别</strong>做了LSTM运算，本质上没有将长时间的记忆融合进去。</p>\n<h1 id=\"与h-DQN和OC的比较\"><a href=\"#与h-DQN和OC的比较\" class=\"headerlink\" title=\"与h-DQN和OC的比较\"></a>与h-DQN和OC的比较</h1><p>FuNs可以视为是h-DQN与OC的部分结合，但又不尽相同。</p>\n<h2 id=\"h-DQN-vs-FuNs\"><a href=\"#h-DQN-vs-FuNs\" class=\"headerlink\" title=\"h-DQN vs. FuNs\"></a>h-DQN vs. FuNs</h2><p>相同：</p>\n<ul>\n<li>都是显式地将决策模型分为两层，上层决策子目标，下层决策具体动作</li>\n<li>上层都是最大化外部环境累计期望回报</li>\n<li>下层都使用了内在奖励</li>\n<li>两者都将子目标作为下层策略的输入</li>\n</ul>\n<p>不同：</p>\n<ul>\n<li>FuNs上层产生的子目标是智能体的观测值在隐状态空间下的方向向量，而h-DQN上层产生的子目标是需要人为设计的，往往在原始观测状态空间上设置。</li>\n<li>FuNs不需要先验知识</li>\n<li>FuNs优化下层模型时，既使用了环境外部奖励，也使用了基于子目标产生的内部奖励，而h-DQN只使用了内部奖励</li>\n<li>h-DQN是Q-Learning式的优化方式，即最小化均方误差，而FuNs是PG式的优化方式，即最大化累计期望奖励</li>\n</ul>\n<h2 id=\"OC-vs-FuNs\"><a href=\"#OC-vs-FuNs\" class=\"headerlink\" title=\"OC vs. FuNs\"></a>OC vs. FuNs</h2><p>相同：</p>\n<ul>\n<li>两者都是用了PG式的更新方式</li>\n<li>两者都是端到端的</li>\n</ul>\n<p>不同：</p>\n<ul>\n<li>OC需要判断option的终止条件，FuNs固定上层策略的步长$c$</li>\n<li>OC需要指定option的数量（离散），而FuNs产生的子目标为方向向量（连续）</li>\n<li>OC需要为每个option构造一个下层策略模型，而FuNs共同一个下层策略模型</li>\n<li>OC的下层策略输入不包含option，只是根据option选到下层策略，而FuNs的下层策略需要包含子目标输入</li>\n<li>OC没有引入内在奖励，FuNs使用了内在奖励</li>\n<li>OC可以应用于连续动作空间，而FuNs用于离散动作空间</li>\n</ul>"},{"title":"Hindsight Experience Replay","copyright":true,"mathjax":true,"top":1,"date":"2019-05-28T10:38:56.000Z","keywords":null,"description":null,"_content":"\n本文介绍了一个“事后诸葛亮”的经验池机制，简称为**HER**，它可以很好地应用于**稀疏奖励**和**二分奖励**的问题中，不需要复杂的奖励函数工程设计。\n\n推荐：\n\n- 稀疏奖励问题的一种解决方案\n- 通俗易懂\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://papers.nips.cc/paper/7090-hindsight-experience-replay.pdf](https://papers.nips.cc/paper/7090-hindsight-experience-replay.pdf)\n\n>Dealing with sparse rewards is one of the biggest challenges in Reinforcement Learning (RL).  \n\n强化学习问题中最棘手的问题之一就是稀疏奖励。\n\n本文提出了一个新颖的技术：Hindsight Experience Replay（HER），可以从稀疏、二分的奖励问题中高效采样并进行学习，而且可以应用于**所有的Off-Policy**算法中。\n\n![](./Hindsight-Experience-Replay/hindsight.png)\n\nHindsight意为事后，结合强化学习中序贯决策问题的特性，我们很容易就可以猜想到，“事后”要不然指的是在状态s下执行动作a之后，要不然指的就是当一个episode结束之后。其实，文中对常规经验池的改进也正是运用了这样的含义。\n\n> HER lets an agent learn from undesired outcomes and tackles the problem of sparse rewards in Reinforcement Learning (RL).——Zhao, R., & Tresp, V. (2018). Energy-Based Hindsight Experience Prioritization. *CoRL*.\n\nHER使智能体从没达到的结果中去学习，解决了强化学习中稀疏奖励的问题。\n\n## 二分奖励 binary reward\n\n简言之，完成目标为一个值，没完成目标为另一个值。如：\n\n- $S_{T}=Goal，r=0$\n- $S\\neq Goal, r=-1. for \\ S \\in \\mathbb{S}$\n\n## 稀疏奖励 sparse reward\n\n简言之，完成目标的episode太少或者完成目标的步数太长，导致负奖励的样本数过多\n\n# 文中精要\n\n在机器人领域，要想使强化学习训练它完美执行某任务，往往需要设计合理的奖励函数，但是设计这样的奖励函数工程师不仅需要懂得强化学习的领域知识，也需要懂得机器人、运动学等领域的知识。而且，有这些知识也未必能设计出很好的奖励函数供智能体进行学习。因此，如果可以从简单的奖励函数（如二分奖励）学习到可完成任务的模型，那就不需要费心设计复杂的奖励函数了。\n\n文中介绍了一个例子来引入HER：\n\n- 名称：bit-flipping environment\n- 状态空间$\\mathcal{S}=\\left \\{ 0,1 \\right \\}^{n}$\n- 动作空间$\\mathcal{A}=\\left \\{ 0,1,\\cdots,n-1 \\right \\}$\n- 规则：对于每个episode，均匀采样长度为$n$的初始状态$s_{0}$（如$n=5，s_{0}=10101$）和目标状态$s_{g}$，每一步从动作空间中选取一个动作$a$，翻转$s_{0}$第$a$个位置的值，如$a=1\\Rightarrow s_{1}=11101$，直到回合结束或者翻转后的状态与$s_{g}$相同\n- 奖励函数：$r_{g}(s,a)=-\\left [ s \\neq g \\right ]$，即达到目标状态则为0，未达到目标状态则为-1。这个很容易理解，$s \\neq g \\Rightarrow true \\doteq 1，s = g \\Rightarrow false \\doteq 0$\n\n*注：下文如无特殊说明，$g$即表示目标状态$s_{g}$*\n\n> Standard RL algorithms are bound to fail in this environment for n > 40 because they will never experience any reward other than -1. Notice that using techniques for improving exploration (e.g. VIME (Houthooft et al., 2016), count-based exploration (Ostrovski et al., 2017) or bootstrapped DQN (Osband et al., 2016)) does not help here because the real problem is not in lack of diversity of states being visited, rather it is simply impractical to explore such a large state space.  \n\n当序列长度$n$大于40时，传统的强化学习算法就算有各种探索机制的加持，也不能学会解决这个问题，因为这个问题完全不是缺乏探索，而是**状态太多，探索不完**，导致奖励极其稀疏，算法根本不知道需要优化的目标在哪里。\n\n为了解决这个问题，作者指出了两个思路：\n\n1. 使用shaped reward（简言之，将reward设计成某些变量的函数，如$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$，即奖励函数为当前状态与目标状态的欧氏距离的负数），将训练的算法逐步引导至奖励函数增大的决策空间。但是这种方法可能很难应用于复杂的问题中。\n2. 使用HER——事后经验池机制\n\n## HER\n\n> The pivotal idea behind our approach is to re-examine this trajectory with a different goal — while this trajectory may not help us learn how to achieve the state g, it definitely tells us something about how to achieve the state $s_{T}$ .\n\nHER的主要思想就是：**为什么一定要考虑我们设定的目标呢？假设我们想让一个智能体学会移动到某个位置，它在一个episode中没有学到移动到目标位置就算失败吗？假定序列为$s_{0},s_{1},s_{2}, \\cdots ,s_{T}$，目标为$g$，我们何不换一种思路考虑：如果我们在episode开始前就将目标状态$g$设置为$s_{T}$，即$g=s_{T}$，那么这样看来智能体不就算是完成目标了吗？**\n\n![](./Hindsight-Experience-Replay/Her.png)\n\nHER就是运用了这个思想对经验池进行了扩充，将稀疏奖励问题给转化成非稀疏奖励，大大的扩展了经验池中完成任务的经验数量。\n\nHER主要特点：\n\n- 传统经验池存入的是状态$s$，而HER存入的是$s||g$，也就是`tf.concat(s,g)`\n- 训练算法的输入也是$s||g$，也就是需要在当前状态后边连结上**每个episode的**目标状态，每个episode的目标状态可能不同\n- HER对经验池进行了扩充，不仅存入实际采样得到的transition/experience，$\\left ( s_{t}||g,a_{t},r_{t},s_{t+1}||g \\right )$，也要在回合结束时**重新设置目标状态**，得到相应的奖励值（在二分奖励问题中，只有在$s=g$时奖励才需要更改），存入“事后”（当初如果这样就好啦！）的经验$\\left ( s_{t}||g',a_{t},r_{t}',s_{t+1}||g' \\right )$，详见伪代码，这个事后经验究竟存入多少份、多少种，由超参数$k$控制，下文讲解。\n- HER更适合解决多目标问题，多目标的意思为，目标点非固定，每个episode的目标状态可以不相同。详见实验部分\n\nHER的几种扩展方式：\n\n> future — replay with k random states which come from the same episode as the transition being replayed and were observed after it,\n> episode — replay with k random states coming from the same episode as the transition being replayed,\n> random — replay with k random states encountered so far in the whole training procedure.\n\n- 未来模式——future：在一个序列$s_{0},s_{1},s_{2},\\cdots,s_{T}$中，如果遍历到状态$s_{2}$，则在$s_{3},\\cdots,s_{T}$之间随机抽取$k$个状态作为目标状态$g'$，并依此向经验池中存入$\\left ( s_{2}||g',a_{2},r_{2}',s_{3}||g' \\right )$，**特点：一个episode的后续部分**\n- 回合模式——episode：在一个序列$s_{0},s_{1},s_{2},...,s_{T}$中，如果遍历到状态$s_{2}$，则在整个序列中随机抽取$k$个状态作为目标状态$g'$，并依此向经验池中存入$\\left ( s_{2}||g',a_{2},r_{2}',s_{3}||g' \\right )$，**特点：一个episode**\n\n- 随机模式——random：在一个序列$s_{0},s_{1},s_{2},...,s_{T}$中，如果遍历到状态$s_{2}$，则在多个序列$\\tau_{0},\\tau_{1},\\tau_{2},\\cdots$中随机抽取$k$个状态作为目标状态$g'$，并依此向经验池中存入$\\left ( s_{2}||g',a_{2},r_{2}',s_{3}||g' \\right )$，**特点：多个episode**\n\n- 最终模式——final：在一个序列$s_{0},s_{1},s_{2},\\cdots,s_{T}$中，如果遍历到状态$s_{2}$，则之间令$g'=s_{T}$，并向经验池中存入$\\left ( s_{2}||g',a_{2},r_{2}',s_{3}||g' \\right )$，**特点：一个episode的最后一个状态，如果设置k，则存入k个相同的经验**\n\n## 伪代码\n\n![](./Hindsight-Experience-Replay/pseudo.png)\n\n解析：\n\n1. 伪代码中没有提到超参数$k$，其实在循环条件$\\textbf{for} \\ g' \\in G \\ \\textbf{do}$中循环执行了$k$次\n2. $||$操作为连结操作，简言之，将两个长度为5的向量合并成一个长度为10的向量\n3. $G:=\\mathbb{S}(\\textbf{current episode})$即为上文提到的四种扩展模式：future、episode、random、final。\n4. 奖励函数$r(s,a,g)=-\\left [ f_{g}(s)=0 \\right ]$即为前文提到的$r_{g}(s,a)=-\\left [ s \\neq g \\right ]$，即完成为0，未完成为-1，具体奖励函数可以根据我们的使用环境设计\n5. $a_{t} \\leftarrow \\pi_{b}(s_{t}||g)$表示神经网络的输入为当前状态与目标状态的连结\n\n## HER的优点\n\n1. 可解决稀疏奖励、二分奖励问题\n2. 可适用于所有的Off-Policy算法\n3. 提升了数据采样效率\n\n# 实验部分\n\n文中实验结果：[https://goo.gl/SMrQnI](https://goo.gl/SMrQnI)\n\n实验部分的完整细节请参考论文原文。\n\n## 环境\n\n- 7自由度机械臂\n- 模拟环境：MuJoCo\n- 任务分为3种\n  - Pushing，推：锁定机械臂的钳子，移动机械臂将物体推到目标点\n  - Sliding，滑动：类似于冰球运动，锁定机械臂的钳子，移动机械臂给与物体一个力，使物体可以在较光滑的桌面上滑动并且达到目标位置\n  - Pick-and-place，摆放：解锁钳子，使用机械臂夹起物体并移动至空中目标点\n\n![](./Hindsight-Experience-Replay/tasks.png)\n\n## 算法\n\n- DDPG\n- Adam优化器\n- 多层感知机MLPs\n- ReLU激活函数\n- 8核并行，更新参数后取平均\n- A-C网络都是3个隐藏层，每层64个隐节点，Actor输出层用tanh激活函数\n- 经验池大小为$10^{6}$，折扣因子$\\gamma=0.98$，学习率$\\alpha=0.001$，探索因子$\\epsilon = 0.2$\n\n> With probability 20% we sample (uniformly) a random action from the hypercube of valid actions. \n\nDDPG使用了随机探索机制\n\n## 训练结果\n\n### final模式与future模式对比\n\n![](./Hindsight-Experience-Replay/finalvsfuture.png)\n\n- 红色曲线为future模式，蓝色曲线为final模式，绿色曲线为使用了[count-based](https://arxiv.org/pdf/1703.01310.pdf)的DDPG，褐红色虚线为原始DDPG\n- 从左至右依次是Pushing，Sliding，Pick-and-place任务\n- 超参数$k=4$\n- 这个实验中，目标状态会变，即为多个目标状态\n\n结果分析：\n\n- future模式比final效果更好\n- 使用了count-based的DDPG智能稍微解决一下Sliding任务\n- 使用HER的DDPG可以完全胜任三个任务\n- 证明了HER是使从稀疏、二分奖励问题中学习成为可能的关键因素\n\n### 单个目标状态的实验\n\n![](./Hindsight-Experience-Replay/singlegoal.png)\n\n- 蓝色曲线为使用了HER的DDPG，文中并未说明HER是哪种模式，**猜测**是final模式，因为文中实验部分之前都是以final模式进行举例\n- 绿色曲线代表应用了count-based的DDPG，褐红色虚线为原始DDPG\n- 实验中，目标状态都为同一状态$g$\n\n结果分析：\n\n- DDPG+HER比原始DDPG的性能要好很多\n- **相比于多个目标的实验，可以发现，在多目标的任务中DDPG训练更快**，所以在实际中，即使我们只关心一个目标，我们最好也使用多个目标来训练\n\n### HER应用于reward shaping问题中\n\n前文已经说过，reward shaping可以简单理解为将奖励函数设置为某些变量的函数，如$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$，即奖励函数为当前状态与目标状态的欧氏距离的负数\n\n![](./Hindsight-Experience-Replay/rewardshape.png)\n\n- 奖励函数为$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$\n\n结果分析：\n\n- 无论使用怎样的reward shaping函数，DDPG、DDPG+HER都不能解决这个问题\n\n- 作者认为原因有二：\n\n  - > There is a huge discrepancy between what we optimize (i.e. a shaped reward function) and the success condition (i.e.: is the object within some radius from the goal at the end of the episode);  \n  \n    判定完成目标的条件和要优化的问题有巨大的矛盾（虽然我也不理解这到底是什么意思，索性就直接抄了过来）\n  \n  - > Shaped rewards penalize for inappropriate behaviour (e.g. moving the box in a wrong direction) which may hinder exploration. It can cause the agent to learn not to touch the box at all if it can not manipulate it precisely and we noticed such behaviour in some of our experiments. \n  \n    reward shaping阻碍了探索\n  \n- > Our results suggest that domain-agnostic reward shaping does not work well (at least in the simple forms we have tried). Of course for every problem there exists a reward which makes it easy (Ng et al., 1999) but designing such shaped rewards requires a lot of domain knowledge and may in some cases not be much easier than directly scripting the policy. This strengthens our belief that learning from sparse, binary rewards is an important problem. \n\n  研究结果表明，与领域无关的reward shaping效果并不好\n\n### 四种模式比较\n\n![](./Hindsight-Experience-Replay/fourmodel.png)\n\n- 红色代表future模式，蓝色代表final模式，绿色代表episode模式，紫色代表episode模式，褐红色虚线代表原始DDPG\n- 横坐标代表超参数$k$，第一行三个图的纵坐标代表最高得分，第二行三个图的纵坐标代表平均得分\n\n结果分析：\n\n- 效果：future>final>episode>random>no HER\n\n- 稳定性：final(好)=no-HER(差)>future>episode>random\n\n- future模式是唯一一个可以解决Sliding任务的，在$k=4$或者$k=8$时效果最好\n\n- 增大$k$超过8会使性能有所下降，主要是因为$k$过大导致经验池中原始真实数据所占的比例太小\n\n- > It confirms that the most valuable goals for replay are the ones which are going to be achieved in the near future \n\n  它证实了回放经验中最有价值的目标是那些在不久的将来能实现的目标\n\n*注：作者根据 future 模式提出了最近邻的 future 模式，即把$g'$设置为$s_{t+1}$，并且进行了实验，实验结果不如 future 模式。*","source":"_posts/Hindsight-Experience-Replay.md","raw":"---\ntitle: Hindsight Experience Replay\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2019-05-28 18:38:56\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n本文介绍了一个“事后诸葛亮”的经验池机制，简称为**HER**，它可以很好地应用于**稀疏奖励**和**二分奖励**的问题中，不需要复杂的奖励函数工程设计。\n\n推荐：\n\n- 稀疏奖励问题的一种解决方案\n- 通俗易懂\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://papers.nips.cc/paper/7090-hindsight-experience-replay.pdf](https://papers.nips.cc/paper/7090-hindsight-experience-replay.pdf)\n\n>Dealing with sparse rewards is one of the biggest challenges in Reinforcement Learning (RL).  \n\n强化学习问题中最棘手的问题之一就是稀疏奖励。\n\n本文提出了一个新颖的技术：Hindsight Experience Replay（HER），可以从稀疏、二分的奖励问题中高效采样并进行学习，而且可以应用于**所有的Off-Policy**算法中。\n\n![](./Hindsight-Experience-Replay/hindsight.png)\n\nHindsight意为事后，结合强化学习中序贯决策问题的特性，我们很容易就可以猜想到，“事后”要不然指的是在状态s下执行动作a之后，要不然指的就是当一个episode结束之后。其实，文中对常规经验池的改进也正是运用了这样的含义。\n\n> HER lets an agent learn from undesired outcomes and tackles the problem of sparse rewards in Reinforcement Learning (RL).——Zhao, R., & Tresp, V. (2018). Energy-Based Hindsight Experience Prioritization. *CoRL*.\n\nHER使智能体从没达到的结果中去学习，解决了强化学习中稀疏奖励的问题。\n\n## 二分奖励 binary reward\n\n简言之，完成目标为一个值，没完成目标为另一个值。如：\n\n- $S_{T}=Goal，r=0$\n- $S\\neq Goal, r=-1. for \\ S \\in \\mathbb{S}$\n\n## 稀疏奖励 sparse reward\n\n简言之，完成目标的episode太少或者完成目标的步数太长，导致负奖励的样本数过多\n\n# 文中精要\n\n在机器人领域，要想使强化学习训练它完美执行某任务，往往需要设计合理的奖励函数，但是设计这样的奖励函数工程师不仅需要懂得强化学习的领域知识，也需要懂得机器人、运动学等领域的知识。而且，有这些知识也未必能设计出很好的奖励函数供智能体进行学习。因此，如果可以从简单的奖励函数（如二分奖励）学习到可完成任务的模型，那就不需要费心设计复杂的奖励函数了。\n\n文中介绍了一个例子来引入HER：\n\n- 名称：bit-flipping environment\n- 状态空间$\\mathcal{S}=\\left \\{ 0,1 \\right \\}^{n}$\n- 动作空间$\\mathcal{A}=\\left \\{ 0,1,\\cdots,n-1 \\right \\}$\n- 规则：对于每个episode，均匀采样长度为$n$的初始状态$s_{0}$（如$n=5，s_{0}=10101$）和目标状态$s_{g}$，每一步从动作空间中选取一个动作$a$，翻转$s_{0}$第$a$个位置的值，如$a=1\\Rightarrow s_{1}=11101$，直到回合结束或者翻转后的状态与$s_{g}$相同\n- 奖励函数：$r_{g}(s,a)=-\\left [ s \\neq g \\right ]$，即达到目标状态则为0，未达到目标状态则为-1。这个很容易理解，$s \\neq g \\Rightarrow true \\doteq 1，s = g \\Rightarrow false \\doteq 0$\n\n*注：下文如无特殊说明，$g$即表示目标状态$s_{g}$*\n\n> Standard RL algorithms are bound to fail in this environment for n > 40 because they will never experience any reward other than -1. Notice that using techniques for improving exploration (e.g. VIME (Houthooft et al., 2016), count-based exploration (Ostrovski et al., 2017) or bootstrapped DQN (Osband et al., 2016)) does not help here because the real problem is not in lack of diversity of states being visited, rather it is simply impractical to explore such a large state space.  \n\n当序列长度$n$大于40时，传统的强化学习算法就算有各种探索机制的加持，也不能学会解决这个问题，因为这个问题完全不是缺乏探索，而是**状态太多，探索不完**，导致奖励极其稀疏，算法根本不知道需要优化的目标在哪里。\n\n为了解决这个问题，作者指出了两个思路：\n\n1. 使用shaped reward（简言之，将reward设计成某些变量的函数，如$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$，即奖励函数为当前状态与目标状态的欧氏距离的负数），将训练的算法逐步引导至奖励函数增大的决策空间。但是这种方法可能很难应用于复杂的问题中。\n2. 使用HER——事后经验池机制\n\n## HER\n\n> The pivotal idea behind our approach is to re-examine this trajectory with a different goal — while this trajectory may not help us learn how to achieve the state g, it definitely tells us something about how to achieve the state $s_{T}$ .\n\nHER的主要思想就是：**为什么一定要考虑我们设定的目标呢？假设我们想让一个智能体学会移动到某个位置，它在一个episode中没有学到移动到目标位置就算失败吗？假定序列为$s_{0},s_{1},s_{2}, \\cdots ,s_{T}$，目标为$g$，我们何不换一种思路考虑：如果我们在episode开始前就将目标状态$g$设置为$s_{T}$，即$g=s_{T}$，那么这样看来智能体不就算是完成目标了吗？**\n\n![](./Hindsight-Experience-Replay/Her.png)\n\nHER就是运用了这个思想对经验池进行了扩充，将稀疏奖励问题给转化成非稀疏奖励，大大的扩展了经验池中完成任务的经验数量。\n\nHER主要特点：\n\n- 传统经验池存入的是状态$s$，而HER存入的是$s||g$，也就是`tf.concat(s,g)`\n- 训练算法的输入也是$s||g$，也就是需要在当前状态后边连结上**每个episode的**目标状态，每个episode的目标状态可能不同\n- HER对经验池进行了扩充，不仅存入实际采样得到的transition/experience，$\\left ( s_{t}||g,a_{t},r_{t},s_{t+1}||g \\right )$，也要在回合结束时**重新设置目标状态**，得到相应的奖励值（在二分奖励问题中，只有在$s=g$时奖励才需要更改），存入“事后”（当初如果这样就好啦！）的经验$\\left ( s_{t}||g',a_{t},r_{t}',s_{t+1}||g' \\right )$，详见伪代码，这个事后经验究竟存入多少份、多少种，由超参数$k$控制，下文讲解。\n- HER更适合解决多目标问题，多目标的意思为，目标点非固定，每个episode的目标状态可以不相同。详见实验部分\n\nHER的几种扩展方式：\n\n> future — replay with k random states which come from the same episode as the transition being replayed and were observed after it,\n> episode — replay with k random states coming from the same episode as the transition being replayed,\n> random — replay with k random states encountered so far in the whole training procedure.\n\n- 未来模式——future：在一个序列$s_{0},s_{1},s_{2},\\cdots,s_{T}$中，如果遍历到状态$s_{2}$，则在$s_{3},\\cdots,s_{T}$之间随机抽取$k$个状态作为目标状态$g'$，并依此向经验池中存入$\\left ( s_{2}||g',a_{2},r_{2}',s_{3}||g' \\right )$，**特点：一个episode的后续部分**\n- 回合模式——episode：在一个序列$s_{0},s_{1},s_{2},...,s_{T}$中，如果遍历到状态$s_{2}$，则在整个序列中随机抽取$k$个状态作为目标状态$g'$，并依此向经验池中存入$\\left ( s_{2}||g',a_{2},r_{2}',s_{3}||g' \\right )$，**特点：一个episode**\n\n- 随机模式——random：在一个序列$s_{0},s_{1},s_{2},...,s_{T}$中，如果遍历到状态$s_{2}$，则在多个序列$\\tau_{0},\\tau_{1},\\tau_{2},\\cdots$中随机抽取$k$个状态作为目标状态$g'$，并依此向经验池中存入$\\left ( s_{2}||g',a_{2},r_{2}',s_{3}||g' \\right )$，**特点：多个episode**\n\n- 最终模式——final：在一个序列$s_{0},s_{1},s_{2},\\cdots,s_{T}$中，如果遍历到状态$s_{2}$，则之间令$g'=s_{T}$，并向经验池中存入$\\left ( s_{2}||g',a_{2},r_{2}',s_{3}||g' \\right )$，**特点：一个episode的最后一个状态，如果设置k，则存入k个相同的经验**\n\n## 伪代码\n\n![](./Hindsight-Experience-Replay/pseudo.png)\n\n解析：\n\n1. 伪代码中没有提到超参数$k$，其实在循环条件$\\textbf{for} \\ g' \\in G \\ \\textbf{do}$中循环执行了$k$次\n2. $||$操作为连结操作，简言之，将两个长度为5的向量合并成一个长度为10的向量\n3. $G:=\\mathbb{S}(\\textbf{current episode})$即为上文提到的四种扩展模式：future、episode、random、final。\n4. 奖励函数$r(s,a,g)=-\\left [ f_{g}(s)=0 \\right ]$即为前文提到的$r_{g}(s,a)=-\\left [ s \\neq g \\right ]$，即完成为0，未完成为-1，具体奖励函数可以根据我们的使用环境设计\n5. $a_{t} \\leftarrow \\pi_{b}(s_{t}||g)$表示神经网络的输入为当前状态与目标状态的连结\n\n## HER的优点\n\n1. 可解决稀疏奖励、二分奖励问题\n2. 可适用于所有的Off-Policy算法\n3. 提升了数据采样效率\n\n# 实验部分\n\n文中实验结果：[https://goo.gl/SMrQnI](https://goo.gl/SMrQnI)\n\n实验部分的完整细节请参考论文原文。\n\n## 环境\n\n- 7自由度机械臂\n- 模拟环境：MuJoCo\n- 任务分为3种\n  - Pushing，推：锁定机械臂的钳子，移动机械臂将物体推到目标点\n  - Sliding，滑动：类似于冰球运动，锁定机械臂的钳子，移动机械臂给与物体一个力，使物体可以在较光滑的桌面上滑动并且达到目标位置\n  - Pick-and-place，摆放：解锁钳子，使用机械臂夹起物体并移动至空中目标点\n\n![](./Hindsight-Experience-Replay/tasks.png)\n\n## 算法\n\n- DDPG\n- Adam优化器\n- 多层感知机MLPs\n- ReLU激活函数\n- 8核并行，更新参数后取平均\n- A-C网络都是3个隐藏层，每层64个隐节点，Actor输出层用tanh激活函数\n- 经验池大小为$10^{6}$，折扣因子$\\gamma=0.98$，学习率$\\alpha=0.001$，探索因子$\\epsilon = 0.2$\n\n> With probability 20% we sample (uniformly) a random action from the hypercube of valid actions. \n\nDDPG使用了随机探索机制\n\n## 训练结果\n\n### final模式与future模式对比\n\n![](./Hindsight-Experience-Replay/finalvsfuture.png)\n\n- 红色曲线为future模式，蓝色曲线为final模式，绿色曲线为使用了[count-based](https://arxiv.org/pdf/1703.01310.pdf)的DDPG，褐红色虚线为原始DDPG\n- 从左至右依次是Pushing，Sliding，Pick-and-place任务\n- 超参数$k=4$\n- 这个实验中，目标状态会变，即为多个目标状态\n\n结果分析：\n\n- future模式比final效果更好\n- 使用了count-based的DDPG智能稍微解决一下Sliding任务\n- 使用HER的DDPG可以完全胜任三个任务\n- 证明了HER是使从稀疏、二分奖励问题中学习成为可能的关键因素\n\n### 单个目标状态的实验\n\n![](./Hindsight-Experience-Replay/singlegoal.png)\n\n- 蓝色曲线为使用了HER的DDPG，文中并未说明HER是哪种模式，**猜测**是final模式，因为文中实验部分之前都是以final模式进行举例\n- 绿色曲线代表应用了count-based的DDPG，褐红色虚线为原始DDPG\n- 实验中，目标状态都为同一状态$g$\n\n结果分析：\n\n- DDPG+HER比原始DDPG的性能要好很多\n- **相比于多个目标的实验，可以发现，在多目标的任务中DDPG训练更快**，所以在实际中，即使我们只关心一个目标，我们最好也使用多个目标来训练\n\n### HER应用于reward shaping问题中\n\n前文已经说过，reward shaping可以简单理解为将奖励函数设置为某些变量的函数，如$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$，即奖励函数为当前状态与目标状态的欧氏距离的负数\n\n![](./Hindsight-Experience-Replay/rewardshape.png)\n\n- 奖励函数为$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$\n\n结果分析：\n\n- 无论使用怎样的reward shaping函数，DDPG、DDPG+HER都不能解决这个问题\n\n- 作者认为原因有二：\n\n  - > There is a huge discrepancy between what we optimize (i.e. a shaped reward function) and the success condition (i.e.: is the object within some radius from the goal at the end of the episode);  \n  \n    判定完成目标的条件和要优化的问题有巨大的矛盾（虽然我也不理解这到底是什么意思，索性就直接抄了过来）\n  \n  - > Shaped rewards penalize for inappropriate behaviour (e.g. moving the box in a wrong direction) which may hinder exploration. It can cause the agent to learn not to touch the box at all if it can not manipulate it precisely and we noticed such behaviour in some of our experiments. \n  \n    reward shaping阻碍了探索\n  \n- > Our results suggest that domain-agnostic reward shaping does not work well (at least in the simple forms we have tried). Of course for every problem there exists a reward which makes it easy (Ng et al., 1999) but designing such shaped rewards requires a lot of domain knowledge and may in some cases not be much easier than directly scripting the policy. This strengthens our belief that learning from sparse, binary rewards is an important problem. \n\n  研究结果表明，与领域无关的reward shaping效果并不好\n\n### 四种模式比较\n\n![](./Hindsight-Experience-Replay/fourmodel.png)\n\n- 红色代表future模式，蓝色代表final模式，绿色代表episode模式，紫色代表episode模式，褐红色虚线代表原始DDPG\n- 横坐标代表超参数$k$，第一行三个图的纵坐标代表最高得分，第二行三个图的纵坐标代表平均得分\n\n结果分析：\n\n- 效果：future>final>episode>random>no HER\n\n- 稳定性：final(好)=no-HER(差)>future>episode>random\n\n- future模式是唯一一个可以解决Sliding任务的，在$k=4$或者$k=8$时效果最好\n\n- 增大$k$超过8会使性能有所下降，主要是因为$k$过大导致经验池中原始真实数据所占的比例太小\n\n- > It confirms that the most valuable goals for replay are the ones which are going to be achieved in the near future \n\n  它证实了回放经验中最有价值的目标是那些在不久的将来能实现的目标\n\n*注：作者根据 future 模式提出了最近邻的 future 模式，即把$g'$设置为$s_{t+1}$，并且进行了实验，实验结果不如 future 模式。*","slug":"Hindsight-Experience-Replay","published":1,"updated":"2019-05-30T09:52:24.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut8k004g20cd9b7b96o4","content":"<p>本文介绍了一个“事后诸葛亮”的经验池机制，简称为<strong>HER</strong>，它可以很好地应用于<strong>稀疏奖励</strong>和<strong>二分奖励</strong>的问题中，不需要复杂的奖励函数工程设计。</p>\n<p>推荐：</p>\n<ul>\n<li>稀疏奖励问题的一种解决方案</li>\n<li>通俗易懂</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://papers.nips.cc/paper/7090-hindsight-experience-replay.pdf\" rel=\"external nofollow\" target=\"_blank\">https://papers.nips.cc/paper/7090-hindsight-experience-replay.pdf</a></p>\n<blockquote>\n<p>Dealing with sparse rewards is one of the biggest challenges in Reinforcement Learning (RL).  </p>\n</blockquote>\n<p>强化学习问题中最棘手的问题之一就是稀疏奖励。</p>\n<p>本文提出了一个新颖的技术：Hindsight Experience Replay（HER），可以从稀疏、二分的奖励问题中高效采样并进行学习，而且可以应用于<strong>所有的Off-Policy</strong>算法中。</p>\n<p><img src=\"./Hindsight-Experience-Replay/hindsight.png\" alt=\"\"></p>\n<p>Hindsight意为事后，结合强化学习中序贯决策问题的特性，我们很容易就可以猜想到，“事后”要不然指的是在状态s下执行动作a之后，要不然指的就是当一个episode结束之后。其实，文中对常规经验池的改进也正是运用了这样的含义。</p>\n<blockquote>\n<p>HER lets an agent learn from undesired outcomes and tackles the problem of sparse rewards in Reinforcement Learning (RL).——Zhao, R., &amp; Tresp, V. (2018). Energy-Based Hindsight Experience Prioritization. <em>CoRL</em>.</p>\n</blockquote>\n<p>HER使智能体从没达到的结果中去学习，解决了强化学习中稀疏奖励的问题。</p>\n<h2 id=\"二分奖励-binary-reward\"><a href=\"#二分奖励-binary-reward\" class=\"headerlink\" title=\"二分奖励 binary reward\"></a>二分奖励 binary reward</h2><p>简言之，完成目标为一个值，没完成目标为另一个值。如：</p>\n<ul>\n<li>$S_{T}=Goal，r=0$</li>\n<li>$S\\neq Goal, r=-1. for \\ S \\in \\mathbb{S}$</li>\n</ul>\n<h2 id=\"稀疏奖励-sparse-reward\"><a href=\"#稀疏奖励-sparse-reward\" class=\"headerlink\" title=\"稀疏奖励 sparse reward\"></a>稀疏奖励 sparse reward</h2><p>简言之，完成目标的episode太少或者完成目标的步数太长，导致负奖励的样本数过多</p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>在机器人领域，要想使强化学习训练它完美执行某任务，往往需要设计合理的奖励函数，但是设计这样的奖励函数工程师不仅需要懂得强化学习的领域知识，也需要懂得机器人、运动学等领域的知识。而且，有这些知识也未必能设计出很好的奖励函数供智能体进行学习。因此，如果可以从简单的奖励函数（如二分奖励）学习到可完成任务的模型，那就不需要费心设计复杂的奖励函数了。</p>\n<p>文中介绍了一个例子来引入HER：</p>\n<ul>\n<li>名称：bit-flipping environment</li>\n<li>状态空间$\\mathcal{S}=\\left \\{ 0,1 \\right \\}^{n}$</li>\n<li>动作空间$\\mathcal{A}=\\left \\{ 0,1,\\cdots,n-1 \\right \\}$</li>\n<li>规则：对于每个episode，均匀采样长度为$n$的初始状态$s_{0}$（如$n=5，s_{0}=10101$）和目标状态$s_{g}$，每一步从动作空间中选取一个动作$a$，翻转$s_{0}$第$a$个位置的值，如$a=1\\Rightarrow s_{1}=11101$，直到回合结束或者翻转后的状态与$s_{g}$相同</li>\n<li>奖励函数：$r_{g}(s,a)=-\\left [ s \\neq g \\right ]$，即达到目标状态则为0，未达到目标状态则为-1。这个很容易理解，$s \\neq g \\Rightarrow true \\doteq 1，s = g \\Rightarrow false \\doteq 0$</li>\n</ul>\n<p><em>注：下文如无特殊说明，$g$即表示目标状态$s_{g}$</em></p>\n<blockquote>\n<p>Standard RL algorithms are bound to fail in this environment for n &gt; 40 because they will never experience any reward other than -1. Notice that using techniques for improving exploration (e.g. VIME (Houthooft et al., 2016), count-based exploration (Ostrovski et al., 2017) or bootstrapped DQN (Osband et al., 2016)) does not help here because the real problem is not in lack of diversity of states being visited, rather it is simply impractical to explore such a large state space.  </p>\n</blockquote>\n<p>当序列长度$n$大于40时，传统的强化学习算法就算有各种探索机制的加持，也不能学会解决这个问题，因为这个问题完全不是缺乏探索，而是<strong>状态太多，探索不完</strong>，导致奖励极其稀疏，算法根本不知道需要优化的目标在哪里。</p>\n<p>为了解决这个问题，作者指出了两个思路：</p>\n<ol>\n<li>使用shaped reward（简言之，将reward设计成某些变量的函数，如$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$，即奖励函数为当前状态与目标状态的欧氏距离的负数），将训练的算法逐步引导至奖励函数增大的决策空间。但是这种方法可能很难应用于复杂的问题中。</li>\n<li>使用HER——事后经验池机制</li>\n</ol>\n<h2 id=\"HER\"><a href=\"#HER\" class=\"headerlink\" title=\"HER\"></a>HER</h2><blockquote>\n<p>The pivotal idea behind our approach is to re-examine this trajectory with a different goal — while this trajectory may not help us learn how to achieve the state g, it definitely tells us something about how to achieve the state $s_{T}$ .</p>\n</blockquote>\n<p>HER的主要思想就是：<strong>为什么一定要考虑我们设定的目标呢？假设我们想让一个智能体学会移动到某个位置，它在一个episode中没有学到移动到目标位置就算失败吗？假定序列为$s_{0},s_{1},s_{2}, \\cdots ,s_{T}$，目标为$g$，我们何不换一种思路考虑：如果我们在episode开始前就将目标状态$g$设置为$s_{T}$，即$g=s_{T}$，那么这样看来智能体不就算是完成目标了吗？</strong></p>\n<p><img src=\"./Hindsight-Experience-Replay/Her.png\" alt=\"\"></p>\n<p>HER就是运用了这个思想对经验池进行了扩充，将稀疏奖励问题给转化成非稀疏奖励，大大的扩展了经验池中完成任务的经验数量。</p>\n<p>HER主要特点：</p>\n<ul>\n<li>传统经验池存入的是状态$s$，而HER存入的是$s||g$，也就是<code>tf.concat(s,g)</code></li>\n<li>训练算法的输入也是$s||g$，也就是需要在当前状态后边连结上<strong>每个episode的</strong>目标状态，每个episode的目标状态可能不同</li>\n<li>HER对经验池进行了扩充，不仅存入实际采样得到的transition/experience，$\\left ( s_{t}||g,a_{t},r_{t},s_{t+1}||g \\right )$，也要在回合结束时<strong>重新设置目标状态</strong>，得到相应的奖励值（在二分奖励问题中，只有在$s=g$时奖励才需要更改），存入“事后”（当初如果这样就好啦！）的经验$\\left ( s_{t}||g’,a_{t},r_{t}’,s_{t+1}||g’ \\right )$，详见伪代码，这个事后经验究竟存入多少份、多少种，由超参数$k$控制，下文讲解。</li>\n<li>HER更适合解决多目标问题，多目标的意思为，目标点非固定，每个episode的目标状态可以不相同。详见实验部分</li>\n</ul>\n<p>HER的几种扩展方式：</p>\n<blockquote>\n<p>future — replay with k random states which come from the same episode as the transition being replayed and were observed after it,<br>episode — replay with k random states coming from the same episode as the transition being replayed,<br>random — replay with k random states encountered so far in the whole training procedure.</p>\n</blockquote>\n<ul>\n<li>未来模式——future：在一个序列$s_{0},s_{1},s_{2},\\cdots,s_{T}$中，如果遍历到状态$s_{2}$，则在$s_{3},\\cdots,s_{T}$之间随机抽取$k$个状态作为目标状态$g’$，并依此向经验池中存入$\\left ( s_{2}||g’,a_{2},r_{2}’,s_{3}||g’ \\right )$，<strong>特点：一个episode的后续部分</strong></li>\n<li><p>回合模式——episode：在一个序列$s_{0},s_{1},s_{2},…,s_{T}$中，如果遍历到状态$s_{2}$，则在整个序列中随机抽取$k$个状态作为目标状态$g’$，并依此向经验池中存入$\\left ( s_{2}||g’,a_{2},r_{2}’,s_{3}||g’ \\right )$，<strong>特点：一个episode</strong></p>\n</li>\n<li><p>随机模式——random：在一个序列$s_{0},s_{1},s_{2},…,s_{T}$中，如果遍历到状态$s_{2}$，则在多个序列$\\tau_{0},\\tau_{1},\\tau_{2},\\cdots$中随机抽取$k$个状态作为目标状态$g’$，并依此向经验池中存入$\\left ( s_{2}||g’,a_{2},r_{2}’,s_{3}||g’ \\right )$，<strong>特点：多个episode</strong></p>\n</li>\n<li><p>最终模式——final：在一个序列$s_{0},s_{1},s_{2},\\cdots,s_{T}$中，如果遍历到状态$s_{2}$，则之间令$g’=s_{T}$，并向经验池中存入$\\left ( s_{2}||g’,a_{2},r_{2}’,s_{3}||g’ \\right )$，<strong>特点：一个episode的最后一个状态，如果设置k，则存入k个相同的经验</strong></p>\n</li>\n</ul>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./Hindsight-Experience-Replay/pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ol>\n<li>伪代码中没有提到超参数$k$，其实在循环条件$\\textbf{for} \\ g’ \\in G \\ \\textbf{do}$中循环执行了$k$次</li>\n<li>$||$操作为连结操作，简言之，将两个长度为5的向量合并成一个长度为10的向量</li>\n<li>$G:=\\mathbb{S}(\\textbf{current episode})$即为上文提到的四种扩展模式：future、episode、random、final。</li>\n<li>奖励函数$r(s,a,g)=-\\left [ f_{g}(s)=0 \\right ]$即为前文提到的$r_{g}(s,a)=-\\left [ s \\neq g \\right ]$，即完成为0，未完成为-1，具体奖励函数可以根据我们的使用环境设计</li>\n<li>$a_{t} \\leftarrow \\pi_{b}(s_{t}||g)$表示神经网络的输入为当前状态与目标状态的连结</li>\n</ol>\n<h2 id=\"HER的优点\"><a href=\"#HER的优点\" class=\"headerlink\" title=\"HER的优点\"></a>HER的优点</h2><ol>\n<li>可解决稀疏奖励、二分奖励问题</li>\n<li>可适用于所有的Off-Policy算法</li>\n<li>提升了数据采样效率</li>\n</ol>\n<h1 id=\"实验部分\"><a href=\"#实验部分\" class=\"headerlink\" title=\"实验部分\"></a>实验部分</h1><p>文中实验结果：<a href=\"https://goo.gl/SMrQnI\" rel=\"external nofollow\" target=\"_blank\">https://goo.gl/SMrQnI</a></p>\n<p>实验部分的完整细节请参考论文原文。</p>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><ul>\n<li>7自由度机械臂</li>\n<li>模拟环境：MuJoCo</li>\n<li>任务分为3种<ul>\n<li>Pushing，推：锁定机械臂的钳子，移动机械臂将物体推到目标点</li>\n<li>Sliding，滑动：类似于冰球运动，锁定机械臂的钳子，移动机械臂给与物体一个力，使物体可以在较光滑的桌面上滑动并且达到目标位置</li>\n<li>Pick-and-place，摆放：解锁钳子，使用机械臂夹起物体并移动至空中目标点</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"./Hindsight-Experience-Replay/tasks.png\" alt=\"\"></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><ul>\n<li>DDPG</li>\n<li>Adam优化器</li>\n<li>多层感知机MLPs</li>\n<li>ReLU激活函数</li>\n<li>8核并行，更新参数后取平均</li>\n<li>A-C网络都是3个隐藏层，每层64个隐节点，Actor输出层用tanh激活函数</li>\n<li>经验池大小为$10^{6}$，折扣因子$\\gamma=0.98$，学习率$\\alpha=0.001$，探索因子$\\epsilon = 0.2$</li>\n</ul>\n<blockquote>\n<p>With probability 20% we sample (uniformly) a random action from the hypercube of valid actions. </p>\n</blockquote>\n<p>DDPG使用了随机探索机制</p>\n<h2 id=\"训练结果\"><a href=\"#训练结果\" class=\"headerlink\" title=\"训练结果\"></a>训练结果</h2><h3 id=\"final模式与future模式对比\"><a href=\"#final模式与future模式对比\" class=\"headerlink\" title=\"final模式与future模式对比\"></a>final模式与future模式对比</h3><p><img src=\"./Hindsight-Experience-Replay/finalvsfuture.png\" alt=\"\"></p>\n<ul>\n<li>红色曲线为future模式，蓝色曲线为final模式，绿色曲线为使用了<a href=\"https://arxiv.org/pdf/1703.01310.pdf\" rel=\"external nofollow\" target=\"_blank\">count-based</a>的DDPG，褐红色虚线为原始DDPG</li>\n<li>从左至右依次是Pushing，Sliding，Pick-and-place任务</li>\n<li>超参数$k=4$</li>\n<li>这个实验中，目标状态会变，即为多个目标状态</li>\n</ul>\n<p>结果分析：</p>\n<ul>\n<li>future模式比final效果更好</li>\n<li>使用了count-based的DDPG智能稍微解决一下Sliding任务</li>\n<li>使用HER的DDPG可以完全胜任三个任务</li>\n<li>证明了HER是使从稀疏、二分奖励问题中学习成为可能的关键因素</li>\n</ul>\n<h3 id=\"单个目标状态的实验\"><a href=\"#单个目标状态的实验\" class=\"headerlink\" title=\"单个目标状态的实验\"></a>单个目标状态的实验</h3><p><img src=\"./Hindsight-Experience-Replay/singlegoal.png\" alt=\"\"></p>\n<ul>\n<li>蓝色曲线为使用了HER的DDPG，文中并未说明HER是哪种模式，<strong>猜测</strong>是final模式，因为文中实验部分之前都是以final模式进行举例</li>\n<li>绿色曲线代表应用了count-based的DDPG，褐红色虚线为原始DDPG</li>\n<li>实验中，目标状态都为同一状态$g$</li>\n</ul>\n<p>结果分析：</p>\n<ul>\n<li>DDPG+HER比原始DDPG的性能要好很多</li>\n<li><strong>相比于多个目标的实验，可以发现，在多目标的任务中DDPG训练更快</strong>，所以在实际中，即使我们只关心一个目标，我们最好也使用多个目标来训练</li>\n</ul>\n<h3 id=\"HER应用于reward-shaping问题中\"><a href=\"#HER应用于reward-shaping问题中\" class=\"headerlink\" title=\"HER应用于reward shaping问题中\"></a>HER应用于reward shaping问题中</h3><p>前文已经说过，reward shaping可以简单理解为将奖励函数设置为某些变量的函数，如$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$，即奖励函数为当前状态与目标状态的欧氏距离的负数</p>\n<p><img src=\"./Hindsight-Experience-Replay/rewardshape.png\" alt=\"\"></p>\n<ul>\n<li>奖励函数为$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$</li>\n</ul>\n<p>结果分析：</p>\n<ul>\n<li><p>无论使用怎样的reward shaping函数，DDPG、DDPG+HER都不能解决这个问题</p>\n</li>\n<li><p>作者认为原因有二：</p>\n<ul>\n<li><blockquote>\n<p>There is a huge discrepancy between what we optimize (i.e. a shaped reward function) and the success condition (i.e.: is the object within some radius from the goal at the end of the episode);  </p>\n</blockquote>\n<p>判定完成目标的条件和要优化的问题有巨大的矛盾（虽然我也不理解这到底是什么意思，索性就直接抄了过来）</p>\n</li>\n<li><blockquote>\n<p>Shaped rewards penalize for inappropriate behaviour (e.g. moving the box in a wrong direction) which may hinder exploration. It can cause the agent to learn not to touch the box at all if it can not manipulate it precisely and we noticed such behaviour in some of our experiments. </p>\n</blockquote>\n<p>reward shaping阻碍了探索</p>\n</li>\n</ul>\n</li>\n<li><blockquote>\n<p>Our results suggest that domain-agnostic reward shaping does not work well (at least in the simple forms we have tried). Of course for every problem there exists a reward which makes it easy (Ng et al., 1999) but designing such shaped rewards requires a lot of domain knowledge and may in some cases not be much easier than directly scripting the policy. This strengthens our belief that learning from sparse, binary rewards is an important problem. </p>\n</blockquote>\n<p>研究结果表明，与领域无关的reward shaping效果并不好</p>\n</li>\n</ul>\n<h3 id=\"四种模式比较\"><a href=\"#四种模式比较\" class=\"headerlink\" title=\"四种模式比较\"></a>四种模式比较</h3><p><img src=\"./Hindsight-Experience-Replay/fourmodel.png\" alt=\"\"></p>\n<ul>\n<li>红色代表future模式，蓝色代表final模式，绿色代表episode模式，紫色代表episode模式，褐红色虚线代表原始DDPG</li>\n<li>横坐标代表超参数$k$，第一行三个图的纵坐标代表最高得分，第二行三个图的纵坐标代表平均得分</li>\n</ul>\n<p>结果分析：</p>\n<ul>\n<li><p>效果：future&gt;final&gt;episode&gt;random&gt;no HER</p>\n</li>\n<li><p>稳定性：final(好)=no-HER(差)&gt;future&gt;episode&gt;random</p>\n</li>\n<li><p>future模式是唯一一个可以解决Sliding任务的，在$k=4$或者$k=8$时效果最好</p>\n</li>\n<li><p>增大$k$超过8会使性能有所下降，主要是因为$k$过大导致经验池中原始真实数据所占的比例太小</p>\n</li>\n<li><blockquote>\n<p>It confirms that the most valuable goals for replay are the ones which are going to be achieved in the near future </p>\n</blockquote>\n<p>它证实了回放经验中最有价值的目标是那些在不久的将来能实现的目标</p>\n</li>\n</ul>\n<p><em>注：作者根据 future 模式提出了最近邻的 future 模式，即把$g’$设置为$s_{t+1}$，并且进行了实验，实验结果不如 future 模式。</em></p>\n","site":{"data":{}},"excerpt":"<p>本文介绍了一个“事后诸葛亮”的经验池机制，简称为<strong>HER</strong>，它可以很好地应用于<strong>稀疏奖励</strong>和<strong>二分奖励</strong>的问题中，不需要复杂的奖励函数工程设计。</p>\n<p>推荐：</p>\n<ul>\n<li>稀疏奖励问题的一种解决方案</li>\n<li>通俗易懂</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://papers.nips.cc/paper/7090-hindsight-experience-replay.pdf\" rel=\"external nofollow\" target=\"_blank\">https://papers.nips.cc/paper/7090-hindsight-experience-replay.pdf</a></p>\n<blockquote>\n<p>Dealing with sparse rewards is one of the biggest challenges in Reinforcement Learning (RL).  </p>\n</blockquote>\n<p>强化学习问题中最棘手的问题之一就是稀疏奖励。</p>\n<p>本文提出了一个新颖的技术：Hindsight Experience Replay（HER），可以从稀疏、二分的奖励问题中高效采样并进行学习，而且可以应用于<strong>所有的Off-Policy</strong>算法中。</p>\n<p><img src=\"./Hindsight-Experience-Replay/hindsight.png\" alt=\"\"></p>\n<p>Hindsight意为事后，结合强化学习中序贯决策问题的特性，我们很容易就可以猜想到，“事后”要不然指的是在状态s下执行动作a之后，要不然指的就是当一个episode结束之后。其实，文中对常规经验池的改进也正是运用了这样的含义。</p>\n<blockquote>\n<p>HER lets an agent learn from undesired outcomes and tackles the problem of sparse rewards in Reinforcement Learning (RL).——Zhao, R., &amp; Tresp, V. (2018). Energy-Based Hindsight Experience Prioritization. <em>CoRL</em>.</p>\n</blockquote>\n<p>HER使智能体从没达到的结果中去学习，解决了强化学习中稀疏奖励的问题。</p>\n<h2 id=\"二分奖励-binary-reward\"><a href=\"#二分奖励-binary-reward\" class=\"headerlink\" title=\"二分奖励 binary reward\"></a>二分奖励 binary reward</h2><p>简言之，完成目标为一个值，没完成目标为另一个值。如：</p>\n<ul>\n<li>$S_{T}=Goal，r=0$</li>\n<li>$S\\neq Goal, r=-1. for \\ S \\in \\mathbb{S}$</li>\n</ul>\n<h2 id=\"稀疏奖励-sparse-reward\"><a href=\"#稀疏奖励-sparse-reward\" class=\"headerlink\" title=\"稀疏奖励 sparse reward\"></a>稀疏奖励 sparse reward</h2><p>简言之，完成目标的episode太少或者完成目标的步数太长，导致负奖励的样本数过多</p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>在机器人领域，要想使强化学习训练它完美执行某任务，往往需要设计合理的奖励函数，但是设计这样的奖励函数工程师不仅需要懂得强化学习的领域知识，也需要懂得机器人、运动学等领域的知识。而且，有这些知识也未必能设计出很好的奖励函数供智能体进行学习。因此，如果可以从简单的奖励函数（如二分奖励）学习到可完成任务的模型，那就不需要费心设计复杂的奖励函数了。</p>\n<p>文中介绍了一个例子来引入HER：</p>\n<ul>\n<li>名称：bit-flipping environment</li>\n<li>状态空间$\\mathcal{S}=\\left \\{ 0,1 \\right \\}^{n}$</li>\n<li>动作空间$\\mathcal{A}=\\left \\{ 0,1,\\cdots,n-1 \\right \\}$</li>\n<li>规则：对于每个episode，均匀采样长度为$n$的初始状态$s_{0}$（如$n=5，s_{0}=10101$）和目标状态$s_{g}$，每一步从动作空间中选取一个动作$a$，翻转$s_{0}$第$a$个位置的值，如$a=1\\Rightarrow s_{1}=11101$，直到回合结束或者翻转后的状态与$s_{g}$相同</li>\n<li>奖励函数：$r_{g}(s,a)=-\\left [ s \\neq g \\right ]$，即达到目标状态则为0，未达到目标状态则为-1。这个很容易理解，$s \\neq g \\Rightarrow true \\doteq 1，s = g \\Rightarrow false \\doteq 0$</li>\n</ul>\n<p><em>注：下文如无特殊说明，$g$即表示目标状态$s_{g}$</em></p>\n<blockquote>\n<p>Standard RL algorithms are bound to fail in this environment for n &gt; 40 because they will never experience any reward other than -1. Notice that using techniques for improving exploration (e.g. VIME (Houthooft et al., 2016), count-based exploration (Ostrovski et al., 2017) or bootstrapped DQN (Osband et al., 2016)) does not help here because the real problem is not in lack of diversity of states being visited, rather it is simply impractical to explore such a large state space.  </p>\n</blockquote>\n<p>当序列长度$n$大于40时，传统的强化学习算法就算有各种探索机制的加持，也不能学会解决这个问题，因为这个问题完全不是缺乏探索，而是<strong>状态太多，探索不完</strong>，导致奖励极其稀疏，算法根本不知道需要优化的目标在哪里。</p>\n<p>为了解决这个问题，作者指出了两个思路：</p>\n<ol>\n<li>使用shaped reward（简言之，将reward设计成某些变量的函数，如$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$，即奖励函数为当前状态与目标状态的欧氏距离的负数），将训练的算法逐步引导至奖励函数增大的决策空间。但是这种方法可能很难应用于复杂的问题中。</li>\n<li>使用HER——事后经验池机制</li>\n</ol>\n<h2 id=\"HER\"><a href=\"#HER\" class=\"headerlink\" title=\"HER\"></a>HER</h2><blockquote>\n<p>The pivotal idea behind our approach is to re-examine this trajectory with a different goal — while this trajectory may not help us learn how to achieve the state g, it definitely tells us something about how to achieve the state $s_{T}$ .</p>\n</blockquote>\n<p>HER的主要思想就是：<strong>为什么一定要考虑我们设定的目标呢？假设我们想让一个智能体学会移动到某个位置，它在一个episode中没有学到移动到目标位置就算失败吗？假定序列为$s_{0},s_{1},s_{2}, \\cdots ,s_{T}$，目标为$g$，我们何不换一种思路考虑：如果我们在episode开始前就将目标状态$g$设置为$s_{T}$，即$g=s_{T}$，那么这样看来智能体不就算是完成目标了吗？</strong></p>\n<p><img src=\"./Hindsight-Experience-Replay/Her.png\" alt=\"\"></p>\n<p>HER就是运用了这个思想对经验池进行了扩充，将稀疏奖励问题给转化成非稀疏奖励，大大的扩展了经验池中完成任务的经验数量。</p>\n<p>HER主要特点：</p>\n<ul>\n<li>传统经验池存入的是状态$s$，而HER存入的是$s||g$，也就是<code>tf.concat(s,g)</code></li>\n<li>训练算法的输入也是$s||g$，也就是需要在当前状态后边连结上<strong>每个episode的</strong>目标状态，每个episode的目标状态可能不同</li>\n<li>HER对经验池进行了扩充，不仅存入实际采样得到的transition/experience，$\\left ( s_{t}||g,a_{t},r_{t},s_{t+1}||g \\right )$，也要在回合结束时<strong>重新设置目标状态</strong>，得到相应的奖励值（在二分奖励问题中，只有在$s=g$时奖励才需要更改），存入“事后”（当初如果这样就好啦！）的经验$\\left ( s_{t}||g’,a_{t},r_{t}’,s_{t+1}||g’ \\right )$，详见伪代码，这个事后经验究竟存入多少份、多少种，由超参数$k$控制，下文讲解。</li>\n<li>HER更适合解决多目标问题，多目标的意思为，目标点非固定，每个episode的目标状态可以不相同。详见实验部分</li>\n</ul>\n<p>HER的几种扩展方式：</p>\n<blockquote>\n<p>future — replay with k random states which come from the same episode as the transition being replayed and were observed after it,<br>episode — replay with k random states coming from the same episode as the transition being replayed,<br>random — replay with k random states encountered so far in the whole training procedure.</p>\n</blockquote>\n<ul>\n<li>未来模式——future：在一个序列$s_{0},s_{1},s_{2},\\cdots,s_{T}$中，如果遍历到状态$s_{2}$，则在$s_{3},\\cdots,s_{T}$之间随机抽取$k$个状态作为目标状态$g’$，并依此向经验池中存入$\\left ( s_{2}||g’,a_{2},r_{2}’,s_{3}||g’ \\right )$，<strong>特点：一个episode的后续部分</strong></li>\n<li><p>回合模式——episode：在一个序列$s_{0},s_{1},s_{2},…,s_{T}$中，如果遍历到状态$s_{2}$，则在整个序列中随机抽取$k$个状态作为目标状态$g’$，并依此向经验池中存入$\\left ( s_{2}||g’,a_{2},r_{2}’,s_{3}||g’ \\right )$，<strong>特点：一个episode</strong></p>\n</li>\n<li><p>随机模式——random：在一个序列$s_{0},s_{1},s_{2},…,s_{T}$中，如果遍历到状态$s_{2}$，则在多个序列$\\tau_{0},\\tau_{1},\\tau_{2},\\cdots$中随机抽取$k$个状态作为目标状态$g’$，并依此向经验池中存入$\\left ( s_{2}||g’,a_{2},r_{2}’,s_{3}||g’ \\right )$，<strong>特点：多个episode</strong></p>\n</li>\n<li><p>最终模式——final：在一个序列$s_{0},s_{1},s_{2},\\cdots,s_{T}$中，如果遍历到状态$s_{2}$，则之间令$g’=s_{T}$，并向经验池中存入$\\left ( s_{2}||g’,a_{2},r_{2}’,s_{3}||g’ \\right )$，<strong>特点：一个episode的最后一个状态，如果设置k，则存入k个相同的经验</strong></p>\n</li>\n</ul>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./Hindsight-Experience-Replay/pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ol>\n<li>伪代码中没有提到超参数$k$，其实在循环条件$\\textbf{for} \\ g’ \\in G \\ \\textbf{do}$中循环执行了$k$次</li>\n<li>$||$操作为连结操作，简言之，将两个长度为5的向量合并成一个长度为10的向量</li>\n<li>$G:=\\mathbb{S}(\\textbf{current episode})$即为上文提到的四种扩展模式：future、episode、random、final。</li>\n<li>奖励函数$r(s,a,g)=-\\left [ f_{g}(s)=0 \\right ]$即为前文提到的$r_{g}(s,a)=-\\left [ s \\neq g \\right ]$，即完成为0，未完成为-1，具体奖励函数可以根据我们的使用环境设计</li>\n<li>$a_{t} \\leftarrow \\pi_{b}(s_{t}||g)$表示神经网络的输入为当前状态与目标状态的连结</li>\n</ol>\n<h2 id=\"HER的优点\"><a href=\"#HER的优点\" class=\"headerlink\" title=\"HER的优点\"></a>HER的优点</h2><ol>\n<li>可解决稀疏奖励、二分奖励问题</li>\n<li>可适用于所有的Off-Policy算法</li>\n<li>提升了数据采样效率</li>\n</ol>\n<h1 id=\"实验部分\"><a href=\"#实验部分\" class=\"headerlink\" title=\"实验部分\"></a>实验部分</h1><p>文中实验结果：<a href=\"https://goo.gl/SMrQnI\" rel=\"external nofollow\" target=\"_blank\">https://goo.gl/SMrQnI</a></p>\n<p>实验部分的完整细节请参考论文原文。</p>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><ul>\n<li>7自由度机械臂</li>\n<li>模拟环境：MuJoCo</li>\n<li>任务分为3种<ul>\n<li>Pushing，推：锁定机械臂的钳子，移动机械臂将物体推到目标点</li>\n<li>Sliding，滑动：类似于冰球运动，锁定机械臂的钳子，移动机械臂给与物体一个力，使物体可以在较光滑的桌面上滑动并且达到目标位置</li>\n<li>Pick-and-place，摆放：解锁钳子，使用机械臂夹起物体并移动至空中目标点</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"./Hindsight-Experience-Replay/tasks.png\" alt=\"\"></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><ul>\n<li>DDPG</li>\n<li>Adam优化器</li>\n<li>多层感知机MLPs</li>\n<li>ReLU激活函数</li>\n<li>8核并行，更新参数后取平均</li>\n<li>A-C网络都是3个隐藏层，每层64个隐节点，Actor输出层用tanh激活函数</li>\n<li>经验池大小为$10^{6}$，折扣因子$\\gamma=0.98$，学习率$\\alpha=0.001$，探索因子$\\epsilon = 0.2$</li>\n</ul>\n<blockquote>\n<p>With probability 20% we sample (uniformly) a random action from the hypercube of valid actions. </p>\n</blockquote>\n<p>DDPG使用了随机探索机制</p>\n<h2 id=\"训练结果\"><a href=\"#训练结果\" class=\"headerlink\" title=\"训练结果\"></a>训练结果</h2><h3 id=\"final模式与future模式对比\"><a href=\"#final模式与future模式对比\" class=\"headerlink\" title=\"final模式与future模式对比\"></a>final模式与future模式对比</h3><p><img src=\"./Hindsight-Experience-Replay/finalvsfuture.png\" alt=\"\"></p>\n<ul>\n<li>红色曲线为future模式，蓝色曲线为final模式，绿色曲线为使用了<a href=\"https://arxiv.org/pdf/1703.01310.pdf\" rel=\"external nofollow\" target=\"_blank\">count-based</a>的DDPG，褐红色虚线为原始DDPG</li>\n<li>从左至右依次是Pushing，Sliding，Pick-and-place任务</li>\n<li>超参数$k=4$</li>\n<li>这个实验中，目标状态会变，即为多个目标状态</li>\n</ul>\n<p>结果分析：</p>\n<ul>\n<li>future模式比final效果更好</li>\n<li>使用了count-based的DDPG智能稍微解决一下Sliding任务</li>\n<li>使用HER的DDPG可以完全胜任三个任务</li>\n<li>证明了HER是使从稀疏、二分奖励问题中学习成为可能的关键因素</li>\n</ul>\n<h3 id=\"单个目标状态的实验\"><a href=\"#单个目标状态的实验\" class=\"headerlink\" title=\"单个目标状态的实验\"></a>单个目标状态的实验</h3><p><img src=\"./Hindsight-Experience-Replay/singlegoal.png\" alt=\"\"></p>\n<ul>\n<li>蓝色曲线为使用了HER的DDPG，文中并未说明HER是哪种模式，<strong>猜测</strong>是final模式，因为文中实验部分之前都是以final模式进行举例</li>\n<li>绿色曲线代表应用了count-based的DDPG，褐红色虚线为原始DDPG</li>\n<li>实验中，目标状态都为同一状态$g$</li>\n</ul>\n<p>结果分析：</p>\n<ul>\n<li>DDPG+HER比原始DDPG的性能要好很多</li>\n<li><strong>相比于多个目标的实验，可以发现，在多目标的任务中DDPG训练更快</strong>，所以在实际中，即使我们只关心一个目标，我们最好也使用多个目标来训练</li>\n</ul>\n<h3 id=\"HER应用于reward-shaping问题中\"><a href=\"#HER应用于reward-shaping问题中\" class=\"headerlink\" title=\"HER应用于reward shaping问题中\"></a>HER应用于reward shaping问题中</h3><p>前文已经说过，reward shaping可以简单理解为将奖励函数设置为某些变量的函数，如$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$，即奖励函数为当前状态与目标状态的欧氏距离的负数</p>\n<p><img src=\"./Hindsight-Experience-Replay/rewardshape.png\" alt=\"\"></p>\n<ul>\n<li>奖励函数为$r_{g}(s,a)=-\\left || s-g \\right ||^{2}$</li>\n</ul>\n<p>结果分析：</p>\n<ul>\n<li><p>无论使用怎样的reward shaping函数，DDPG、DDPG+HER都不能解决这个问题</p>\n</li>\n<li><p>作者认为原因有二：</p>\n<ul>\n<li><blockquote>\n<p>There is a huge discrepancy between what we optimize (i.e. a shaped reward function) and the success condition (i.e.: is the object within some radius from the goal at the end of the episode);  </p>\n</blockquote>\n<p>判定完成目标的条件和要优化的问题有巨大的矛盾（虽然我也不理解这到底是什么意思，索性就直接抄了过来）</p>\n</li>\n<li><blockquote>\n<p>Shaped rewards penalize for inappropriate behaviour (e.g. moving the box in a wrong direction) which may hinder exploration. It can cause the agent to learn not to touch the box at all if it can not manipulate it precisely and we noticed such behaviour in some of our experiments. </p>\n</blockquote>\n<p>reward shaping阻碍了探索</p>\n</li>\n</ul>\n</li>\n<li><blockquote>\n<p>Our results suggest that domain-agnostic reward shaping does not work well (at least in the simple forms we have tried). Of course for every problem there exists a reward which makes it easy (Ng et al., 1999) but designing such shaped rewards requires a lot of domain knowledge and may in some cases not be much easier than directly scripting the policy. This strengthens our belief that learning from sparse, binary rewards is an important problem. </p>\n</blockquote>\n<p>研究结果表明，与领域无关的reward shaping效果并不好</p>\n</li>\n</ul>\n<h3 id=\"四种模式比较\"><a href=\"#四种模式比较\" class=\"headerlink\" title=\"四种模式比较\"></a>四种模式比较</h3><p><img src=\"./Hindsight-Experience-Replay/fourmodel.png\" alt=\"\"></p>\n<ul>\n<li>红色代表future模式，蓝色代表final模式，绿色代表episode模式，紫色代表episode模式，褐红色虚线代表原始DDPG</li>\n<li>横坐标代表超参数$k$，第一行三个图的纵坐标代表最高得分，第二行三个图的纵坐标代表平均得分</li>\n</ul>\n<p>结果分析：</p>\n<ul>\n<li><p>效果：future&gt;final&gt;episode&gt;random&gt;no HER</p>\n</li>\n<li><p>稳定性：final(好)=no-HER(差)&gt;future&gt;episode&gt;random</p>\n</li>\n<li><p>future模式是唯一一个可以解决Sliding任务的，在$k=4$或者$k=8$时效果最好</p>\n</li>\n<li><p>增大$k$超过8会使性能有所下降，主要是因为$k$过大导致经验池中原始真实数据所占的比例太小</p>\n</li>\n<li><blockquote>\n<p>It confirms that the most valuable goals for replay are the ones which are going to be achieved in the near future </p>\n</blockquote>\n<p>它证实了回放经验中最有价值的目标是那些在不久的将来能实现的目标</p>\n</li>\n</ul>\n<p><em>注：作者根据 future 模式提出了最近邻的 future 模式，即把$g’$设置为$s_{t+1}$，并且进行了实验，实验结果不如 future 模式。</em></p>"},{"title":"Asynchronous Methods for Deep Reinforcement Learning","copyright":true,"mathjax":true,"top":1,"date":"2019-05-30T07:22:13.000Z","keywords":null,"description":null,"_content":"\n本文提出了A3C模型，即Asynchronous Advantage Actor-Critic，是A2C的异步版本，使用CPU多核而不用GPU进行训练，文中说效果比使用GPU反而更好。\n\n推荐：\n\n- 并行梯度优化的佳作\n- 通俗易懂\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1602.01783.pdf](https://arxiv.org/pdf/1602.01783.pdf)\n\n本文提出了一个概念简单、异步梯度优化的轻量级深度强化学习训练框架。提出该框架的初衷是占用少的资源稳定深度神经网络的学习。\n\n该框架可适用于：\n\n- 基于值与基于策略的方法\n- on-policy与off-policy的方法\n- 离散与连续问题\n\n效果：\n\n- 稳定训练\n- 在Atari游戏上使用DQN算法，一个16核CPU比Nvidia K40 GPU快，使用A3C算法可以快一倍\n- 成功适用于很多连续运动学控制问题，例如图像输入的3D迷宫\n\n> the sequence of observed data encountered by an online RL agent is non-stationary, and on-line RL updates are strongly correlated. By storing the agent’s data in an experience replay memory, the data can be batched or randomly sampled from different time-steps. Aggregating over memory in this way reduces non-stationarity and decorrelates updates, but at the same time limits the methods to off-policy reinforcement learning algorithms \n\n文中指出，on-policy方法训练不稳定，数据相关性很强，off-policy机制结合经验池机制减轻了训练的不稳定性和数据相关性。\n\n经验池的缺点：\n\n1. 占用内存，增加计算量\n2. 需要off-policy算法\n\n本文为深度强化学习提供了一个非常不同的范例，不使用经验池机制，而使用异步并行的方法在多个**相同环境**中执行多个智能体。（同时训练多个不同环境没有进行描述和实验）\n\n这种异步并行方式的优点是：\n\n1. 实现减轻数据相关性的效果，使训练稳定\n2. 可用于大范围on-policy算法，如Sarsa，n-step方法，A-C方法，也可用于off-policy方法，如Q-learning\n3. 利用深度神经网络设计算法，保持鲁棒性与有效性（不予置评）\n4. 不使用GPU，只使用多核CPU，反而训练时间短\n5. 比大规模分布式需要更少的资源占用（内存、算力等）\n6. **相比于[Gorila](https://arxiv.org/pdf/1507.04296.pdf)异步训练方式，本文中的训练方式不需要中心服务器，其使用的是共享内存模式**\n7. 单机运行减少了通信（梯度和超参数）的开销\n\n# 文中精要\n\n由于本文思想非常简单，所以精简描述论文精华\n\n本文使用**[Hogwild!](https://arxiv.org/pdf/1106.5730.pdf)**方式进行异步梯度下降\n\nHogwild! 这个方法的提出也很偶然，容我步步道来：\n\n我们使用函数对样本集进行拟合如下图所示\n\n![](./asynchronous-methods-for-drl/regression.png)\n\n当我们想要判断函数是否拟合的不错，我们往往使用损失函数来衡量，损失越小，则代表函数拟合得越好（但，过拟合不是我们想要的）。\n\n![](./asynchronous-methods-for-drl/lossfunction.png)\n\n为了减小损失，我们常用梯度下降算法来优化。标准的梯度下降原理如下图所示，如果函数为凸函数，且更新步长很小，那么在有限步长内总可以下降至函数最小点，即，获得使损失函数最小的参数$\\theta^{\\ast}$\n\n![](./asynchronous-methods-for-drl/gd.png)\n\n之后出现了SGD，也就是随机梯度下降，这种方法差不多在60年代提出，由于思想过于简单，迭代次数很长，一直不被主流优化算法接受。但是，当大数据时代到来时，SGD变成了很普遍的优化方法。\n\nSGD的算法流程如下：\n\n- 选一个初始参数向量$\\theta$和正步长$\\alpha$\n- 循环直到满足结束条件：\n  - 从训练集中随机选择一个样本$x_{i}$\n  - 更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$\n\nSGD的优点：\n\n1. 少内存占用。SGD不需要所有的样本集进行计算梯度，只需要从样本集中抽取一个样本进行训练。频繁的采样操作可以使用高速缓存来加速训练。\n2. 收敛至**可接受的解**速度很快。其实我们不希望看到过拟合，当然也不希望看到欠拟合，SGD正好是这两个极端的trade-off。SGD可以很快的收敛到一个较好的解，相对于样本集较好的解比相对于样本集最好的解的泛化能力可要强得多。下图展示了SGD与标准梯度下降的损失函数曲线比较。\n\n![](./asynchronous-methods-for-drl/sgdvsgd.png)\n\n看图像可能会觉得SGD并没有严格下降，有时会有损失上升的倾向，但是，总体来看，这种方法最终也是可以收敛到最小值的。总体上，它使损失进行了下降。\n\n对于熟悉并行编程的人来说，如果让他们设计并行随机梯度下降，他们一定会像这样设计：\n\n- 每个线程从训练集随机抽取一个样本$x_{i}$\n  - 锁参数$\\theta$\n  - 线程读参数$\\theta$\n  - 线程更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$\n  - 解锁\n\n更新前锁定参数，更新后解锁参数。对于许多问题，更新这一步骤耗时在微秒级，而锁参数耗时在毫秒级，这意味着锁参数要比更新多占用1000多倍的时间。虽然有一些其他方法可以对该过程进行优化，但差距还是很明显。\n\n如果，**注释掉关于锁的代码呢？**这真是一个大胆的想法，但是Hogwild!就是这么做的。（这都是一个叫Feng Niu的人搞出来的，不知是出于好奇还是在Debug，他在研究加速SGD的时候注释掉了锁的代码，算法不仅有效，还提升了一百多倍。所以说，多试试总是好的。。。）流程如下：\n\n- 每个线程从训练集随机抽取一个样本$x_{i}$\n  - ~~锁参数$\\theta $~~​\n  - 线程读参数$\\theta$\n  - 线程更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$\n  - ~~解锁~~\n\n> In a sentence, the main idea of Hogwild! is — “**Remove all thread locks from parallel SGD code**.” In Hogwild!, threads can overwrite each other by writing at the same time and compute gradients using a stale version of the “current solution.” \n\n我们不禁都有一个疑问，这么做，真的可以吗？还真别说，经过实验表明，该方法取得了多线程的益处却没有数学效率上的负面影响。\n\n本文中的异步更新就是用这种方法，唯一有问题的可能就是两个线程同写，但是即便是同写，写入还是有先后的，最多也就是把前一个线程写入的给覆盖掉，丢弃一个线程的数据更新而已，无伤大雅，至于多个线程写后读、读后写倒都没有大的影响，不影响参数更新与收敛。\n\n## 伪代码\n\n**本文中所有伪代码都使用Hogwild!方式进行梯度更新。**\n\n以下伪代码都是单个线程中actor-learning的操作。每个线程中的actor可以使用不同的探索机制，实验证明不同的探索机制可以提高算法的鲁棒性和性能效果。\n\n首先介绍异步one-step Q-Learning的训练模式\n\n![](./asynchronous-methods-for-drl/a1stepq.png)\n\n解析：\n\n- 相比后两个伪代码，该代码中各线程是不需要复制用于选择动作的训练网络（因为各方对target network的定义不同，有些人认为等待赋值的是目标网络，有些人认为需要训练的是目标网络，因此，此处不使用目标网络的术语）的，即每次选择动作，都使用其他线程可能更新过的Q网络进行决策。这是因为不需要使用同一个决策模型向后看多步\n- $\\theta$是动态变化的，即在该线程的训练过程中，其他线程也可能对参数$\\theta$进行了更新\n- $I_{target}$代表双Q学习赋值的间隔\n- $I_{AsyncUpdate}$代表单线程对共享参数$\\theta$更新的间隔\n\n---\n\n接下来是异步n-step Q-Learning的训练模式：\n\n相比于n-step，one-step方法中获得的立即奖励$r$只影响导致其产生的$Q(s,a)$，从而通过$Q(s,a)$间接影响其他的动作值，这会使训练过程很慢，因为需要多次更新才能将奖励传播到前面的相关状态和动作。使奖励传播更快的一个方法就是使用n-step回报。\n$$\nG_{t}=r_{t}+\\gamma r_{t+1}+\\cdots+\\gamma^{n-1} r_{t+n-1}+\\max _{a} \\gamma^{n} Q\\left(s_{t+n}, a\\right)\n$$\n![](./asynchronous-methods-for-drl/anstepq.png)\n\n解析：\n\n- 相比于one-step，该算法为每个线程配置了一个备份网络$\\color{red}{\\theta'}$\n- $t_{max}$为n-step中的$n$\n\n---\n\n最后是异步A2C，即A3C的训练模式：\n\n![](./asynchronous-methods-for-drl/a3c.png)\n\n解析：\n\n- $t_{max}$为n-step向前看的步数\n- 文中针对该模型将A-C网络架构共享了部分神经网络参数，并且对actor网络的损失函数公式进行了改造：$\\nabla_{\\theta^{\\prime}} \\log \\pi\\left(a_{t} | s_{t} ; \\theta^{\\prime}\\right)\\left(R_{t}-V\\left(s_{t} ; \\theta_{v}\\right)\\right)+\\color{red}{\\beta \\nabla_{\\theta^{\\prime}} H\\left(\\pi\\left(s_{t} ; \\theta^{\\prime}\\right)\\right)}$，即添加了熵正则化项，它的作用是增加探索，避免网络过早地收敛至局部最优，$\\beta$为超参数\n\n正态分布的熵可以表示为$-\\frac{1}{2}\\left(\\log \\left(2 \\pi \\sigma^{2}\\right)+1\\right)$\n\n# 实验部分\n\n实验结果视频：\n\n- [TORCS A3C训练驾驶汽车](https://youtu.be/0xo1Ldx3L5Q)\n- [MuJoco 一些训练效果](https://youtu.be/Ajjc08-iPx8)\n- [Labyrinth 3D迷宫](https://youtu.be/nMR5mjCFZCw)\n\nAtari 2600 实验结果：\n\n![](./asynchronous-methods-for-drl/table1.png)\n\n不同线程数的加速效果：\n\n![](./asynchronous-methods-for-drl/table2.png)\n\n文中比较了三种优化函数的性能，分别是：\n\n- 动量SGD，Momentum SGD\n- RMSProp\n- Shared RMSProp\n\nRMSProp是这样更新的：\n$$\ng=\\alpha g+(1-\\alpha) \\Delta \\theta^{2}\n$$\n\n$$\n\\theta \\leftarrow \\theta-\\eta \\frac{\\Delta \\theta}{\\sqrt{g+\\epsilon}}\n$$\n\n$\\eta$为学习率，$\\alpha$为RMSProp折扣因子\n\nRMSProp与Shared RMSProp的差别就是：\n\n- Shared RMSProp各线程共享参数$g$，且无锁异步更新\n- RMSProp各线程独立一个参数$g$\n\n实验结果如下：\n\n测试每种算法50次试验，得分从高到低排列，算法为n-step Q-Learning和A3C\n\n**综合来看，三种优化方式效果差别不大，但是Shared RMSProp>RMSProp>Momentum SGD**\n\n![](./asynchronous-methods-for-drl/threeoptimizer.png)\n\n---\n\n实验结果太多，懒得贴了，总之，这种异步框架方法的优点是：\n\n- 使用离线在线策略，基于值基于策略方法，离散连续问题\n- 稳定训练\n- 加速训练\n- 比经验池少消耗资源\n\n# 引用\n\n> [Parallel Machine Learning with Hogwild!](https://medium.com/@krishna_srd/parallel-machine-learning-with-hogwild-f945ad7e48a4)","source":"_posts/asynchronous-methods-for-drl.md","raw":"---\ntitle: Asynchronous Methods for Deep Reinforcement Learning\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2019-05-30 15:22:13\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n本文提出了A3C模型，即Asynchronous Advantage Actor-Critic，是A2C的异步版本，使用CPU多核而不用GPU进行训练，文中说效果比使用GPU反而更好。\n\n推荐：\n\n- 并行梯度优化的佳作\n- 通俗易懂\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1602.01783.pdf](https://arxiv.org/pdf/1602.01783.pdf)\n\n本文提出了一个概念简单、异步梯度优化的轻量级深度强化学习训练框架。提出该框架的初衷是占用少的资源稳定深度神经网络的学习。\n\n该框架可适用于：\n\n- 基于值与基于策略的方法\n- on-policy与off-policy的方法\n- 离散与连续问题\n\n效果：\n\n- 稳定训练\n- 在Atari游戏上使用DQN算法，一个16核CPU比Nvidia K40 GPU快，使用A3C算法可以快一倍\n- 成功适用于很多连续运动学控制问题，例如图像输入的3D迷宫\n\n> the sequence of observed data encountered by an online RL agent is non-stationary, and on-line RL updates are strongly correlated. By storing the agent’s data in an experience replay memory, the data can be batched or randomly sampled from different time-steps. Aggregating over memory in this way reduces non-stationarity and decorrelates updates, but at the same time limits the methods to off-policy reinforcement learning algorithms \n\n文中指出，on-policy方法训练不稳定，数据相关性很强，off-policy机制结合经验池机制减轻了训练的不稳定性和数据相关性。\n\n经验池的缺点：\n\n1. 占用内存，增加计算量\n2. 需要off-policy算法\n\n本文为深度强化学习提供了一个非常不同的范例，不使用经验池机制，而使用异步并行的方法在多个**相同环境**中执行多个智能体。（同时训练多个不同环境没有进行描述和实验）\n\n这种异步并行方式的优点是：\n\n1. 实现减轻数据相关性的效果，使训练稳定\n2. 可用于大范围on-policy算法，如Sarsa，n-step方法，A-C方法，也可用于off-policy方法，如Q-learning\n3. 利用深度神经网络设计算法，保持鲁棒性与有效性（不予置评）\n4. 不使用GPU，只使用多核CPU，反而训练时间短\n5. 比大规模分布式需要更少的资源占用（内存、算力等）\n6. **相比于[Gorila](https://arxiv.org/pdf/1507.04296.pdf)异步训练方式，本文中的训练方式不需要中心服务器，其使用的是共享内存模式**\n7. 单机运行减少了通信（梯度和超参数）的开销\n\n# 文中精要\n\n由于本文思想非常简单，所以精简描述论文精华\n\n本文使用**[Hogwild!](https://arxiv.org/pdf/1106.5730.pdf)**方式进行异步梯度下降\n\nHogwild! 这个方法的提出也很偶然，容我步步道来：\n\n我们使用函数对样本集进行拟合如下图所示\n\n![](./asynchronous-methods-for-drl/regression.png)\n\n当我们想要判断函数是否拟合的不错，我们往往使用损失函数来衡量，损失越小，则代表函数拟合得越好（但，过拟合不是我们想要的）。\n\n![](./asynchronous-methods-for-drl/lossfunction.png)\n\n为了减小损失，我们常用梯度下降算法来优化。标准的梯度下降原理如下图所示，如果函数为凸函数，且更新步长很小，那么在有限步长内总可以下降至函数最小点，即，获得使损失函数最小的参数$\\theta^{\\ast}$\n\n![](./asynchronous-methods-for-drl/gd.png)\n\n之后出现了SGD，也就是随机梯度下降，这种方法差不多在60年代提出，由于思想过于简单，迭代次数很长，一直不被主流优化算法接受。但是，当大数据时代到来时，SGD变成了很普遍的优化方法。\n\nSGD的算法流程如下：\n\n- 选一个初始参数向量$\\theta$和正步长$\\alpha$\n- 循环直到满足结束条件：\n  - 从训练集中随机选择一个样本$x_{i}$\n  - 更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$\n\nSGD的优点：\n\n1. 少内存占用。SGD不需要所有的样本集进行计算梯度，只需要从样本集中抽取一个样本进行训练。频繁的采样操作可以使用高速缓存来加速训练。\n2. 收敛至**可接受的解**速度很快。其实我们不希望看到过拟合，当然也不希望看到欠拟合，SGD正好是这两个极端的trade-off。SGD可以很快的收敛到一个较好的解，相对于样本集较好的解比相对于样本集最好的解的泛化能力可要强得多。下图展示了SGD与标准梯度下降的损失函数曲线比较。\n\n![](./asynchronous-methods-for-drl/sgdvsgd.png)\n\n看图像可能会觉得SGD并没有严格下降，有时会有损失上升的倾向，但是，总体来看，这种方法最终也是可以收敛到最小值的。总体上，它使损失进行了下降。\n\n对于熟悉并行编程的人来说，如果让他们设计并行随机梯度下降，他们一定会像这样设计：\n\n- 每个线程从训练集随机抽取一个样本$x_{i}$\n  - 锁参数$\\theta$\n  - 线程读参数$\\theta$\n  - 线程更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$\n  - 解锁\n\n更新前锁定参数，更新后解锁参数。对于许多问题，更新这一步骤耗时在微秒级，而锁参数耗时在毫秒级，这意味着锁参数要比更新多占用1000多倍的时间。虽然有一些其他方法可以对该过程进行优化，但差距还是很明显。\n\n如果，**注释掉关于锁的代码呢？**这真是一个大胆的想法，但是Hogwild!就是这么做的。（这都是一个叫Feng Niu的人搞出来的，不知是出于好奇还是在Debug，他在研究加速SGD的时候注释掉了锁的代码，算法不仅有效，还提升了一百多倍。所以说，多试试总是好的。。。）流程如下：\n\n- 每个线程从训练集随机抽取一个样本$x_{i}$\n  - ~~锁参数$\\theta $~~​\n  - 线程读参数$\\theta$\n  - 线程更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$\n  - ~~解锁~~\n\n> In a sentence, the main idea of Hogwild! is — “**Remove all thread locks from parallel SGD code**.” In Hogwild!, threads can overwrite each other by writing at the same time and compute gradients using a stale version of the “current solution.” \n\n我们不禁都有一个疑问，这么做，真的可以吗？还真别说，经过实验表明，该方法取得了多线程的益处却没有数学效率上的负面影响。\n\n本文中的异步更新就是用这种方法，唯一有问题的可能就是两个线程同写，但是即便是同写，写入还是有先后的，最多也就是把前一个线程写入的给覆盖掉，丢弃一个线程的数据更新而已，无伤大雅，至于多个线程写后读、读后写倒都没有大的影响，不影响参数更新与收敛。\n\n## 伪代码\n\n**本文中所有伪代码都使用Hogwild!方式进行梯度更新。**\n\n以下伪代码都是单个线程中actor-learning的操作。每个线程中的actor可以使用不同的探索机制，实验证明不同的探索机制可以提高算法的鲁棒性和性能效果。\n\n首先介绍异步one-step Q-Learning的训练模式\n\n![](./asynchronous-methods-for-drl/a1stepq.png)\n\n解析：\n\n- 相比后两个伪代码，该代码中各线程是不需要复制用于选择动作的训练网络（因为各方对target network的定义不同，有些人认为等待赋值的是目标网络，有些人认为需要训练的是目标网络，因此，此处不使用目标网络的术语）的，即每次选择动作，都使用其他线程可能更新过的Q网络进行决策。这是因为不需要使用同一个决策模型向后看多步\n- $\\theta$是动态变化的，即在该线程的训练过程中，其他线程也可能对参数$\\theta$进行了更新\n- $I_{target}$代表双Q学习赋值的间隔\n- $I_{AsyncUpdate}$代表单线程对共享参数$\\theta$更新的间隔\n\n---\n\n接下来是异步n-step Q-Learning的训练模式：\n\n相比于n-step，one-step方法中获得的立即奖励$r$只影响导致其产生的$Q(s,a)$，从而通过$Q(s,a)$间接影响其他的动作值，这会使训练过程很慢，因为需要多次更新才能将奖励传播到前面的相关状态和动作。使奖励传播更快的一个方法就是使用n-step回报。\n$$\nG_{t}=r_{t}+\\gamma r_{t+1}+\\cdots+\\gamma^{n-1} r_{t+n-1}+\\max _{a} \\gamma^{n} Q\\left(s_{t+n}, a\\right)\n$$\n![](./asynchronous-methods-for-drl/anstepq.png)\n\n解析：\n\n- 相比于one-step，该算法为每个线程配置了一个备份网络$\\color{red}{\\theta'}$\n- $t_{max}$为n-step中的$n$\n\n---\n\n最后是异步A2C，即A3C的训练模式：\n\n![](./asynchronous-methods-for-drl/a3c.png)\n\n解析：\n\n- $t_{max}$为n-step向前看的步数\n- 文中针对该模型将A-C网络架构共享了部分神经网络参数，并且对actor网络的损失函数公式进行了改造：$\\nabla_{\\theta^{\\prime}} \\log \\pi\\left(a_{t} | s_{t} ; \\theta^{\\prime}\\right)\\left(R_{t}-V\\left(s_{t} ; \\theta_{v}\\right)\\right)+\\color{red}{\\beta \\nabla_{\\theta^{\\prime}} H\\left(\\pi\\left(s_{t} ; \\theta^{\\prime}\\right)\\right)}$，即添加了熵正则化项，它的作用是增加探索，避免网络过早地收敛至局部最优，$\\beta$为超参数\n\n正态分布的熵可以表示为$-\\frac{1}{2}\\left(\\log \\left(2 \\pi \\sigma^{2}\\right)+1\\right)$\n\n# 实验部分\n\n实验结果视频：\n\n- [TORCS A3C训练驾驶汽车](https://youtu.be/0xo1Ldx3L5Q)\n- [MuJoco 一些训练效果](https://youtu.be/Ajjc08-iPx8)\n- [Labyrinth 3D迷宫](https://youtu.be/nMR5mjCFZCw)\n\nAtari 2600 实验结果：\n\n![](./asynchronous-methods-for-drl/table1.png)\n\n不同线程数的加速效果：\n\n![](./asynchronous-methods-for-drl/table2.png)\n\n文中比较了三种优化函数的性能，分别是：\n\n- 动量SGD，Momentum SGD\n- RMSProp\n- Shared RMSProp\n\nRMSProp是这样更新的：\n$$\ng=\\alpha g+(1-\\alpha) \\Delta \\theta^{2}\n$$\n\n$$\n\\theta \\leftarrow \\theta-\\eta \\frac{\\Delta \\theta}{\\sqrt{g+\\epsilon}}\n$$\n\n$\\eta$为学习率，$\\alpha$为RMSProp折扣因子\n\nRMSProp与Shared RMSProp的差别就是：\n\n- Shared RMSProp各线程共享参数$g$，且无锁异步更新\n- RMSProp各线程独立一个参数$g$\n\n实验结果如下：\n\n测试每种算法50次试验，得分从高到低排列，算法为n-step Q-Learning和A3C\n\n**综合来看，三种优化方式效果差别不大，但是Shared RMSProp>RMSProp>Momentum SGD**\n\n![](./asynchronous-methods-for-drl/threeoptimizer.png)\n\n---\n\n实验结果太多，懒得贴了，总之，这种异步框架方法的优点是：\n\n- 使用离线在线策略，基于值基于策略方法，离散连续问题\n- 稳定训练\n- 加速训练\n- 比经验池少消耗资源\n\n# 引用\n\n> [Parallel Machine Learning with Hogwild!](https://medium.com/@krishna_srd/parallel-machine-learning-with-hogwild-f945ad7e48a4)","slug":"asynchronous-methods-for-drl","published":1,"updated":"2019-05-31T16:01:49.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut8o004k20cdaoqytz5x","content":"<p>本文提出了A3C模型，即Asynchronous Advantage Actor-Critic，是A2C的异步版本，使用CPU多核而不用GPU进行训练，文中说效果比使用GPU反而更好。</p>\n<p>推荐：</p>\n<ul>\n<li>并行梯度优化的佳作</li>\n<li>通俗易懂</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1602.01783.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1602.01783.pdf</a></p>\n<p>本文提出了一个概念简单、异步梯度优化的轻量级深度强化学习训练框架。提出该框架的初衷是占用少的资源稳定深度神经网络的学习。</p>\n<p>该框架可适用于：</p>\n<ul>\n<li>基于值与基于策略的方法</li>\n<li>on-policy与off-policy的方法</li>\n<li>离散与连续问题</li>\n</ul>\n<p>效果：</p>\n<ul>\n<li>稳定训练</li>\n<li>在Atari游戏上使用DQN算法，一个16核CPU比Nvidia K40 GPU快，使用A3C算法可以快一倍</li>\n<li>成功适用于很多连续运动学控制问题，例如图像输入的3D迷宫</li>\n</ul>\n<blockquote>\n<p>the sequence of observed data encountered by an online RL agent is non-stationary, and on-line RL updates are strongly correlated. By storing the agent’s data in an experience replay memory, the data can be batched or randomly sampled from different time-steps. Aggregating over memory in this way reduces non-stationarity and decorrelates updates, but at the same time limits the methods to off-policy reinforcement learning algorithms </p>\n</blockquote>\n<p>文中指出，on-policy方法训练不稳定，数据相关性很强，off-policy机制结合经验池机制减轻了训练的不稳定性和数据相关性。</p>\n<p>经验池的缺点：</p>\n<ol>\n<li>占用内存，增加计算量</li>\n<li>需要off-policy算法</li>\n</ol>\n<p>本文为深度强化学习提供了一个非常不同的范例，不使用经验池机制，而使用异步并行的方法在多个<strong>相同环境</strong>中执行多个智能体。（同时训练多个不同环境没有进行描述和实验）</p>\n<p>这种异步并行方式的优点是：</p>\n<ol>\n<li>实现减轻数据相关性的效果，使训练稳定</li>\n<li>可用于大范围on-policy算法，如Sarsa，n-step方法，A-C方法，也可用于off-policy方法，如Q-learning</li>\n<li>利用深度神经网络设计算法，保持鲁棒性与有效性（不予置评）</li>\n<li>不使用GPU，只使用多核CPU，反而训练时间短</li>\n<li>比大规模分布式需要更少的资源占用（内存、算力等）</li>\n<li><strong>相比于<a href=\"https://arxiv.org/pdf/1507.04296.pdf\" rel=\"external nofollow\" target=\"_blank\">Gorila</a>异步训练方式，本文中的训练方式不需要中心服务器，其使用的是共享内存模式</strong></li>\n<li>单机运行减少了通信（梯度和超参数）的开销</li>\n</ol>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>由于本文思想非常简单，所以精简描述论文精华</p>\n<p>本文使用<strong><a href=\"https://arxiv.org/pdf/1106.5730.pdf\" rel=\"external nofollow\" target=\"_blank\">Hogwild!</a></strong>方式进行异步梯度下降</p>\n<p>Hogwild! 这个方法的提出也很偶然，容我步步道来：</p>\n<p>我们使用函数对样本集进行拟合如下图所示</p>\n<p><img src=\"./asynchronous-methods-for-drl/regression.png\" alt=\"\"></p>\n<p>当我们想要判断函数是否拟合的不错，我们往往使用损失函数来衡量，损失越小，则代表函数拟合得越好（但，过拟合不是我们想要的）。</p>\n<p><img src=\"./asynchronous-methods-for-drl/lossfunction.png\" alt=\"\"></p>\n<p>为了减小损失，我们常用梯度下降算法来优化。标准的梯度下降原理如下图所示，如果函数为凸函数，且更新步长很小，那么在有限步长内总可以下降至函数最小点，即，获得使损失函数最小的参数$\\theta^{\\ast}$</p>\n<p><img src=\"./asynchronous-methods-for-drl/gd.png\" alt=\"\"></p>\n<p>之后出现了SGD，也就是随机梯度下降，这种方法差不多在60年代提出，由于思想过于简单，迭代次数很长，一直不被主流优化算法接受。但是，当大数据时代到来时，SGD变成了很普遍的优化方法。</p>\n<p>SGD的算法流程如下：</p>\n<ul>\n<li>选一个初始参数向量$\\theta$和正步长$\\alpha$</li>\n<li>循环直到满足结束条件：<ul>\n<li>从训练集中随机选择一个样本$x_{i}$</li>\n<li>更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$</li>\n</ul>\n</li>\n</ul>\n<p>SGD的优点：</p>\n<ol>\n<li>少内存占用。SGD不需要所有的样本集进行计算梯度，只需要从样本集中抽取一个样本进行训练。频繁的采样操作可以使用高速缓存来加速训练。</li>\n<li>收敛至<strong>可接受的解</strong>速度很快。其实我们不希望看到过拟合，当然也不希望看到欠拟合，SGD正好是这两个极端的trade-off。SGD可以很快的收敛到一个较好的解，相对于样本集较好的解比相对于样本集最好的解的泛化能力可要强得多。下图展示了SGD与标准梯度下降的损失函数曲线比较。</li>\n</ol>\n<p><img src=\"./asynchronous-methods-for-drl/sgdvsgd.png\" alt=\"\"></p>\n<p>看图像可能会觉得SGD并没有严格下降，有时会有损失上升的倾向，但是，总体来看，这种方法最终也是可以收敛到最小值的。总体上，它使损失进行了下降。</p>\n<p>对于熟悉并行编程的人来说，如果让他们设计并行随机梯度下降，他们一定会像这样设计：</p>\n<ul>\n<li>每个线程从训练集随机抽取一个样本$x_{i}$<ul>\n<li>锁参数$\\theta$</li>\n<li>线程读参数$\\theta$</li>\n<li>线程更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$</li>\n<li>解锁</li>\n</ul>\n</li>\n</ul>\n<p>更新前锁定参数，更新后解锁参数。对于许多问题，更新这一步骤耗时在微秒级，而锁参数耗时在毫秒级，这意味着锁参数要比更新多占用1000多倍的时间。虽然有一些其他方法可以对该过程进行优化，但差距还是很明显。</p>\n<p>如果，<strong>注释掉关于锁的代码呢？</strong>这真是一个大胆的想法，但是Hogwild!就是这么做的。（这都是一个叫Feng Niu的人搞出来的，不知是出于好奇还是在Debug，他在研究加速SGD的时候注释掉了锁的代码，算法不仅有效，还提升了一百多倍。所以说，多试试总是好的。。。）流程如下：</p>\n<ul>\n<li>每个线程从训练集随机抽取一个样本$x_{i}$<ul>\n<li><del>锁参数$\\theta $</del>​</li>\n<li>线程读参数$\\theta$</li>\n<li>线程更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$</li>\n<li><del>解锁</del></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>In a sentence, the main idea of Hogwild! is — “<strong>Remove all thread locks from parallel SGD code</strong>.” In Hogwild!, threads can overwrite each other by writing at the same time and compute gradients using a stale version of the “current solution.” </p>\n</blockquote>\n<p>我们不禁都有一个疑问，这么做，真的可以吗？还真别说，经过实验表明，该方法取得了多线程的益处却没有数学效率上的负面影响。</p>\n<p>本文中的异步更新就是用这种方法，唯一有问题的可能就是两个线程同写，但是即便是同写，写入还是有先后的，最多也就是把前一个线程写入的给覆盖掉，丢弃一个线程的数据更新而已，无伤大雅，至于多个线程写后读、读后写倒都没有大的影响，不影响参数更新与收敛。</p>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><strong>本文中所有伪代码都使用Hogwild!方式进行梯度更新。</strong></p>\n<p>以下伪代码都是单个线程中actor-learning的操作。每个线程中的actor可以使用不同的探索机制，实验证明不同的探索机制可以提高算法的鲁棒性和性能效果。</p>\n<p>首先介绍异步one-step Q-Learning的训练模式</p>\n<p><img src=\"./asynchronous-methods-for-drl/a1stepq.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>相比后两个伪代码，该代码中各线程是不需要复制用于选择动作的训练网络（因为各方对target network的定义不同，有些人认为等待赋值的是目标网络，有些人认为需要训练的是目标网络，因此，此处不使用目标网络的术语）的，即每次选择动作，都使用其他线程可能更新过的Q网络进行决策。这是因为不需要使用同一个决策模型向后看多步</li>\n<li>$\\theta$是动态变化的，即在该线程的训练过程中，其他线程也可能对参数$\\theta$进行了更新</li>\n<li>$I_{target}$代表双Q学习赋值的间隔</li>\n<li>$I_{AsyncUpdate}$代表单线程对共享参数$\\theta$更新的间隔</li>\n</ul>\n<hr>\n<p>接下来是异步n-step Q-Learning的训练模式：</p>\n<p>相比于n-step，one-step方法中获得的立即奖励$r$只影响导致其产生的$Q(s,a)$，从而通过$Q(s,a)$间接影响其他的动作值，这会使训练过程很慢，因为需要多次更新才能将奖励传播到前面的相关状态和动作。使奖励传播更快的一个方法就是使用n-step回报。</p>\n<script type=\"math/tex; mode=display\">\nG_{t}=r_{t}+\\gamma r_{t+1}+\\cdots+\\gamma^{n-1} r_{t+n-1}+\\max _{a} \\gamma^{n} Q\\left(s_{t+n}, a\\right)</script><p><img src=\"./asynchronous-methods-for-drl/anstepq.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>相比于one-step，该算法为每个线程配置了一个备份网络$\\color{red}{\\theta’}$</li>\n<li>$t_{max}$为n-step中的$n$</li>\n</ul>\n<hr>\n<p>最后是异步A2C，即A3C的训练模式：</p>\n<p><img src=\"./asynchronous-methods-for-drl/a3c.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>$t_{max}$为n-step向前看的步数</li>\n<li>文中针对该模型将A-C网络架构共享了部分神经网络参数，并且对actor网络的损失函数公式进行了改造：$\\nabla_{\\theta^{\\prime}} \\log \\pi\\left(a_{t} | s_{t} ; \\theta^{\\prime}\\right)\\left(R_{t}-V\\left(s_{t} ; \\theta_{v}\\right)\\right)+\\color{red}{\\beta \\nabla_{\\theta^{\\prime}} H\\left(\\pi\\left(s_{t} ; \\theta^{\\prime}\\right)\\right)}$，即添加了熵正则化项，它的作用是增加探索，避免网络过早地收敛至局部最优，$\\beta$为超参数</li>\n</ul>\n<p>正态分布的熵可以表示为$-\\frac{1}{2}\\left(\\log \\left(2 \\pi \\sigma^{2}\\right)+1\\right)$</p>\n<h1 id=\"实验部分\"><a href=\"#实验部分\" class=\"headerlink\" title=\"实验部分\"></a>实验部分</h1><p>实验结果视频：</p>\n<ul>\n<li><a href=\"https://youtu.be/0xo1Ldx3L5Q\" rel=\"external nofollow\" target=\"_blank\">TORCS A3C训练驾驶汽车</a></li>\n<li><a href=\"https://youtu.be/Ajjc08-iPx8\" rel=\"external nofollow\" target=\"_blank\">MuJoco 一些训练效果</a></li>\n<li><a href=\"https://youtu.be/nMR5mjCFZCw\" rel=\"external nofollow\" target=\"_blank\">Labyrinth 3D迷宫</a></li>\n</ul>\n<p>Atari 2600 实验结果：</p>\n<p><img src=\"./asynchronous-methods-for-drl/table1.png\" alt=\"\"></p>\n<p>不同线程数的加速效果：</p>\n<p><img src=\"./asynchronous-methods-for-drl/table2.png\" alt=\"\"></p>\n<p>文中比较了三种优化函数的性能，分别是：</p>\n<ul>\n<li>动量SGD，Momentum SGD</li>\n<li>RMSProp</li>\n<li>Shared RMSProp</li>\n</ul>\n<p>RMSProp是这样更新的：</p>\n<script type=\"math/tex; mode=display\">\ng=\\alpha g+(1-\\alpha) \\Delta \\theta^{2}</script><script type=\"math/tex; mode=display\">\n\\theta \\leftarrow \\theta-\\eta \\frac{\\Delta \\theta}{\\sqrt{g+\\epsilon}}</script><p>$\\eta$为学习率，$\\alpha$为RMSProp折扣因子</p>\n<p>RMSProp与Shared RMSProp的差别就是：</p>\n<ul>\n<li>Shared RMSProp各线程共享参数$g$，且无锁异步更新</li>\n<li>RMSProp各线程独立一个参数$g$</li>\n</ul>\n<p>实验结果如下：</p>\n<p>测试每种算法50次试验，得分从高到低排列，算法为n-step Q-Learning和A3C</p>\n<p><strong>综合来看，三种优化方式效果差别不大，但是Shared RMSProp&gt;RMSProp&gt;Momentum SGD</strong></p>\n<p><img src=\"./asynchronous-methods-for-drl/threeoptimizer.png\" alt=\"\"></p>\n<hr>\n<p>实验结果太多，懒得贴了，总之，这种异步框架方法的优点是：</p>\n<ul>\n<li>使用离线在线策略，基于值基于策略方法，离散连续问题</li>\n<li>稳定训练</li>\n<li>加速训练</li>\n<li>比经验池少消耗资源</li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><blockquote>\n<p><a href=\"https://medium.com/@krishna_srd/parallel-machine-learning-with-hogwild-f945ad7e48a4\" rel=\"external nofollow\" target=\"_blank\">Parallel Machine Learning with Hogwild!</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>本文提出了A3C模型，即Asynchronous Advantage Actor-Critic，是A2C的异步版本，使用CPU多核而不用GPU进行训练，文中说效果比使用GPU反而更好。</p>\n<p>推荐：</p>\n<ul>\n<li>并行梯度优化的佳作</li>\n<li>通俗易懂</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1602.01783.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1602.01783.pdf</a></p>\n<p>本文提出了一个概念简单、异步梯度优化的轻量级深度强化学习训练框架。提出该框架的初衷是占用少的资源稳定深度神经网络的学习。</p>\n<p>该框架可适用于：</p>\n<ul>\n<li>基于值与基于策略的方法</li>\n<li>on-policy与off-policy的方法</li>\n<li>离散与连续问题</li>\n</ul>\n<p>效果：</p>\n<ul>\n<li>稳定训练</li>\n<li>在Atari游戏上使用DQN算法，一个16核CPU比Nvidia K40 GPU快，使用A3C算法可以快一倍</li>\n<li>成功适用于很多连续运动学控制问题，例如图像输入的3D迷宫</li>\n</ul>\n<blockquote>\n<p>the sequence of observed data encountered by an online RL agent is non-stationary, and on-line RL updates are strongly correlated. By storing the agent’s data in an experience replay memory, the data can be batched or randomly sampled from different time-steps. Aggregating over memory in this way reduces non-stationarity and decorrelates updates, but at the same time limits the methods to off-policy reinforcement learning algorithms </p>\n</blockquote>\n<p>文中指出，on-policy方法训练不稳定，数据相关性很强，off-policy机制结合经验池机制减轻了训练的不稳定性和数据相关性。</p>\n<p>经验池的缺点：</p>\n<ol>\n<li>占用内存，增加计算量</li>\n<li>需要off-policy算法</li>\n</ol>\n<p>本文为深度强化学习提供了一个非常不同的范例，不使用经验池机制，而使用异步并行的方法在多个<strong>相同环境</strong>中执行多个智能体。（同时训练多个不同环境没有进行描述和实验）</p>\n<p>这种异步并行方式的优点是：</p>\n<ol>\n<li>实现减轻数据相关性的效果，使训练稳定</li>\n<li>可用于大范围on-policy算法，如Sarsa，n-step方法，A-C方法，也可用于off-policy方法，如Q-learning</li>\n<li>利用深度神经网络设计算法，保持鲁棒性与有效性（不予置评）</li>\n<li>不使用GPU，只使用多核CPU，反而训练时间短</li>\n<li>比大规模分布式需要更少的资源占用（内存、算力等）</li>\n<li><strong>相比于<a href=\"https://arxiv.org/pdf/1507.04296.pdf\" rel=\"external nofollow\" target=\"_blank\">Gorila</a>异步训练方式，本文中的训练方式不需要中心服务器，其使用的是共享内存模式</strong></li>\n<li>单机运行减少了通信（梯度和超参数）的开销</li>\n</ol>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>由于本文思想非常简单，所以精简描述论文精华</p>\n<p>本文使用<strong><a href=\"https://arxiv.org/pdf/1106.5730.pdf\" rel=\"external nofollow\" target=\"_blank\">Hogwild!</a></strong>方式进行异步梯度下降</p>\n<p>Hogwild! 这个方法的提出也很偶然，容我步步道来：</p>\n<p>我们使用函数对样本集进行拟合如下图所示</p>\n<p><img src=\"./asynchronous-methods-for-drl/regression.png\" alt=\"\"></p>\n<p>当我们想要判断函数是否拟合的不错，我们往往使用损失函数来衡量，损失越小，则代表函数拟合得越好（但，过拟合不是我们想要的）。</p>\n<p><img src=\"./asynchronous-methods-for-drl/lossfunction.png\" alt=\"\"></p>\n<p>为了减小损失，我们常用梯度下降算法来优化。标准的梯度下降原理如下图所示，如果函数为凸函数，且更新步长很小，那么在有限步长内总可以下降至函数最小点，即，获得使损失函数最小的参数$\\theta^{\\ast}$</p>\n<p><img src=\"./asynchronous-methods-for-drl/gd.png\" alt=\"\"></p>\n<p>之后出现了SGD，也就是随机梯度下降，这种方法差不多在60年代提出，由于思想过于简单，迭代次数很长，一直不被主流优化算法接受。但是，当大数据时代到来时，SGD变成了很普遍的优化方法。</p>\n<p>SGD的算法流程如下：</p>\n<ul>\n<li>选一个初始参数向量$\\theta$和正步长$\\alpha$</li>\n<li>循环直到满足结束条件：<ul>\n<li>从训练集中随机选择一个样本$x_{i}$</li>\n<li>更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$</li>\n</ul>\n</li>\n</ul>\n<p>SGD的优点：</p>\n<ol>\n<li>少内存占用。SGD不需要所有的样本集进行计算梯度，只需要从样本集中抽取一个样本进行训练。频繁的采样操作可以使用高速缓存来加速训练。</li>\n<li>收敛至<strong>可接受的解</strong>速度很快。其实我们不希望看到过拟合，当然也不希望看到欠拟合，SGD正好是这两个极端的trade-off。SGD可以很快的收敛到一个较好的解，相对于样本集较好的解比相对于样本集最好的解的泛化能力可要强得多。下图展示了SGD与标准梯度下降的损失函数曲线比较。</li>\n</ol>\n<p><img src=\"./asynchronous-methods-for-drl/sgdvsgd.png\" alt=\"\"></p>\n<p>看图像可能会觉得SGD并没有严格下降，有时会有损失上升的倾向，但是，总体来看，这种方法最终也是可以收敛到最小值的。总体上，它使损失进行了下降。</p>\n<p>对于熟悉并行编程的人来说，如果让他们设计并行随机梯度下降，他们一定会像这样设计：</p>\n<ul>\n<li>每个线程从训练集随机抽取一个样本$x_{i}$<ul>\n<li>锁参数$\\theta$</li>\n<li>线程读参数$\\theta$</li>\n<li>线程更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$</li>\n<li>解锁</li>\n</ul>\n</li>\n</ul>\n<p>更新前锁定参数，更新后解锁参数。对于许多问题，更新这一步骤耗时在微秒级，而锁参数耗时在毫秒级，这意味着锁参数要比更新多占用1000多倍的时间。虽然有一些其他方法可以对该过程进行优化，但差距还是很明显。</p>\n<p>如果，<strong>注释掉关于锁的代码呢？</strong>这真是一个大胆的想法，但是Hogwild!就是这么做的。（这都是一个叫Feng Niu的人搞出来的，不知是出于好奇还是在Debug，他在研究加速SGD的时候注释掉了锁的代码，算法不仅有效，还提升了一百多倍。所以说，多试试总是好的。。。）流程如下：</p>\n<ul>\n<li>每个线程从训练集随机抽取一个样本$x_{i}$<ul>\n<li><del>锁参数$\\theta $</del>​</li>\n<li>线程读参数$\\theta$</li>\n<li>线程更新参数$\\theta \\leftarrow\\left(\\theta-\\alpha \\nabla L\\left(f_{\\theta}\\left(x_{i}\\right), y_{i}\\right)\\right)$</li>\n<li><del>解锁</del></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>In a sentence, the main idea of Hogwild! is — “<strong>Remove all thread locks from parallel SGD code</strong>.” In Hogwild!, threads can overwrite each other by writing at the same time and compute gradients using a stale version of the “current solution.” </p>\n</blockquote>\n<p>我们不禁都有一个疑问，这么做，真的可以吗？还真别说，经过实验表明，该方法取得了多线程的益处却没有数学效率上的负面影响。</p>\n<p>本文中的异步更新就是用这种方法，唯一有问题的可能就是两个线程同写，但是即便是同写，写入还是有先后的，最多也就是把前一个线程写入的给覆盖掉，丢弃一个线程的数据更新而已，无伤大雅，至于多个线程写后读、读后写倒都没有大的影响，不影响参数更新与收敛。</p>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><strong>本文中所有伪代码都使用Hogwild!方式进行梯度更新。</strong></p>\n<p>以下伪代码都是单个线程中actor-learning的操作。每个线程中的actor可以使用不同的探索机制，实验证明不同的探索机制可以提高算法的鲁棒性和性能效果。</p>\n<p>首先介绍异步one-step Q-Learning的训练模式</p>\n<p><img src=\"./asynchronous-methods-for-drl/a1stepq.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>相比后两个伪代码，该代码中各线程是不需要复制用于选择动作的训练网络（因为各方对target network的定义不同，有些人认为等待赋值的是目标网络，有些人认为需要训练的是目标网络，因此，此处不使用目标网络的术语）的，即每次选择动作，都使用其他线程可能更新过的Q网络进行决策。这是因为不需要使用同一个决策模型向后看多步</li>\n<li>$\\theta$是动态变化的，即在该线程的训练过程中，其他线程也可能对参数$\\theta$进行了更新</li>\n<li>$I_{target}$代表双Q学习赋值的间隔</li>\n<li>$I_{AsyncUpdate}$代表单线程对共享参数$\\theta$更新的间隔</li>\n</ul>\n<hr>\n<p>接下来是异步n-step Q-Learning的训练模式：</p>\n<p>相比于n-step，one-step方法中获得的立即奖励$r$只影响导致其产生的$Q(s,a)$，从而通过$Q(s,a)$间接影响其他的动作值，这会使训练过程很慢，因为需要多次更新才能将奖励传播到前面的相关状态和动作。使奖励传播更快的一个方法就是使用n-step回报。</p>\n<script type=\"math/tex; mode=display\">\nG_{t}=r_{t}+\\gamma r_{t+1}+\\cdots+\\gamma^{n-1} r_{t+n-1}+\\max _{a} \\gamma^{n} Q\\left(s_{t+n}, a\\right)</script><p><img src=\"./asynchronous-methods-for-drl/anstepq.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>相比于one-step，该算法为每个线程配置了一个备份网络$\\color{red}{\\theta’}$</li>\n<li>$t_{max}$为n-step中的$n$</li>\n</ul>\n<hr>\n<p>最后是异步A2C，即A3C的训练模式：</p>\n<p><img src=\"./asynchronous-methods-for-drl/a3c.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>$t_{max}$为n-step向前看的步数</li>\n<li>文中针对该模型将A-C网络架构共享了部分神经网络参数，并且对actor网络的损失函数公式进行了改造：$\\nabla_{\\theta^{\\prime}} \\log \\pi\\left(a_{t} | s_{t} ; \\theta^{\\prime}\\right)\\left(R_{t}-V\\left(s_{t} ; \\theta_{v}\\right)\\right)+\\color{red}{\\beta \\nabla_{\\theta^{\\prime}} H\\left(\\pi\\left(s_{t} ; \\theta^{\\prime}\\right)\\right)}$，即添加了熵正则化项，它的作用是增加探索，避免网络过早地收敛至局部最优，$\\beta$为超参数</li>\n</ul>\n<p>正态分布的熵可以表示为$-\\frac{1}{2}\\left(\\log \\left(2 \\pi \\sigma^{2}\\right)+1\\right)$</p>\n<h1 id=\"实验部分\"><a href=\"#实验部分\" class=\"headerlink\" title=\"实验部分\"></a>实验部分</h1><p>实验结果视频：</p>\n<ul>\n<li><a href=\"https://youtu.be/0xo1Ldx3L5Q\" rel=\"external nofollow\" target=\"_blank\">TORCS A3C训练驾驶汽车</a></li>\n<li><a href=\"https://youtu.be/Ajjc08-iPx8\" rel=\"external nofollow\" target=\"_blank\">MuJoco 一些训练效果</a></li>\n<li><a href=\"https://youtu.be/nMR5mjCFZCw\" rel=\"external nofollow\" target=\"_blank\">Labyrinth 3D迷宫</a></li>\n</ul>\n<p>Atari 2600 实验结果：</p>\n<p><img src=\"./asynchronous-methods-for-drl/table1.png\" alt=\"\"></p>\n<p>不同线程数的加速效果：</p>\n<p><img src=\"./asynchronous-methods-for-drl/table2.png\" alt=\"\"></p>\n<p>文中比较了三种优化函数的性能，分别是：</p>\n<ul>\n<li>动量SGD，Momentum SGD</li>\n<li>RMSProp</li>\n<li>Shared RMSProp</li>\n</ul>\n<p>RMSProp是这样更新的：</p>\n<script type=\"math/tex; mode=display\">\ng=\\alpha g+(1-\\alpha) \\Delta \\theta^{2}</script><script type=\"math/tex; mode=display\">\n\\theta \\leftarrow \\theta-\\eta \\frac{\\Delta \\theta}{\\sqrt{g+\\epsilon}}</script><p>$\\eta$为学习率，$\\alpha$为RMSProp折扣因子</p>\n<p>RMSProp与Shared RMSProp的差别就是：</p>\n<ul>\n<li>Shared RMSProp各线程共享参数$g$，且无锁异步更新</li>\n<li>RMSProp各线程独立一个参数$g$</li>\n</ul>\n<p>实验结果如下：</p>\n<p>测试每种算法50次试验，得分从高到低排列，算法为n-step Q-Learning和A3C</p>\n<p><strong>综合来看，三种优化方式效果差别不大，但是Shared RMSProp&gt;RMSProp&gt;Momentum SGD</strong></p>\n<p><img src=\"./asynchronous-methods-for-drl/threeoptimizer.png\" alt=\"\"></p>\n<hr>\n<p>实验结果太多，懒得贴了，总之，这种异步框架方法的优点是：</p>\n<ul>\n<li>使用离线在线策略，基于值基于策略方法，离散连续问题</li>\n<li>稳定训练</li>\n<li>加速训练</li>\n<li>比经验池少消耗资源</li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><blockquote>\n<p><a href=\"https://medium.com/@krishna_srd/parallel-machine-learning-with-hogwild-f945ad7e48a4\" rel=\"external nofollow\" target=\"_blank\">Parallel Machine Learning with Hogwild!</a></p>\n</blockquote>"},{"title":"Build一个基于Mxnet的Sniper镜像","copyright":true,"top":1,"date":"2019-01-02T13:58:44.000Z","_content":"\n本文记录了如何在学校机器学习平台上创建一个基于Mxnet的Sniper镜像。\n\n<!--more-->\n\n# 说明\n\n由于此镜像是用于学校机器学习平台,所以文中会出现FTP服务器等字眼,其实是在平台上使用镜像创建一个容器时,平台会**自动**将服务器上我所申请的文件存储区`mount`到创建的容器,我通过`FileZilla`FTP工具与在平台申请的文件存储区进行连接\n​\t\n本文教程虽然有了一个FTP过程,但是如果是生成本地镜像,不考虑FTP,无视文中相关部分即可\n\n**虽然本文中写了关于压缩的相关内容,但是最终并没有使用压缩,原因是由于压缩后出现未知问题,导致在平台上创建的容器不能使用宿主机的NVIDIA驱动,并不能成功运行Demo**\n\n# 环境\n\n本机环境\n- windows 10 专业版\n- docker client version 18.09.0\n- docker server version 18.09.0\n- FTP工具 FileZilla\n\n平台环境\n- docker version 17.06.2-ce\n\n镜像环境\n- python 2.7.12\n- CUDA version 9.0.176\n- pip 9.0.3\n\n[SNIPER](https://github.com/mahyarnajibi/SNIPER)\n[机器学习平台](http://10.0.4.228),这是学校资源\n\n# 一 配置基础镜像\n\n从学校机器学习平台上拉取原始镜像,因为这个镜像配好了一些基本的环境,如python2.x,CUDA9.0等等,所以直接使用它们的镜像作为基础镜像比较省心省力\n`docker pull hub.hoc.ccshu.net/ces/deepo:all-py27-jupyter-ssh`\n\n拉取到镜像之后,可以选择使用`Dockerfile`来生成我们需要的镜像,但是往往我们需要在镜像中添加许多库/包/插件,而且使用`Dockerfile`来生成镜像很容易出BUG.当然,最好的方式是使用`Dockerfile`,前提是你能确保`Dockerfile`文件中的每一行命令都不会出错.\n在当前情况下,我选择使用从容器生成镜像的方法,这种方式会使得最终生成的镜像占内存巨大,但是可以在容器内部调试每一步配置过程.\n使用`docker run -itd --name [name] hub.hoc.ccshu.net/ces/deepo:all-py27-jupyter-ssh`开启一个容器\n\n使用`docker ps -a`查看正在运行的容器`ID`\n\n使用`docker exec -it [name] /bin/bash`进入容器\n\n在容器中使用`cat /etc/issue`命令查看容器的操作系统版本\n\n结果输出: `Ubuntu 16.04.4 LTS \\n \\l`\n\n## 安装 apt-file\n\n安装`apt-file`\n\n`apt-get install apt-file -y`\n\n出现错误:\n\n![](./create-sniper-docker-image/Snipaste_2019-01-03_08-30-41.png)\n\n使用`apt-get install apt-file -y --fix-missing`同样不能解决问题\n\n考虑**换源**\n\n`cp /etc/apt/sources.list /etc/apt/sources.list.bak`备份系统原有的源\n\n安装Linux下的文本编辑器`nano`,执行命令`apt-get install nano -y`\n安装`nano`成功后,执行`nano /etc/apt/sources.list`修改源文件\n在打开的文件中,将内容替换为\n```\n# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted\ndeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties\ndeb http://archive.canonical.com/ubuntu xenial partner\ndeb-src http://archive.canonical.com/ubuntu xenial partner\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse\n```\n\n这里使用的源是阿里的镜像站,也可以使用网易163的,源如下:\n```\ndeb http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse\ndeb http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse\ndeb http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse\ndeb http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse\ndeb http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse\ndeb-src http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse\ndeb-src http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse\ndeb-src http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse\ndeb-src http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse\n```\n\n更改好源文件后,执行`sudo apt-get update`更新源\n\n再次执行`apt-get install apt-file -y`,可以成功安装`apt-file`包\n\n之后执行`apt-file update`更新apt-file cache\n使用`apt-file find [name]`可以查找计算机上文件的位置,很方便\n使用`apt-file search [name]`可以搜索缺少的库,解决文件缺失依赖\n选择好自己需要的包,然后使用`apt-get install [name]`即可\n\n- 如果需要把镜像上传到云上使用,有可能需要网络服务,\n- 执行`apt-get install net-tools`安装ifconfig\n- 执行`apt-get install iputils-ping`安装ping\n\n此时为了避免诸如使用`ping [IP]`有效,但是`ping [HOST]`无效的情况,需要使用`nano /etc/resolv.conf`修改配置文件\n将`namespace`后的IP地址更改为`8.8.8.8`或者`4.4.4.4`\n*或者使用`echo \"nameserver 114.114.114.114 > /etc/resolv.conf\"`也可以*\n退出保存即可\n\n*有可能上述修改DNS的方式并不成功,原因是在云上运行容器时,配置文件自动修改,如果发生这种情况,请每次在新开一个容器时,手动修改配置文件的DNS服务器,使其可以使用网络服务*\n\n# 二 安装编译依赖各种包\n\n在电脑上空闲的地方,从Github拉取Sniper项目\n\n`git clone --recursive https://github.com/mahyarnajibi/SNIPER.git`\n\n- 因为我是在学校机器学习平台上运行docker容器,所以选择直接将clone下的文件上传至容器`mount`的ftp服务器,使用的软件是`FileZilla`\n\n- 上传成功后可以在容器内通过`cd /data/[file or folder name]`进行访问\n\n如果要在本地镜像内操作的话,也可以直接把本机文件或文件夹拷贝过去\n`docker cp 本地文件路径 ID全称:容器路径`\n\n---\n\n`cd /data/SNIPER/SNIPER-mxnet`\n`make USE_CUDA_PATH=/usr/local/cuda-9.0`\n输出信息:\n![](./create-sniper-docker-image/Snipaste_2019-01-03_09-42-07.png)\n\n## 安装 jemalloc\n\n选择安装`jemalloc`,这个工具可以加速编译,碎片整理,具体请自行谷歌\n- `apt-get install autoconf`\n- `apt-get install automake`\n- `apt-get install libtool`\n- `git clone https://github.com/jemalloc/jemalloc.git`\n- `cd jemalloc`\n- `git checkout 4.5.0`安装4.5.0版本的jemalloc,5.x版本的有坑,深坑\n- `./autogen.sh`\n- `make`\n- `make install_bin install_include install_lib`,之所以不使用`make install`是因为会报错,如下: ![](./create-sniper-docker-image/Snipaste_2019-01-03_09-56-41.png)\n\n切换至`SNIPER-mxnet`文件夹,再次`make USE_CUDA_PATH=/usr/local/cuda-9.0`\n虽然可以编译,但是有以下信息: \n![](./create-sniper-docker-image/Snipaste_2019-01-03_10-03-30.png)\n强迫症必须搞定它,果断`ctrl+c`终止编译\n\n## 安装 pkg-config\n\n- 打开[https://pkg-config.freedesktop.org/releases/](https://pkg-config.freedesktop.org/releases/)\n- 下载最新的,现在看到的是`pkg-config-0.29.2.tar.gz`\n- 下载好之后,通过`FileZilla`等工具传输到FTP服务器\n- 在容器内`cd`到压缩包位置\n- `tar -xf pkg-config-0.29.2.tar.gz`\n- `cd pkg-config-0.29.2`\n- `./configure --with-internal-glib`,注意,中间是一个空格,非常关键\n- `make && make install`\n![](./create-sniper-docker-image/Snipaste_2019-01-03_10-11-01.png)\n\n再次`make USE_CUDA_PATH=/usr/local/cuda-9.0`\n算了，还是安装一下cudnn吧\n\n## 安装 cudnn7.0\n- [https://developer.nvidia.com/rdp/cudnn-archive](https://developer.nvidia.com/rdp/cudnn-archive) 下载cuDNN Libraries for Linux,不要下载 Power 8\n- 把下载好的包上传到FTP服务器\n- `cd`到包位置\n- `cp cudnn-9.0-linux-x64-v7.solitairetheme8 cudnn-9.0-linux-x64-v7.tgz`\n- `tar -xvf cudnn-9.0-linux-x64-v7.tgz`\n- `cp include/* /usr/local/cuda-9.0/include`\n- `cp lib64/* /usr/local/cuda-9.0/lib64`\n- `chmod a+r /usr/local/cuda-9.0/include/cudnn.h /usr/local/cuda-9.0/lib64/libcudnn*`\n- `export PATH=/usr/local/cuda-9.0/bin:$PATH`\n- `cd`到`/usr/local/cuda-9.0/lib64`\n- `nano ~/.bashrc`,关联环境变量\n- 在最后一行加入`export LD_LIBRARY_PATH=/home/cuda/lib64:$LD_LIBRARY_PATH`\n- `source ~/.bashrc`\n- `ldconfig -v`\n- 使用`cat /usr/local/cuda-9.0/include/cudnn.h | grep CUDNN_MAJOR -A 2` 查看cudnn版本\n![](./create-sniper-docker-image/Snipaste_2019-01-03_10-56-08.png)\n\n## 安装 OpenCV\n- 使用`pkg-config opencv --modversion`查看\n- 发现已经有OpenCV\n![](./create-sniper-docker-image/Snipaste_2019-01-03_10-57-56.png)\n\n## 安装 OpenBLAS\n- `apt-get install libopenblas-dev`\n\n## 编译 Mxnet\n\n`make USE_CUDA_PATH=/usr/local/cuda-9.0`\n![](./create-sniper-docker-image/Snipaste_2019-01-03_13-49-28.png)\n\n**心好累,总共make了将近两个半小时**\n\n编译`c++`文件`bash scripts/compile.sh`\n这一步一定要在`/SNIPER/`文件夹下,不然贼坑,绝对不要`cd`到`/SNIPER/scripts`文件夹下再`bash compile.sh`,因为代码内有`cd lib/nms`等,如果不在`/SNIPER`文件夹下,会找不到文件\n\n如果出现`syntax error near unexpected token `$'\\r''`错误,可以使用`sed`命令将`\\r`去掉,或者是在[Github](https://github.com/mahyarnajibi/SNIPER/blob/master/scripts/compile.sh)上将代码复制,使用`nano`编辑然后粘贴\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-32-08.png)\n可以使用`cat -v [filename]`查看\n![]./create-sniper-docker-image/Snipaste_2019-01-03_16-33-27.png)\n以`^M`结尾的代表你所处理的文件换行符是dos格式的`\"\\r\\n\"`\n\n我选择第二种笨方法,因为涉及的代码并不多\n\n执行结果:\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-24-49.png)\n\n## 安装 dos2unix\n\n由于发现这种简单的复制粘贴方式并不能很好的解决,所以查了一些[相关资料](https://blog.csdn.net/lovelovelovelovelo/article/details/79239068)\n选择使用`dos2unix`来转换\n\n- `apt-get install dos2unix`\n- `dos2unix [filename]`\n\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-40-53.png)\n问题解决啦\n\n## 安装依赖\n\n在`/SNIPER/`文件夹下`pip install -r requirements.txt`\n一定要确保镜像内可以联网\n\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-29-58.png)\n\n## 测试Demo\n\n- `bash download_sniper_detector.sh`,download_sniper_detector.sh\n文件在`/SNIPER/scripts`文件夹下\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-44-22.png)\n- `cd .. && python demo.py`\n![](./create-sniper-docker-image/Snipaste_2019-01-03_17-05-30.png)\n\n**运行成功!!!**\n\n# 三 生成镜像\n- 使用`exit`退出容器\n- 使用`docker ps -a`查看容器ID\n- 使用`docker stop [ID]`停止容器\n- 使用`docker commit -a \"作者信息\" -m \"附带信息\" [ID] [name]:[tag]`生成镜像,会返回一个`sha256`开头的长ID,这个就是生成的镜像ID\n- 使用`docker images`查看生成的镜像\n- 如果需要的话,使用`docker push [name]:[tag]`将刚刚生成的镜像推送到云上\n\n# 四 压缩镜像\n\n**压缩镜像非常麻烦,但是也是有方法的,目前大概三种方法**\n\n1. 使用`Dockerfile`生成镜像\n2. 这种方法需要让容器在运行状态,使用`docker export [ID] | docker import - [name]:[tag]`导出容器快照,并从快照生成镜像,这种方式可以大大压缩镜像,但是缺点是有可能会使得镜像中的环境变量、开放端口、默认进入命令改变或消失.使用这种方式时,最好在生成镜像之后,创建一个`Dockerfile`文件,`From`这个镜像,并添加端口和命令入口\n3. 使用`docker-squash`压缩镜像,这个方法适用于Linux和Mac系统\n\n目前可以运行的镜像是13.6G\n![](./create-sniper-docker-image/Snipaste_2019-01-03_17-12-36.png)\n`hub.hoc.ccshu.net/wjs/sniper:v1.1`\n现在要对它进行压缩\n\n## 第一步,移除镜像内的SNIPER文件夹,把其放到FTP服务器上去\n\n- 开启一个容器`docker run -itd --name [name] [id]`\n- 复制容器内文件到本地`docker cp [长ID]:[容器内路径] [本地路径]`,将放置在本地的文件夹上传至FTP服务器\n- 进入容器`docker exec -it [name] /bin/bash`\n- 删除容器内文件夹`/SNIPER/`,使用`rm -rf SNIPER`,**一定要小心使用**\n- 退出容器`exit`\n\n## 第二步,压缩镜像\n\n压缩容器\n`docker export [ID] | docker import - [name]:[tag]`\n\n可以看到,镜像体积少了大约2个G\n![](./create-sniper-docker-image/Snipaste_2019-01-03_17-39-07.png)\n\n由于使用这种方法会使得镜像丢失部分信息,所以,创建一个新的`Dockerfile`,在其中添加缺失的信息\n\n## 第三步,完善镜像\n\n在任意位置新建`Dockerfile`\n输入\n```\nFROM [name]:[tag]\nEXPOSE 22\nENTRYPOINT [\"/usr/sbin/sshd\",\"-D\"]\n```\n![](./create-sniper-docker-image/Snipaste_2019-01-03_18-08-49.png)\n\n然后`docker build -t [name]:[tag] .`,不要忘了最后的`.`\n\n## 第四步 Push\n\n`docker push [name]:[tag]`\n\n至此,所有配置以及完成\n镜像在`hoc.hoc.ccshu.net`的私有仓库里\nSNIPER文件夹放置在机器学习平台服务器`mount`的目录里\n\n# 五 测试\n\n- 在平台上创建容器\n![](./create-sniper-docker-image/Snipaste_2019-01-03_18-11-49.png)\n\n- 耐心等待创建完成\n![](./create-sniper-docker-image/Snipaste_2019-01-03_18-14-21.png)\n\n- 创建成功\n![](./create-sniper-docker-image/Snipaste_2019-01-03_18-20-07.png)\n\n- 测试结果\n![](./create-sniper-docker-image/Snipaste_2019-01-03_18-31-16.png)\n**测试失败**\n\n**但是,使用未压缩的镜像测试成功**\n","source":"_posts/create-sniper-docker-image.md","raw":"---\ntitle: Build一个基于Mxnet的Sniper镜像\ncopyright: true\ntop: 1\ndate: 2019-01-02 21:58:44\ncategories:  Docker\ntags:\n- docker\n- mxnet\n- sniper\n\n---\n\n本文记录了如何在学校机器学习平台上创建一个基于Mxnet的Sniper镜像。\n\n<!--more-->\n\n# 说明\n\n由于此镜像是用于学校机器学习平台,所以文中会出现FTP服务器等字眼,其实是在平台上使用镜像创建一个容器时,平台会**自动**将服务器上我所申请的文件存储区`mount`到创建的容器,我通过`FileZilla`FTP工具与在平台申请的文件存储区进行连接\n​\t\n本文教程虽然有了一个FTP过程,但是如果是生成本地镜像,不考虑FTP,无视文中相关部分即可\n\n**虽然本文中写了关于压缩的相关内容,但是最终并没有使用压缩,原因是由于压缩后出现未知问题,导致在平台上创建的容器不能使用宿主机的NVIDIA驱动,并不能成功运行Demo**\n\n# 环境\n\n本机环境\n- windows 10 专业版\n- docker client version 18.09.0\n- docker server version 18.09.0\n- FTP工具 FileZilla\n\n平台环境\n- docker version 17.06.2-ce\n\n镜像环境\n- python 2.7.12\n- CUDA version 9.0.176\n- pip 9.0.3\n\n[SNIPER](https://github.com/mahyarnajibi/SNIPER)\n[机器学习平台](http://10.0.4.228),这是学校资源\n\n# 一 配置基础镜像\n\n从学校机器学习平台上拉取原始镜像,因为这个镜像配好了一些基本的环境,如python2.x,CUDA9.0等等,所以直接使用它们的镜像作为基础镜像比较省心省力\n`docker pull hub.hoc.ccshu.net/ces/deepo:all-py27-jupyter-ssh`\n\n拉取到镜像之后,可以选择使用`Dockerfile`来生成我们需要的镜像,但是往往我们需要在镜像中添加许多库/包/插件,而且使用`Dockerfile`来生成镜像很容易出BUG.当然,最好的方式是使用`Dockerfile`,前提是你能确保`Dockerfile`文件中的每一行命令都不会出错.\n在当前情况下,我选择使用从容器生成镜像的方法,这种方式会使得最终生成的镜像占内存巨大,但是可以在容器内部调试每一步配置过程.\n使用`docker run -itd --name [name] hub.hoc.ccshu.net/ces/deepo:all-py27-jupyter-ssh`开启一个容器\n\n使用`docker ps -a`查看正在运行的容器`ID`\n\n使用`docker exec -it [name] /bin/bash`进入容器\n\n在容器中使用`cat /etc/issue`命令查看容器的操作系统版本\n\n结果输出: `Ubuntu 16.04.4 LTS \\n \\l`\n\n## 安装 apt-file\n\n安装`apt-file`\n\n`apt-get install apt-file -y`\n\n出现错误:\n\n![](./create-sniper-docker-image/Snipaste_2019-01-03_08-30-41.png)\n\n使用`apt-get install apt-file -y --fix-missing`同样不能解决问题\n\n考虑**换源**\n\n`cp /etc/apt/sources.list /etc/apt/sources.list.bak`备份系统原有的源\n\n安装Linux下的文本编辑器`nano`,执行命令`apt-get install nano -y`\n安装`nano`成功后,执行`nano /etc/apt/sources.list`修改源文件\n在打开的文件中,将内容替换为\n```\n# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted\ndeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties\ndeb http://archive.canonical.com/ubuntu xenial partner\ndeb-src http://archive.canonical.com/ubuntu xenial partner\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse\n```\n\n这里使用的源是阿里的镜像站,也可以使用网易163的,源如下:\n```\ndeb http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse\ndeb http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse\ndeb http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse\ndeb http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse\ndeb http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse\ndeb-src http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse\ndeb-src http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse\ndeb-src http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse\ndeb-src http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse\n```\n\n更改好源文件后,执行`sudo apt-get update`更新源\n\n再次执行`apt-get install apt-file -y`,可以成功安装`apt-file`包\n\n之后执行`apt-file update`更新apt-file cache\n使用`apt-file find [name]`可以查找计算机上文件的位置,很方便\n使用`apt-file search [name]`可以搜索缺少的库,解决文件缺失依赖\n选择好自己需要的包,然后使用`apt-get install [name]`即可\n\n- 如果需要把镜像上传到云上使用,有可能需要网络服务,\n- 执行`apt-get install net-tools`安装ifconfig\n- 执行`apt-get install iputils-ping`安装ping\n\n此时为了避免诸如使用`ping [IP]`有效,但是`ping [HOST]`无效的情况,需要使用`nano /etc/resolv.conf`修改配置文件\n将`namespace`后的IP地址更改为`8.8.8.8`或者`4.4.4.4`\n*或者使用`echo \"nameserver 114.114.114.114 > /etc/resolv.conf\"`也可以*\n退出保存即可\n\n*有可能上述修改DNS的方式并不成功,原因是在云上运行容器时,配置文件自动修改,如果发生这种情况,请每次在新开一个容器时,手动修改配置文件的DNS服务器,使其可以使用网络服务*\n\n# 二 安装编译依赖各种包\n\n在电脑上空闲的地方,从Github拉取Sniper项目\n\n`git clone --recursive https://github.com/mahyarnajibi/SNIPER.git`\n\n- 因为我是在学校机器学习平台上运行docker容器,所以选择直接将clone下的文件上传至容器`mount`的ftp服务器,使用的软件是`FileZilla`\n\n- 上传成功后可以在容器内通过`cd /data/[file or folder name]`进行访问\n\n如果要在本地镜像内操作的话,也可以直接把本机文件或文件夹拷贝过去\n`docker cp 本地文件路径 ID全称:容器路径`\n\n---\n\n`cd /data/SNIPER/SNIPER-mxnet`\n`make USE_CUDA_PATH=/usr/local/cuda-9.0`\n输出信息:\n![](./create-sniper-docker-image/Snipaste_2019-01-03_09-42-07.png)\n\n## 安装 jemalloc\n\n选择安装`jemalloc`,这个工具可以加速编译,碎片整理,具体请自行谷歌\n- `apt-get install autoconf`\n- `apt-get install automake`\n- `apt-get install libtool`\n- `git clone https://github.com/jemalloc/jemalloc.git`\n- `cd jemalloc`\n- `git checkout 4.5.0`安装4.5.0版本的jemalloc,5.x版本的有坑,深坑\n- `./autogen.sh`\n- `make`\n- `make install_bin install_include install_lib`,之所以不使用`make install`是因为会报错,如下: ![](./create-sniper-docker-image/Snipaste_2019-01-03_09-56-41.png)\n\n切换至`SNIPER-mxnet`文件夹,再次`make USE_CUDA_PATH=/usr/local/cuda-9.0`\n虽然可以编译,但是有以下信息: \n![](./create-sniper-docker-image/Snipaste_2019-01-03_10-03-30.png)\n强迫症必须搞定它,果断`ctrl+c`终止编译\n\n## 安装 pkg-config\n\n- 打开[https://pkg-config.freedesktop.org/releases/](https://pkg-config.freedesktop.org/releases/)\n- 下载最新的,现在看到的是`pkg-config-0.29.2.tar.gz`\n- 下载好之后,通过`FileZilla`等工具传输到FTP服务器\n- 在容器内`cd`到压缩包位置\n- `tar -xf pkg-config-0.29.2.tar.gz`\n- `cd pkg-config-0.29.2`\n- `./configure --with-internal-glib`,注意,中间是一个空格,非常关键\n- `make && make install`\n![](./create-sniper-docker-image/Snipaste_2019-01-03_10-11-01.png)\n\n再次`make USE_CUDA_PATH=/usr/local/cuda-9.0`\n算了，还是安装一下cudnn吧\n\n## 安装 cudnn7.0\n- [https://developer.nvidia.com/rdp/cudnn-archive](https://developer.nvidia.com/rdp/cudnn-archive) 下载cuDNN Libraries for Linux,不要下载 Power 8\n- 把下载好的包上传到FTP服务器\n- `cd`到包位置\n- `cp cudnn-9.0-linux-x64-v7.solitairetheme8 cudnn-9.0-linux-x64-v7.tgz`\n- `tar -xvf cudnn-9.0-linux-x64-v7.tgz`\n- `cp include/* /usr/local/cuda-9.0/include`\n- `cp lib64/* /usr/local/cuda-9.0/lib64`\n- `chmod a+r /usr/local/cuda-9.0/include/cudnn.h /usr/local/cuda-9.0/lib64/libcudnn*`\n- `export PATH=/usr/local/cuda-9.0/bin:$PATH`\n- `cd`到`/usr/local/cuda-9.0/lib64`\n- `nano ~/.bashrc`,关联环境变量\n- 在最后一行加入`export LD_LIBRARY_PATH=/home/cuda/lib64:$LD_LIBRARY_PATH`\n- `source ~/.bashrc`\n- `ldconfig -v`\n- 使用`cat /usr/local/cuda-9.0/include/cudnn.h | grep CUDNN_MAJOR -A 2` 查看cudnn版本\n![](./create-sniper-docker-image/Snipaste_2019-01-03_10-56-08.png)\n\n## 安装 OpenCV\n- 使用`pkg-config opencv --modversion`查看\n- 发现已经有OpenCV\n![](./create-sniper-docker-image/Snipaste_2019-01-03_10-57-56.png)\n\n## 安装 OpenBLAS\n- `apt-get install libopenblas-dev`\n\n## 编译 Mxnet\n\n`make USE_CUDA_PATH=/usr/local/cuda-9.0`\n![](./create-sniper-docker-image/Snipaste_2019-01-03_13-49-28.png)\n\n**心好累,总共make了将近两个半小时**\n\n编译`c++`文件`bash scripts/compile.sh`\n这一步一定要在`/SNIPER/`文件夹下,不然贼坑,绝对不要`cd`到`/SNIPER/scripts`文件夹下再`bash compile.sh`,因为代码内有`cd lib/nms`等,如果不在`/SNIPER`文件夹下,会找不到文件\n\n如果出现`syntax error near unexpected token `$'\\r''`错误,可以使用`sed`命令将`\\r`去掉,或者是在[Github](https://github.com/mahyarnajibi/SNIPER/blob/master/scripts/compile.sh)上将代码复制,使用`nano`编辑然后粘贴\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-32-08.png)\n可以使用`cat -v [filename]`查看\n![]./create-sniper-docker-image/Snipaste_2019-01-03_16-33-27.png)\n以`^M`结尾的代表你所处理的文件换行符是dos格式的`\"\\r\\n\"`\n\n我选择第二种笨方法,因为涉及的代码并不多\n\n执行结果:\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-24-49.png)\n\n## 安装 dos2unix\n\n由于发现这种简单的复制粘贴方式并不能很好的解决,所以查了一些[相关资料](https://blog.csdn.net/lovelovelovelovelo/article/details/79239068)\n选择使用`dos2unix`来转换\n\n- `apt-get install dos2unix`\n- `dos2unix [filename]`\n\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-40-53.png)\n问题解决啦\n\n## 安装依赖\n\n在`/SNIPER/`文件夹下`pip install -r requirements.txt`\n一定要确保镜像内可以联网\n\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-29-58.png)\n\n## 测试Demo\n\n- `bash download_sniper_detector.sh`,download_sniper_detector.sh\n文件在`/SNIPER/scripts`文件夹下\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-44-22.png)\n- `cd .. && python demo.py`\n![](./create-sniper-docker-image/Snipaste_2019-01-03_17-05-30.png)\n\n**运行成功!!!**\n\n# 三 生成镜像\n- 使用`exit`退出容器\n- 使用`docker ps -a`查看容器ID\n- 使用`docker stop [ID]`停止容器\n- 使用`docker commit -a \"作者信息\" -m \"附带信息\" [ID] [name]:[tag]`生成镜像,会返回一个`sha256`开头的长ID,这个就是生成的镜像ID\n- 使用`docker images`查看生成的镜像\n- 如果需要的话,使用`docker push [name]:[tag]`将刚刚生成的镜像推送到云上\n\n# 四 压缩镜像\n\n**压缩镜像非常麻烦,但是也是有方法的,目前大概三种方法**\n\n1. 使用`Dockerfile`生成镜像\n2. 这种方法需要让容器在运行状态,使用`docker export [ID] | docker import - [name]:[tag]`导出容器快照,并从快照生成镜像,这种方式可以大大压缩镜像,但是缺点是有可能会使得镜像中的环境变量、开放端口、默认进入命令改变或消失.使用这种方式时,最好在生成镜像之后,创建一个`Dockerfile`文件,`From`这个镜像,并添加端口和命令入口\n3. 使用`docker-squash`压缩镜像,这个方法适用于Linux和Mac系统\n\n目前可以运行的镜像是13.6G\n![](./create-sniper-docker-image/Snipaste_2019-01-03_17-12-36.png)\n`hub.hoc.ccshu.net/wjs/sniper:v1.1`\n现在要对它进行压缩\n\n## 第一步,移除镜像内的SNIPER文件夹,把其放到FTP服务器上去\n\n- 开启一个容器`docker run -itd --name [name] [id]`\n- 复制容器内文件到本地`docker cp [长ID]:[容器内路径] [本地路径]`,将放置在本地的文件夹上传至FTP服务器\n- 进入容器`docker exec -it [name] /bin/bash`\n- 删除容器内文件夹`/SNIPER/`,使用`rm -rf SNIPER`,**一定要小心使用**\n- 退出容器`exit`\n\n## 第二步,压缩镜像\n\n压缩容器\n`docker export [ID] | docker import - [name]:[tag]`\n\n可以看到,镜像体积少了大约2个G\n![](./create-sniper-docker-image/Snipaste_2019-01-03_17-39-07.png)\n\n由于使用这种方法会使得镜像丢失部分信息,所以,创建一个新的`Dockerfile`,在其中添加缺失的信息\n\n## 第三步,完善镜像\n\n在任意位置新建`Dockerfile`\n输入\n```\nFROM [name]:[tag]\nEXPOSE 22\nENTRYPOINT [\"/usr/sbin/sshd\",\"-D\"]\n```\n![](./create-sniper-docker-image/Snipaste_2019-01-03_18-08-49.png)\n\n然后`docker build -t [name]:[tag] .`,不要忘了最后的`.`\n\n## 第四步 Push\n\n`docker push [name]:[tag]`\n\n至此,所有配置以及完成\n镜像在`hoc.hoc.ccshu.net`的私有仓库里\nSNIPER文件夹放置在机器学习平台服务器`mount`的目录里\n\n# 五 测试\n\n- 在平台上创建容器\n![](./create-sniper-docker-image/Snipaste_2019-01-03_18-11-49.png)\n\n- 耐心等待创建完成\n![](./create-sniper-docker-image/Snipaste_2019-01-03_18-14-21.png)\n\n- 创建成功\n![](./create-sniper-docker-image/Snipaste_2019-01-03_18-20-07.png)\n\n- 测试结果\n![](./create-sniper-docker-image/Snipaste_2019-01-03_18-31-16.png)\n**测试失败**\n\n**但是,使用未压缩的镜像测试成功**\n","slug":"create-sniper-docker-image","published":1,"updated":"2019-05-13T14:27:05.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut8p004n20cd9evxpgtz","content":"<p>本文记录了如何在学校机器学习平台上创建一个基于Mxnet的Sniper镜像。</p>\n<a id=\"more\"></a>\n<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>由于此镜像是用于学校机器学习平台,所以文中会出现FTP服务器等字眼,其实是在平台上使用镜像创建一个容器时,平台会<strong>自动</strong>将服务器上我所申请的文件存储区<code>mount</code>到创建的容器,我通过<code>FileZilla</code>FTP工具与在平台申请的文件存储区进行连接<br>​<br>本文教程虽然有了一个FTP过程,但是如果是生成本地镜像,不考虑FTP,无视文中相关部分即可</p>\n<p><strong>虽然本文中写了关于压缩的相关内容,但是最终并没有使用压缩,原因是由于压缩后出现未知问题,导致在平台上创建的容器不能使用宿主机的NVIDIA驱动,并不能成功运行Demo</strong></p>\n<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><p>本机环境</p>\n<ul>\n<li>windows 10 专业版</li>\n<li>docker client version 18.09.0</li>\n<li>docker server version 18.09.0</li>\n<li>FTP工具 FileZilla</li>\n</ul>\n<p>平台环境</p>\n<ul>\n<li>docker version 17.06.2-ce</li>\n</ul>\n<p>镜像环境</p>\n<ul>\n<li>python 2.7.12</li>\n<li>CUDA version 9.0.176</li>\n<li>pip 9.0.3</li>\n</ul>\n<p><a href=\"https://github.com/mahyarnajibi/SNIPER\" rel=\"external nofollow\" target=\"_blank\">SNIPER</a><br><a href=\"http://10.0.4.228\" rel=\"external nofollow\" target=\"_blank\">机器学习平台</a>,这是学校资源</p>\n<h1 id=\"一-配置基础镜像\"><a href=\"#一-配置基础镜像\" class=\"headerlink\" title=\"一 配置基础镜像\"></a>一 配置基础镜像</h1><p>从学校机器学习平台上拉取原始镜像,因为这个镜像配好了一些基本的环境,如python2.x,CUDA9.0等等,所以直接使用它们的镜像作为基础镜像比较省心省力<br><code>docker pull hub.hoc.ccshu.net/ces/deepo:all-py27-jupyter-ssh</code></p>\n<p>拉取到镜像之后,可以选择使用<code>Dockerfile</code>来生成我们需要的镜像,但是往往我们需要在镜像中添加许多库/包/插件,而且使用<code>Dockerfile</code>来生成镜像很容易出BUG.当然,最好的方式是使用<code>Dockerfile</code>,前提是你能确保<code>Dockerfile</code>文件中的每一行命令都不会出错.<br>在当前情况下,我选择使用从容器生成镜像的方法,这种方式会使得最终生成的镜像占内存巨大,但是可以在容器内部调试每一步配置过程.<br>使用<code>docker run -itd --name [name] hub.hoc.ccshu.net/ces/deepo:all-py27-jupyter-ssh</code>开启一个容器</p>\n<p>使用<code>docker ps -a</code>查看正在运行的容器<code>ID</code></p>\n<p>使用<code>docker exec -it [name] /bin/bash</code>进入容器</p>\n<p>在容器中使用<code>cat /etc/issue</code>命令查看容器的操作系统版本</p>\n<p>结果输出: <code>Ubuntu 16.04.4 LTS \\n \\l</code></p>\n<h2 id=\"安装-apt-file\"><a href=\"#安装-apt-file\" class=\"headerlink\" title=\"安装 apt-file\"></a>安装 apt-file</h2><p>安装<code>apt-file</code></p>\n<p><code>apt-get install apt-file -y</code></p>\n<p>出现错误:</p>\n<p><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_08-30-41.png\" alt=\"\"></p>\n<p>使用<code>apt-get install apt-file -y --fix-missing</code>同样不能解决问题</p>\n<p>考虑<strong>换源</strong></p>\n<p><code>cp /etc/apt/sources.list /etc/apt/sources.list.bak</code>备份系统原有的源</p>\n<p>安装Linux下的文本编辑器<code>nano</code>,执行命令<code>apt-get install nano -y</code><br>安装<code>nano</code>成功后,执行<code>nano /etc/apt/sources.list</code>修改源文件<br>在打开的文件中,将内容替换为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span><br><span class=\"line\">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class=\"line\">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure></p>\n<p>这里使用的源是阿里的镜像站,也可以使用网易163的,源如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></p>\n<p>更改好源文件后,执行<code>sudo apt-get update</code>更新源</p>\n<p>再次执行<code>apt-get install apt-file -y</code>,可以成功安装<code>apt-file</code>包</p>\n<p>之后执行<code>apt-file update</code>更新apt-file cache<br>使用<code>apt-file find [name]</code>可以查找计算机上文件的位置,很方便<br>使用<code>apt-file search [name]</code>可以搜索缺少的库,解决文件缺失依赖<br>选择好自己需要的包,然后使用<code>apt-get install [name]</code>即可</p>\n<ul>\n<li>如果需要把镜像上传到云上使用,有可能需要网络服务,</li>\n<li>执行<code>apt-get install net-tools</code>安装ifconfig</li>\n<li>执行<code>apt-get install iputils-ping</code>安装ping</li>\n</ul>\n<p>此时为了避免诸如使用<code>ping [IP]</code>有效,但是<code>ping [HOST]</code>无效的情况,需要使用<code>nano /etc/resolv.conf</code>修改配置文件<br>将<code>namespace</code>后的IP地址更改为<code>8.8.8.8</code>或者<code>4.4.4.4</code><br><em>或者使用<code>echo &quot;nameserver 114.114.114.114 &gt; /etc/resolv.conf&quot;</code>也可以</em><br>退出保存即可</p>\n<p><em>有可能上述修改DNS的方式并不成功,原因是在云上运行容器时,配置文件自动修改,如果发生这种情况,请每次在新开一个容器时,手动修改配置文件的DNS服务器,使其可以使用网络服务</em></p>\n<h1 id=\"二-安装编译依赖各种包\"><a href=\"#二-安装编译依赖各种包\" class=\"headerlink\" title=\"二 安装编译依赖各种包\"></a>二 安装编译依赖各种包</h1><p>在电脑上空闲的地方,从Github拉取Sniper项目</p>\n<p><code>git clone --recursive https://github.com/mahyarnajibi/SNIPER.git</code></p>\n<ul>\n<li><p>因为我是在学校机器学习平台上运行docker容器,所以选择直接将clone下的文件上传至容器<code>mount</code>的ftp服务器,使用的软件是<code>FileZilla</code></p>\n</li>\n<li><p>上传成功后可以在容器内通过<code>cd /data/[file or folder name]</code>进行访问</p>\n</li>\n</ul>\n<p>如果要在本地镜像内操作的话,也可以直接把本机文件或文件夹拷贝过去<br><code>docker cp 本地文件路径 ID全称:容器路径</code></p>\n<hr>\n<p><code>cd /data/SNIPER/SNIPER-mxnet</code><br><code>make USE_CUDA_PATH=/usr/local/cuda-9.0</code><br>输出信息:<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_09-42-07.png\" alt=\"\"></p>\n<h2 id=\"安装-jemalloc\"><a href=\"#安装-jemalloc\" class=\"headerlink\" title=\"安装 jemalloc\"></a>安装 jemalloc</h2><p>选择安装<code>jemalloc</code>,这个工具可以加速编译,碎片整理,具体请自行谷歌</p>\n<ul>\n<li><code>apt-get install autoconf</code></li>\n<li><code>apt-get install automake</code></li>\n<li><code>apt-get install libtool</code></li>\n<li><code>git clone https://github.com/jemalloc/jemalloc.git</code></li>\n<li><code>cd jemalloc</code></li>\n<li><code>git checkout 4.5.0</code>安装4.5.0版本的jemalloc,5.x版本的有坑,深坑</li>\n<li><code>./autogen.sh</code></li>\n<li><code>make</code></li>\n<li><code>make install_bin install_include install_lib</code>,之所以不使用<code>make install</code>是因为会报错,如下: <img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_09-56-41.png\" alt=\"\"></li>\n</ul>\n<p>切换至<code>SNIPER-mxnet</code>文件夹,再次<code>make USE_CUDA_PATH=/usr/local/cuda-9.0</code><br>虽然可以编译,但是有以下信息:<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_10-03-30.png\" alt=\"\"><br>强迫症必须搞定它,果断<code>ctrl+c</code>终止编译</p>\n<h2 id=\"安装-pkg-config\"><a href=\"#安装-pkg-config\" class=\"headerlink\" title=\"安装 pkg-config\"></a>安装 pkg-config</h2><ul>\n<li>打开<a href=\"https://pkg-config.freedesktop.org/releases/\" rel=\"external nofollow\" target=\"_blank\">https://pkg-config.freedesktop.org/releases/</a></li>\n<li>下载最新的,现在看到的是<code>pkg-config-0.29.2.tar.gz</code></li>\n<li>下载好之后,通过<code>FileZilla</code>等工具传输到FTP服务器</li>\n<li>在容器内<code>cd</code>到压缩包位置</li>\n<li><code>tar -xf pkg-config-0.29.2.tar.gz</code></li>\n<li><code>cd pkg-config-0.29.2</code></li>\n<li><code>./configure --with-internal-glib</code>,注意,中间是一个空格,非常关键</li>\n<li><code>make &amp;&amp; make install</code><br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_10-11-01.png\" alt=\"\"></li>\n</ul>\n<p>再次<code>make USE_CUDA_PATH=/usr/local/cuda-9.0</code><br>算了，还是安装一下cudnn吧</p>\n<h2 id=\"安装-cudnn7-0\"><a href=\"#安装-cudnn7-0\" class=\"headerlink\" title=\"安装 cudnn7.0\"></a>安装 cudnn7.0</h2><ul>\n<li><a href=\"https://developer.nvidia.com/rdp/cudnn-archive\" rel=\"external nofollow\" target=\"_blank\">https://developer.nvidia.com/rdp/cudnn-archive</a> 下载cuDNN Libraries for Linux,不要下载 Power 8</li>\n<li>把下载好的包上传到FTP服务器</li>\n<li><code>cd</code>到包位置</li>\n<li><code>cp cudnn-9.0-linux-x64-v7.solitairetheme8 cudnn-9.0-linux-x64-v7.tgz</code></li>\n<li><code>tar -xvf cudnn-9.0-linux-x64-v7.tgz</code></li>\n<li><code>cp include/* /usr/local/cuda-9.0/include</code></li>\n<li><code>cp lib64/* /usr/local/cuda-9.0/lib64</code></li>\n<li><code>chmod a+r /usr/local/cuda-9.0/include/cudnn.h /usr/local/cuda-9.0/lib64/libcudnn*</code></li>\n<li><code>export PATH=/usr/local/cuda-9.0/bin:$PATH</code></li>\n<li><code>cd</code>到<code>/usr/local/cuda-9.0/lib64</code></li>\n<li><code>nano ~/.bashrc</code>,关联环境变量</li>\n<li>在最后一行加入<code>export LD_LIBRARY_PATH=/home/cuda/lib64:$LD_LIBRARY_PATH</code></li>\n<li><code>source ~/.bashrc</code></li>\n<li><code>ldconfig -v</code></li>\n<li>使用<code>cat /usr/local/cuda-9.0/include/cudnn.h | grep CUDNN_MAJOR -A 2</code> 查看cudnn版本<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_10-56-08.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"安装-OpenCV\"><a href=\"#安装-OpenCV\" class=\"headerlink\" title=\"安装 OpenCV\"></a>安装 OpenCV</h2><ul>\n<li>使用<code>pkg-config opencv --modversion</code>查看</li>\n<li>发现已经有OpenCV<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_10-57-56.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"安装-OpenBLAS\"><a href=\"#安装-OpenBLAS\" class=\"headerlink\" title=\"安装 OpenBLAS\"></a>安装 OpenBLAS</h2><ul>\n<li><code>apt-get install libopenblas-dev</code></li>\n</ul>\n<h2 id=\"编译-Mxnet\"><a href=\"#编译-Mxnet\" class=\"headerlink\" title=\"编译 Mxnet\"></a>编译 Mxnet</h2><p><code>make USE_CUDA_PATH=/usr/local/cuda-9.0</code><br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_13-49-28.png\" alt=\"\"></p>\n<p><strong>心好累,总共make了将近两个半小时</strong></p>\n<p>编译<code>c++</code>文件<code>bash scripts/compile.sh</code><br>这一步一定要在<code>/SNIPER/</code>文件夹下,不然贼坑,绝对不要<code>cd</code>到<code>/SNIPER/scripts</code>文件夹下再<code>bash compile.sh</code>,因为代码内有<code>cd lib/nms</code>等,如果不在<code>/SNIPER</code>文件夹下,会找不到文件</p>\n<p>如果出现<code>syntax error near unexpected token</code>$’\\r’’<code>错误,可以使用</code>sed<code>命令将</code>\\r<code>去掉,或者是在[Github](https://github.com/mahyarnajibi/SNIPER/blob/master/scripts/compile.sh)上将代码复制,使用</code>nano<code>编辑然后粘贴\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-32-08.png)\n可以使用</code>cat -v [filename]<code>查看\n![]./create-sniper-docker-image/Snipaste_2019-01-03_16-33-27.png)\n以</code>^M<code>结尾的代表你所处理的文件换行符是dos格式的</code>“\\r\\n”`</p>\n<p>我选择第二种笨方法,因为涉及的代码并不多</p>\n<p>执行结果:<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_16-24-49.png\" alt=\"\"></p>\n<h2 id=\"安装-dos2unix\"><a href=\"#安装-dos2unix\" class=\"headerlink\" title=\"安装 dos2unix\"></a>安装 dos2unix</h2><p>由于发现这种简单的复制粘贴方式并不能很好的解决,所以查了一些<a href=\"https://blog.csdn.net/lovelovelovelovelo/article/details/79239068\" rel=\"external nofollow\" target=\"_blank\">相关资料</a><br>选择使用<code>dos2unix</code>来转换</p>\n<ul>\n<li><code>apt-get install dos2unix</code></li>\n<li><code>dos2unix [filename]</code></li>\n</ul>\n<p><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_16-40-53.png\" alt=\"\"><br>问题解决啦</p>\n<h2 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h2><p>在<code>/SNIPER/</code>文件夹下<code>pip install -r requirements.txt</code><br>一定要确保镜像内可以联网</p>\n<p><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_16-29-58.png\" alt=\"\"></p>\n<h2 id=\"测试Demo\"><a href=\"#测试Demo\" class=\"headerlink\" title=\"测试Demo\"></a>测试Demo</h2><ul>\n<li><code>bash download_sniper_detector.sh</code>,download_sniper_detector.sh<br>文件在<code>/SNIPER/scripts</code>文件夹下<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_16-44-22.png\" alt=\"\"></li>\n<li><code>cd .. &amp;&amp; python demo.py</code><br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_17-05-30.png\" alt=\"\"></li>\n</ul>\n<p><strong>运行成功!!!</strong></p>\n<h1 id=\"三-生成镜像\"><a href=\"#三-生成镜像\" class=\"headerlink\" title=\"三 生成镜像\"></a>三 生成镜像</h1><ul>\n<li>使用<code>exit</code>退出容器</li>\n<li>使用<code>docker ps -a</code>查看容器ID</li>\n<li>使用<code>docker stop [ID]</code>停止容器</li>\n<li>使用<code>docker commit -a &quot;作者信息&quot; -m &quot;附带信息&quot; [ID] [name]:[tag]</code>生成镜像,会返回一个<code>sha256</code>开头的长ID,这个就是生成的镜像ID</li>\n<li>使用<code>docker images</code>查看生成的镜像</li>\n<li>如果需要的话,使用<code>docker push [name]:[tag]</code>将刚刚生成的镜像推送到云上</li>\n</ul>\n<h1 id=\"四-压缩镜像\"><a href=\"#四-压缩镜像\" class=\"headerlink\" title=\"四 压缩镜像\"></a>四 压缩镜像</h1><p><strong>压缩镜像非常麻烦,但是也是有方法的,目前大概三种方法</strong></p>\n<ol>\n<li>使用<code>Dockerfile</code>生成镜像</li>\n<li>这种方法需要让容器在运行状态,使用<code>docker export [ID] | docker import - [name]:[tag]</code>导出容器快照,并从快照生成镜像,这种方式可以大大压缩镜像,但是缺点是有可能会使得镜像中的环境变量、开放端口、默认进入命令改变或消失.使用这种方式时,最好在生成镜像之后,创建一个<code>Dockerfile</code>文件,<code>From</code>这个镜像,并添加端口和命令入口</li>\n<li>使用<code>docker-squash</code>压缩镜像,这个方法适用于Linux和Mac系统</li>\n</ol>\n<p>目前可以运行的镜像是13.6G<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_17-12-36.png\" alt=\"\"><br><code>hub.hoc.ccshu.net/wjs/sniper:v1.1</code><br>现在要对它进行压缩</p>\n<h2 id=\"第一步-移除镜像内的SNIPER文件夹-把其放到FTP服务器上去\"><a href=\"#第一步-移除镜像内的SNIPER文件夹-把其放到FTP服务器上去\" class=\"headerlink\" title=\"第一步,移除镜像内的SNIPER文件夹,把其放到FTP服务器上去\"></a>第一步,移除镜像内的SNIPER文件夹,把其放到FTP服务器上去</h2><ul>\n<li>开启一个容器<code>docker run -itd --name [name] [id]</code></li>\n<li>复制容器内文件到本地<code>docker cp [长ID]:[容器内路径] [本地路径]</code>,将放置在本地的文件夹上传至FTP服务器</li>\n<li>进入容器<code>docker exec -it [name] /bin/bash</code></li>\n<li>删除容器内文件夹<code>/SNIPER/</code>,使用<code>rm -rf SNIPER</code>,<strong>一定要小心使用</strong></li>\n<li>退出容器<code>exit</code></li>\n</ul>\n<h2 id=\"第二步-压缩镜像\"><a href=\"#第二步-压缩镜像\" class=\"headerlink\" title=\"第二步,压缩镜像\"></a>第二步,压缩镜像</h2><p>压缩容器<br><code>docker export [ID] | docker import - [name]:[tag]</code></p>\n<p>可以看到,镜像体积少了大约2个G<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_17-39-07.png\" alt=\"\"></p>\n<p>由于使用这种方法会使得镜像丢失部分信息,所以,创建一个新的<code>Dockerfile</code>,在其中添加缺失的信息</p>\n<h2 id=\"第三步-完善镜像\"><a href=\"#第三步-完善镜像\" class=\"headerlink\" title=\"第三步,完善镜像\"></a>第三步,完善镜像</h2><p>在任意位置新建<code>Dockerfile</code><br>输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM [name]:[tag]</span><br><span class=\"line\">EXPOSE 22</span><br><span class=\"line\">ENTRYPOINT [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_18-08-49.png\" alt=\"\"></p>\n<p>然后<code>docker build -t [name]:[tag] .</code>,不要忘了最后的<code>.</code></p>\n<h2 id=\"第四步-Push\"><a href=\"#第四步-Push\" class=\"headerlink\" title=\"第四步 Push\"></a>第四步 Push</h2><p><code>docker push [name]:[tag]</code></p>\n<p>至此,所有配置以及完成<br>镜像在<code>hoc.hoc.ccshu.net</code>的私有仓库里<br>SNIPER文件夹放置在机器学习平台服务器<code>mount</code>的目录里</p>\n<h1 id=\"五-测试\"><a href=\"#五-测试\" class=\"headerlink\" title=\"五 测试\"></a>五 测试</h1><ul>\n<li><p>在平台上创建容器<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_18-11-49.png\" alt=\"\"></p>\n</li>\n<li><p>耐心等待创建完成<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_18-14-21.png\" alt=\"\"></p>\n</li>\n<li><p>创建成功<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_18-20-07.png\" alt=\"\"></p>\n</li>\n<li><p>测试结果<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_18-31-16.png\" alt=\"\"><br><strong>测试失败</strong></p>\n</li>\n</ul>\n<p><strong>但是,使用未压缩的镜像测试成功</strong></p>\n","site":{"data":{}},"excerpt":"<p>本文记录了如何在学校机器学习平台上创建一个基于Mxnet的Sniper镜像。</p>","more":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>由于此镜像是用于学校机器学习平台,所以文中会出现FTP服务器等字眼,其实是在平台上使用镜像创建一个容器时,平台会<strong>自动</strong>将服务器上我所申请的文件存储区<code>mount</code>到创建的容器,我通过<code>FileZilla</code>FTP工具与在平台申请的文件存储区进行连接<br>​<br>本文教程虽然有了一个FTP过程,但是如果是生成本地镜像,不考虑FTP,无视文中相关部分即可</p>\n<p><strong>虽然本文中写了关于压缩的相关内容,但是最终并没有使用压缩,原因是由于压缩后出现未知问题,导致在平台上创建的容器不能使用宿主机的NVIDIA驱动,并不能成功运行Demo</strong></p>\n<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><p>本机环境</p>\n<ul>\n<li>windows 10 专业版</li>\n<li>docker client version 18.09.0</li>\n<li>docker server version 18.09.0</li>\n<li>FTP工具 FileZilla</li>\n</ul>\n<p>平台环境</p>\n<ul>\n<li>docker version 17.06.2-ce</li>\n</ul>\n<p>镜像环境</p>\n<ul>\n<li>python 2.7.12</li>\n<li>CUDA version 9.0.176</li>\n<li>pip 9.0.3</li>\n</ul>\n<p><a href=\"https://github.com/mahyarnajibi/SNIPER\" rel=\"external nofollow\" target=\"_blank\">SNIPER</a><br><a href=\"http://10.0.4.228\" rel=\"external nofollow\" target=\"_blank\">机器学习平台</a>,这是学校资源</p>\n<h1 id=\"一-配置基础镜像\"><a href=\"#一-配置基础镜像\" class=\"headerlink\" title=\"一 配置基础镜像\"></a>一 配置基础镜像</h1><p>从学校机器学习平台上拉取原始镜像,因为这个镜像配好了一些基本的环境,如python2.x,CUDA9.0等等,所以直接使用它们的镜像作为基础镜像比较省心省力<br><code>docker pull hub.hoc.ccshu.net/ces/deepo:all-py27-jupyter-ssh</code></p>\n<p>拉取到镜像之后,可以选择使用<code>Dockerfile</code>来生成我们需要的镜像,但是往往我们需要在镜像中添加许多库/包/插件,而且使用<code>Dockerfile</code>来生成镜像很容易出BUG.当然,最好的方式是使用<code>Dockerfile</code>,前提是你能确保<code>Dockerfile</code>文件中的每一行命令都不会出错.<br>在当前情况下,我选择使用从容器生成镜像的方法,这种方式会使得最终生成的镜像占内存巨大,但是可以在容器内部调试每一步配置过程.<br>使用<code>docker run -itd --name [name] hub.hoc.ccshu.net/ces/deepo:all-py27-jupyter-ssh</code>开启一个容器</p>\n<p>使用<code>docker ps -a</code>查看正在运行的容器<code>ID</code></p>\n<p>使用<code>docker exec -it [name] /bin/bash</code>进入容器</p>\n<p>在容器中使用<code>cat /etc/issue</code>命令查看容器的操作系统版本</p>\n<p>结果输出: <code>Ubuntu 16.04.4 LTS \\n \\l</code></p>\n<h2 id=\"安装-apt-file\"><a href=\"#安装-apt-file\" class=\"headerlink\" title=\"安装 apt-file\"></a>安装 apt-file</h2><p>安装<code>apt-file</code></p>\n<p><code>apt-get install apt-file -y</code></p>\n<p>出现错误:</p>\n<p><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_08-30-41.png\" alt=\"\"></p>\n<p>使用<code>apt-get install apt-file -y --fix-missing</code>同样不能解决问题</p>\n<p>考虑<strong>换源</strong></p>\n<p><code>cp /etc/apt/sources.list /etc/apt/sources.list.bak</code>备份系统原有的源</p>\n<p>安装Linux下的文本编辑器<code>nano</code>,执行命令<code>apt-get install nano -y</code><br>安装<code>nano</code>成功后,执行<code>nano /etc/apt/sources.list</code>修改源文件<br>在打开的文件中,将内容替换为<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span><br><span class=\"line\">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class=\"line\">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure></p>\n<p>这里使用的源是阿里的镜像站,也可以使用网易163的,源如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deb http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class=\"line\">deb http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.163.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.163.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.163.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.163.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.163.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></p>\n<p>更改好源文件后,执行<code>sudo apt-get update</code>更新源</p>\n<p>再次执行<code>apt-get install apt-file -y</code>,可以成功安装<code>apt-file</code>包</p>\n<p>之后执行<code>apt-file update</code>更新apt-file cache<br>使用<code>apt-file find [name]</code>可以查找计算机上文件的位置,很方便<br>使用<code>apt-file search [name]</code>可以搜索缺少的库,解决文件缺失依赖<br>选择好自己需要的包,然后使用<code>apt-get install [name]</code>即可</p>\n<ul>\n<li>如果需要把镜像上传到云上使用,有可能需要网络服务,</li>\n<li>执行<code>apt-get install net-tools</code>安装ifconfig</li>\n<li>执行<code>apt-get install iputils-ping</code>安装ping</li>\n</ul>\n<p>此时为了避免诸如使用<code>ping [IP]</code>有效,但是<code>ping [HOST]</code>无效的情况,需要使用<code>nano /etc/resolv.conf</code>修改配置文件<br>将<code>namespace</code>后的IP地址更改为<code>8.8.8.8</code>或者<code>4.4.4.4</code><br><em>或者使用<code>echo &quot;nameserver 114.114.114.114 &gt; /etc/resolv.conf&quot;</code>也可以</em><br>退出保存即可</p>\n<p><em>有可能上述修改DNS的方式并不成功,原因是在云上运行容器时,配置文件自动修改,如果发生这种情况,请每次在新开一个容器时,手动修改配置文件的DNS服务器,使其可以使用网络服务</em></p>\n<h1 id=\"二-安装编译依赖各种包\"><a href=\"#二-安装编译依赖各种包\" class=\"headerlink\" title=\"二 安装编译依赖各种包\"></a>二 安装编译依赖各种包</h1><p>在电脑上空闲的地方,从Github拉取Sniper项目</p>\n<p><code>git clone --recursive https://github.com/mahyarnajibi/SNIPER.git</code></p>\n<ul>\n<li><p>因为我是在学校机器学习平台上运行docker容器,所以选择直接将clone下的文件上传至容器<code>mount</code>的ftp服务器,使用的软件是<code>FileZilla</code></p>\n</li>\n<li><p>上传成功后可以在容器内通过<code>cd /data/[file or folder name]</code>进行访问</p>\n</li>\n</ul>\n<p>如果要在本地镜像内操作的话,也可以直接把本机文件或文件夹拷贝过去<br><code>docker cp 本地文件路径 ID全称:容器路径</code></p>\n<hr>\n<p><code>cd /data/SNIPER/SNIPER-mxnet</code><br><code>make USE_CUDA_PATH=/usr/local/cuda-9.0</code><br>输出信息:<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_09-42-07.png\" alt=\"\"></p>\n<h2 id=\"安装-jemalloc\"><a href=\"#安装-jemalloc\" class=\"headerlink\" title=\"安装 jemalloc\"></a>安装 jemalloc</h2><p>选择安装<code>jemalloc</code>,这个工具可以加速编译,碎片整理,具体请自行谷歌</p>\n<ul>\n<li><code>apt-get install autoconf</code></li>\n<li><code>apt-get install automake</code></li>\n<li><code>apt-get install libtool</code></li>\n<li><code>git clone https://github.com/jemalloc/jemalloc.git</code></li>\n<li><code>cd jemalloc</code></li>\n<li><code>git checkout 4.5.0</code>安装4.5.0版本的jemalloc,5.x版本的有坑,深坑</li>\n<li><code>./autogen.sh</code></li>\n<li><code>make</code></li>\n<li><code>make install_bin install_include install_lib</code>,之所以不使用<code>make install</code>是因为会报错,如下: <img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_09-56-41.png\" alt=\"\"></li>\n</ul>\n<p>切换至<code>SNIPER-mxnet</code>文件夹,再次<code>make USE_CUDA_PATH=/usr/local/cuda-9.0</code><br>虽然可以编译,但是有以下信息:<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_10-03-30.png\" alt=\"\"><br>强迫症必须搞定它,果断<code>ctrl+c</code>终止编译</p>\n<h2 id=\"安装-pkg-config\"><a href=\"#安装-pkg-config\" class=\"headerlink\" title=\"安装 pkg-config\"></a>安装 pkg-config</h2><ul>\n<li>打开<a href=\"https://pkg-config.freedesktop.org/releases/\" rel=\"external nofollow\" target=\"_blank\">https://pkg-config.freedesktop.org/releases/</a></li>\n<li>下载最新的,现在看到的是<code>pkg-config-0.29.2.tar.gz</code></li>\n<li>下载好之后,通过<code>FileZilla</code>等工具传输到FTP服务器</li>\n<li>在容器内<code>cd</code>到压缩包位置</li>\n<li><code>tar -xf pkg-config-0.29.2.tar.gz</code></li>\n<li><code>cd pkg-config-0.29.2</code></li>\n<li><code>./configure --with-internal-glib</code>,注意,中间是一个空格,非常关键</li>\n<li><code>make &amp;&amp; make install</code><br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_10-11-01.png\" alt=\"\"></li>\n</ul>\n<p>再次<code>make USE_CUDA_PATH=/usr/local/cuda-9.0</code><br>算了，还是安装一下cudnn吧</p>\n<h2 id=\"安装-cudnn7-0\"><a href=\"#安装-cudnn7-0\" class=\"headerlink\" title=\"安装 cudnn7.0\"></a>安装 cudnn7.0</h2><ul>\n<li><a href=\"https://developer.nvidia.com/rdp/cudnn-archive\" rel=\"external nofollow\" target=\"_blank\">https://developer.nvidia.com/rdp/cudnn-archive</a> 下载cuDNN Libraries for Linux,不要下载 Power 8</li>\n<li>把下载好的包上传到FTP服务器</li>\n<li><code>cd</code>到包位置</li>\n<li><code>cp cudnn-9.0-linux-x64-v7.solitairetheme8 cudnn-9.0-linux-x64-v7.tgz</code></li>\n<li><code>tar -xvf cudnn-9.0-linux-x64-v7.tgz</code></li>\n<li><code>cp include/* /usr/local/cuda-9.0/include</code></li>\n<li><code>cp lib64/* /usr/local/cuda-9.0/lib64</code></li>\n<li><code>chmod a+r /usr/local/cuda-9.0/include/cudnn.h /usr/local/cuda-9.0/lib64/libcudnn*</code></li>\n<li><code>export PATH=/usr/local/cuda-9.0/bin:$PATH</code></li>\n<li><code>cd</code>到<code>/usr/local/cuda-9.0/lib64</code></li>\n<li><code>nano ~/.bashrc</code>,关联环境变量</li>\n<li>在最后一行加入<code>export LD_LIBRARY_PATH=/home/cuda/lib64:$LD_LIBRARY_PATH</code></li>\n<li><code>source ~/.bashrc</code></li>\n<li><code>ldconfig -v</code></li>\n<li>使用<code>cat /usr/local/cuda-9.0/include/cudnn.h | grep CUDNN_MAJOR -A 2</code> 查看cudnn版本<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_10-56-08.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"安装-OpenCV\"><a href=\"#安装-OpenCV\" class=\"headerlink\" title=\"安装 OpenCV\"></a>安装 OpenCV</h2><ul>\n<li>使用<code>pkg-config opencv --modversion</code>查看</li>\n<li>发现已经有OpenCV<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_10-57-56.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"安装-OpenBLAS\"><a href=\"#安装-OpenBLAS\" class=\"headerlink\" title=\"安装 OpenBLAS\"></a>安装 OpenBLAS</h2><ul>\n<li><code>apt-get install libopenblas-dev</code></li>\n</ul>\n<h2 id=\"编译-Mxnet\"><a href=\"#编译-Mxnet\" class=\"headerlink\" title=\"编译 Mxnet\"></a>编译 Mxnet</h2><p><code>make USE_CUDA_PATH=/usr/local/cuda-9.0</code><br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_13-49-28.png\" alt=\"\"></p>\n<p><strong>心好累,总共make了将近两个半小时</strong></p>\n<p>编译<code>c++</code>文件<code>bash scripts/compile.sh</code><br>这一步一定要在<code>/SNIPER/</code>文件夹下,不然贼坑,绝对不要<code>cd</code>到<code>/SNIPER/scripts</code>文件夹下再<code>bash compile.sh</code>,因为代码内有<code>cd lib/nms</code>等,如果不在<code>/SNIPER</code>文件夹下,会找不到文件</p>\n<p>如果出现<code>syntax error near unexpected token</code>$’\\r’’<code>错误,可以使用</code>sed<code>命令将</code>\\r<code>去掉,或者是在[Github](https://github.com/mahyarnajibi/SNIPER/blob/master/scripts/compile.sh)上将代码复制,使用</code>nano<code>编辑然后粘贴\n![](./create-sniper-docker-image/Snipaste_2019-01-03_16-32-08.png)\n可以使用</code>cat -v [filename]<code>查看\n![]./create-sniper-docker-image/Snipaste_2019-01-03_16-33-27.png)\n以</code>^M<code>结尾的代表你所处理的文件换行符是dos格式的</code>“\\r\\n”`</p>\n<p>我选择第二种笨方法,因为涉及的代码并不多</p>\n<p>执行结果:<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_16-24-49.png\" alt=\"\"></p>\n<h2 id=\"安装-dos2unix\"><a href=\"#安装-dos2unix\" class=\"headerlink\" title=\"安装 dos2unix\"></a>安装 dos2unix</h2><p>由于发现这种简单的复制粘贴方式并不能很好的解决,所以查了一些<a href=\"https://blog.csdn.net/lovelovelovelovelo/article/details/79239068\" rel=\"external nofollow\" target=\"_blank\">相关资料</a><br>选择使用<code>dos2unix</code>来转换</p>\n<ul>\n<li><code>apt-get install dos2unix</code></li>\n<li><code>dos2unix [filename]</code></li>\n</ul>\n<p><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_16-40-53.png\" alt=\"\"><br>问题解决啦</p>\n<h2 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h2><p>在<code>/SNIPER/</code>文件夹下<code>pip install -r requirements.txt</code><br>一定要确保镜像内可以联网</p>\n<p><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_16-29-58.png\" alt=\"\"></p>\n<h2 id=\"测试Demo\"><a href=\"#测试Demo\" class=\"headerlink\" title=\"测试Demo\"></a>测试Demo</h2><ul>\n<li><code>bash download_sniper_detector.sh</code>,download_sniper_detector.sh<br>文件在<code>/SNIPER/scripts</code>文件夹下<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_16-44-22.png\" alt=\"\"></li>\n<li><code>cd .. &amp;&amp; python demo.py</code><br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_17-05-30.png\" alt=\"\"></li>\n</ul>\n<p><strong>运行成功!!!</strong></p>\n<h1 id=\"三-生成镜像\"><a href=\"#三-生成镜像\" class=\"headerlink\" title=\"三 生成镜像\"></a>三 生成镜像</h1><ul>\n<li>使用<code>exit</code>退出容器</li>\n<li>使用<code>docker ps -a</code>查看容器ID</li>\n<li>使用<code>docker stop [ID]</code>停止容器</li>\n<li>使用<code>docker commit -a &quot;作者信息&quot; -m &quot;附带信息&quot; [ID] [name]:[tag]</code>生成镜像,会返回一个<code>sha256</code>开头的长ID,这个就是生成的镜像ID</li>\n<li>使用<code>docker images</code>查看生成的镜像</li>\n<li>如果需要的话,使用<code>docker push [name]:[tag]</code>将刚刚生成的镜像推送到云上</li>\n</ul>\n<h1 id=\"四-压缩镜像\"><a href=\"#四-压缩镜像\" class=\"headerlink\" title=\"四 压缩镜像\"></a>四 压缩镜像</h1><p><strong>压缩镜像非常麻烦,但是也是有方法的,目前大概三种方法</strong></p>\n<ol>\n<li>使用<code>Dockerfile</code>生成镜像</li>\n<li>这种方法需要让容器在运行状态,使用<code>docker export [ID] | docker import - [name]:[tag]</code>导出容器快照,并从快照生成镜像,这种方式可以大大压缩镜像,但是缺点是有可能会使得镜像中的环境变量、开放端口、默认进入命令改变或消失.使用这种方式时,最好在生成镜像之后,创建一个<code>Dockerfile</code>文件,<code>From</code>这个镜像,并添加端口和命令入口</li>\n<li>使用<code>docker-squash</code>压缩镜像,这个方法适用于Linux和Mac系统</li>\n</ol>\n<p>目前可以运行的镜像是13.6G<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_17-12-36.png\" alt=\"\"><br><code>hub.hoc.ccshu.net/wjs/sniper:v1.1</code><br>现在要对它进行压缩</p>\n<h2 id=\"第一步-移除镜像内的SNIPER文件夹-把其放到FTP服务器上去\"><a href=\"#第一步-移除镜像内的SNIPER文件夹-把其放到FTP服务器上去\" class=\"headerlink\" title=\"第一步,移除镜像内的SNIPER文件夹,把其放到FTP服务器上去\"></a>第一步,移除镜像内的SNIPER文件夹,把其放到FTP服务器上去</h2><ul>\n<li>开启一个容器<code>docker run -itd --name [name] [id]</code></li>\n<li>复制容器内文件到本地<code>docker cp [长ID]:[容器内路径] [本地路径]</code>,将放置在本地的文件夹上传至FTP服务器</li>\n<li>进入容器<code>docker exec -it [name] /bin/bash</code></li>\n<li>删除容器内文件夹<code>/SNIPER/</code>,使用<code>rm -rf SNIPER</code>,<strong>一定要小心使用</strong></li>\n<li>退出容器<code>exit</code></li>\n</ul>\n<h2 id=\"第二步-压缩镜像\"><a href=\"#第二步-压缩镜像\" class=\"headerlink\" title=\"第二步,压缩镜像\"></a>第二步,压缩镜像</h2><p>压缩容器<br><code>docker export [ID] | docker import - [name]:[tag]</code></p>\n<p>可以看到,镜像体积少了大约2个G<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_17-39-07.png\" alt=\"\"></p>\n<p>由于使用这种方法会使得镜像丢失部分信息,所以,创建一个新的<code>Dockerfile</code>,在其中添加缺失的信息</p>\n<h2 id=\"第三步-完善镜像\"><a href=\"#第三步-完善镜像\" class=\"headerlink\" title=\"第三步,完善镜像\"></a>第三步,完善镜像</h2><p>在任意位置新建<code>Dockerfile</code><br>输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM [name]:[tag]</span><br><span class=\"line\">EXPOSE 22</span><br><span class=\"line\">ENTRYPOINT [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_18-08-49.png\" alt=\"\"></p>\n<p>然后<code>docker build -t [name]:[tag] .</code>,不要忘了最后的<code>.</code></p>\n<h2 id=\"第四步-Push\"><a href=\"#第四步-Push\" class=\"headerlink\" title=\"第四步 Push\"></a>第四步 Push</h2><p><code>docker push [name]:[tag]</code></p>\n<p>至此,所有配置以及完成<br>镜像在<code>hoc.hoc.ccshu.net</code>的私有仓库里<br>SNIPER文件夹放置在机器学习平台服务器<code>mount</code>的目录里</p>\n<h1 id=\"五-测试\"><a href=\"#五-测试\" class=\"headerlink\" title=\"五 测试\"></a>五 测试</h1><ul>\n<li><p>在平台上创建容器<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_18-11-49.png\" alt=\"\"></p>\n</li>\n<li><p>耐心等待创建完成<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_18-14-21.png\" alt=\"\"></p>\n</li>\n<li><p>创建成功<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_18-20-07.png\" alt=\"\"></p>\n</li>\n<li><p>测试结果<br><img src=\"./create-sniper-docker-image/Snipaste_2019-01-03_18-31-16.png\" alt=\"\"><br><strong>测试失败</strong></p>\n</li>\n</ul>\n<p><strong>但是,使用未压缩的镜像测试成功</strong></p>"},{"title":"动态规划 Dynamic Programming","copyright":true,"top":1,"date":"2019-05-12T12:16:22.000Z","mathjax":true,"keywords":null,"description":null,"_content":"\n本文介绍了强化学习问题中最简单基本的算法——动态规划（Dynamic Programming），介绍了贝尔曼方程在该算法中的应用。\n\n<!--more-->\n\n# DP的基本概念\n\n> 动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。——[百度百科]([https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin](https://baike.baidu.com/item/动态规划/529408?fr=aladdin))\n\n动态规划-DP算法指的不是单一一个算法，而是**一系列可以在给定满足MDP的完全可知环境模型中计算出最优策略的算法**。\n\nDP的特点：\n\n- Model-Based\n- Value-Based\n- Off-Policy(这个比较牵强，因为DP不涉及采样、预测，完全靠planning)\n\nDP具有很重要的理论基础作用，但是在现在的强化学习问题中，DP并不常使用，主要原因有二：\n\n- 需要完全可知的模型，状态空间、动作空间离散，状态转移、奖励函数可知且确定\n- 计算量很大(每次更新都需要完全规划所有可能性)\n\n在一些表格型的问题中，如完全可知的迷宫，可以使用DP，但是要解决人类现实世界极其复杂的问题、任务，DP可能就有些力不从心啦。\n\n其实，所有的强化学习算法都可以被认为是在**不完全可知的环境**中使用**少量计算**得到如DP效果一样的策略（最优策略）。\n\n# 算法\n\n先回顾一下之前提到的贝尔曼方程。\n\n贝尔曼期望方程：\n$$\nv_{\\pi}(s) =\\sum_{a}\\pi(a\\mid s)\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\n$$\n\n$$\nq_{\\pi}(s,a) =\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\n$$\n\n贝尔曼最优方程：\n$$\nv_{*}(s) =\\max_{a}\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\right]\n$$\n\n$$\nq_{*}(s,a) =\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\n$$\n\n为什么要再次提到贝尔曼方程呢？因为动态规划算法中的策略迭代、值迭代就是将贝尔曼方程给结合了起来。\n\n回顾一下在[价值与贝尔曼方差](./价值与贝尔曼方程.html)最后的例子中迭代计算$V(S)$和$Q(S,A)$，遍历所有$Q(S,A)$以计算$V(S)$，再遍历所有$V(S)$以计算$Q(S,A)$。在一个简单的场景下循环迭代至收敛就需要很大的计算量，如果在复杂场景中(还是完全可知的)迭代计算可想有多费时费力，动态规划DP下的Policy Iteration和Value Iteration减轻了计算的负担，同时又不影响收敛性。\n\n引用《Reinfocement Learning : An Introduction》中的一个网格世界的例子：\n\n![](./dynamic-programming/gridworld.png)\n\n在这个例子中，有1-14个非终态以及两个终态(左上角、右下角)，动作空间为上下左右四种，在边缘位置的状态，例如$S=1$，可选的动作只有左右下三种，且等概率选择每种动作，每进行一次移动，就给予-1的奖励值。智能体需要尽快的到达网格世界的出口-终态，以获得尽量少的负奖励(即累计奖励最大)。\n\n如果按照**先遍历所有$Q(S,A)$以计算$V(S)$，再遍历所有$V(S)$以计算$Q(S,A)$**的方式计算，值函数的表格将会如下图所示：\n\n![](./dynamic-programming/iteration.png)\n\n左边展示的是进行$k$次迭代，使值函数表格可以收敛，右边表示在每次迭代中，取$a=argmax_{a}q(s,a)$的策略。\n\n可以发现，这样迭代$V(S)$至收敛有两个浪费算力的地方：\n\n1. 选择动作的概率完全按照环境设置，导致计算状态$s$的值函数时，最差的动作$a$所带来的影响也被计算在其中，但其实真正执行的时候，永远不会执行该动作。\n2. $k=3$与$k=10$时的策略表示一样，也就意味着，不必等到$V(S)$迭代至完全收敛就有可能可以获得最优策略，那么后续迭代完全没有用处，造成了资源浪费。\n\n策略迭代、值迭代的思想都是贪心策略，但策略迭代针对问题1通过**剪裁可选动作**的方式进行了优化，值迭代针对问题2通过**取最大动作值函数**的方式进行了优化。\n\n## 策略迭代 Policy Iteration\n\n动作是通过策略产生的，因此势必需要对初始策略（GridWorld中的完全随机策略）进行替换，以达到更改动作选取概率的目的。\n\n既然要在不同的阶段更改动作选择的概率，那么要进行多次策略的更改，随之而来的问题就是：\n\n1. 值函数迭代更新到什么情况下时，开始更新策略\n2. 如何更新策略？\n\n针对第一个问题，我们使用**策略评估Policy Evaluation**的方式来解决，针对第二个问题，我们使用**策略提升Policy Improvation**的方式来解决，最终当新策略与旧策略相同时，终止迭代，得到最优策略。\n$$\n\\pi_{0} \\xrightarrow{E} v_{\\pi_{0}} \\xrightarrow{I} \\pi_{1} \\xrightarrow{E} v_{\\pi_{1}} \\xrightarrow{I} \\pi_{2} \\xrightarrow{E} ... \\xrightarrow{I} \\pi_{\\ast} \\xrightarrow{E} v_{\\pi_{\\ast}}\n$$\n\n### 伪代码\n\n![](./dynamic-programming/pi.png)\n\n### 策略评估 Policy Evaluation\n\n问题：值函数迭代更新到什么情况下时，开始更新策略\n\n答：设置更新幅度阈值$\\theta$，当sweep(横扫)一遍状态空间计算$V(S)$时，与上次更新时的$V(S)$相比较，如果最大的更新幅度小于阈值$\\theta$，即$\\Delta \\lt \\theta$，则认为策略评估已经完成，开始进行策略更新\n\n特点：使用了贝尔曼期望方程-$v_{\\pi}(s)$\n\n*注：策略评估指的不是评估一个策略的好坏，而是在当前策略下评估所有的状态值，使状态值表格近似收敛。*\n\n### 策略提升 Policy Improvement\n\n问题：如何更新策略？\n\n答：根据策略评估步骤得到的值函数$V(S)$，计算$Q(S,A)$表格，选取每个状态下使动作值函数最大的动作作为新的动作集，每个动作的选择概率相同，接着进行策略评估。\n\n特点：使用了贝尔曼期望方程-$q_{\\pi}(s,a)$\n\n## 值迭代 Value Iteration\n\n策略迭代的一个缺点是在得到最优策略$\\pi_{\\ast}$之前，需要多次更新策略，每次更新策略都会引起可选取动作的改变，这会引起在更新完策略后的前几次策略评估中值函数偏差比较大，导致在策略评估过程中需要花费大量的迭代来减小更新幅度$\\Delta$，因此需要多次sweep(横扫)$V(S)$来迭代计算。\n\n值迭代的思想是：**能不能通过早停的方式，在不更改策略的情况下，直接一次得到最优策略？**\n\n值迭代运用了策略评估、策略迭代的思想，并将它们融合在一起，即不更新策略，直接选择动作值函数$q(s,a)$最大的动作作为状态值$v(s)$，直接迭代出**近似最优**（早停，$\\Delta \\lt \\theta$即可）状态价值函数$V_{\\ast}(S)$，使用贪心策略进而得到最优策略$\\pi_{\\ast}$。\n\n特点：使用了贝尔曼最优方程-$v_{\\ast}(s)，q_{\\ast}(s,a)$。\n\n### 伪代码\n\n![](./dynamic-programming/vi.png)\n\n## PI与VI的比较\n\n![](./dynamic-programming/pivsvi.png)\n\n相同点：\n\n- 在$0 \\leq \\gamma \\lt 1$，有限MDPs环境中，两种方式都可以收敛到最优策略$\\pi_{\\ast}$\n- 都使用了贝尔曼方程进行状态值函数的迭代\n\n不同点：\n\n1. 收敛方式\n   - 策略迭代PI包括策略评估Policy Evaluation和策略提升Policy Improvement，这两部循环迭代至策略收敛\n   - 值迭代VI包括找到最优状态值函数和一步提取策略，这两步不需要循环迭代，而是根据最优值函数直接得到最优策略\n2. 动作改变方式\n   - 策略迭代PI获得新策略$\\pi_{new}$后，**更改每个状态的可选动作集**，多次横扫（遍历）$V(S)$\n   - 值迭代VI过程中不产生策略，不更改每个状态的可选动作集，但是**只取每个状态下动作值函数最大的动作作为状态值**，一次横扫（遍历）$V(S)$。（这里需要解释一下，虽然循环是多次遍历，但是因为max操作，每次遍历每个状态所选取的动作不一定一样，虽然策略一直是随机策略，没有产生新策略，但是计算过程没有遍历到所有动作，可以隐含的看作是一个新策略，因此每次遍历时这个“隐策略”都会改变，所以称为一次遍历。）\n3. 计算方式\n   - 策略迭代PI使用贝尔曼期望方程\n   - 值迭代VI使用贝尔曼最优方程\n4. Policy方式\n   - 策略迭代PI是On-Policy\n   - 值迭代VI是Off-Policy\n5. 稳定性检查\n   - 策略迭代PI中更新策略时进行了策略稳定性检查，判断是否收敛\n   - 值迭代VI获得新策略$\\pi$时没有进行策略稳定性检查\n\n至于策略迭代PI与值迭代VI的收敛速度，**通常情况**下，PI的迭代次数更少，VI的运行时间更少。\n\n> [What is the difference between value iteration and policy iteration?](https://stackoverflow.com/a/42493295/11483803)\n>\n> [《Reinforcement Learning : An Introduction 2nd Edition》p77](http://incompleteideas.net/book/RLbook2018.pdf)\n\n","source":"_posts/dynamic-programming.md","raw":"---\ntitle: 动态规划 Dynamic Programming\ncopyright: true\ntop: 1\ndate: 2019-05-12 20:16:22\nmathjax: true\nkeywords: \ndescription: \ncategories: ReinforcementLearning\ntags:\n- rl\n---\n\n本文介绍了强化学习问题中最简单基本的算法——动态规划（Dynamic Programming），介绍了贝尔曼方程在该算法中的应用。\n\n<!--more-->\n\n# DP的基本概念\n\n> 动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。——[百度百科]([https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin](https://baike.baidu.com/item/动态规划/529408?fr=aladdin))\n\n动态规划-DP算法指的不是单一一个算法，而是**一系列可以在给定满足MDP的完全可知环境模型中计算出最优策略的算法**。\n\nDP的特点：\n\n- Model-Based\n- Value-Based\n- Off-Policy(这个比较牵强，因为DP不涉及采样、预测，完全靠planning)\n\nDP具有很重要的理论基础作用，但是在现在的强化学习问题中，DP并不常使用，主要原因有二：\n\n- 需要完全可知的模型，状态空间、动作空间离散，状态转移、奖励函数可知且确定\n- 计算量很大(每次更新都需要完全规划所有可能性)\n\n在一些表格型的问题中，如完全可知的迷宫，可以使用DP，但是要解决人类现实世界极其复杂的问题、任务，DP可能就有些力不从心啦。\n\n其实，所有的强化学习算法都可以被认为是在**不完全可知的环境**中使用**少量计算**得到如DP效果一样的策略（最优策略）。\n\n# 算法\n\n先回顾一下之前提到的贝尔曼方程。\n\n贝尔曼期望方程：\n$$\nv_{\\pi}(s) =\\sum_{a}\\pi(a\\mid s)\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\n$$\n\n$$\nq_{\\pi}(s,a) =\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\n$$\n\n贝尔曼最优方程：\n$$\nv_{*}(s) =\\max_{a}\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\right]\n$$\n\n$$\nq_{*}(s,a) =\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\n$$\n\n为什么要再次提到贝尔曼方程呢？因为动态规划算法中的策略迭代、值迭代就是将贝尔曼方程给结合了起来。\n\n回顾一下在[价值与贝尔曼方差](./价值与贝尔曼方程.html)最后的例子中迭代计算$V(S)$和$Q(S,A)$，遍历所有$Q(S,A)$以计算$V(S)$，再遍历所有$V(S)$以计算$Q(S,A)$。在一个简单的场景下循环迭代至收敛就需要很大的计算量，如果在复杂场景中(还是完全可知的)迭代计算可想有多费时费力，动态规划DP下的Policy Iteration和Value Iteration减轻了计算的负担，同时又不影响收敛性。\n\n引用《Reinfocement Learning : An Introduction》中的一个网格世界的例子：\n\n![](./dynamic-programming/gridworld.png)\n\n在这个例子中，有1-14个非终态以及两个终态(左上角、右下角)，动作空间为上下左右四种，在边缘位置的状态，例如$S=1$，可选的动作只有左右下三种，且等概率选择每种动作，每进行一次移动，就给予-1的奖励值。智能体需要尽快的到达网格世界的出口-终态，以获得尽量少的负奖励(即累计奖励最大)。\n\n如果按照**先遍历所有$Q(S,A)$以计算$V(S)$，再遍历所有$V(S)$以计算$Q(S,A)$**的方式计算，值函数的表格将会如下图所示：\n\n![](./dynamic-programming/iteration.png)\n\n左边展示的是进行$k$次迭代，使值函数表格可以收敛，右边表示在每次迭代中，取$a=argmax_{a}q(s,a)$的策略。\n\n可以发现，这样迭代$V(S)$至收敛有两个浪费算力的地方：\n\n1. 选择动作的概率完全按照环境设置，导致计算状态$s$的值函数时，最差的动作$a$所带来的影响也被计算在其中，但其实真正执行的时候，永远不会执行该动作。\n2. $k=3$与$k=10$时的策略表示一样，也就意味着，不必等到$V(S)$迭代至完全收敛就有可能可以获得最优策略，那么后续迭代完全没有用处，造成了资源浪费。\n\n策略迭代、值迭代的思想都是贪心策略，但策略迭代针对问题1通过**剪裁可选动作**的方式进行了优化，值迭代针对问题2通过**取最大动作值函数**的方式进行了优化。\n\n## 策略迭代 Policy Iteration\n\n动作是通过策略产生的，因此势必需要对初始策略（GridWorld中的完全随机策略）进行替换，以达到更改动作选取概率的目的。\n\n既然要在不同的阶段更改动作选择的概率，那么要进行多次策略的更改，随之而来的问题就是：\n\n1. 值函数迭代更新到什么情况下时，开始更新策略\n2. 如何更新策略？\n\n针对第一个问题，我们使用**策略评估Policy Evaluation**的方式来解决，针对第二个问题，我们使用**策略提升Policy Improvation**的方式来解决，最终当新策略与旧策略相同时，终止迭代，得到最优策略。\n$$\n\\pi_{0} \\xrightarrow{E} v_{\\pi_{0}} \\xrightarrow{I} \\pi_{1} \\xrightarrow{E} v_{\\pi_{1}} \\xrightarrow{I} \\pi_{2} \\xrightarrow{E} ... \\xrightarrow{I} \\pi_{\\ast} \\xrightarrow{E} v_{\\pi_{\\ast}}\n$$\n\n### 伪代码\n\n![](./dynamic-programming/pi.png)\n\n### 策略评估 Policy Evaluation\n\n问题：值函数迭代更新到什么情况下时，开始更新策略\n\n答：设置更新幅度阈值$\\theta$，当sweep(横扫)一遍状态空间计算$V(S)$时，与上次更新时的$V(S)$相比较，如果最大的更新幅度小于阈值$\\theta$，即$\\Delta \\lt \\theta$，则认为策略评估已经完成，开始进行策略更新\n\n特点：使用了贝尔曼期望方程-$v_{\\pi}(s)$\n\n*注：策略评估指的不是评估一个策略的好坏，而是在当前策略下评估所有的状态值，使状态值表格近似收敛。*\n\n### 策略提升 Policy Improvement\n\n问题：如何更新策略？\n\n答：根据策略评估步骤得到的值函数$V(S)$，计算$Q(S,A)$表格，选取每个状态下使动作值函数最大的动作作为新的动作集，每个动作的选择概率相同，接着进行策略评估。\n\n特点：使用了贝尔曼期望方程-$q_{\\pi}(s,a)$\n\n## 值迭代 Value Iteration\n\n策略迭代的一个缺点是在得到最优策略$\\pi_{\\ast}$之前，需要多次更新策略，每次更新策略都会引起可选取动作的改变，这会引起在更新完策略后的前几次策略评估中值函数偏差比较大，导致在策略评估过程中需要花费大量的迭代来减小更新幅度$\\Delta$，因此需要多次sweep(横扫)$V(S)$来迭代计算。\n\n值迭代的思想是：**能不能通过早停的方式，在不更改策略的情况下，直接一次得到最优策略？**\n\n值迭代运用了策略评估、策略迭代的思想，并将它们融合在一起，即不更新策略，直接选择动作值函数$q(s,a)$最大的动作作为状态值$v(s)$，直接迭代出**近似最优**（早停，$\\Delta \\lt \\theta$即可）状态价值函数$V_{\\ast}(S)$，使用贪心策略进而得到最优策略$\\pi_{\\ast}$。\n\n特点：使用了贝尔曼最优方程-$v_{\\ast}(s)，q_{\\ast}(s,a)$。\n\n### 伪代码\n\n![](./dynamic-programming/vi.png)\n\n## PI与VI的比较\n\n![](./dynamic-programming/pivsvi.png)\n\n相同点：\n\n- 在$0 \\leq \\gamma \\lt 1$，有限MDPs环境中，两种方式都可以收敛到最优策略$\\pi_{\\ast}$\n- 都使用了贝尔曼方程进行状态值函数的迭代\n\n不同点：\n\n1. 收敛方式\n   - 策略迭代PI包括策略评估Policy Evaluation和策略提升Policy Improvement，这两部循环迭代至策略收敛\n   - 值迭代VI包括找到最优状态值函数和一步提取策略，这两步不需要循环迭代，而是根据最优值函数直接得到最优策略\n2. 动作改变方式\n   - 策略迭代PI获得新策略$\\pi_{new}$后，**更改每个状态的可选动作集**，多次横扫（遍历）$V(S)$\n   - 值迭代VI过程中不产生策略，不更改每个状态的可选动作集，但是**只取每个状态下动作值函数最大的动作作为状态值**，一次横扫（遍历）$V(S)$。（这里需要解释一下，虽然循环是多次遍历，但是因为max操作，每次遍历每个状态所选取的动作不一定一样，虽然策略一直是随机策略，没有产生新策略，但是计算过程没有遍历到所有动作，可以隐含的看作是一个新策略，因此每次遍历时这个“隐策略”都会改变，所以称为一次遍历。）\n3. 计算方式\n   - 策略迭代PI使用贝尔曼期望方程\n   - 值迭代VI使用贝尔曼最优方程\n4. Policy方式\n   - 策略迭代PI是On-Policy\n   - 值迭代VI是Off-Policy\n5. 稳定性检查\n   - 策略迭代PI中更新策略时进行了策略稳定性检查，判断是否收敛\n   - 值迭代VI获得新策略$\\pi$时没有进行策略稳定性检查\n\n至于策略迭代PI与值迭代VI的收敛速度，**通常情况**下，PI的迭代次数更少，VI的运行时间更少。\n\n> [What is the difference between value iteration and policy iteration?](https://stackoverflow.com/a/42493295/11483803)\n>\n> [《Reinforcement Learning : An Introduction 2nd Edition》p77](http://incompleteideas.net/book/RLbook2018.pdf)\n\n","slug":"dynamic-programming","published":1,"updated":"2019-05-13T14:27:05.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut8w004q20cd0fljrs1v","content":"<p>本文介绍了强化学习问题中最简单基本的算法——动态规划（Dynamic Programming），介绍了贝尔曼方程在该算法中的应用。</p>\n<a id=\"more\"></a>\n<h1 id=\"DP的基本概念\"><a href=\"#DP的基本概念\" class=\"headerlink\" title=\"DP的基本概念\"></a>DP的基本概念</h1><blockquote>\n<p>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。——<a href=\"[https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin](https://baike.baidu.com/item/动态规划/529408?fr=aladdin\">百度百科</a>)</p>\n</blockquote>\n<p>动态规划-DP算法指的不是单一一个算法，而是<strong>一系列可以在给定满足MDP的完全可知环境模型中计算出最优策略的算法</strong>。</p>\n<p>DP的特点：</p>\n<ul>\n<li>Model-Based</li>\n<li>Value-Based</li>\n<li>Off-Policy(这个比较牵强，因为DP不涉及采样、预测，完全靠planning)</li>\n</ul>\n<p>DP具有很重要的理论基础作用，但是在现在的强化学习问题中，DP并不常使用，主要原因有二：</p>\n<ul>\n<li>需要完全可知的模型，状态空间、动作空间离散，状态转移、奖励函数可知且确定</li>\n<li>计算量很大(每次更新都需要完全规划所有可能性)</li>\n</ul>\n<p>在一些表格型的问题中，如完全可知的迷宫，可以使用DP，但是要解决人类现实世界极其复杂的问题、任务，DP可能就有些力不从心啦。</p>\n<p>其实，所有的强化学习算法都可以被认为是在<strong>不完全可知的环境</strong>中使用<strong>少量计算</strong>得到如DP效果一样的策略（最优策略）。</p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p>先回顾一下之前提到的贝尔曼方程。</p>\n<p>贝尔曼期望方程：</p>\n<script type=\"math/tex; mode=display\">\nv_{\\pi}(s) =\\sum_{a}\\pi(a\\mid s)\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]</script><script type=\"math/tex; mode=display\">\nq_{\\pi}(s,a) =\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]</script><p>贝尔曼最优方程：</p>\n<script type=\"math/tex; mode=display\">\nv_{*}(s) =\\max_{a}\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\right]</script><script type=\"math/tex; mode=display\">\nq_{*}(s,a) =\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]</script><p>为什么要再次提到贝尔曼方程呢？因为动态规划算法中的策略迭代、值迭代就是将贝尔曼方程给结合了起来。</p>\n<p>回顾一下在<a href=\"./价值与贝尔曼方程.html\">价值与贝尔曼方差</a>最后的例子中迭代计算$V(S)$和$Q(S,A)$，遍历所有$Q(S,A)$以计算$V(S)$，再遍历所有$V(S)$以计算$Q(S,A)$。在一个简单的场景下循环迭代至收敛就需要很大的计算量，如果在复杂场景中(还是完全可知的)迭代计算可想有多费时费力，动态规划DP下的Policy Iteration和Value Iteration减轻了计算的负担，同时又不影响收敛性。</p>\n<p>引用《Reinfocement Learning : An Introduction》中的一个网格世界的例子：</p>\n<p><img src=\"./dynamic-programming/gridworld.png\" alt=\"\"></p>\n<p>在这个例子中，有1-14个非终态以及两个终态(左上角、右下角)，动作空间为上下左右四种，在边缘位置的状态，例如$S=1$，可选的动作只有左右下三种，且等概率选择每种动作，每进行一次移动，就给予-1的奖励值。智能体需要尽快的到达网格世界的出口-终态，以获得尽量少的负奖励(即累计奖励最大)。</p>\n<p>如果按照<strong>先遍历所有$Q(S,A)$以计算$V(S)$，再遍历所有$V(S)$以计算$Q(S,A)$</strong>的方式计算，值函数的表格将会如下图所示：</p>\n<p><img src=\"./dynamic-programming/iteration.png\" alt=\"\"></p>\n<p>左边展示的是进行$k$次迭代，使值函数表格可以收敛，右边表示在每次迭代中，取$a=argmax_{a}q(s,a)$的策略。</p>\n<p>可以发现，这样迭代$V(S)$至收敛有两个浪费算力的地方：</p>\n<ol>\n<li>选择动作的概率完全按照环境设置，导致计算状态$s$的值函数时，最差的动作$a$所带来的影响也被计算在其中，但其实真正执行的时候，永远不会执行该动作。</li>\n<li>$k=3$与$k=10$时的策略表示一样，也就意味着，不必等到$V(S)$迭代至完全收敛就有可能可以获得最优策略，那么后续迭代完全没有用处，造成了资源浪费。</li>\n</ol>\n<p>策略迭代、值迭代的思想都是贪心策略，但策略迭代针对问题1通过<strong>剪裁可选动作</strong>的方式进行了优化，值迭代针对问题2通过<strong>取最大动作值函数</strong>的方式进行了优化。</p>\n<h2 id=\"策略迭代-Policy-Iteration\"><a href=\"#策略迭代-Policy-Iteration\" class=\"headerlink\" title=\"策略迭代 Policy Iteration\"></a>策略迭代 Policy Iteration</h2><p>动作是通过策略产生的，因此势必需要对初始策略（GridWorld中的完全随机策略）进行替换，以达到更改动作选取概率的目的。</p>\n<p>既然要在不同的阶段更改动作选择的概率，那么要进行多次策略的更改，随之而来的问题就是：</p>\n<ol>\n<li>值函数迭代更新到什么情况下时，开始更新策略</li>\n<li>如何更新策略？</li>\n</ol>\n<p>针对第一个问题，我们使用<strong>策略评估Policy Evaluation</strong>的方式来解决，针对第二个问题，我们使用<strong>策略提升Policy Improvation</strong>的方式来解决，最终当新策略与旧策略相同时，终止迭代，得到最优策略。</p>\n<script type=\"math/tex; mode=display\">\n\\pi_{0} \\xrightarrow{E} v_{\\pi_{0}} \\xrightarrow{I} \\pi_{1} \\xrightarrow{E} v_{\\pi_{1}} \\xrightarrow{I} \\pi_{2} \\xrightarrow{E} ... \\xrightarrow{I} \\pi_{\\ast} \\xrightarrow{E} v_{\\pi_{\\ast}}</script><h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p><img src=\"./dynamic-programming/pi.png\" alt=\"\"></p>\n<h3 id=\"策略评估-Policy-Evaluation\"><a href=\"#策略评估-Policy-Evaluation\" class=\"headerlink\" title=\"策略评估 Policy Evaluation\"></a>策略评估 Policy Evaluation</h3><p>问题：值函数迭代更新到什么情况下时，开始更新策略</p>\n<p>答：设置更新幅度阈值$\\theta$，当sweep(横扫)一遍状态空间计算$V(S)$时，与上次更新时的$V(S)$相比较，如果最大的更新幅度小于阈值$\\theta$，即$\\Delta \\lt \\theta$，则认为策略评估已经完成，开始进行策略更新</p>\n<p>特点：使用了贝尔曼期望方程-$v_{\\pi}(s)$</p>\n<p><em>注：策略评估指的不是评估一个策略的好坏，而是在当前策略下评估所有的状态值，使状态值表格近似收敛。</em></p>\n<h3 id=\"策略提升-Policy-Improvement\"><a href=\"#策略提升-Policy-Improvement\" class=\"headerlink\" title=\"策略提升 Policy Improvement\"></a>策略提升 Policy Improvement</h3><p>问题：如何更新策略？</p>\n<p>答：根据策略评估步骤得到的值函数$V(S)$，计算$Q(S,A)$表格，选取每个状态下使动作值函数最大的动作作为新的动作集，每个动作的选择概率相同，接着进行策略评估。</p>\n<p>特点：使用了贝尔曼期望方程-$q_{\\pi}(s,a)$</p>\n<h2 id=\"值迭代-Value-Iteration\"><a href=\"#值迭代-Value-Iteration\" class=\"headerlink\" title=\"值迭代 Value Iteration\"></a>值迭代 Value Iteration</h2><p>策略迭代的一个缺点是在得到最优策略$\\pi_{\\ast}$之前，需要多次更新策略，每次更新策略都会引起可选取动作的改变，这会引起在更新完策略后的前几次策略评估中值函数偏差比较大，导致在策略评估过程中需要花费大量的迭代来减小更新幅度$\\Delta$，因此需要多次sweep(横扫)$V(S)$来迭代计算。</p>\n<p>值迭代的思想是：<strong>能不能通过早停的方式，在不更改策略的情况下，直接一次得到最优策略？</strong></p>\n<p>值迭代运用了策略评估、策略迭代的思想，并将它们融合在一起，即不更新策略，直接选择动作值函数$q(s,a)$最大的动作作为状态值$v(s)$，直接迭代出<strong>近似最优</strong>（早停，$\\Delta \\lt \\theta$即可）状态价值函数$V_{\\ast}(S)$，使用贪心策略进而得到最优策略$\\pi_{\\ast}$。</p>\n<p>特点：使用了贝尔曼最优方程-$v_{\\ast}(s)，q_{\\ast}(s,a)$。</p>\n<h3 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p><img src=\"./dynamic-programming/vi.png\" alt=\"\"></p>\n<h2 id=\"PI与VI的比较\"><a href=\"#PI与VI的比较\" class=\"headerlink\" title=\"PI与VI的比较\"></a>PI与VI的比较</h2><p><img src=\"./dynamic-programming/pivsvi.png\" alt=\"\"></p>\n<p>相同点：</p>\n<ul>\n<li>在$0 \\leq \\gamma \\lt 1$，有限MDPs环境中，两种方式都可以收敛到最优策略$\\pi_{\\ast}$</li>\n<li>都使用了贝尔曼方程进行状态值函数的迭代</li>\n</ul>\n<p>不同点：</p>\n<ol>\n<li>收敛方式<ul>\n<li>策略迭代PI包括策略评估Policy Evaluation和策略提升Policy Improvement，这两部循环迭代至策略收敛</li>\n<li>值迭代VI包括找到最优状态值函数和一步提取策略，这两步不需要循环迭代，而是根据最优值函数直接得到最优策略</li>\n</ul>\n</li>\n<li>动作改变方式<ul>\n<li>策略迭代PI获得新策略$\\pi_{new}$后，<strong>更改每个状态的可选动作集</strong>，多次横扫（遍历）$V(S)$</li>\n<li>值迭代VI过程中不产生策略，不更改每个状态的可选动作集，但是<strong>只取每个状态下动作值函数最大的动作作为状态值</strong>，一次横扫（遍历）$V(S)$。（这里需要解释一下，虽然循环是多次遍历，但是因为max操作，每次遍历每个状态所选取的动作不一定一样，虽然策略一直是随机策略，没有产生新策略，但是计算过程没有遍历到所有动作，可以隐含的看作是一个新策略，因此每次遍历时这个“隐策略”都会改变，所以称为一次遍历。）</li>\n</ul>\n</li>\n<li>计算方式<ul>\n<li>策略迭代PI使用贝尔曼期望方程</li>\n<li>值迭代VI使用贝尔曼最优方程</li>\n</ul>\n</li>\n<li>Policy方式<ul>\n<li>策略迭代PI是On-Policy</li>\n<li>值迭代VI是Off-Policy</li>\n</ul>\n</li>\n<li>稳定性检查<ul>\n<li>策略迭代PI中更新策略时进行了策略稳定性检查，判断是否收敛</li>\n<li>值迭代VI获得新策略$\\pi$时没有进行策略稳定性检查</li>\n</ul>\n</li>\n</ol>\n<p>至于策略迭代PI与值迭代VI的收敛速度，<strong>通常情况</strong>下，PI的迭代次数更少，VI的运行时间更少。</p>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/a/42493295/11483803\" rel=\"external nofollow\" target=\"_blank\">What is the difference between value iteration and policy iteration?</a></p>\n<p><a href=\"http://incompleteideas.net/book/RLbook2018.pdf\" rel=\"external nofollow\" target=\"_blank\">《Reinforcement Learning : An Introduction 2nd Edition》p77</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>本文介绍了强化学习问题中最简单基本的算法——动态规划（Dynamic Programming），介绍了贝尔曼方程在该算法中的应用。</p>","more":"<h1 id=\"DP的基本概念\"><a href=\"#DP的基本概念\" class=\"headerlink\" title=\"DP的基本概念\"></a>DP的基本概念</h1><blockquote>\n<p>动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。——<a href=\"[https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin](https://baike.baidu.com/item/动态规划/529408?fr=aladdin\">百度百科</a>)</p>\n</blockquote>\n<p>动态规划-DP算法指的不是单一一个算法，而是<strong>一系列可以在给定满足MDP的完全可知环境模型中计算出最优策略的算法</strong>。</p>\n<p>DP的特点：</p>\n<ul>\n<li>Model-Based</li>\n<li>Value-Based</li>\n<li>Off-Policy(这个比较牵强，因为DP不涉及采样、预测，完全靠planning)</li>\n</ul>\n<p>DP具有很重要的理论基础作用，但是在现在的强化学习问题中，DP并不常使用，主要原因有二：</p>\n<ul>\n<li>需要完全可知的模型，状态空间、动作空间离散，状态转移、奖励函数可知且确定</li>\n<li>计算量很大(每次更新都需要完全规划所有可能性)</li>\n</ul>\n<p>在一些表格型的问题中，如完全可知的迷宫，可以使用DP，但是要解决人类现实世界极其复杂的问题、任务，DP可能就有些力不从心啦。</p>\n<p>其实，所有的强化学习算法都可以被认为是在<strong>不完全可知的环境</strong>中使用<strong>少量计算</strong>得到如DP效果一样的策略（最优策略）。</p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p>先回顾一下之前提到的贝尔曼方程。</p>\n<p>贝尔曼期望方程：</p>\n<script type=\"math/tex; mode=display\">\nv_{\\pi}(s) =\\sum_{a}\\pi(a\\mid s)\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]</script><script type=\"math/tex; mode=display\">\nq_{\\pi}(s,a) =\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]</script><p>贝尔曼最优方程：</p>\n<script type=\"math/tex; mode=display\">\nv_{*}(s) =\\max_{a}\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\right]</script><script type=\"math/tex; mode=display\">\nq_{*}(s,a) =\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]</script><p>为什么要再次提到贝尔曼方程呢？因为动态规划算法中的策略迭代、值迭代就是将贝尔曼方程给结合了起来。</p>\n<p>回顾一下在<a href=\"./价值与贝尔曼方程.html\">价值与贝尔曼方差</a>最后的例子中迭代计算$V(S)$和$Q(S,A)$，遍历所有$Q(S,A)$以计算$V(S)$，再遍历所有$V(S)$以计算$Q(S,A)$。在一个简单的场景下循环迭代至收敛就需要很大的计算量，如果在复杂场景中(还是完全可知的)迭代计算可想有多费时费力，动态规划DP下的Policy Iteration和Value Iteration减轻了计算的负担，同时又不影响收敛性。</p>\n<p>引用《Reinfocement Learning : An Introduction》中的一个网格世界的例子：</p>\n<p><img src=\"./dynamic-programming/gridworld.png\" alt=\"\"></p>\n<p>在这个例子中，有1-14个非终态以及两个终态(左上角、右下角)，动作空间为上下左右四种，在边缘位置的状态，例如$S=1$，可选的动作只有左右下三种，且等概率选择每种动作，每进行一次移动，就给予-1的奖励值。智能体需要尽快的到达网格世界的出口-终态，以获得尽量少的负奖励(即累计奖励最大)。</p>\n<p>如果按照<strong>先遍历所有$Q(S,A)$以计算$V(S)$，再遍历所有$V(S)$以计算$Q(S,A)$</strong>的方式计算，值函数的表格将会如下图所示：</p>\n<p><img src=\"./dynamic-programming/iteration.png\" alt=\"\"></p>\n<p>左边展示的是进行$k$次迭代，使值函数表格可以收敛，右边表示在每次迭代中，取$a=argmax_{a}q(s,a)$的策略。</p>\n<p>可以发现，这样迭代$V(S)$至收敛有两个浪费算力的地方：</p>\n<ol>\n<li>选择动作的概率完全按照环境设置，导致计算状态$s$的值函数时，最差的动作$a$所带来的影响也被计算在其中，但其实真正执行的时候，永远不会执行该动作。</li>\n<li>$k=3$与$k=10$时的策略表示一样，也就意味着，不必等到$V(S)$迭代至完全收敛就有可能可以获得最优策略，那么后续迭代完全没有用处，造成了资源浪费。</li>\n</ol>\n<p>策略迭代、值迭代的思想都是贪心策略，但策略迭代针对问题1通过<strong>剪裁可选动作</strong>的方式进行了优化，值迭代针对问题2通过<strong>取最大动作值函数</strong>的方式进行了优化。</p>\n<h2 id=\"策略迭代-Policy-Iteration\"><a href=\"#策略迭代-Policy-Iteration\" class=\"headerlink\" title=\"策略迭代 Policy Iteration\"></a>策略迭代 Policy Iteration</h2><p>动作是通过策略产生的，因此势必需要对初始策略（GridWorld中的完全随机策略）进行替换，以达到更改动作选取概率的目的。</p>\n<p>既然要在不同的阶段更改动作选择的概率，那么要进行多次策略的更改，随之而来的问题就是：</p>\n<ol>\n<li>值函数迭代更新到什么情况下时，开始更新策略</li>\n<li>如何更新策略？</li>\n</ol>\n<p>针对第一个问题，我们使用<strong>策略评估Policy Evaluation</strong>的方式来解决，针对第二个问题，我们使用<strong>策略提升Policy Improvation</strong>的方式来解决，最终当新策略与旧策略相同时，终止迭代，得到最优策略。</p>\n<script type=\"math/tex; mode=display\">\n\\pi_{0} \\xrightarrow{E} v_{\\pi_{0}} \\xrightarrow{I} \\pi_{1} \\xrightarrow{E} v_{\\pi_{1}} \\xrightarrow{I} \\pi_{2} \\xrightarrow{E} ... \\xrightarrow{I} \\pi_{\\ast} \\xrightarrow{E} v_{\\pi_{\\ast}}</script><h3 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p><img src=\"./dynamic-programming/pi.png\" alt=\"\"></p>\n<h3 id=\"策略评估-Policy-Evaluation\"><a href=\"#策略评估-Policy-Evaluation\" class=\"headerlink\" title=\"策略评估 Policy Evaluation\"></a>策略评估 Policy Evaluation</h3><p>问题：值函数迭代更新到什么情况下时，开始更新策略</p>\n<p>答：设置更新幅度阈值$\\theta$，当sweep(横扫)一遍状态空间计算$V(S)$时，与上次更新时的$V(S)$相比较，如果最大的更新幅度小于阈值$\\theta$，即$\\Delta \\lt \\theta$，则认为策略评估已经完成，开始进行策略更新</p>\n<p>特点：使用了贝尔曼期望方程-$v_{\\pi}(s)$</p>\n<p><em>注：策略评估指的不是评估一个策略的好坏，而是在当前策略下评估所有的状态值，使状态值表格近似收敛。</em></p>\n<h3 id=\"策略提升-Policy-Improvement\"><a href=\"#策略提升-Policy-Improvement\" class=\"headerlink\" title=\"策略提升 Policy Improvement\"></a>策略提升 Policy Improvement</h3><p>问题：如何更新策略？</p>\n<p>答：根据策略评估步骤得到的值函数$V(S)$，计算$Q(S,A)$表格，选取每个状态下使动作值函数最大的动作作为新的动作集，每个动作的选择概率相同，接着进行策略评估。</p>\n<p>特点：使用了贝尔曼期望方程-$q_{\\pi}(s,a)$</p>\n<h2 id=\"值迭代-Value-Iteration\"><a href=\"#值迭代-Value-Iteration\" class=\"headerlink\" title=\"值迭代 Value Iteration\"></a>值迭代 Value Iteration</h2><p>策略迭代的一个缺点是在得到最优策略$\\pi_{\\ast}$之前，需要多次更新策略，每次更新策略都会引起可选取动作的改变，这会引起在更新完策略后的前几次策略评估中值函数偏差比较大，导致在策略评估过程中需要花费大量的迭代来减小更新幅度$\\Delta$，因此需要多次sweep(横扫)$V(S)$来迭代计算。</p>\n<p>值迭代的思想是：<strong>能不能通过早停的方式，在不更改策略的情况下，直接一次得到最优策略？</strong></p>\n<p>值迭代运用了策略评估、策略迭代的思想，并将它们融合在一起，即不更新策略，直接选择动作值函数$q(s,a)$最大的动作作为状态值$v(s)$，直接迭代出<strong>近似最优</strong>（早停，$\\Delta \\lt \\theta$即可）状态价值函数$V_{\\ast}(S)$，使用贪心策略进而得到最优策略$\\pi_{\\ast}$。</p>\n<p>特点：使用了贝尔曼最优方程-$v_{\\ast}(s)，q_{\\ast}(s,a)$。</p>\n<h3 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h3><p><img src=\"./dynamic-programming/vi.png\" alt=\"\"></p>\n<h2 id=\"PI与VI的比较\"><a href=\"#PI与VI的比较\" class=\"headerlink\" title=\"PI与VI的比较\"></a>PI与VI的比较</h2><p><img src=\"./dynamic-programming/pivsvi.png\" alt=\"\"></p>\n<p>相同点：</p>\n<ul>\n<li>在$0 \\leq \\gamma \\lt 1$，有限MDPs环境中，两种方式都可以收敛到最优策略$\\pi_{\\ast}$</li>\n<li>都使用了贝尔曼方程进行状态值函数的迭代</li>\n</ul>\n<p>不同点：</p>\n<ol>\n<li>收敛方式<ul>\n<li>策略迭代PI包括策略评估Policy Evaluation和策略提升Policy Improvement，这两部循环迭代至策略收敛</li>\n<li>值迭代VI包括找到最优状态值函数和一步提取策略，这两步不需要循环迭代，而是根据最优值函数直接得到最优策略</li>\n</ul>\n</li>\n<li>动作改变方式<ul>\n<li>策略迭代PI获得新策略$\\pi_{new}$后，<strong>更改每个状态的可选动作集</strong>，多次横扫（遍历）$V(S)$</li>\n<li>值迭代VI过程中不产生策略，不更改每个状态的可选动作集，但是<strong>只取每个状态下动作值函数最大的动作作为状态值</strong>，一次横扫（遍历）$V(S)$。（这里需要解释一下，虽然循环是多次遍历，但是因为max操作，每次遍历每个状态所选取的动作不一定一样，虽然策略一直是随机策略，没有产生新策略，但是计算过程没有遍历到所有动作，可以隐含的看作是一个新策略，因此每次遍历时这个“隐策略”都会改变，所以称为一次遍历。）</li>\n</ul>\n</li>\n<li>计算方式<ul>\n<li>策略迭代PI使用贝尔曼期望方程</li>\n<li>值迭代VI使用贝尔曼最优方程</li>\n</ul>\n</li>\n<li>Policy方式<ul>\n<li>策略迭代PI是On-Policy</li>\n<li>值迭代VI是Off-Policy</li>\n</ul>\n</li>\n<li>稳定性检查<ul>\n<li>策略迭代PI中更新策略时进行了策略稳定性检查，判断是否收敛</li>\n<li>值迭代VI获得新策略$\\pi$时没有进行策略稳定性检查</li>\n</ul>\n</li>\n</ol>\n<p>至于策略迭代PI与值迭代VI的收敛速度，<strong>通常情况</strong>下，PI的迭代次数更少，VI的运行时间更少。</p>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/a/42493295/11483803\" rel=\"external nofollow\" target=\"_blank\">What is the difference between value iteration and policy iteration?</a></p>\n<p><a href=\"http://incompleteideas.net/book/RLbook2018.pdf\" rel=\"external nofollow\" target=\"_blank\">《Reinforcement Learning : An Introduction 2nd Edition》p77</a></p>\n</blockquote>"},{"title":"Energy-Based Hindsight Experience Prioritization","copyright":true,"mathjax":true,"top":1,"date":"2019-05-30T00:58:58.000Z","keywords":null,"description":null,"_content":"\n本文是对HER“事后”经验池机制的一个扩展，它结合了物理学的能量知识以及优先经验回放PER对HER进行提升。简称：EBP\n\n推荐：\n\n- 创新虽不多，但是基于能量的创意可以拓宽在机器人领域训练的视野\n- 通俗易懂\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1810.01363.pdf](https://arxiv.org/pdf/1810.01363.pdf)\n\n这篇论文由慕尼黑大学博三学生[赵瑞](https://ruizhaogit.github.io)和他的导师Volker Tresp发于2018年的CoRL会议。\n\n**本文提出了一个简单高效的、基于能量的方法去优先回放“事后经验”。Energy+HER+PER**\n\n在HER中，智能体从它可完成的“虚拟”目标中进行大量学习，虚拟目标就是我们使用“事后诸葛亮”方法所调整的经验中的目标。\n\n本文针对原始HER提出了一个稍有不足的地方：经验回放是完全随机的，即没有优先级，没有考虑哪些episode哪些经验对学习更有价值，其实这个问题与PER相对于传统经验池机制也是一样的。\n\n本文中使用的功能定理（work-energy principle）来计算能量。\n\n# 文中精要\n\n相比于传统的PER优先经验回放使用TD-error作为衡量优先级的度量，本文中使用“迹能量”作为其度量。\n\n迹能量是这么定义的：\n\n- > We define a trajectory energy function as the sum of the transition energy of the target object over the trajectory. \n\n- 迹能量是一个episode中transition energy（不知道怎么翻译合适，过渡能量？经验能量？转换能量？）的总和\n\n接下来介绍一下能量在本文中是如何体现的。\n\n## 经验能量差 Transition Energy\n\n我就直接拿论文中实验场景所用到的能力来说明这个能量差。简言之，在本文的实验中主要是操作机械手臂移动物体的水平位置和垂直高度，所以物体的能量基本包含三种：\n\n1. **势能 Potential Energy** $E_{p}(s_{t})$\n2. **动能 Kinetic Energy** $E_{k}(s_{t})$\n3. **转动能，也叫角动能 Rotational Energy** $E_{r}(s_{t})$\n\n一个物体的能量由这三部分之和组成：\n$$\nE\\left(s_{t}\\right)=E_{p}\\left(s_{t}\\right)+E_{k}\\left(s_{t}\\right)+E_{r}\\left(s_{t}\\right)\n$$\n经验能量差指的就是相邻状态转移之间的能量差值，表示为：\n$$\nE_{t r a n}\\left(s_{t-1}, s_{t}\\right)=\\operatorname{clip}\\left(E\\left(s_{t}\\right)-E\\left(s_{t-1}\\right), 0, E_{t r a n}^{\\max }\\right)\n$$\n其中，\n\n- 将差值clip到0是因为我们只对由机器人做功导致物体的能量增值感兴趣\n\n- 将差值clip到$E_{t r a n}^{\\max }$是想减缓某些特别大的能量差值的影响，使**训练更稳定**\n\n*注：其实我觉得文中加这个clip操作完全是想多使用一个trick，让文章看起来更饱满一点，我个人认为不使用这个clip，或者只对下界进行clip，对算法性能是没有影响的。有待验证。*\n\n### 势能 Potential Energy\n\n物理学中学过，物体的重力势能公式为：$E=mgh$\n\n本文中这样书写：\n$$\nE_{p}(s_{t})=mgz_{t}\n$$\n\n- $m$代表物体的质量\n- $g$代表地球的重力系数，$g \\approx 9.81 \\mathrm{m} / \\mathrm{s}^{2}$\n- $z_{t}$代表物体在$t$时刻的高度$h$\n\n### 动能 Kinetic Energy\n\n物理学中学过，物体的动能公式为：\n$$\nE=\\frac{1}{2} mv^{2}=\\frac{1}{2} m\\left [ \\frac{\\sqrt{v_{x}^{2}+v_{y}^{2}+v_{z}^{2}}}{\\Delta t} \\right ]^{2}\n$$\n本文中这样书写：\n$$\nE_{k}\\left(s_{t}\\right)=\\frac{1}{2} m v_{x, t}^{2}+\\frac{1}{2} m v_{y, t}^{2}+\\frac{1}{2} m v_{z, t}^{2} \\approx \\frac{m\\left(\\left(x_{t}-x_{t-1}\\right)^{2}+\\left(y_{t}-y_{t-1}\\right)^{2}+\\left(z_{t}-z_{t-1}\\right)^{2}\\right)}{2 \\Delta t^{2}}\n$$\n\n- $v_{x, t} \\approx\\left(x_{t}-x_{t-1}\\right) / \\Delta t$\n- $v_{y, t} \\approx\\left(y_{t}-y_{t-1}\\right) / \\Delta t$\n- $v_{z, t} \\approx\\left(z_{t}-z_{t-1}\\right) / \\Delta t$\n- $\\Delta t$表示相邻两个状态之间的时间间隔，假设我们在模拟器中，1秒60帧，即每帧16.67ms，我们如果每帧执行一次动作，那么$\\Delta t=16.67ms$，如果每60帧执行一次动作，那么$\\Delta t=1s$\n\n### 转动能 Rotational Energy\n\n物理学中学过，物体的转动能公式为：$K=\\frac{1}{2} I \\cdot \\omega^{2}$，注意，中间的点代表点乘，$I$代表物体的惯性矩，$\\omega$代表物体的角速度\n\n本文中这样书写：\n$$\n\\left[ \\begin{array}{c}{\\phi} \\\\ {\\theta} \\\\ {\\psi}\\end{array}\\right]=\\left[ \\begin{array}{c}{\\arctan \\frac{2(a b+c d)}{1-2\\left(b^{2}+c^{2}\\right)}} \\\\ {\\arcsin (2(a c-d b))} \\\\ {\\arcsin \\frac{2(a d+b c)}{1-2\\left(c^{2}+d^{2}\\right)}}\\end{array}\\right]=\\left[ \\begin{array}{c}{\\operatorname{atan} 2\\left(2(a b+c d), 1-2\\left(b^{2}+c^{2}\\right)\\right)} \\\\ {\\operatorname{asin}(2(a c-d b))} \\\\ {\\operatorname{atan} 2\\left(2(a d+b c), 1-2\\left(c^{2}+d^{2}\\right)\\right)}\\end{array}\\right]\n$$\n\n$$\nE_{r}\\left(s_{t}\\right)=\\frac{1}{2} I_{x} \\omega_{x, t}^{2}+\\frac{1}{2} I_{y} \\omega_{y, t}^{2}+\\frac{1}{2} I_{z} \\omega_{z, t}^{2} \\approx \\frac{I_{x}\\left(\\phi_{t}-\\phi_{t-1}\\right)^{2}+I_{y}\\left(\\theta_{t}-\\theta_{t-1}\\right)^{2}+I_{z}\\left(\\psi_{t}-\\psi_{t-1}\\right)^{2}}{2 \\Delta t^{2}}\n$$\n\n其中$a,b,c,d$为旋转四元组，其知识可以百度或google自行了解。\n\n\n$$\nq=a+b \\imath+c \\jmath+d k\n$$\n\n$\\phi, \\theta, \\psi$代表$x,y,z$轴方向的旋转角度\n\n- $\\omega_{x, t} \\approx\\left(\\phi_{t}-\\phi_{t-1}\\right) / \\Delta_{t}$\n- $\\omega_{y, t} \\approx\\left(\\theta_{t}-\\theta_{t-1}\\right) / \\Delta_{t}$\n- $\\omega_{z, t} \\approx\\left(\\psi_{t}-\\psi_{t-1}\\right) / \\Delta_{t}$\n- $\\Delta t$与上文解释相同\n\n**$m,I_{x},I_{y},I_{z}$可以设置为常量，本文实验中设置$m=I_{x}=I_{y}=I_{z}=1$**\n\n\n\n## 迹能量 Trajectory Energy\n\n给定一个回合中所有的经验能量差，迹能量可以表示为这个回合中所有经验能量差之和：\n$$\nE_{t r a j}(\\mathcal{T})=E_{t r a j}\\left(s_{0}, s_{1}, \\ldots, s_{T}\\right)=\\sum_{t=1}^{T} E_{t r a n}\\left(s_{t-1}, s_{t}\\right)\n$$\n\n## 基于能量的优先级\n\n首先计算迹能量，然后对迹能量高的迹（episode）优先进行回放。\n\n根据迹能量计算迹的优先级为：\n$$\np\\left(\\mathcal{T}_{i}\\right)=\\frac{E_{t r a j}\\left(\\mathcal{T}_{i}\\right)}{\\sum_{n=1}^{N} E_{t r a j}\\left(\\mathcal{T}_{n}\\right)}\n$$\n$N$代表经验池中迹的总数量\n\n## 伪代码\n\n![](./energy-based-hindsight-experience-prioritization/pseudo.png)\n\n解析：\n\n- 以本文实验为例，状态$s$由七元组$\\left[x_{t}, y_{t}, z_{t}, a_{t}, b_{t}, c_{t}, d_{t}\\right]$表示，其中前三个代表物体的位置，后三个代表物体旋转的四元组。\n- 目标$g$与状态$s$的表示相同\n- $||$操作符为连结的意思，即`tf.concat(a,b)`\n- 向经验池中存入的不仅仅有$(s,a,r,s')$，还有优先级$p$与迹能量$E_{traj}$，**其实我感觉这样很多余，如果使用sum-tree结构的，存其一即可**\n- 文中所使用的HER是**future模式**\n\n**注意：**\n\n我认为伪代码中有两行很有问题，即\n\n![](./energy-based-hindsight-experience-prioritization/issue.png)\n\n我不明白为什么把原始经验$\\left(s_{t}\\left\\|g, a_{t}, r_{t}, s_{t+1}\\right\\| g, p, E_{t r a j}\\right)$存入经验池之后，需要根据优先级采样一个迹，再从采样到的迹中采样出一个经验$\\left(s_{t}, a_{t}, s_{t+1}\\right)$\n\n起初我是这么认为的，它想对经验池中迹能量高的episode进行大概率抽取，并对其中的经验进行多次扩充，由此对迹能量小的episode更加忽视，突出迹能量高的episode\n\n但是，看到下一行![](./energy-based-hindsight-experience-prioritization/issue2.png)我有一个疑问：如果根据优先级采样出的迹$\\mathcal{T}$与当前所操作的迹$\\mathcal{T}_{current}$不同，那么，为什么还要为不同迹中的经验存入相同的优先级和迹能量呢？即$\\left(s_{t}\\left\\|g^{\\prime}, a_{t}, r_{t}^{\\prime}, s_{t+1}\\right\\| g^{\\prime}, p, E_{t r a j}\\right)$\n\n这样肯定是不行的，那么只有一个答案，采样迹这一步多余的，或者说，不应该出现在这里，而应该放在最后一个循环的开始，即\n\n![](./energy-based-hindsight-experience-prioritization/issue3.png)\n\n也就是说，应该把采样迹，从迹中采样经验的步骤放在minibatch之前，这样就合情合理了。\n\n这是我自己的一个疑问，如果读者有其他见解，欢迎置评讨论。\n\n## EBP的总结\n\nEBP与PER的不同点：\n\n- EBP使用物理学中的能量\n- PER使用TD-error\n\n相比于将HER与PER结合而使用TD-error作为衡量优先级的方法，使用迹能量较少了计算量，因为PER每次回放经验都必须重新计算使用经验的新的TD-error，并存回经验池。（其实，如果使用sum-tree来构建PER，这个劣势其实很小）\n\n文中通过实验发现：比较PER与EBP的时间复杂性，显示EBP提升了算法的性能效果（performance）但是却不增加额外的计算量。PER则提升较少，计算量也增加了。\n\nEBP的优点：\n\n- 可结合任意off-policy算法\n- 结合了物理知识，使其可以应用于现实世界的问题\n- 提升采样效率进两倍\n- 相比最先进的（state-of-the-art）算法，不增加计算时间的情况下，算法效果提升了4个百分点。（此条可以忽略，因为其未必做了充分的实验来进行对比）\n- 适用于任何机器人操作任务\n- 适用于多目标算法\n\n# 实验部分\n\n文中实验结果：[https://youtu.be/jtsF2tTeUGQ](https://youtu.be/jtsF2tTeUGQ)\n\n代码地址：[https://github.com/ruizhaogit/EnergyBasedPrioritization](https://github.com/ruizhaogit/EnergyBasedPrioritization)\n\n实验部分的完整细节请参考论文原文。\n\n## 环境\n\n- OpenAI Gym与MuJoCo物理引擎\n- 一个7自由度的机械手臂，与HER中一样；一个24自由度的机器手\n- 四项任务：pick & place，机器手操作方块、蛋、笔\n\n![](./energy-based-hindsight-experience-prioritization/env.png)\n\n- 使用稀疏奖励，二分奖励，完成容忍度内目标为0，否则为-1\n\n## 算法\n\n- 文中没有说明具体使用什么算法作对比，只有伪代码中提到了DPG、DDPG\n- 文中亦没有对算法中的超参数设置、网络结构进行说明\n- 19个CPU\n- 器械臂场景$E_{t r a n}^{\\max }=0.5$，机械手场景$E_{t r a n}^{\\max }=2.5$\n- 文中主要比较了HER、HER+PER、HER+EBP\n\n## 实验结果\n\n![](./energy-based-hindsight-experience-prioritization/meansuccessrate.png)\n\n- 横坐标是训练的轮数，应该是指episode的意思\n- 纵坐标是5个随机种子实验的平均成功率\n- 蓝色代表HER+EBP，橘色代表HER，绿色代表HER+PER\n\n![](./energy-based-hindsight-experience-prioritization/trainingtime.png)\n\n结果：\n\n- 从上图可以看出，四项任务中，HER+EBP比其他两种方法收敛速度都快，效果也更好一点\n- 从上表可以看出，HER+EBP与HER的训练时间基本相同，而HER+PER要消耗10倍的时间\n\n---\n\n![](./energy-based-hindsight-experience-prioritization/finalmeanrate.png)\n\n结果：\n\n- 训练结束后，HER+EBP在四项任务中效果都最好\n- HER+EBP比HER提高了1-5个百分点，平均提升了3.75个百分点\n\n>We can see that EBP is a simple yet effective method, without increasing computational time, but still, improves current state-of-the-art methods. \n\n![](./energy-based-hindsight-experience-prioritization/sampleefficiency.png)\n\n结果：\n\n- 采样效率方面，总体来看，EBP+HER比HER提升了2倍\n\n---\n\n最后，作者比较了迹能量与TD-error的pearson相关系数\n\n- 系数为1，即正线性相关\n- 系数为-1，即负线性相关\n- 系数为0，即不线性相关\n\n![](./energy-based-hindsight-experience-prioritization/pearsoncorrelation.png)\n\n结果：\n\n- 四个实验中，迹能量与TD-error均成正相关\n- 平均下来pearson系数为0.6，说明迹能量与TD-error呈正线性相关关系，也就是说迹能量可以像TD-error一样表示经验的可学习价值","source":"_posts/energy-based-hindsight-experience-prioritization.md","raw":"---\ntitle: Energy-Based Hindsight Experience Prioritization\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2019-05-30 08:58:58\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n本文是对HER“事后”经验池机制的一个扩展，它结合了物理学的能量知识以及优先经验回放PER对HER进行提升。简称：EBP\n\n推荐：\n\n- 创新虽不多，但是基于能量的创意可以拓宽在机器人领域训练的视野\n- 通俗易懂\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1810.01363.pdf](https://arxiv.org/pdf/1810.01363.pdf)\n\n这篇论文由慕尼黑大学博三学生[赵瑞](https://ruizhaogit.github.io)和他的导师Volker Tresp发于2018年的CoRL会议。\n\n**本文提出了一个简单高效的、基于能量的方法去优先回放“事后经验”。Energy+HER+PER**\n\n在HER中，智能体从它可完成的“虚拟”目标中进行大量学习，虚拟目标就是我们使用“事后诸葛亮”方法所调整的经验中的目标。\n\n本文针对原始HER提出了一个稍有不足的地方：经验回放是完全随机的，即没有优先级，没有考虑哪些episode哪些经验对学习更有价值，其实这个问题与PER相对于传统经验池机制也是一样的。\n\n本文中使用的功能定理（work-energy principle）来计算能量。\n\n# 文中精要\n\n相比于传统的PER优先经验回放使用TD-error作为衡量优先级的度量，本文中使用“迹能量”作为其度量。\n\n迹能量是这么定义的：\n\n- > We define a trajectory energy function as the sum of the transition energy of the target object over the trajectory. \n\n- 迹能量是一个episode中transition energy（不知道怎么翻译合适，过渡能量？经验能量？转换能量？）的总和\n\n接下来介绍一下能量在本文中是如何体现的。\n\n## 经验能量差 Transition Energy\n\n我就直接拿论文中实验场景所用到的能力来说明这个能量差。简言之，在本文的实验中主要是操作机械手臂移动物体的水平位置和垂直高度，所以物体的能量基本包含三种：\n\n1. **势能 Potential Energy** $E_{p}(s_{t})$\n2. **动能 Kinetic Energy** $E_{k}(s_{t})$\n3. **转动能，也叫角动能 Rotational Energy** $E_{r}(s_{t})$\n\n一个物体的能量由这三部分之和组成：\n$$\nE\\left(s_{t}\\right)=E_{p}\\left(s_{t}\\right)+E_{k}\\left(s_{t}\\right)+E_{r}\\left(s_{t}\\right)\n$$\n经验能量差指的就是相邻状态转移之间的能量差值，表示为：\n$$\nE_{t r a n}\\left(s_{t-1}, s_{t}\\right)=\\operatorname{clip}\\left(E\\left(s_{t}\\right)-E\\left(s_{t-1}\\right), 0, E_{t r a n}^{\\max }\\right)\n$$\n其中，\n\n- 将差值clip到0是因为我们只对由机器人做功导致物体的能量增值感兴趣\n\n- 将差值clip到$E_{t r a n}^{\\max }$是想减缓某些特别大的能量差值的影响，使**训练更稳定**\n\n*注：其实我觉得文中加这个clip操作完全是想多使用一个trick，让文章看起来更饱满一点，我个人认为不使用这个clip，或者只对下界进行clip，对算法性能是没有影响的。有待验证。*\n\n### 势能 Potential Energy\n\n物理学中学过，物体的重力势能公式为：$E=mgh$\n\n本文中这样书写：\n$$\nE_{p}(s_{t})=mgz_{t}\n$$\n\n- $m$代表物体的质量\n- $g$代表地球的重力系数，$g \\approx 9.81 \\mathrm{m} / \\mathrm{s}^{2}$\n- $z_{t}$代表物体在$t$时刻的高度$h$\n\n### 动能 Kinetic Energy\n\n物理学中学过，物体的动能公式为：\n$$\nE=\\frac{1}{2} mv^{2}=\\frac{1}{2} m\\left [ \\frac{\\sqrt{v_{x}^{2}+v_{y}^{2}+v_{z}^{2}}}{\\Delta t} \\right ]^{2}\n$$\n本文中这样书写：\n$$\nE_{k}\\left(s_{t}\\right)=\\frac{1}{2} m v_{x, t}^{2}+\\frac{1}{2} m v_{y, t}^{2}+\\frac{1}{2} m v_{z, t}^{2} \\approx \\frac{m\\left(\\left(x_{t}-x_{t-1}\\right)^{2}+\\left(y_{t}-y_{t-1}\\right)^{2}+\\left(z_{t}-z_{t-1}\\right)^{2}\\right)}{2 \\Delta t^{2}}\n$$\n\n- $v_{x, t} \\approx\\left(x_{t}-x_{t-1}\\right) / \\Delta t$\n- $v_{y, t} \\approx\\left(y_{t}-y_{t-1}\\right) / \\Delta t$\n- $v_{z, t} \\approx\\left(z_{t}-z_{t-1}\\right) / \\Delta t$\n- $\\Delta t$表示相邻两个状态之间的时间间隔，假设我们在模拟器中，1秒60帧，即每帧16.67ms，我们如果每帧执行一次动作，那么$\\Delta t=16.67ms$，如果每60帧执行一次动作，那么$\\Delta t=1s$\n\n### 转动能 Rotational Energy\n\n物理学中学过，物体的转动能公式为：$K=\\frac{1}{2} I \\cdot \\omega^{2}$，注意，中间的点代表点乘，$I$代表物体的惯性矩，$\\omega$代表物体的角速度\n\n本文中这样书写：\n$$\n\\left[ \\begin{array}{c}{\\phi} \\\\ {\\theta} \\\\ {\\psi}\\end{array}\\right]=\\left[ \\begin{array}{c}{\\arctan \\frac{2(a b+c d)}{1-2\\left(b^{2}+c^{2}\\right)}} \\\\ {\\arcsin (2(a c-d b))} \\\\ {\\arcsin \\frac{2(a d+b c)}{1-2\\left(c^{2}+d^{2}\\right)}}\\end{array}\\right]=\\left[ \\begin{array}{c}{\\operatorname{atan} 2\\left(2(a b+c d), 1-2\\left(b^{2}+c^{2}\\right)\\right)} \\\\ {\\operatorname{asin}(2(a c-d b))} \\\\ {\\operatorname{atan} 2\\left(2(a d+b c), 1-2\\left(c^{2}+d^{2}\\right)\\right)}\\end{array}\\right]\n$$\n\n$$\nE_{r}\\left(s_{t}\\right)=\\frac{1}{2} I_{x} \\omega_{x, t}^{2}+\\frac{1}{2} I_{y} \\omega_{y, t}^{2}+\\frac{1}{2} I_{z} \\omega_{z, t}^{2} \\approx \\frac{I_{x}\\left(\\phi_{t}-\\phi_{t-1}\\right)^{2}+I_{y}\\left(\\theta_{t}-\\theta_{t-1}\\right)^{2}+I_{z}\\left(\\psi_{t}-\\psi_{t-1}\\right)^{2}}{2 \\Delta t^{2}}\n$$\n\n其中$a,b,c,d$为旋转四元组，其知识可以百度或google自行了解。\n\n\n$$\nq=a+b \\imath+c \\jmath+d k\n$$\n\n$\\phi, \\theta, \\psi$代表$x,y,z$轴方向的旋转角度\n\n- $\\omega_{x, t} \\approx\\left(\\phi_{t}-\\phi_{t-1}\\right) / \\Delta_{t}$\n- $\\omega_{y, t} \\approx\\left(\\theta_{t}-\\theta_{t-1}\\right) / \\Delta_{t}$\n- $\\omega_{z, t} \\approx\\left(\\psi_{t}-\\psi_{t-1}\\right) / \\Delta_{t}$\n- $\\Delta t$与上文解释相同\n\n**$m,I_{x},I_{y},I_{z}$可以设置为常量，本文实验中设置$m=I_{x}=I_{y}=I_{z}=1$**\n\n\n\n## 迹能量 Trajectory Energy\n\n给定一个回合中所有的经验能量差，迹能量可以表示为这个回合中所有经验能量差之和：\n$$\nE_{t r a j}(\\mathcal{T})=E_{t r a j}\\left(s_{0}, s_{1}, \\ldots, s_{T}\\right)=\\sum_{t=1}^{T} E_{t r a n}\\left(s_{t-1}, s_{t}\\right)\n$$\n\n## 基于能量的优先级\n\n首先计算迹能量，然后对迹能量高的迹（episode）优先进行回放。\n\n根据迹能量计算迹的优先级为：\n$$\np\\left(\\mathcal{T}_{i}\\right)=\\frac{E_{t r a j}\\left(\\mathcal{T}_{i}\\right)}{\\sum_{n=1}^{N} E_{t r a j}\\left(\\mathcal{T}_{n}\\right)}\n$$\n$N$代表经验池中迹的总数量\n\n## 伪代码\n\n![](./energy-based-hindsight-experience-prioritization/pseudo.png)\n\n解析：\n\n- 以本文实验为例，状态$s$由七元组$\\left[x_{t}, y_{t}, z_{t}, a_{t}, b_{t}, c_{t}, d_{t}\\right]$表示，其中前三个代表物体的位置，后三个代表物体旋转的四元组。\n- 目标$g$与状态$s$的表示相同\n- $||$操作符为连结的意思，即`tf.concat(a,b)`\n- 向经验池中存入的不仅仅有$(s,a,r,s')$，还有优先级$p$与迹能量$E_{traj}$，**其实我感觉这样很多余，如果使用sum-tree结构的，存其一即可**\n- 文中所使用的HER是**future模式**\n\n**注意：**\n\n我认为伪代码中有两行很有问题，即\n\n![](./energy-based-hindsight-experience-prioritization/issue.png)\n\n我不明白为什么把原始经验$\\left(s_{t}\\left\\|g, a_{t}, r_{t}, s_{t+1}\\right\\| g, p, E_{t r a j}\\right)$存入经验池之后，需要根据优先级采样一个迹，再从采样到的迹中采样出一个经验$\\left(s_{t}, a_{t}, s_{t+1}\\right)$\n\n起初我是这么认为的，它想对经验池中迹能量高的episode进行大概率抽取，并对其中的经验进行多次扩充，由此对迹能量小的episode更加忽视，突出迹能量高的episode\n\n但是，看到下一行![](./energy-based-hindsight-experience-prioritization/issue2.png)我有一个疑问：如果根据优先级采样出的迹$\\mathcal{T}$与当前所操作的迹$\\mathcal{T}_{current}$不同，那么，为什么还要为不同迹中的经验存入相同的优先级和迹能量呢？即$\\left(s_{t}\\left\\|g^{\\prime}, a_{t}, r_{t}^{\\prime}, s_{t+1}\\right\\| g^{\\prime}, p, E_{t r a j}\\right)$\n\n这样肯定是不行的，那么只有一个答案，采样迹这一步多余的，或者说，不应该出现在这里，而应该放在最后一个循环的开始，即\n\n![](./energy-based-hindsight-experience-prioritization/issue3.png)\n\n也就是说，应该把采样迹，从迹中采样经验的步骤放在minibatch之前，这样就合情合理了。\n\n这是我自己的一个疑问，如果读者有其他见解，欢迎置评讨论。\n\n## EBP的总结\n\nEBP与PER的不同点：\n\n- EBP使用物理学中的能量\n- PER使用TD-error\n\n相比于将HER与PER结合而使用TD-error作为衡量优先级的方法，使用迹能量较少了计算量，因为PER每次回放经验都必须重新计算使用经验的新的TD-error，并存回经验池。（其实，如果使用sum-tree来构建PER，这个劣势其实很小）\n\n文中通过实验发现：比较PER与EBP的时间复杂性，显示EBP提升了算法的性能效果（performance）但是却不增加额外的计算量。PER则提升较少，计算量也增加了。\n\nEBP的优点：\n\n- 可结合任意off-policy算法\n- 结合了物理知识，使其可以应用于现实世界的问题\n- 提升采样效率进两倍\n- 相比最先进的（state-of-the-art）算法，不增加计算时间的情况下，算法效果提升了4个百分点。（此条可以忽略，因为其未必做了充分的实验来进行对比）\n- 适用于任何机器人操作任务\n- 适用于多目标算法\n\n# 实验部分\n\n文中实验结果：[https://youtu.be/jtsF2tTeUGQ](https://youtu.be/jtsF2tTeUGQ)\n\n代码地址：[https://github.com/ruizhaogit/EnergyBasedPrioritization](https://github.com/ruizhaogit/EnergyBasedPrioritization)\n\n实验部分的完整细节请参考论文原文。\n\n## 环境\n\n- OpenAI Gym与MuJoCo物理引擎\n- 一个7自由度的机械手臂，与HER中一样；一个24自由度的机器手\n- 四项任务：pick & place，机器手操作方块、蛋、笔\n\n![](./energy-based-hindsight-experience-prioritization/env.png)\n\n- 使用稀疏奖励，二分奖励，完成容忍度内目标为0，否则为-1\n\n## 算法\n\n- 文中没有说明具体使用什么算法作对比，只有伪代码中提到了DPG、DDPG\n- 文中亦没有对算法中的超参数设置、网络结构进行说明\n- 19个CPU\n- 器械臂场景$E_{t r a n}^{\\max }=0.5$，机械手场景$E_{t r a n}^{\\max }=2.5$\n- 文中主要比较了HER、HER+PER、HER+EBP\n\n## 实验结果\n\n![](./energy-based-hindsight-experience-prioritization/meansuccessrate.png)\n\n- 横坐标是训练的轮数，应该是指episode的意思\n- 纵坐标是5个随机种子实验的平均成功率\n- 蓝色代表HER+EBP，橘色代表HER，绿色代表HER+PER\n\n![](./energy-based-hindsight-experience-prioritization/trainingtime.png)\n\n结果：\n\n- 从上图可以看出，四项任务中，HER+EBP比其他两种方法收敛速度都快，效果也更好一点\n- 从上表可以看出，HER+EBP与HER的训练时间基本相同，而HER+PER要消耗10倍的时间\n\n---\n\n![](./energy-based-hindsight-experience-prioritization/finalmeanrate.png)\n\n结果：\n\n- 训练结束后，HER+EBP在四项任务中效果都最好\n- HER+EBP比HER提高了1-5个百分点，平均提升了3.75个百分点\n\n>We can see that EBP is a simple yet effective method, without increasing computational time, but still, improves current state-of-the-art methods. \n\n![](./energy-based-hindsight-experience-prioritization/sampleefficiency.png)\n\n结果：\n\n- 采样效率方面，总体来看，EBP+HER比HER提升了2倍\n\n---\n\n最后，作者比较了迹能量与TD-error的pearson相关系数\n\n- 系数为1，即正线性相关\n- 系数为-1，即负线性相关\n- 系数为0，即不线性相关\n\n![](./energy-based-hindsight-experience-prioritization/pearsoncorrelation.png)\n\n结果：\n\n- 四个实验中，迹能量与TD-error均成正相关\n- 平均下来pearson系数为0.6，说明迹能量与TD-error呈正线性相关关系，也就是说迹能量可以像TD-error一样表示经验的可学习价值","slug":"energy-based-hindsight-experience-prioritization","published":1,"updated":"2019-05-30T09:52:24.500Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut8x004u20cd2ax0y581","content":"<p>本文是对HER“事后”经验池机制的一个扩展，它结合了物理学的能量知识以及优先经验回放PER对HER进行提升。简称：EBP</p>\n<p>推荐：</p>\n<ul>\n<li>创新虽不多，但是基于能量的创意可以拓宽在机器人领域训练的视野</li>\n<li>通俗易懂</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1810.01363.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1810.01363.pdf</a></p>\n<p>这篇论文由慕尼黑大学博三学生<a href=\"https://ruizhaogit.github.io\" rel=\"external nofollow\" target=\"_blank\">赵瑞</a>和他的导师Volker Tresp发于2018年的CoRL会议。</p>\n<p><strong>本文提出了一个简单高效的、基于能量的方法去优先回放“事后经验”。Energy+HER+PER</strong></p>\n<p>在HER中，智能体从它可完成的“虚拟”目标中进行大量学习，虚拟目标就是我们使用“事后诸葛亮”方法所调整的经验中的目标。</p>\n<p>本文针对原始HER提出了一个稍有不足的地方：经验回放是完全随机的，即没有优先级，没有考虑哪些episode哪些经验对学习更有价值，其实这个问题与PER相对于传统经验池机制也是一样的。</p>\n<p>本文中使用的功能定理（work-energy principle）来计算能量。</p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>相比于传统的PER优先经验回放使用TD-error作为衡量优先级的度量，本文中使用“迹能量”作为其度量。</p>\n<p>迹能量是这么定义的：</p>\n<ul>\n<li><blockquote>\n<p>We define a trajectory energy function as the sum of the transition energy of the target object over the trajectory. </p>\n</blockquote>\n</li>\n<li><p>迹能量是一个episode中transition energy（不知道怎么翻译合适，过渡能量？经验能量？转换能量？）的总和</p>\n</li>\n</ul>\n<p>接下来介绍一下能量在本文中是如何体现的。</p>\n<h2 id=\"经验能量差-Transition-Energy\"><a href=\"#经验能量差-Transition-Energy\" class=\"headerlink\" title=\"经验能量差 Transition Energy\"></a>经验能量差 Transition Energy</h2><p>我就直接拿论文中实验场景所用到的能力来说明这个能量差。简言之，在本文的实验中主要是操作机械手臂移动物体的水平位置和垂直高度，所以物体的能量基本包含三种：</p>\n<ol>\n<li><strong>势能 Potential Energy</strong> $E_{p}(s_{t})$</li>\n<li><strong>动能 Kinetic Energy</strong> $E_{k}(s_{t})$</li>\n<li><strong>转动能，也叫角动能 Rotational Energy</strong> $E_{r}(s_{t})$</li>\n</ol>\n<p>一个物体的能量由这三部分之和组成：</p>\n<script type=\"math/tex; mode=display\">\nE\\left(s_{t}\\right)=E_{p}\\left(s_{t}\\right)+E_{k}\\left(s_{t}\\right)+E_{r}\\left(s_{t}\\right)</script><p>经验能量差指的就是相邻状态转移之间的能量差值，表示为：</p>\n<script type=\"math/tex; mode=display\">\nE_{t r a n}\\left(s_{t-1}, s_{t}\\right)=\\operatorname{clip}\\left(E\\left(s_{t}\\right)-E\\left(s_{t-1}\\right), 0, E_{t r a n}^{\\max }\\right)</script><p>其中，</p>\n<ul>\n<li><p>将差值clip到0是因为我们只对由机器人做功导致物体的能量增值感兴趣</p>\n</li>\n<li><p>将差值clip到$E_{t r a n}^{\\max }$是想减缓某些特别大的能量差值的影响，使<strong>训练更稳定</strong></p>\n</li>\n</ul>\n<p><em>注：其实我觉得文中加这个clip操作完全是想多使用一个trick，让文章看起来更饱满一点，我个人认为不使用这个clip，或者只对下界进行clip，对算法性能是没有影响的。有待验证。</em></p>\n<h3 id=\"势能-Potential-Energy\"><a href=\"#势能-Potential-Energy\" class=\"headerlink\" title=\"势能 Potential Energy\"></a>势能 Potential Energy</h3><p>物理学中学过，物体的重力势能公式为：$E=mgh$</p>\n<p>本文中这样书写：</p>\n<script type=\"math/tex; mode=display\">\nE_{p}(s_{t})=mgz_{t}</script><ul>\n<li>$m$代表物体的质量</li>\n<li>$g$代表地球的重力系数，$g \\approx 9.81 \\mathrm{m} / \\mathrm{s}^{2}$</li>\n<li>$z_{t}$代表物体在$t$时刻的高度$h$</li>\n</ul>\n<h3 id=\"动能-Kinetic-Energy\"><a href=\"#动能-Kinetic-Energy\" class=\"headerlink\" title=\"动能 Kinetic Energy\"></a>动能 Kinetic Energy</h3><p>物理学中学过，物体的动能公式为：</p>\n<script type=\"math/tex; mode=display\">\nE=\\frac{1}{2} mv^{2}=\\frac{1}{2} m\\left [ \\frac{\\sqrt{v_{x}^{2}+v_{y}^{2}+v_{z}^{2}}}{\\Delta t} \\right ]^{2}</script><p>本文中这样书写：</p>\n<script type=\"math/tex; mode=display\">\nE_{k}\\left(s_{t}\\right)=\\frac{1}{2} m v_{x, t}^{2}+\\frac{1}{2} m v_{y, t}^{2}+\\frac{1}{2} m v_{z, t}^{2} \\approx \\frac{m\\left(\\left(x_{t}-x_{t-1}\\right)^{2}+\\left(y_{t}-y_{t-1}\\right)^{2}+\\left(z_{t}-z_{t-1}\\right)^{2}\\right)}{2 \\Delta t^{2}}</script><ul>\n<li>$v_{x, t} \\approx\\left(x_{t}-x_{t-1}\\right) / \\Delta t$</li>\n<li>$v_{y, t} \\approx\\left(y_{t}-y_{t-1}\\right) / \\Delta t$</li>\n<li>$v_{z, t} \\approx\\left(z_{t}-z_{t-1}\\right) / \\Delta t$</li>\n<li>$\\Delta t$表示相邻两个状态之间的时间间隔，假设我们在模拟器中，1秒60帧，即每帧16.67ms，我们如果每帧执行一次动作，那么$\\Delta t=16.67ms$，如果每60帧执行一次动作，那么$\\Delta t=1s$</li>\n</ul>\n<h3 id=\"转动能-Rotational-Energy\"><a href=\"#转动能-Rotational-Energy\" class=\"headerlink\" title=\"转动能 Rotational Energy\"></a>转动能 Rotational Energy</h3><p>物理学中学过，物体的转动能公式为：$K=\\frac{1}{2} I \\cdot \\omega^{2}$，注意，中间的点代表点乘，$I$代表物体的惯性矩，$\\omega$代表物体的角速度</p>\n<p>本文中这样书写：</p>\n<script type=\"math/tex; mode=display\">\n\\left[ \\begin{array}{c}{\\phi} \\\\ {\\theta} \\\\ {\\psi}\\end{array}\\right]=\\left[ \\begin{array}{c}{\\arctan \\frac{2(a b+c d)}{1-2\\left(b^{2}+c^{2}\\right)}} \\\\ {\\arcsin (2(a c-d b))} \\\\ {\\arcsin \\frac{2(a d+b c)}{1-2\\left(c^{2}+d^{2}\\right)}}\\end{array}\\right]=\\left[ \\begin{array}{c}{\\operatorname{atan} 2\\left(2(a b+c d), 1-2\\left(b^{2}+c^{2}\\right)\\right)} \\\\ {\\operatorname{asin}(2(a c-d b))} \\\\ {\\operatorname{atan} 2\\left(2(a d+b c), 1-2\\left(c^{2}+d^{2}\\right)\\right)}\\end{array}\\right]</script><script type=\"math/tex; mode=display\">\nE_{r}\\left(s_{t}\\right)=\\frac{1}{2} I_{x} \\omega_{x, t}^{2}+\\frac{1}{2} I_{y} \\omega_{y, t}^{2}+\\frac{1}{2} I_{z} \\omega_{z, t}^{2} \\approx \\frac{I_{x}\\left(\\phi_{t}-\\phi_{t-1}\\right)^{2}+I_{y}\\left(\\theta_{t}-\\theta_{t-1}\\right)^{2}+I_{z}\\left(\\psi_{t}-\\psi_{t-1}\\right)^{2}}{2 \\Delta t^{2}}</script><p>其中$a,b,c,d$为旋转四元组，其知识可以百度或google自行了解。</p>\n<script type=\"math/tex; mode=display\">\nq=a+b \\imath+c \\jmath+d k</script><p>$\\phi, \\theta, \\psi$代表$x,y,z$轴方向的旋转角度</p>\n<ul>\n<li>$\\omega_{x, t} \\approx\\left(\\phi_{t}-\\phi_{t-1}\\right) / \\Delta_{t}$</li>\n<li>$\\omega_{y, t} \\approx\\left(\\theta_{t}-\\theta_{t-1}\\right) / \\Delta_{t}$</li>\n<li>$\\omega_{z, t} \\approx\\left(\\psi_{t}-\\psi_{t-1}\\right) / \\Delta_{t}$</li>\n<li>$\\Delta t$与上文解释相同</li>\n</ul>\n<p><strong>$m,I_{x},I_{y},I_{z}$可以设置为常量，本文实验中设置$m=I_{x}=I_{y}=I_{z}=1$</strong></p>\n<h2 id=\"迹能量-Trajectory-Energy\"><a href=\"#迹能量-Trajectory-Energy\" class=\"headerlink\" title=\"迹能量 Trajectory Energy\"></a>迹能量 Trajectory Energy</h2><p>给定一个回合中所有的经验能量差，迹能量可以表示为这个回合中所有经验能量差之和：</p>\n<script type=\"math/tex; mode=display\">\nE_{t r a j}(\\mathcal{T})=E_{t r a j}\\left(s_{0}, s_{1}, \\ldots, s_{T}\\right)=\\sum_{t=1}^{T} E_{t r a n}\\left(s_{t-1}, s_{t}\\right)</script><h2 id=\"基于能量的优先级\"><a href=\"#基于能量的优先级\" class=\"headerlink\" title=\"基于能量的优先级\"></a>基于能量的优先级</h2><p>首先计算迹能量，然后对迹能量高的迹（episode）优先进行回放。</p>\n<p>根据迹能量计算迹的优先级为：</p>\n<script type=\"math/tex; mode=display\">\np\\left(\\mathcal{T}_{i}\\right)=\\frac{E_{t r a j}\\left(\\mathcal{T}_{i}\\right)}{\\sum_{n=1}^{N} E_{t r a j}\\left(\\mathcal{T}_{n}\\right)}</script><p>$N$代表经验池中迹的总数量</p>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./energy-based-hindsight-experience-prioritization/pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>以本文实验为例，状态$s$由七元组$\\left[x_{t}, y_{t}, z_{t}, a_{t}, b_{t}, c_{t}, d_{t}\\right]$表示，其中前三个代表物体的位置，后三个代表物体旋转的四元组。</li>\n<li>目标$g$与状态$s$的表示相同</li>\n<li>$||$操作符为连结的意思，即<code>tf.concat(a,b)</code></li>\n<li>向经验池中存入的不仅仅有$(s,a,r,s’)$，还有优先级$p$与迹能量$E_{traj}$，<strong>其实我感觉这样很多余，如果使用sum-tree结构的，存其一即可</strong></li>\n<li>文中所使用的HER是<strong>future模式</strong></li>\n</ul>\n<p><strong>注意：</strong></p>\n<p>我认为伪代码中有两行很有问题，即</p>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/issue.png\" alt=\"\"></p>\n<p>我不明白为什么把原始经验$\\left(s_{t}\\left|g, a_{t}, r_{t}, s_{t+1}\\right| g, p, E_{t r a j}\\right)$存入经验池之后，需要根据优先级采样一个迹，再从采样到的迹中采样出一个经验$\\left(s_{t}, a_{t}, s_{t+1}\\right)$</p>\n<p>起初我是这么认为的，它想对经验池中迹能量高的episode进行大概率抽取，并对其中的经验进行多次扩充，由此对迹能量小的episode更加忽视，突出迹能量高的episode</p>\n<p>但是，看到下一行<img src=\"./energy-based-hindsight-experience-prioritization/issue2.png\" alt=\"\">我有一个疑问：如果根据优先级采样出的迹$\\mathcal{T}$与当前所操作的迹$\\mathcal{T}_{current}$不同，那么，为什么还要为不同迹中的经验存入相同的优先级和迹能量呢？即$\\left(s_{t}\\left|g^{\\prime}, a_{t}, r_{t}^{\\prime}, s_{t+1}\\right| g^{\\prime}, p, E_{t r a j}\\right)$</p>\n<p>这样肯定是不行的，那么只有一个答案，采样迹这一步多余的，或者说，不应该出现在这里，而应该放在最后一个循环的开始，即</p>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/issue3.png\" alt=\"\"></p>\n<p>也就是说，应该把采样迹，从迹中采样经验的步骤放在minibatch之前，这样就合情合理了。</p>\n<p>这是我自己的一个疑问，如果读者有其他见解，欢迎置评讨论。</p>\n<h2 id=\"EBP的总结\"><a href=\"#EBP的总结\" class=\"headerlink\" title=\"EBP的总结\"></a>EBP的总结</h2><p>EBP与PER的不同点：</p>\n<ul>\n<li>EBP使用物理学中的能量</li>\n<li>PER使用TD-error</li>\n</ul>\n<p>相比于将HER与PER结合而使用TD-error作为衡量优先级的方法，使用迹能量较少了计算量，因为PER每次回放经验都必须重新计算使用经验的新的TD-error，并存回经验池。（其实，如果使用sum-tree来构建PER，这个劣势其实很小）</p>\n<p>文中通过实验发现：比较PER与EBP的时间复杂性，显示EBP提升了算法的性能效果（performance）但是却不增加额外的计算量。PER则提升较少，计算量也增加了。</p>\n<p>EBP的优点：</p>\n<ul>\n<li>可结合任意off-policy算法</li>\n<li>结合了物理知识，使其可以应用于现实世界的问题</li>\n<li>提升采样效率进两倍</li>\n<li>相比最先进的（state-of-the-art）算法，不增加计算时间的情况下，算法效果提升了4个百分点。（此条可以忽略，因为其未必做了充分的实验来进行对比）</li>\n<li>适用于任何机器人操作任务</li>\n<li>适用于多目标算法</li>\n</ul>\n<h1 id=\"实验部分\"><a href=\"#实验部分\" class=\"headerlink\" title=\"实验部分\"></a>实验部分</h1><p>文中实验结果：<a href=\"https://youtu.be/jtsF2tTeUGQ\" rel=\"external nofollow\" target=\"_blank\">https://youtu.be/jtsF2tTeUGQ</a></p>\n<p>代码地址：<a href=\"https://github.com/ruizhaogit/EnergyBasedPrioritization\" rel=\"external nofollow\" target=\"_blank\">https://github.com/ruizhaogit/EnergyBasedPrioritization</a></p>\n<p>实验部分的完整细节请参考论文原文。</p>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><ul>\n<li>OpenAI Gym与MuJoCo物理引擎</li>\n<li>一个7自由度的机械手臂，与HER中一样；一个24自由度的机器手</li>\n<li>四项任务：pick &amp; place，机器手操作方块、蛋、笔</li>\n</ul>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/env.png\" alt=\"\"></p>\n<ul>\n<li>使用稀疏奖励，二分奖励，完成容忍度内目标为0，否则为-1</li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><ul>\n<li>文中没有说明具体使用什么算法作对比，只有伪代码中提到了DPG、DDPG</li>\n<li>文中亦没有对算法中的超参数设置、网络结构进行说明</li>\n<li>19个CPU</li>\n<li>器械臂场景$E_{t r a n}^{\\max }=0.5$，机械手场景$E_{t r a n}^{\\max }=2.5$</li>\n<li>文中主要比较了HER、HER+PER、HER+EBP</li>\n</ul>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p><img src=\"./energy-based-hindsight-experience-prioritization/meansuccessrate.png\" alt=\"\"></p>\n<ul>\n<li>横坐标是训练的轮数，应该是指episode的意思</li>\n<li>纵坐标是5个随机种子实验的平均成功率</li>\n<li>蓝色代表HER+EBP，橘色代表HER，绿色代表HER+PER</li>\n</ul>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/trainingtime.png\" alt=\"\"></p>\n<p>结果：</p>\n<ul>\n<li>从上图可以看出，四项任务中，HER+EBP比其他两种方法收敛速度都快，效果也更好一点</li>\n<li>从上表可以看出，HER+EBP与HER的训练时间基本相同，而HER+PER要消耗10倍的时间</li>\n</ul>\n<hr>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/finalmeanrate.png\" alt=\"\"></p>\n<p>结果：</p>\n<ul>\n<li>训练结束后，HER+EBP在四项任务中效果都最好</li>\n<li>HER+EBP比HER提高了1-5个百分点，平均提升了3.75个百分点</li>\n</ul>\n<blockquote>\n<p>We can see that EBP is a simple yet effective method, without increasing computational time, but still, improves current state-of-the-art methods. </p>\n</blockquote>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/sampleefficiency.png\" alt=\"\"></p>\n<p>结果：</p>\n<ul>\n<li>采样效率方面，总体来看，EBP+HER比HER提升了2倍</li>\n</ul>\n<hr>\n<p>最后，作者比较了迹能量与TD-error的pearson相关系数</p>\n<ul>\n<li>系数为1，即正线性相关</li>\n<li>系数为-1，即负线性相关</li>\n<li>系数为0，即不线性相关</li>\n</ul>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/pearsoncorrelation.png\" alt=\"\"></p>\n<p>结果：</p>\n<ul>\n<li>四个实验中，迹能量与TD-error均成正相关</li>\n<li>平均下来pearson系数为0.6，说明迹能量与TD-error呈正线性相关关系，也就是说迹能量可以像TD-error一样表示经验的可学习价值</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文是对HER“事后”经验池机制的一个扩展，它结合了物理学的能量知识以及优先经验回放PER对HER进行提升。简称：EBP</p>\n<p>推荐：</p>\n<ul>\n<li>创新虽不多，但是基于能量的创意可以拓宽在机器人领域训练的视野</li>\n<li>通俗易懂</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1810.01363.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1810.01363.pdf</a></p>\n<p>这篇论文由慕尼黑大学博三学生<a href=\"https://ruizhaogit.github.io\" rel=\"external nofollow\" target=\"_blank\">赵瑞</a>和他的导师Volker Tresp发于2018年的CoRL会议。</p>\n<p><strong>本文提出了一个简单高效的、基于能量的方法去优先回放“事后经验”。Energy+HER+PER</strong></p>\n<p>在HER中，智能体从它可完成的“虚拟”目标中进行大量学习，虚拟目标就是我们使用“事后诸葛亮”方法所调整的经验中的目标。</p>\n<p>本文针对原始HER提出了一个稍有不足的地方：经验回放是完全随机的，即没有优先级，没有考虑哪些episode哪些经验对学习更有价值，其实这个问题与PER相对于传统经验池机制也是一样的。</p>\n<p>本文中使用的功能定理（work-energy principle）来计算能量。</p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>相比于传统的PER优先经验回放使用TD-error作为衡量优先级的度量，本文中使用“迹能量”作为其度量。</p>\n<p>迹能量是这么定义的：</p>\n<ul>\n<li><blockquote>\n<p>We define a trajectory energy function as the sum of the transition energy of the target object over the trajectory. </p>\n</blockquote>\n</li>\n<li><p>迹能量是一个episode中transition energy（不知道怎么翻译合适，过渡能量？经验能量？转换能量？）的总和</p>\n</li>\n</ul>\n<p>接下来介绍一下能量在本文中是如何体现的。</p>\n<h2 id=\"经验能量差-Transition-Energy\"><a href=\"#经验能量差-Transition-Energy\" class=\"headerlink\" title=\"经验能量差 Transition Energy\"></a>经验能量差 Transition Energy</h2><p>我就直接拿论文中实验场景所用到的能力来说明这个能量差。简言之，在本文的实验中主要是操作机械手臂移动物体的水平位置和垂直高度，所以物体的能量基本包含三种：</p>\n<ol>\n<li><strong>势能 Potential Energy</strong> $E_{p}(s_{t})$</li>\n<li><strong>动能 Kinetic Energy</strong> $E_{k}(s_{t})$</li>\n<li><strong>转动能，也叫角动能 Rotational Energy</strong> $E_{r}(s_{t})$</li>\n</ol>\n<p>一个物体的能量由这三部分之和组成：</p>\n<script type=\"math/tex; mode=display\">\nE\\left(s_{t}\\right)=E_{p}\\left(s_{t}\\right)+E_{k}\\left(s_{t}\\right)+E_{r}\\left(s_{t}\\right)</script><p>经验能量差指的就是相邻状态转移之间的能量差值，表示为：</p>\n<script type=\"math/tex; mode=display\">\nE_{t r a n}\\left(s_{t-1}, s_{t}\\right)=\\operatorname{clip}\\left(E\\left(s_{t}\\right)-E\\left(s_{t-1}\\right), 0, E_{t r a n}^{\\max }\\right)</script><p>其中，</p>\n<ul>\n<li><p>将差值clip到0是因为我们只对由机器人做功导致物体的能量增值感兴趣</p>\n</li>\n<li><p>将差值clip到$E_{t r a n}^{\\max }$是想减缓某些特别大的能量差值的影响，使<strong>训练更稳定</strong></p>\n</li>\n</ul>\n<p><em>注：其实我觉得文中加这个clip操作完全是想多使用一个trick，让文章看起来更饱满一点，我个人认为不使用这个clip，或者只对下界进行clip，对算法性能是没有影响的。有待验证。</em></p>\n<h3 id=\"势能-Potential-Energy\"><a href=\"#势能-Potential-Energy\" class=\"headerlink\" title=\"势能 Potential Energy\"></a>势能 Potential Energy</h3><p>物理学中学过，物体的重力势能公式为：$E=mgh$</p>\n<p>本文中这样书写：</p>\n<script type=\"math/tex; mode=display\">\nE_{p}(s_{t})=mgz_{t}</script><ul>\n<li>$m$代表物体的质量</li>\n<li>$g$代表地球的重力系数，$g \\approx 9.81 \\mathrm{m} / \\mathrm{s}^{2}$</li>\n<li>$z_{t}$代表物体在$t$时刻的高度$h$</li>\n</ul>\n<h3 id=\"动能-Kinetic-Energy\"><a href=\"#动能-Kinetic-Energy\" class=\"headerlink\" title=\"动能 Kinetic Energy\"></a>动能 Kinetic Energy</h3><p>物理学中学过，物体的动能公式为：</p>\n<script type=\"math/tex; mode=display\">\nE=\\frac{1}{2} mv^{2}=\\frac{1}{2} m\\left [ \\frac{\\sqrt{v_{x}^{2}+v_{y}^{2}+v_{z}^{2}}}{\\Delta t} \\right ]^{2}</script><p>本文中这样书写：</p>\n<script type=\"math/tex; mode=display\">\nE_{k}\\left(s_{t}\\right)=\\frac{1}{2} m v_{x, t}^{2}+\\frac{1}{2} m v_{y, t}^{2}+\\frac{1}{2} m v_{z, t}^{2} \\approx \\frac{m\\left(\\left(x_{t}-x_{t-1}\\right)^{2}+\\left(y_{t}-y_{t-1}\\right)^{2}+\\left(z_{t}-z_{t-1}\\right)^{2}\\right)}{2 \\Delta t^{2}}</script><ul>\n<li>$v_{x, t} \\approx\\left(x_{t}-x_{t-1}\\right) / \\Delta t$</li>\n<li>$v_{y, t} \\approx\\left(y_{t}-y_{t-1}\\right) / \\Delta t$</li>\n<li>$v_{z, t} \\approx\\left(z_{t}-z_{t-1}\\right) / \\Delta t$</li>\n<li>$\\Delta t$表示相邻两个状态之间的时间间隔，假设我们在模拟器中，1秒60帧，即每帧16.67ms，我们如果每帧执行一次动作，那么$\\Delta t=16.67ms$，如果每60帧执行一次动作，那么$\\Delta t=1s$</li>\n</ul>\n<h3 id=\"转动能-Rotational-Energy\"><a href=\"#转动能-Rotational-Energy\" class=\"headerlink\" title=\"转动能 Rotational Energy\"></a>转动能 Rotational Energy</h3><p>物理学中学过，物体的转动能公式为：$K=\\frac{1}{2} I \\cdot \\omega^{2}$，注意，中间的点代表点乘，$I$代表物体的惯性矩，$\\omega$代表物体的角速度</p>\n<p>本文中这样书写：</p>\n<script type=\"math/tex; mode=display\">\n\\left[ \\begin{array}{c}{\\phi} \\\\ {\\theta} \\\\ {\\psi}\\end{array}\\right]=\\left[ \\begin{array}{c}{\\arctan \\frac{2(a b+c d)}{1-2\\left(b^{2}+c^{2}\\right)}} \\\\ {\\arcsin (2(a c-d b))} \\\\ {\\arcsin \\frac{2(a d+b c)}{1-2\\left(c^{2}+d^{2}\\right)}}\\end{array}\\right]=\\left[ \\begin{array}{c}{\\operatorname{atan} 2\\left(2(a b+c d), 1-2\\left(b^{2}+c^{2}\\right)\\right)} \\\\ {\\operatorname{asin}(2(a c-d b))} \\\\ {\\operatorname{atan} 2\\left(2(a d+b c), 1-2\\left(c^{2}+d^{2}\\right)\\right)}\\end{array}\\right]</script><script type=\"math/tex; mode=display\">\nE_{r}\\left(s_{t}\\right)=\\frac{1}{2} I_{x} \\omega_{x, t}^{2}+\\frac{1}{2} I_{y} \\omega_{y, t}^{2}+\\frac{1}{2} I_{z} \\omega_{z, t}^{2} \\approx \\frac{I_{x}\\left(\\phi_{t}-\\phi_{t-1}\\right)^{2}+I_{y}\\left(\\theta_{t}-\\theta_{t-1}\\right)^{2}+I_{z}\\left(\\psi_{t}-\\psi_{t-1}\\right)^{2}}{2 \\Delta t^{2}}</script><p>其中$a,b,c,d$为旋转四元组，其知识可以百度或google自行了解。</p>\n<script type=\"math/tex; mode=display\">\nq=a+b \\imath+c \\jmath+d k</script><p>$\\phi, \\theta, \\psi$代表$x,y,z$轴方向的旋转角度</p>\n<ul>\n<li>$\\omega_{x, t} \\approx\\left(\\phi_{t}-\\phi_{t-1}\\right) / \\Delta_{t}$</li>\n<li>$\\omega_{y, t} \\approx\\left(\\theta_{t}-\\theta_{t-1}\\right) / \\Delta_{t}$</li>\n<li>$\\omega_{z, t} \\approx\\left(\\psi_{t}-\\psi_{t-1}\\right) / \\Delta_{t}$</li>\n<li>$\\Delta t$与上文解释相同</li>\n</ul>\n<p><strong>$m,I_{x},I_{y},I_{z}$可以设置为常量，本文实验中设置$m=I_{x}=I_{y}=I_{z}=1$</strong></p>\n<h2 id=\"迹能量-Trajectory-Energy\"><a href=\"#迹能量-Trajectory-Energy\" class=\"headerlink\" title=\"迹能量 Trajectory Energy\"></a>迹能量 Trajectory Energy</h2><p>给定一个回合中所有的经验能量差，迹能量可以表示为这个回合中所有经验能量差之和：</p>\n<script type=\"math/tex; mode=display\">\nE_{t r a j}(\\mathcal{T})=E_{t r a j}\\left(s_{0}, s_{1}, \\ldots, s_{T}\\right)=\\sum_{t=1}^{T} E_{t r a n}\\left(s_{t-1}, s_{t}\\right)</script><h2 id=\"基于能量的优先级\"><a href=\"#基于能量的优先级\" class=\"headerlink\" title=\"基于能量的优先级\"></a>基于能量的优先级</h2><p>首先计算迹能量，然后对迹能量高的迹（episode）优先进行回放。</p>\n<p>根据迹能量计算迹的优先级为：</p>\n<script type=\"math/tex; mode=display\">\np\\left(\\mathcal{T}_{i}\\right)=\\frac{E_{t r a j}\\left(\\mathcal{T}_{i}\\right)}{\\sum_{n=1}^{N} E_{t r a j}\\left(\\mathcal{T}_{n}\\right)}</script><p>$N$代表经验池中迹的总数量</p>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./energy-based-hindsight-experience-prioritization/pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>以本文实验为例，状态$s$由七元组$\\left[x_{t}, y_{t}, z_{t}, a_{t}, b_{t}, c_{t}, d_{t}\\right]$表示，其中前三个代表物体的位置，后三个代表物体旋转的四元组。</li>\n<li>目标$g$与状态$s$的表示相同</li>\n<li>$||$操作符为连结的意思，即<code>tf.concat(a,b)</code></li>\n<li>向经验池中存入的不仅仅有$(s,a,r,s’)$，还有优先级$p$与迹能量$E_{traj}$，<strong>其实我感觉这样很多余，如果使用sum-tree结构的，存其一即可</strong></li>\n<li>文中所使用的HER是<strong>future模式</strong></li>\n</ul>\n<p><strong>注意：</strong></p>\n<p>我认为伪代码中有两行很有问题，即</p>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/issue.png\" alt=\"\"></p>\n<p>我不明白为什么把原始经验$\\left(s_{t}\\left|g, a_{t}, r_{t}, s_{t+1}\\right| g, p, E_{t r a j}\\right)$存入经验池之后，需要根据优先级采样一个迹，再从采样到的迹中采样出一个经验$\\left(s_{t}, a_{t}, s_{t+1}\\right)$</p>\n<p>起初我是这么认为的，它想对经验池中迹能量高的episode进行大概率抽取，并对其中的经验进行多次扩充，由此对迹能量小的episode更加忽视，突出迹能量高的episode</p>\n<p>但是，看到下一行<img src=\"./energy-based-hindsight-experience-prioritization/issue2.png\" alt=\"\">我有一个疑问：如果根据优先级采样出的迹$\\mathcal{T}$与当前所操作的迹$\\mathcal{T}_{current}$不同，那么，为什么还要为不同迹中的经验存入相同的优先级和迹能量呢？即$\\left(s_{t}\\left|g^{\\prime}, a_{t}, r_{t}^{\\prime}, s_{t+1}\\right| g^{\\prime}, p, E_{t r a j}\\right)$</p>\n<p>这样肯定是不行的，那么只有一个答案，采样迹这一步多余的，或者说，不应该出现在这里，而应该放在最后一个循环的开始，即</p>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/issue3.png\" alt=\"\"></p>\n<p>也就是说，应该把采样迹，从迹中采样经验的步骤放在minibatch之前，这样就合情合理了。</p>\n<p>这是我自己的一个疑问，如果读者有其他见解，欢迎置评讨论。</p>\n<h2 id=\"EBP的总结\"><a href=\"#EBP的总结\" class=\"headerlink\" title=\"EBP的总结\"></a>EBP的总结</h2><p>EBP与PER的不同点：</p>\n<ul>\n<li>EBP使用物理学中的能量</li>\n<li>PER使用TD-error</li>\n</ul>\n<p>相比于将HER与PER结合而使用TD-error作为衡量优先级的方法，使用迹能量较少了计算量，因为PER每次回放经验都必须重新计算使用经验的新的TD-error，并存回经验池。（其实，如果使用sum-tree来构建PER，这个劣势其实很小）</p>\n<p>文中通过实验发现：比较PER与EBP的时间复杂性，显示EBP提升了算法的性能效果（performance）但是却不增加额外的计算量。PER则提升较少，计算量也增加了。</p>\n<p>EBP的优点：</p>\n<ul>\n<li>可结合任意off-policy算法</li>\n<li>结合了物理知识，使其可以应用于现实世界的问题</li>\n<li>提升采样效率进两倍</li>\n<li>相比最先进的（state-of-the-art）算法，不增加计算时间的情况下，算法效果提升了4个百分点。（此条可以忽略，因为其未必做了充分的实验来进行对比）</li>\n<li>适用于任何机器人操作任务</li>\n<li>适用于多目标算法</li>\n</ul>\n<h1 id=\"实验部分\"><a href=\"#实验部分\" class=\"headerlink\" title=\"实验部分\"></a>实验部分</h1><p>文中实验结果：<a href=\"https://youtu.be/jtsF2tTeUGQ\" rel=\"external nofollow\" target=\"_blank\">https://youtu.be/jtsF2tTeUGQ</a></p>\n<p>代码地址：<a href=\"https://github.com/ruizhaogit/EnergyBasedPrioritization\" rel=\"external nofollow\" target=\"_blank\">https://github.com/ruizhaogit/EnergyBasedPrioritization</a></p>\n<p>实验部分的完整细节请参考论文原文。</p>\n<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><ul>\n<li>OpenAI Gym与MuJoCo物理引擎</li>\n<li>一个7自由度的机械手臂，与HER中一样；一个24自由度的机器手</li>\n<li>四项任务：pick &amp; place，机器手操作方块、蛋、笔</li>\n</ul>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/env.png\" alt=\"\"></p>\n<ul>\n<li>使用稀疏奖励，二分奖励，完成容忍度内目标为0，否则为-1</li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><ul>\n<li>文中没有说明具体使用什么算法作对比，只有伪代码中提到了DPG、DDPG</li>\n<li>文中亦没有对算法中的超参数设置、网络结构进行说明</li>\n<li>19个CPU</li>\n<li>器械臂场景$E_{t r a n}^{\\max }=0.5$，机械手场景$E_{t r a n}^{\\max }=2.5$</li>\n<li>文中主要比较了HER、HER+PER、HER+EBP</li>\n</ul>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p><img src=\"./energy-based-hindsight-experience-prioritization/meansuccessrate.png\" alt=\"\"></p>\n<ul>\n<li>横坐标是训练的轮数，应该是指episode的意思</li>\n<li>纵坐标是5个随机种子实验的平均成功率</li>\n<li>蓝色代表HER+EBP，橘色代表HER，绿色代表HER+PER</li>\n</ul>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/trainingtime.png\" alt=\"\"></p>\n<p>结果：</p>\n<ul>\n<li>从上图可以看出，四项任务中，HER+EBP比其他两种方法收敛速度都快，效果也更好一点</li>\n<li>从上表可以看出，HER+EBP与HER的训练时间基本相同，而HER+PER要消耗10倍的时间</li>\n</ul>\n<hr>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/finalmeanrate.png\" alt=\"\"></p>\n<p>结果：</p>\n<ul>\n<li>训练结束后，HER+EBP在四项任务中效果都最好</li>\n<li>HER+EBP比HER提高了1-5个百分点，平均提升了3.75个百分点</li>\n</ul>\n<blockquote>\n<p>We can see that EBP is a simple yet effective method, without increasing computational time, but still, improves current state-of-the-art methods. </p>\n</blockquote>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/sampleefficiency.png\" alt=\"\"></p>\n<p>结果：</p>\n<ul>\n<li>采样效率方面，总体来看，EBP+HER比HER提升了2倍</li>\n</ul>\n<hr>\n<p>最后，作者比较了迹能量与TD-error的pearson相关系数</p>\n<ul>\n<li>系数为1，即正线性相关</li>\n<li>系数为-1，即负线性相关</li>\n<li>系数为0，即不线性相关</li>\n</ul>\n<p><img src=\"./energy-based-hindsight-experience-prioritization/pearsoncorrelation.png\" alt=\"\"></p>\n<p>结果：</p>\n<ul>\n<li>四个实验中，迹能量与TD-error均成正相关</li>\n<li>平均下来pearson系数为0.6，说明迹能量与TD-error呈正线性相关关系，也就是说迹能量可以像TD-error一样表示经验的可学习价值</li>\n</ul>"},{"title":"Keeping Your Distance: Solving Sparse Reward Tasks Using Self-Balancing Shaped Rewards","copyright":true,"mathjax":true,"top":1,"date":"2020-03-30T10:09:45.000Z","keywords":null,"description":null,"_content":"\n这篇论文介绍了一个简单有效的model-free方法——**Sibling Rivalry**(同胞对抗？)，用于解决稀疏奖励问题。该方法特定于“以达到某个目标状态(goal-oriented)”为任务的问题，并且从塑性的距离目标相关奖励(distance-to-goal rewards)中学习。\n\n推荐：\n\n- self-balancing 奖励机制\n- 基于奖励函数的创新，比较有趣\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1911.01417.pdf](http://arxiv.org/abs/1911.01417)\n\n这篇文章解决的问题点是：\n\n- 由朴素的距离目标相关的奖励(naive distance-to-goal reward shaping)引起的动态学习在局部最优点稳定的问题\n\n这篇文章方法的优点是：\n\n- 增强目标但不需额外奖励工程设计，也不需领域专家知识\n- 可以收敛至原始的稀疏奖励目标\n\n文章发表在NeurIPS 2019上。\n\n这篇论文提出的Sibling Rivalry(SR)方法结合了塑性奖励的可学习性与稀疏奖励的通用性。它主要解决面向目标(goal-oriented)的任务，是对距离奖励函数的改进，实现了奖励函数的自平衡(self-balancing，自动退化至纯稀疏奖励形式)，它的特点是：\n\n- model-free\n- 应用在on-policy算法上\n- 应用在***目标状态已知***，且***以距离为奖励函数导向***的任务中\n- **动态**奖励塑性\n- 保持稀疏奖励任务的原有最优策略\n- 跳出局部最优解，寻找全局最优\n- 可以与分层RL相结合（有实验佐证）\n\n# 文中精要\n\n文中shaped rewards一时不知道该如何做翻译，姑且就称之为“塑性奖励”好了，意为为解决某一特定问题而精心设计的奖励函数机制。\n\nReward shaping是一种修改奖励信号的技术，比如，它可以用于重新标注失败的经验序列，并从其中筛选出可促进任务完成的经验序列进行学习。然而，这种技术是否可以提升任务性能严重取决于塑性奖励的精心设计。这种塑性奖励有时可以解决稀疏奖励问题，但是具有两个显著特点：\n\n1. 需要精心的工程设计，也可以理解为需要对环境或任务的先验知识\n\n   > requires careful engineering\n\n2. 往往只适用于特定任务，特定问题，比如同样的避障问题，载具类型不同，可能就不适用\n\n   > is problem specific\n\n对于现实世界的RL问题，需要手动设计一个与任务契合/对齐的奖励机制，一个好的奖励函数往往比算法的选择更加重要。但是现实世界问题非常复杂，细粒度的奖励函数也十分难以设计，往往会具有“捡了芝麻丢了西瓜”的特点。比如，在避障问题中，如果针对墙壁这种障碍物设置奖励函数，策略在学习过程中会对墙壁这种实体过拟合，导致当遇到一种新的障碍物时，策略无法适用，还不如简单的稀疏奖励（完成即获得奖励，反之则无），让智能体自己从环境中学习哪些具有障碍物共有或特有特性。\n\n还有一个很严重的问题是，复杂的奖励机制容易使策略陷入局部最优，比如说达到状态A可以获得奖励+10，而达到状态B可以获得奖励+1，那么如果状态A十分难以到达，策略往往会收敛在状态B，或者其他相似的状态附近中去，造成策略在这些局部最优解附近稳定下来。\n\n稀疏奖励往往不存在这种局部最优，或者考虑不周的问题。设计一个合适的稀疏奖励函数很简单，也很直接，但是从这种奖励函数中学习需要大量的时间，而且甚至学习不出来任何东西，**通常需要额外的启发式探索机制去帮助智能体发现这个稀疏的正奖励**。\n\n\n\n# 方法\n\n纯稀疏奖励的形式是这样的：\n$$\nr(s, g)=\\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n0, & \\text { otherwise }\n\\end{array}\\right.\n$$\n其中，$s$代表当前状态，$g$代表目标状态。$d$是一个函数用来判断当前状态与目标状态的距离度量，例如$L_1$或$L_2$距离，这个距离可以用来表示任务的完成度，即距离越短，任务完成度越高。$\\delta$代表目标点的半径，也就是说，状态不必完全等于目标状态，只需要距离度量小于一定范围$\\delta$即可，这个是很常用的做法，比如Unity ML-Agents的示例环境——RollerBall，也是使用这样的设置。\n\n这种纯稀疏奖励的设置很难解决，往往需要很大的探索才能获取到寥寥无几的正奖励样本轨迹，给智能体的学习带来了很大的困难。\n\n其实可以对上述奖励进行修改，使得其可以按照距目标状态的距离给出不同的奖励，引导智能体朝向目标状态移动。它通常为下边这种形式：\n$$\n\\begin{array}{ll}\n\\tilde{r}(s, g)= & \\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n-d(s, g), & \\text { otherwise }\n\\end{array}\\right.\n\\end{array}\n$$\n这种奖励形式很直观，如果没有达到目标状态，则一直是负奖励，且距离越远则负奖励越大，这样将会引导智能体朝向目标状态移动。针对一些比较简单的稀疏奖励环境，这种形式的奖励设计可以带来算法性能的提升，而且往往可以解决稀疏奖励问题。但是，这种基于距离的塑性奖励（Distance-based shaped rewards）很容易陷入局部最优点，并且在局部最优点附近稳定下来，得不到进一步地策略提升。为什么这么说呢？就比如gym的MountainCar场景，智能体需要先倒退再前进才能达到目标点，也就是说要先经历负奖励的增大过程，再经历负奖励的减小过程，才能最终完成目标，从初始状态直接朝向目标点移动是不能把车子开到山顶上去的。使用这种形式的奖励将会使得智能体抵达半山腰，却永远都触及不到目标点。还有一些U-shape的路径问题，在U型的两端设置起始点与目标点，使用这种奖励机制将会使得智能体在直线朝向目标点移动时偏离轨道，永远学不会以U型的方式完成目标。\n\n使用上述奖励形式的问题经验存在各种各样的局部最优点，而且这些局部最优点与状态空间结构（state space structure）、转移动态（transition dynamics）和环境的其他特性都有关系。\n\n那么有没有一种对奖励进行塑性的方式可以避免局部最优点的影响呢？确实是有的，我们再对上述奖励函数做如下改进：\n$$\nr^{\\prime}(s, g, \\bar{g})=\\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n\\min [0,-d(s, g)+d(s, \\bar{g})], & \\text { otherwise }\n\\end{array}\\right.\n$$\n与上式不同的是，这里多了一个符号——$\\bar g$，它用来表示局部最优点的状态。论文中给出了这样一个例子：\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/motivating-example.png)\n\n最左边的图是一个简单的环境，智能体的目标是到达绿色的Goal点，如果使用前文提到的$\\tilde{r}$，则会存在局部最优点，也就是图中的Local Optimum。为什么会存在这个局部最优点呢？可以设想一下，假设智能体从左下角出发，那么它在上方路径和下方路径各走一步时，明显下方路径的负奖励衰减的更快，所以智能体通常会选择走下方路径，最终收敛到与Goal隔岸相望的Local Optimum。$\\tilde{r}$的奖励函数图像轮廓如上面中间图像红色线条所示，图中横坐标为坐标点，纵坐标为奖励值的高低。绿色光点为智能体在轨迹终态的分布，可以看出，使用$\\tilde{r}$作为奖励函数时，在这个环境中奖励图像存在一个小的山峰，相比于全局最优点，智能体更易达到局部最优点，而且会在局部最优附近稳定下来，导致无法产生全局最优策略。\n\n最右侧的图是使用了增强后的距离奖励函数$r^{\\prime}$所描绘的奖励图像轮廓，可以看出，通过将局部最优点的山峰构造成低谷，即可抵消局部最优点的影响。绿色点的分布也彰显了增强奖励函数后，智能体可以收敛到全局最优策略。为什么像$r^{\\prime}$一样构造奖励函数即可解决局部最优点的影响呢？可以想象一下，将三角形的原理应用上去，当智能体选择上方路径时，两距离相减值逐渐趋于正值，也就是奖励逐渐增大，而选择下方路径时， 两距离相减横为负奖励，这种特性引导着智能体向逐渐增大的正奖励的方向靠拢。\n\n虽然像$r^{\\prime}$这种增强距离奖励的形式可以解决稀疏奖励问题，并跳出局部最优点，但是其通常具有如下几个缺点：\n\n1. 需要领域专家知识分析局部最优点；\n2. 环境或任务复杂时，存在多种局部最优点，难以确定合适的奖励函数；\n3. 一不小心便会弄巧成拙，还会引入新的局部最优点。\n\n## 同胞对抗——Sibling Rivalry\n\n作者十分中意这种跳出局部最优点的方式，所以，作者设想需要一个新的奖励机制，它应当满足：\n\n1. 可以解决稀疏奖励问题\n2. 不需要专家及领域知识对环境进行全面的分析与判断\n3. 动态评估局部最优点，自适应调整奖励函数\n\n这有点像静态图与动态图的区别，$r^{\\prime}$就好像是静态图，需要专家先把图构好，再解决问题，而同胞对抗（Sibling Rivalry， SR）的思想就好像是动态图，一边执行一边应对潜在的局部最优点。\n\n先来说一下SR的思想：\n\n1. 每次采样两条轨迹，同样的起始点与目标点；\n\n2. 距离目标近的为$\\tau^c$，远的为$\\tau^f$;\n\n3. 互相认为对方的终态$s_T$为局部最优点（假想敌），构造奖励函数，计算轨迹每一时间步的奖励。\n\n如下图所示，每次都roll out两条轨迹，这两条轨迹即称为同胞，然后互相指认对方的终态$S_T^c$和$S_T^f$为局部最优点，促使智能体不选择对方的路径，即为对抗。注意，这样的方式确实有可能使得策略在远离局部最优点的同时，也偏离潜在的正确路径，因为智能体并不真正了解什么样的路径是比较好或者比较坏的。\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/sr-example.png)\n\n这种互相对抗的方式增加了智能体的探索能力，因为当智能体的策略不是最优时，它会趋向于选择各种不同的路径，以使得策略可以避开尽可能多的局部最优点。\n\n基于两条同胞轨迹$\\tau^{c}$和$\\tau^{f}$，如何构造它们的奖励函数呢？其实也很简单，像$r^{\\prime}$一样，将其中的局部最优点$\\bar g$更换一下即可：\n$$\nr_{\\tau^{f}}^{\\prime}=r^{\\prime}\\left(s_{T}^{f}, g, s_{T}^{c}\\right) \\quad \\& \\quad r_{\\tau^{c}}^{\\prime}=r^{\\prime}\\left(s_{T}^{c}, g, s_{T}^{f}\\right)\n$$\n作者将这种奖励机制称为**Self-balancing reward**，可以翻译为自平衡/自适应奖励。什么意思呢？可以想想一下，如果策略已经接近全局最优了，那么$g \\approx s_{T}^{f} \\approx s_{T}^{c}$，此时的奖励从$r^{\\prime}_{\\tau^{f}}$和$r^{\\prime}_{\\tau^{c}}$逐渐退化至纯稀疏奖励$r$。为什么呢？因为此时的$-d(s, g)+d(s, \\bar{g})$几乎为0呀！\n\n这样自动退化的奖励机制有什么好处呢？会**使得智能体最终的最优策略与使用纯稀疏奖励时一致**，大道至简，复杂的奖励函数未必可以引导智能体习得期望的行为，然而，纯稀疏奖励虽然难以学习，但是其产生的智能体行为往往是最直接最符合设计者的期望的。\n\n有了轨迹经验，也根据各自的奖励函数生成了奖励，那么该如何进行优化呢？既然取得了两条同胞轨迹，两条轨迹都要拿来训练么？我们结合伪代码进行分析。\n\n# 伪代码\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/pseudo.png)\n\n解析：\n\n- $\\rho(s_0, g)$为一个分布，用于采样任务的初始状态和目标状态，论文中的实验都是将智能体的起止点和目标点固定在一个小范围内，至于SR是否可以用在大范围随机的起始、目标点场景中，还未可知；\n- $m$是一个函数映射，用于将智能体状态空间$S$映射至目标状态空间$G$，$m(s): S \\rightarrow G$；\n- $d$是一个距离度量函数，通常为$L_1,L_2$度量；\n- $\\delta$是判定目标完成的容错半径；\n- 注意，Critic网络V的输入不仅包括状态$s$，目标$g$，也包括局部最优点（同胞轨迹的终态）$\\bar g$；\n- 作者引入了一个“包容性阈值”$\\epsilon$，这个值用来控制对使用距离目标点较近的轨迹$\\tau^c$来训练的容忍度，也用来平衡探索与利用，当$\\epsilon\\uparrow$，利用增加，当$\\epsilon\\downarrow$，探索增加（学习远距离经验）；\n- SR是先采样轨迹$s,a,s,a,...$再计算每一步的奖励的，采样时不包括$r$；\n- 每次rollout两条轨迹——$\\tau^a$和$\\tau^b$，距离目标点$g$比较近的终态轨迹标记为$\\tau^c$，远的标记为$\\tau^{f}$；\n- 优化模型时，何时用$\\tau^f$？\n  - 任何时候\n  - 猜想：距离远的不太可能是局部最优点，因为距离越远，负奖励越大，算法不会稳定收敛在距离目标点很远的局部最优处，会想办法跳出来\n- 优化模型时，何时用$\\tau^c$?\n  - 1，当两条同胞轨迹的终态距离小于$\\epsilon$时；2，当$\\tau^c$的终态已足以完成目标时\n  - 猜想：当两条轨迹的终态距离小于一定阈值时，认为轨迹质量差不多，都可以用来更新\n  - 距离目标点$g$近的轨迹已经足够近，是可以获得全局最优解的轨迹，要学习\n\n# 实验分析\n\n作者使用PPO算法在四种类型的任务场景中进行了实验：\n\n1. 连续动作任务\n2. 分层决策任务\n3. 离散动作任务\n4. 《我的世界》3D构造任务，这个任务主要用来测试SR的可扩展性\n\n任务的细节设置以及实验结果详情请看原论文。\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/experiment1.png)\n\n在这两个实验中，可以看出SR比ICM和HER的效果都要好，任务完成的成功率也必将高，且方差比较小。\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/experiment2.png)\n\n在这个离散的任务中，从图像看出纯DQN即可以解决，但是却没有看到蓝色的纯PPO曲线，按道理来说PPO应该也能解决。\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/experiment3.png)\n\n# 总结\n\n> We introduce Sibling Rivalry, a simple and effective method for learning goal-reaching tasks from a generic class of distance-based shaped rewards. Sibling Rivalry makes use of sibling rollouts and self-balancing rewards to prevent the learning dynamics from stabilizing around local optima. By leveraging the distance metric used to deﬁne the underlying sparse reward, our technique enables robust learning from shaped rewards without relying on carefully-designed, problem-speciﬁc reward functions. We demonstrate the applicability of our method across a variety of goal-reaching tasks where naive distance-to-goal reward shaping consistently fails and techniques to learn from sparse rewards struggle to explore properly and/or generalize from failed rollouts. Our experiments show that Sibling Rivalry can be readily applied to both continuous and discrete domains, incorporated into hierarchical RL, and scaled to demanding environments.\n\n","source":"_posts/keeping-your-distance-solving-sparse-reward-tasks.md","raw":"---\ntitle: \"Keeping Your Distance: Solving Sparse Reward Tasks Using Self-Balancing Shaped Rewards\"\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-03-30 18:09:45\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n这篇论文介绍了一个简单有效的model-free方法——**Sibling Rivalry**(同胞对抗？)，用于解决稀疏奖励问题。该方法特定于“以达到某个目标状态(goal-oriented)”为任务的问题，并且从塑性的距离目标相关奖励(distance-to-goal rewards)中学习。\n\n推荐：\n\n- self-balancing 奖励机制\n- 基于奖励函数的创新，比较有趣\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/1911.01417.pdf](http://arxiv.org/abs/1911.01417)\n\n这篇文章解决的问题点是：\n\n- 由朴素的距离目标相关的奖励(naive distance-to-goal reward shaping)引起的动态学习在局部最优点稳定的问题\n\n这篇文章方法的优点是：\n\n- 增强目标但不需额外奖励工程设计，也不需领域专家知识\n- 可以收敛至原始的稀疏奖励目标\n\n文章发表在NeurIPS 2019上。\n\n这篇论文提出的Sibling Rivalry(SR)方法结合了塑性奖励的可学习性与稀疏奖励的通用性。它主要解决面向目标(goal-oriented)的任务，是对距离奖励函数的改进，实现了奖励函数的自平衡(self-balancing，自动退化至纯稀疏奖励形式)，它的特点是：\n\n- model-free\n- 应用在on-policy算法上\n- 应用在***目标状态已知***，且***以距离为奖励函数导向***的任务中\n- **动态**奖励塑性\n- 保持稀疏奖励任务的原有最优策略\n- 跳出局部最优解，寻找全局最优\n- 可以与分层RL相结合（有实验佐证）\n\n# 文中精要\n\n文中shaped rewards一时不知道该如何做翻译，姑且就称之为“塑性奖励”好了，意为为解决某一特定问题而精心设计的奖励函数机制。\n\nReward shaping是一种修改奖励信号的技术，比如，它可以用于重新标注失败的经验序列，并从其中筛选出可促进任务完成的经验序列进行学习。然而，这种技术是否可以提升任务性能严重取决于塑性奖励的精心设计。这种塑性奖励有时可以解决稀疏奖励问题，但是具有两个显著特点：\n\n1. 需要精心的工程设计，也可以理解为需要对环境或任务的先验知识\n\n   > requires careful engineering\n\n2. 往往只适用于特定任务，特定问题，比如同样的避障问题，载具类型不同，可能就不适用\n\n   > is problem specific\n\n对于现实世界的RL问题，需要手动设计一个与任务契合/对齐的奖励机制，一个好的奖励函数往往比算法的选择更加重要。但是现实世界问题非常复杂，细粒度的奖励函数也十分难以设计，往往会具有“捡了芝麻丢了西瓜”的特点。比如，在避障问题中，如果针对墙壁这种障碍物设置奖励函数，策略在学习过程中会对墙壁这种实体过拟合，导致当遇到一种新的障碍物时，策略无法适用，还不如简单的稀疏奖励（完成即获得奖励，反之则无），让智能体自己从环境中学习哪些具有障碍物共有或特有特性。\n\n还有一个很严重的问题是，复杂的奖励机制容易使策略陷入局部最优，比如说达到状态A可以获得奖励+10，而达到状态B可以获得奖励+1，那么如果状态A十分难以到达，策略往往会收敛在状态B，或者其他相似的状态附近中去，造成策略在这些局部最优解附近稳定下来。\n\n稀疏奖励往往不存在这种局部最优，或者考虑不周的问题。设计一个合适的稀疏奖励函数很简单，也很直接，但是从这种奖励函数中学习需要大量的时间，而且甚至学习不出来任何东西，**通常需要额外的启发式探索机制去帮助智能体发现这个稀疏的正奖励**。\n\n\n\n# 方法\n\n纯稀疏奖励的形式是这样的：\n$$\nr(s, g)=\\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n0, & \\text { otherwise }\n\\end{array}\\right.\n$$\n其中，$s$代表当前状态，$g$代表目标状态。$d$是一个函数用来判断当前状态与目标状态的距离度量，例如$L_1$或$L_2$距离，这个距离可以用来表示任务的完成度，即距离越短，任务完成度越高。$\\delta$代表目标点的半径，也就是说，状态不必完全等于目标状态，只需要距离度量小于一定范围$\\delta$即可，这个是很常用的做法，比如Unity ML-Agents的示例环境——RollerBall，也是使用这样的设置。\n\n这种纯稀疏奖励的设置很难解决，往往需要很大的探索才能获取到寥寥无几的正奖励样本轨迹，给智能体的学习带来了很大的困难。\n\n其实可以对上述奖励进行修改，使得其可以按照距目标状态的距离给出不同的奖励，引导智能体朝向目标状态移动。它通常为下边这种形式：\n$$\n\\begin{array}{ll}\n\\tilde{r}(s, g)= & \\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n-d(s, g), & \\text { otherwise }\n\\end{array}\\right.\n\\end{array}\n$$\n这种奖励形式很直观，如果没有达到目标状态，则一直是负奖励，且距离越远则负奖励越大，这样将会引导智能体朝向目标状态移动。针对一些比较简单的稀疏奖励环境，这种形式的奖励设计可以带来算法性能的提升，而且往往可以解决稀疏奖励问题。但是，这种基于距离的塑性奖励（Distance-based shaped rewards）很容易陷入局部最优点，并且在局部最优点附近稳定下来，得不到进一步地策略提升。为什么这么说呢？就比如gym的MountainCar场景，智能体需要先倒退再前进才能达到目标点，也就是说要先经历负奖励的增大过程，再经历负奖励的减小过程，才能最终完成目标，从初始状态直接朝向目标点移动是不能把车子开到山顶上去的。使用这种形式的奖励将会使得智能体抵达半山腰，却永远都触及不到目标点。还有一些U-shape的路径问题，在U型的两端设置起始点与目标点，使用这种奖励机制将会使得智能体在直线朝向目标点移动时偏离轨道，永远学不会以U型的方式完成目标。\n\n使用上述奖励形式的问题经验存在各种各样的局部最优点，而且这些局部最优点与状态空间结构（state space structure）、转移动态（transition dynamics）和环境的其他特性都有关系。\n\n那么有没有一种对奖励进行塑性的方式可以避免局部最优点的影响呢？确实是有的，我们再对上述奖励函数做如下改进：\n$$\nr^{\\prime}(s, g, \\bar{g})=\\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n\\min [0,-d(s, g)+d(s, \\bar{g})], & \\text { otherwise }\n\\end{array}\\right.\n$$\n与上式不同的是，这里多了一个符号——$\\bar g$，它用来表示局部最优点的状态。论文中给出了这样一个例子：\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/motivating-example.png)\n\n最左边的图是一个简单的环境，智能体的目标是到达绿色的Goal点，如果使用前文提到的$\\tilde{r}$，则会存在局部最优点，也就是图中的Local Optimum。为什么会存在这个局部最优点呢？可以设想一下，假设智能体从左下角出发，那么它在上方路径和下方路径各走一步时，明显下方路径的负奖励衰减的更快，所以智能体通常会选择走下方路径，最终收敛到与Goal隔岸相望的Local Optimum。$\\tilde{r}$的奖励函数图像轮廓如上面中间图像红色线条所示，图中横坐标为坐标点，纵坐标为奖励值的高低。绿色光点为智能体在轨迹终态的分布，可以看出，使用$\\tilde{r}$作为奖励函数时，在这个环境中奖励图像存在一个小的山峰，相比于全局最优点，智能体更易达到局部最优点，而且会在局部最优附近稳定下来，导致无法产生全局最优策略。\n\n最右侧的图是使用了增强后的距离奖励函数$r^{\\prime}$所描绘的奖励图像轮廓，可以看出，通过将局部最优点的山峰构造成低谷，即可抵消局部最优点的影响。绿色点的分布也彰显了增强奖励函数后，智能体可以收敛到全局最优策略。为什么像$r^{\\prime}$一样构造奖励函数即可解决局部最优点的影响呢？可以想象一下，将三角形的原理应用上去，当智能体选择上方路径时，两距离相减值逐渐趋于正值，也就是奖励逐渐增大，而选择下方路径时， 两距离相减横为负奖励，这种特性引导着智能体向逐渐增大的正奖励的方向靠拢。\n\n虽然像$r^{\\prime}$这种增强距离奖励的形式可以解决稀疏奖励问题，并跳出局部最优点，但是其通常具有如下几个缺点：\n\n1. 需要领域专家知识分析局部最优点；\n2. 环境或任务复杂时，存在多种局部最优点，难以确定合适的奖励函数；\n3. 一不小心便会弄巧成拙，还会引入新的局部最优点。\n\n## 同胞对抗——Sibling Rivalry\n\n作者十分中意这种跳出局部最优点的方式，所以，作者设想需要一个新的奖励机制，它应当满足：\n\n1. 可以解决稀疏奖励问题\n2. 不需要专家及领域知识对环境进行全面的分析与判断\n3. 动态评估局部最优点，自适应调整奖励函数\n\n这有点像静态图与动态图的区别，$r^{\\prime}$就好像是静态图，需要专家先把图构好，再解决问题，而同胞对抗（Sibling Rivalry， SR）的思想就好像是动态图，一边执行一边应对潜在的局部最优点。\n\n先来说一下SR的思想：\n\n1. 每次采样两条轨迹，同样的起始点与目标点；\n\n2. 距离目标近的为$\\tau^c$，远的为$\\tau^f$;\n\n3. 互相认为对方的终态$s_T$为局部最优点（假想敌），构造奖励函数，计算轨迹每一时间步的奖励。\n\n如下图所示，每次都roll out两条轨迹，这两条轨迹即称为同胞，然后互相指认对方的终态$S_T^c$和$S_T^f$为局部最优点，促使智能体不选择对方的路径，即为对抗。注意，这样的方式确实有可能使得策略在远离局部最优点的同时，也偏离潜在的正确路径，因为智能体并不真正了解什么样的路径是比较好或者比较坏的。\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/sr-example.png)\n\n这种互相对抗的方式增加了智能体的探索能力，因为当智能体的策略不是最优时，它会趋向于选择各种不同的路径，以使得策略可以避开尽可能多的局部最优点。\n\n基于两条同胞轨迹$\\tau^{c}$和$\\tau^{f}$，如何构造它们的奖励函数呢？其实也很简单，像$r^{\\prime}$一样，将其中的局部最优点$\\bar g$更换一下即可：\n$$\nr_{\\tau^{f}}^{\\prime}=r^{\\prime}\\left(s_{T}^{f}, g, s_{T}^{c}\\right) \\quad \\& \\quad r_{\\tau^{c}}^{\\prime}=r^{\\prime}\\left(s_{T}^{c}, g, s_{T}^{f}\\right)\n$$\n作者将这种奖励机制称为**Self-balancing reward**，可以翻译为自平衡/自适应奖励。什么意思呢？可以想想一下，如果策略已经接近全局最优了，那么$g \\approx s_{T}^{f} \\approx s_{T}^{c}$，此时的奖励从$r^{\\prime}_{\\tau^{f}}$和$r^{\\prime}_{\\tau^{c}}$逐渐退化至纯稀疏奖励$r$。为什么呢？因为此时的$-d(s, g)+d(s, \\bar{g})$几乎为0呀！\n\n这样自动退化的奖励机制有什么好处呢？会**使得智能体最终的最优策略与使用纯稀疏奖励时一致**，大道至简，复杂的奖励函数未必可以引导智能体习得期望的行为，然而，纯稀疏奖励虽然难以学习，但是其产生的智能体行为往往是最直接最符合设计者的期望的。\n\n有了轨迹经验，也根据各自的奖励函数生成了奖励，那么该如何进行优化呢？既然取得了两条同胞轨迹，两条轨迹都要拿来训练么？我们结合伪代码进行分析。\n\n# 伪代码\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/pseudo.png)\n\n解析：\n\n- $\\rho(s_0, g)$为一个分布，用于采样任务的初始状态和目标状态，论文中的实验都是将智能体的起止点和目标点固定在一个小范围内，至于SR是否可以用在大范围随机的起始、目标点场景中，还未可知；\n- $m$是一个函数映射，用于将智能体状态空间$S$映射至目标状态空间$G$，$m(s): S \\rightarrow G$；\n- $d$是一个距离度量函数，通常为$L_1,L_2$度量；\n- $\\delta$是判定目标完成的容错半径；\n- 注意，Critic网络V的输入不仅包括状态$s$，目标$g$，也包括局部最优点（同胞轨迹的终态）$\\bar g$；\n- 作者引入了一个“包容性阈值”$\\epsilon$，这个值用来控制对使用距离目标点较近的轨迹$\\tau^c$来训练的容忍度，也用来平衡探索与利用，当$\\epsilon\\uparrow$，利用增加，当$\\epsilon\\downarrow$，探索增加（学习远距离经验）；\n- SR是先采样轨迹$s,a,s,a,...$再计算每一步的奖励的，采样时不包括$r$；\n- 每次rollout两条轨迹——$\\tau^a$和$\\tau^b$，距离目标点$g$比较近的终态轨迹标记为$\\tau^c$，远的标记为$\\tau^{f}$；\n- 优化模型时，何时用$\\tau^f$？\n  - 任何时候\n  - 猜想：距离远的不太可能是局部最优点，因为距离越远，负奖励越大，算法不会稳定收敛在距离目标点很远的局部最优处，会想办法跳出来\n- 优化模型时，何时用$\\tau^c$?\n  - 1，当两条同胞轨迹的终态距离小于$\\epsilon$时；2，当$\\tau^c$的终态已足以完成目标时\n  - 猜想：当两条轨迹的终态距离小于一定阈值时，认为轨迹质量差不多，都可以用来更新\n  - 距离目标点$g$近的轨迹已经足够近，是可以获得全局最优解的轨迹，要学习\n\n# 实验分析\n\n作者使用PPO算法在四种类型的任务场景中进行了实验：\n\n1. 连续动作任务\n2. 分层决策任务\n3. 离散动作任务\n4. 《我的世界》3D构造任务，这个任务主要用来测试SR的可扩展性\n\n任务的细节设置以及实验结果详情请看原论文。\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/experiment1.png)\n\n在这两个实验中，可以看出SR比ICM和HER的效果都要好，任务完成的成功率也必将高，且方差比较小。\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/experiment2.png)\n\n在这个离散的任务中，从图像看出纯DQN即可以解决，但是却没有看到蓝色的纯PPO曲线，按道理来说PPO应该也能解决。\n\n![](./keeping-your-distance-solving-sparse-reward-tasks/experiment3.png)\n\n# 总结\n\n> We introduce Sibling Rivalry, a simple and effective method for learning goal-reaching tasks from a generic class of distance-based shaped rewards. Sibling Rivalry makes use of sibling rollouts and self-balancing rewards to prevent the learning dynamics from stabilizing around local optima. By leveraging the distance metric used to deﬁne the underlying sparse reward, our technique enables robust learning from shaped rewards without relying on carefully-designed, problem-speciﬁc reward functions. We demonstrate the applicability of our method across a variety of goal-reaching tasks where naive distance-to-goal reward shaping consistently fails and techniques to learn from sparse rewards struggle to explore properly and/or generalize from failed rollouts. Our experiments show that Sibling Rivalry can be readily applied to both continuous and discrete domains, incorporated into hierarchical RL, and scaled to demanding environments.\n\n","slug":"keeping-your-distance-solving-sparse-reward-tasks","published":1,"updated":"2020-04-09T03:46:55.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut90004x20cd6o5drnip","content":"<p>这篇论文介绍了一个简单有效的model-free方法——<strong>Sibling Rivalry</strong>(同胞对抗？)，用于解决稀疏奖励问题。该方法特定于“以达到某个目标状态(goal-oriented)”为任务的问题，并且从塑性的距离目标相关奖励(distance-to-goal rewards)中学习。</p>\n<p>推荐：</p>\n<ul>\n<li>self-balancing 奖励机制</li>\n<li>基于奖励函数的创新，比较有趣</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1911.01417\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1911.01417.pdf</a></p>\n<p>这篇文章解决的问题点是：</p>\n<ul>\n<li>由朴素的距离目标相关的奖励(naive distance-to-goal reward shaping)引起的动态学习在局部最优点稳定的问题</li>\n</ul>\n<p>这篇文章方法的优点是：</p>\n<ul>\n<li>增强目标但不需额外奖励工程设计，也不需领域专家知识</li>\n<li>可以收敛至原始的稀疏奖励目标</li>\n</ul>\n<p>文章发表在NeurIPS 2019上。</p>\n<p>这篇论文提出的Sibling Rivalry(SR)方法结合了塑性奖励的可学习性与稀疏奖励的通用性。它主要解决面向目标(goal-oriented)的任务，是对距离奖励函数的改进，实现了奖励函数的自平衡(self-balancing，自动退化至纯稀疏奖励形式)，它的特点是：</p>\n<ul>\n<li>model-free</li>\n<li>应用在on-policy算法上</li>\n<li>应用在<strong><em>目标状态已知</em></strong>，且<strong><em>以距离为奖励函数导向</em></strong>的任务中</li>\n<li><strong>动态</strong>奖励塑性</li>\n<li>保持稀疏奖励任务的原有最优策略</li>\n<li>跳出局部最优解，寻找全局最优</li>\n<li>可以与分层RL相结合（有实验佐证）</li>\n</ul>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>文中shaped rewards一时不知道该如何做翻译，姑且就称之为“塑性奖励”好了，意为为解决某一特定问题而精心设计的奖励函数机制。</p>\n<p>Reward shaping是一种修改奖励信号的技术，比如，它可以用于重新标注失败的经验序列，并从其中筛选出可促进任务完成的经验序列进行学习。然而，这种技术是否可以提升任务性能严重取决于塑性奖励的精心设计。这种塑性奖励有时可以解决稀疏奖励问题，但是具有两个显著特点：</p>\n<ol>\n<li><p>需要精心的工程设计，也可以理解为需要对环境或任务的先验知识</p>\n<blockquote>\n<p>requires careful engineering</p>\n</blockquote>\n</li>\n<li><p>往往只适用于特定任务，特定问题，比如同样的避障问题，载具类型不同，可能就不适用</p>\n<blockquote>\n<p>is problem specific</p>\n</blockquote>\n</li>\n</ol>\n<p>对于现实世界的RL问题，需要手动设计一个与任务契合/对齐的奖励机制，一个好的奖励函数往往比算法的选择更加重要。但是现实世界问题非常复杂，细粒度的奖励函数也十分难以设计，往往会具有“捡了芝麻丢了西瓜”的特点。比如，在避障问题中，如果针对墙壁这种障碍物设置奖励函数，策略在学习过程中会对墙壁这种实体过拟合，导致当遇到一种新的障碍物时，策略无法适用，还不如简单的稀疏奖励（完成即获得奖励，反之则无），让智能体自己从环境中学习哪些具有障碍物共有或特有特性。</p>\n<p>还有一个很严重的问题是，复杂的奖励机制容易使策略陷入局部最优，比如说达到状态A可以获得奖励+10，而达到状态B可以获得奖励+1，那么如果状态A十分难以到达，策略往往会收敛在状态B，或者其他相似的状态附近中去，造成策略在这些局部最优解附近稳定下来。</p>\n<p>稀疏奖励往往不存在这种局部最优，或者考虑不周的问题。设计一个合适的稀疏奖励函数很简单，也很直接，但是从这种奖励函数中学习需要大量的时间，而且甚至学习不出来任何东西，<strong>通常需要额外的启发式探索机制去帮助智能体发现这个稀疏的正奖励</strong>。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>纯稀疏奖励的形式是这样的：</p>\n<script type=\"math/tex; mode=display\">\nr(s, g)=\\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n0, & \\text { otherwise }\n\\end{array}\\right.</script><p>其中，$s$代表当前状态，$g$代表目标状态。$d$是一个函数用来判断当前状态与目标状态的距离度量，例如$L_1$或$L_2$距离，这个距离可以用来表示任务的完成度，即距离越短，任务完成度越高。$\\delta$代表目标点的半径，也就是说，状态不必完全等于目标状态，只需要距离度量小于一定范围$\\delta$即可，这个是很常用的做法，比如Unity ML-Agents的示例环境——RollerBall，也是使用这样的设置。</p>\n<p>这种纯稀疏奖励的设置很难解决，往往需要很大的探索才能获取到寥寥无几的正奖励样本轨迹，给智能体的学习带来了很大的困难。</p>\n<p>其实可以对上述奖励进行修改，使得其可以按照距目标状态的距离给出不同的奖励，引导智能体朝向目标状态移动。它通常为下边这种形式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{ll}\n\\tilde{r}(s, g)= & \\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n-d(s, g), & \\text { otherwise }\n\\end{array}\\right.\n\\end{array}</script><p>这种奖励形式很直观，如果没有达到目标状态，则一直是负奖励，且距离越远则负奖励越大，这样将会引导智能体朝向目标状态移动。针对一些比较简单的稀疏奖励环境，这种形式的奖励设计可以带来算法性能的提升，而且往往可以解决稀疏奖励问题。但是，这种基于距离的塑性奖励（Distance-based shaped rewards）很容易陷入局部最优点，并且在局部最优点附近稳定下来，得不到进一步地策略提升。为什么这么说呢？就比如gym的MountainCar场景，智能体需要先倒退再前进才能达到目标点，也就是说要先经历负奖励的增大过程，再经历负奖励的减小过程，才能最终完成目标，从初始状态直接朝向目标点移动是不能把车子开到山顶上去的。使用这种形式的奖励将会使得智能体抵达半山腰，却永远都触及不到目标点。还有一些U-shape的路径问题，在U型的两端设置起始点与目标点，使用这种奖励机制将会使得智能体在直线朝向目标点移动时偏离轨道，永远学不会以U型的方式完成目标。</p>\n<p>使用上述奖励形式的问题经验存在各种各样的局部最优点，而且这些局部最优点与状态空间结构（state space structure）、转移动态（transition dynamics）和环境的其他特性都有关系。</p>\n<p>那么有没有一种对奖励进行塑性的方式可以避免局部最优点的影响呢？确实是有的，我们再对上述奖励函数做如下改进：</p>\n<script type=\"math/tex; mode=display\">\nr^{\\prime}(s, g, \\bar{g})=\\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n\\min [0,-d(s, g)+d(s, \\bar{g})], & \\text { otherwise }\n\\end{array}\\right.</script><p>与上式不同的是，这里多了一个符号——$\\bar g$，它用来表示局部最优点的状态。论文中给出了这样一个例子：</p>\n<p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/motivating-example.png\" alt=\"\"></p>\n<p>最左边的图是一个简单的环境，智能体的目标是到达绿色的Goal点，如果使用前文提到的$\\tilde{r}$，则会存在局部最优点，也就是图中的Local Optimum。为什么会存在这个局部最优点呢？可以设想一下，假设智能体从左下角出发，那么它在上方路径和下方路径各走一步时，明显下方路径的负奖励衰减的更快，所以智能体通常会选择走下方路径，最终收敛到与Goal隔岸相望的Local Optimum。$\\tilde{r}$的奖励函数图像轮廓如上面中间图像红色线条所示，图中横坐标为坐标点，纵坐标为奖励值的高低。绿色光点为智能体在轨迹终态的分布，可以看出，使用$\\tilde{r}$作为奖励函数时，在这个环境中奖励图像存在一个小的山峰，相比于全局最优点，智能体更易达到局部最优点，而且会在局部最优附近稳定下来，导致无法产生全局最优策略。</p>\n<p>最右侧的图是使用了增强后的距离奖励函数$r^{\\prime}$所描绘的奖励图像轮廓，可以看出，通过将局部最优点的山峰构造成低谷，即可抵消局部最优点的影响。绿色点的分布也彰显了增强奖励函数后，智能体可以收敛到全局最优策略。为什么像$r^{\\prime}$一样构造奖励函数即可解决局部最优点的影响呢？可以想象一下，将三角形的原理应用上去，当智能体选择上方路径时，两距离相减值逐渐趋于正值，也就是奖励逐渐增大，而选择下方路径时， 两距离相减横为负奖励，这种特性引导着智能体向逐渐增大的正奖励的方向靠拢。</p>\n<p>虽然像$r^{\\prime}$这种增强距离奖励的形式可以解决稀疏奖励问题，并跳出局部最优点，但是其通常具有如下几个缺点：</p>\n<ol>\n<li>需要领域专家知识分析局部最优点；</li>\n<li>环境或任务复杂时，存在多种局部最优点，难以确定合适的奖励函数；</li>\n<li>一不小心便会弄巧成拙，还会引入新的局部最优点。</li>\n</ol>\n<h2 id=\"同胞对抗——Sibling-Rivalry\"><a href=\"#同胞对抗——Sibling-Rivalry\" class=\"headerlink\" title=\"同胞对抗——Sibling Rivalry\"></a>同胞对抗——Sibling Rivalry</h2><p>作者十分中意这种跳出局部最优点的方式，所以，作者设想需要一个新的奖励机制，它应当满足：</p>\n<ol>\n<li>可以解决稀疏奖励问题</li>\n<li>不需要专家及领域知识对环境进行全面的分析与判断</li>\n<li>动态评估局部最优点，自适应调整奖励函数</li>\n</ol>\n<p>这有点像静态图与动态图的区别，$r^{\\prime}$就好像是静态图，需要专家先把图构好，再解决问题，而同胞对抗（Sibling Rivalry， SR）的思想就好像是动态图，一边执行一边应对潜在的局部最优点。</p>\n<p>先来说一下SR的思想：</p>\n<ol>\n<li><p>每次采样两条轨迹，同样的起始点与目标点；</p>\n</li>\n<li><p>距离目标近的为$\\tau^c$，远的为$\\tau^f$;</p>\n</li>\n<li><p>互相认为对方的终态$s_T$为局部最优点（假想敌），构造奖励函数，计算轨迹每一时间步的奖励。</p>\n</li>\n</ol>\n<p>如下图所示，每次都roll out两条轨迹，这两条轨迹即称为同胞，然后互相指认对方的终态$S_T^c$和$S_T^f$为局部最优点，促使智能体不选择对方的路径，即为对抗。注意，这样的方式确实有可能使得策略在远离局部最优点的同时，也偏离潜在的正确路径，因为智能体并不真正了解什么样的路径是比较好或者比较坏的。</p>\n<p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/sr-example.png\" alt=\"\"></p>\n<p>这种互相对抗的方式增加了智能体的探索能力，因为当智能体的策略不是最优时，它会趋向于选择各种不同的路径，以使得策略可以避开尽可能多的局部最优点。</p>\n<p>基于两条同胞轨迹$\\tau^{c}$和$\\tau^{f}$，如何构造它们的奖励函数呢？其实也很简单，像$r^{\\prime}$一样，将其中的局部最优点$\\bar g$更换一下即可：</p>\n<script type=\"math/tex; mode=display\">\nr_{\\tau^{f}}^{\\prime}=r^{\\prime}\\left(s_{T}^{f}, g, s_{T}^{c}\\right) \\quad \\& \\quad r_{\\tau^{c}}^{\\prime}=r^{\\prime}\\left(s_{T}^{c}, g, s_{T}^{f}\\right)</script><p>作者将这种奖励机制称为<strong>Self-balancing reward</strong>，可以翻译为自平衡/自适应奖励。什么意思呢？可以想想一下，如果策略已经接近全局最优了，那么$g \\approx s_{T}^{f} \\approx s_{T}^{c}$，此时的奖励从$r^{\\prime}_{\\tau^{f}}$和$r^{\\prime}_{\\tau^{c}}$逐渐退化至纯稀疏奖励$r$。为什么呢？因为此时的$-d(s, g)+d(s, \\bar{g})$几乎为0呀！</p>\n<p>这样自动退化的奖励机制有什么好处呢？会<strong>使得智能体最终的最优策略与使用纯稀疏奖励时一致</strong>，大道至简，复杂的奖励函数未必可以引导智能体习得期望的行为，然而，纯稀疏奖励虽然难以学习，但是其产生的智能体行为往往是最直接最符合设计者的期望的。</p>\n<p>有了轨迹经验，也根据各自的奖励函数生成了奖励，那么该如何进行优化呢？既然取得了两条同胞轨迹，两条轨迹都要拿来训练么？我们结合伪代码进行分析。</p>\n<h1 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h1><p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>$\\rho(s_0, g)$为一个分布，用于采样任务的初始状态和目标状态，论文中的实验都是将智能体的起止点和目标点固定在一个小范围内，至于SR是否可以用在大范围随机的起始、目标点场景中，还未可知；</li>\n<li>$m$是一个函数映射，用于将智能体状态空间$S$映射至目标状态空间$G$，$m(s): S \\rightarrow G$；</li>\n<li>$d$是一个距离度量函数，通常为$L_1,L_2$度量；</li>\n<li>$\\delta$是判定目标完成的容错半径；</li>\n<li>注意，Critic网络V的输入不仅包括状态$s$，目标$g$，也包括局部最优点（同胞轨迹的终态）$\\bar g$；</li>\n<li>作者引入了一个“包容性阈值”$\\epsilon$，这个值用来控制对使用距离目标点较近的轨迹$\\tau^c$来训练的容忍度，也用来平衡探索与利用，当$\\epsilon\\uparrow$，利用增加，当$\\epsilon\\downarrow$，探索增加（学习远距离经验）；</li>\n<li>SR是先采样轨迹$s,a,s,a,…$再计算每一步的奖励的，采样时不包括$r$；</li>\n<li>每次rollout两条轨迹——$\\tau^a$和$\\tau^b$，距离目标点$g$比较近的终态轨迹标记为$\\tau^c$，远的标记为$\\tau^{f}$；</li>\n<li>优化模型时，何时用$\\tau^f$？<ul>\n<li>任何时候</li>\n<li>猜想：距离远的不太可能是局部最优点，因为距离越远，负奖励越大，算法不会稳定收敛在距离目标点很远的局部最优处，会想办法跳出来</li>\n</ul>\n</li>\n<li>优化模型时，何时用$\\tau^c$?<ul>\n<li>1，当两条同胞轨迹的终态距离小于$\\epsilon$时；2，当$\\tau^c$的终态已足以完成目标时</li>\n<li>猜想：当两条轨迹的终态距离小于一定阈值时，认为轨迹质量差不多，都可以用来更新</li>\n<li>距离目标点$g$近的轨迹已经足够近，是可以获得全局最优解的轨迹，要学习</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"实验分析\"><a href=\"#实验分析\" class=\"headerlink\" title=\"实验分析\"></a>实验分析</h1><p>作者使用PPO算法在四种类型的任务场景中进行了实验：</p>\n<ol>\n<li>连续动作任务</li>\n<li>分层决策任务</li>\n<li>离散动作任务</li>\n<li>《我的世界》3D构造任务，这个任务主要用来测试SR的可扩展性</li>\n</ol>\n<p>任务的细节设置以及实验结果详情请看原论文。</p>\n<p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/experiment1.png\" alt=\"\"></p>\n<p>在这两个实验中，可以看出SR比ICM和HER的效果都要好，任务完成的成功率也必将高，且方差比较小。</p>\n<p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/experiment2.png\" alt=\"\"></p>\n<p>在这个离散的任务中，从图像看出纯DQN即可以解决，但是却没有看到蓝色的纯PPO曲线，按道理来说PPO应该也能解决。</p>\n<p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/experiment3.png\" alt=\"\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><blockquote>\n<p>We introduce Sibling Rivalry, a simple and effective method for learning goal-reaching tasks from a generic class of distance-based shaped rewards. Sibling Rivalry makes use of sibling rollouts and self-balancing rewards to prevent the learning dynamics from stabilizing around local optima. By leveraging the distance metric used to deﬁne the underlying sparse reward, our technique enables robust learning from shaped rewards without relying on carefully-designed, problem-speciﬁc reward functions. We demonstrate the applicability of our method across a variety of goal-reaching tasks where naive distance-to-goal reward shaping consistently fails and techniques to learn from sparse rewards struggle to explore properly and/or generalize from failed rollouts. Our experiments show that Sibling Rivalry can be readily applied to both continuous and discrete domains, incorporated into hierarchical RL, and scaled to demanding environments.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>这篇论文介绍了一个简单有效的model-free方法——<strong>Sibling Rivalry</strong>(同胞对抗？)，用于解决稀疏奖励问题。该方法特定于“以达到某个目标状态(goal-oriented)”为任务的问题，并且从塑性的距离目标相关奖励(distance-to-goal rewards)中学习。</p>\n<p>推荐：</p>\n<ul>\n<li>self-balancing 奖励机制</li>\n<li>基于奖励函数的创新，比较有趣</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/1911.01417\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1911.01417.pdf</a></p>\n<p>这篇文章解决的问题点是：</p>\n<ul>\n<li>由朴素的距离目标相关的奖励(naive distance-to-goal reward shaping)引起的动态学习在局部最优点稳定的问题</li>\n</ul>\n<p>这篇文章方法的优点是：</p>\n<ul>\n<li>增强目标但不需额外奖励工程设计，也不需领域专家知识</li>\n<li>可以收敛至原始的稀疏奖励目标</li>\n</ul>\n<p>文章发表在NeurIPS 2019上。</p>\n<p>这篇论文提出的Sibling Rivalry(SR)方法结合了塑性奖励的可学习性与稀疏奖励的通用性。它主要解决面向目标(goal-oriented)的任务，是对距离奖励函数的改进，实现了奖励函数的自平衡(self-balancing，自动退化至纯稀疏奖励形式)，它的特点是：</p>\n<ul>\n<li>model-free</li>\n<li>应用在on-policy算法上</li>\n<li>应用在<strong><em>目标状态已知</em></strong>，且<strong><em>以距离为奖励函数导向</em></strong>的任务中</li>\n<li><strong>动态</strong>奖励塑性</li>\n<li>保持稀疏奖励任务的原有最优策略</li>\n<li>跳出局部最优解，寻找全局最优</li>\n<li>可以与分层RL相结合（有实验佐证）</li>\n</ul>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>文中shaped rewards一时不知道该如何做翻译，姑且就称之为“塑性奖励”好了，意为为解决某一特定问题而精心设计的奖励函数机制。</p>\n<p>Reward shaping是一种修改奖励信号的技术，比如，它可以用于重新标注失败的经验序列，并从其中筛选出可促进任务完成的经验序列进行学习。然而，这种技术是否可以提升任务性能严重取决于塑性奖励的精心设计。这种塑性奖励有时可以解决稀疏奖励问题，但是具有两个显著特点：</p>\n<ol>\n<li><p>需要精心的工程设计，也可以理解为需要对环境或任务的先验知识</p>\n<blockquote>\n<p>requires careful engineering</p>\n</blockquote>\n</li>\n<li><p>往往只适用于特定任务，特定问题，比如同样的避障问题，载具类型不同，可能就不适用</p>\n<blockquote>\n<p>is problem specific</p>\n</blockquote>\n</li>\n</ol>\n<p>对于现实世界的RL问题，需要手动设计一个与任务契合/对齐的奖励机制，一个好的奖励函数往往比算法的选择更加重要。但是现实世界问题非常复杂，细粒度的奖励函数也十分难以设计，往往会具有“捡了芝麻丢了西瓜”的特点。比如，在避障问题中，如果针对墙壁这种障碍物设置奖励函数，策略在学习过程中会对墙壁这种实体过拟合，导致当遇到一种新的障碍物时，策略无法适用，还不如简单的稀疏奖励（完成即获得奖励，反之则无），让智能体自己从环境中学习哪些具有障碍物共有或特有特性。</p>\n<p>还有一个很严重的问题是，复杂的奖励机制容易使策略陷入局部最优，比如说达到状态A可以获得奖励+10，而达到状态B可以获得奖励+1，那么如果状态A十分难以到达，策略往往会收敛在状态B，或者其他相似的状态附近中去，造成策略在这些局部最优解附近稳定下来。</p>\n<p>稀疏奖励往往不存在这种局部最优，或者考虑不周的问题。设计一个合适的稀疏奖励函数很简单，也很直接，但是从这种奖励函数中学习需要大量的时间，而且甚至学习不出来任何东西，<strong>通常需要额外的启发式探索机制去帮助智能体发现这个稀疏的正奖励</strong>。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>纯稀疏奖励的形式是这样的：</p>\n<script type=\"math/tex; mode=display\">\nr(s, g)=\\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n0, & \\text { otherwise }\n\\end{array}\\right.</script><p>其中，$s$代表当前状态，$g$代表目标状态。$d$是一个函数用来判断当前状态与目标状态的距离度量，例如$L_1$或$L_2$距离，这个距离可以用来表示任务的完成度，即距离越短，任务完成度越高。$\\delta$代表目标点的半径，也就是说，状态不必完全等于目标状态，只需要距离度量小于一定范围$\\delta$即可，这个是很常用的做法，比如Unity ML-Agents的示例环境——RollerBall，也是使用这样的设置。</p>\n<p>这种纯稀疏奖励的设置很难解决，往往需要很大的探索才能获取到寥寥无几的正奖励样本轨迹，给智能体的学习带来了很大的困难。</p>\n<p>其实可以对上述奖励进行修改，使得其可以按照距目标状态的距离给出不同的奖励，引导智能体朝向目标状态移动。它通常为下边这种形式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{ll}\n\\tilde{r}(s, g)= & \\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n-d(s, g), & \\text { otherwise }\n\\end{array}\\right.\n\\end{array}</script><p>这种奖励形式很直观，如果没有达到目标状态，则一直是负奖励，且距离越远则负奖励越大，这样将会引导智能体朝向目标状态移动。针对一些比较简单的稀疏奖励环境，这种形式的奖励设计可以带来算法性能的提升，而且往往可以解决稀疏奖励问题。但是，这种基于距离的塑性奖励（Distance-based shaped rewards）很容易陷入局部最优点，并且在局部最优点附近稳定下来，得不到进一步地策略提升。为什么这么说呢？就比如gym的MountainCar场景，智能体需要先倒退再前进才能达到目标点，也就是说要先经历负奖励的增大过程，再经历负奖励的减小过程，才能最终完成目标，从初始状态直接朝向目标点移动是不能把车子开到山顶上去的。使用这种形式的奖励将会使得智能体抵达半山腰，却永远都触及不到目标点。还有一些U-shape的路径问题，在U型的两端设置起始点与目标点，使用这种奖励机制将会使得智能体在直线朝向目标点移动时偏离轨道，永远学不会以U型的方式完成目标。</p>\n<p>使用上述奖励形式的问题经验存在各种各样的局部最优点，而且这些局部最优点与状态空间结构（state space structure）、转移动态（transition dynamics）和环境的其他特性都有关系。</p>\n<p>那么有没有一种对奖励进行塑性的方式可以避免局部最优点的影响呢？确实是有的，我们再对上述奖励函数做如下改进：</p>\n<script type=\"math/tex; mode=display\">\nr^{\\prime}(s, g, \\bar{g})=\\left\\{\\begin{array}{ll}\n1, & d(s, g) \\leq \\delta \\\\\n\\min [0,-d(s, g)+d(s, \\bar{g})], & \\text { otherwise }\n\\end{array}\\right.</script><p>与上式不同的是，这里多了一个符号——$\\bar g$，它用来表示局部最优点的状态。论文中给出了这样一个例子：</p>\n<p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/motivating-example.png\" alt=\"\"></p>\n<p>最左边的图是一个简单的环境，智能体的目标是到达绿色的Goal点，如果使用前文提到的$\\tilde{r}$，则会存在局部最优点，也就是图中的Local Optimum。为什么会存在这个局部最优点呢？可以设想一下，假设智能体从左下角出发，那么它在上方路径和下方路径各走一步时，明显下方路径的负奖励衰减的更快，所以智能体通常会选择走下方路径，最终收敛到与Goal隔岸相望的Local Optimum。$\\tilde{r}$的奖励函数图像轮廓如上面中间图像红色线条所示，图中横坐标为坐标点，纵坐标为奖励值的高低。绿色光点为智能体在轨迹终态的分布，可以看出，使用$\\tilde{r}$作为奖励函数时，在这个环境中奖励图像存在一个小的山峰，相比于全局最优点，智能体更易达到局部最优点，而且会在局部最优附近稳定下来，导致无法产生全局最优策略。</p>\n<p>最右侧的图是使用了增强后的距离奖励函数$r^{\\prime}$所描绘的奖励图像轮廓，可以看出，通过将局部最优点的山峰构造成低谷，即可抵消局部最优点的影响。绿色点的分布也彰显了增强奖励函数后，智能体可以收敛到全局最优策略。为什么像$r^{\\prime}$一样构造奖励函数即可解决局部最优点的影响呢？可以想象一下，将三角形的原理应用上去，当智能体选择上方路径时，两距离相减值逐渐趋于正值，也就是奖励逐渐增大，而选择下方路径时， 两距离相减横为负奖励，这种特性引导着智能体向逐渐增大的正奖励的方向靠拢。</p>\n<p>虽然像$r^{\\prime}$这种增强距离奖励的形式可以解决稀疏奖励问题，并跳出局部最优点，但是其通常具有如下几个缺点：</p>\n<ol>\n<li>需要领域专家知识分析局部最优点；</li>\n<li>环境或任务复杂时，存在多种局部最优点，难以确定合适的奖励函数；</li>\n<li>一不小心便会弄巧成拙，还会引入新的局部最优点。</li>\n</ol>\n<h2 id=\"同胞对抗——Sibling-Rivalry\"><a href=\"#同胞对抗——Sibling-Rivalry\" class=\"headerlink\" title=\"同胞对抗——Sibling Rivalry\"></a>同胞对抗——Sibling Rivalry</h2><p>作者十分中意这种跳出局部最优点的方式，所以，作者设想需要一个新的奖励机制，它应当满足：</p>\n<ol>\n<li>可以解决稀疏奖励问题</li>\n<li>不需要专家及领域知识对环境进行全面的分析与判断</li>\n<li>动态评估局部最优点，自适应调整奖励函数</li>\n</ol>\n<p>这有点像静态图与动态图的区别，$r^{\\prime}$就好像是静态图，需要专家先把图构好，再解决问题，而同胞对抗（Sibling Rivalry， SR）的思想就好像是动态图，一边执行一边应对潜在的局部最优点。</p>\n<p>先来说一下SR的思想：</p>\n<ol>\n<li><p>每次采样两条轨迹，同样的起始点与目标点；</p>\n</li>\n<li><p>距离目标近的为$\\tau^c$，远的为$\\tau^f$;</p>\n</li>\n<li><p>互相认为对方的终态$s_T$为局部最优点（假想敌），构造奖励函数，计算轨迹每一时间步的奖励。</p>\n</li>\n</ol>\n<p>如下图所示，每次都roll out两条轨迹，这两条轨迹即称为同胞，然后互相指认对方的终态$S_T^c$和$S_T^f$为局部最优点，促使智能体不选择对方的路径，即为对抗。注意，这样的方式确实有可能使得策略在远离局部最优点的同时，也偏离潜在的正确路径，因为智能体并不真正了解什么样的路径是比较好或者比较坏的。</p>\n<p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/sr-example.png\" alt=\"\"></p>\n<p>这种互相对抗的方式增加了智能体的探索能力，因为当智能体的策略不是最优时，它会趋向于选择各种不同的路径，以使得策略可以避开尽可能多的局部最优点。</p>\n<p>基于两条同胞轨迹$\\tau^{c}$和$\\tau^{f}$，如何构造它们的奖励函数呢？其实也很简单，像$r^{\\prime}$一样，将其中的局部最优点$\\bar g$更换一下即可：</p>\n<script type=\"math/tex; mode=display\">\nr_{\\tau^{f}}^{\\prime}=r^{\\prime}\\left(s_{T}^{f}, g, s_{T}^{c}\\right) \\quad \\& \\quad r_{\\tau^{c}}^{\\prime}=r^{\\prime}\\left(s_{T}^{c}, g, s_{T}^{f}\\right)</script><p>作者将这种奖励机制称为<strong>Self-balancing reward</strong>，可以翻译为自平衡/自适应奖励。什么意思呢？可以想想一下，如果策略已经接近全局最优了，那么$g \\approx s_{T}^{f} \\approx s_{T}^{c}$，此时的奖励从$r^{\\prime}_{\\tau^{f}}$和$r^{\\prime}_{\\tau^{c}}$逐渐退化至纯稀疏奖励$r$。为什么呢？因为此时的$-d(s, g)+d(s, \\bar{g})$几乎为0呀！</p>\n<p>这样自动退化的奖励机制有什么好处呢？会<strong>使得智能体最终的最优策略与使用纯稀疏奖励时一致</strong>，大道至简，复杂的奖励函数未必可以引导智能体习得期望的行为，然而，纯稀疏奖励虽然难以学习，但是其产生的智能体行为往往是最直接最符合设计者的期望的。</p>\n<p>有了轨迹经验，也根据各自的奖励函数生成了奖励，那么该如何进行优化呢？既然取得了两条同胞轨迹，两条轨迹都要拿来训练么？我们结合伪代码进行分析。</p>\n<h1 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h1><p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>$\\rho(s_0, g)$为一个分布，用于采样任务的初始状态和目标状态，论文中的实验都是将智能体的起止点和目标点固定在一个小范围内，至于SR是否可以用在大范围随机的起始、目标点场景中，还未可知；</li>\n<li>$m$是一个函数映射，用于将智能体状态空间$S$映射至目标状态空间$G$，$m(s): S \\rightarrow G$；</li>\n<li>$d$是一个距离度量函数，通常为$L_1,L_2$度量；</li>\n<li>$\\delta$是判定目标完成的容错半径；</li>\n<li>注意，Critic网络V的输入不仅包括状态$s$，目标$g$，也包括局部最优点（同胞轨迹的终态）$\\bar g$；</li>\n<li>作者引入了一个“包容性阈值”$\\epsilon$，这个值用来控制对使用距离目标点较近的轨迹$\\tau^c$来训练的容忍度，也用来平衡探索与利用，当$\\epsilon\\uparrow$，利用增加，当$\\epsilon\\downarrow$，探索增加（学习远距离经验）；</li>\n<li>SR是先采样轨迹$s,a,s,a,…$再计算每一步的奖励的，采样时不包括$r$；</li>\n<li>每次rollout两条轨迹——$\\tau^a$和$\\tau^b$，距离目标点$g$比较近的终态轨迹标记为$\\tau^c$，远的标记为$\\tau^{f}$；</li>\n<li>优化模型时，何时用$\\tau^f$？<ul>\n<li>任何时候</li>\n<li>猜想：距离远的不太可能是局部最优点，因为距离越远，负奖励越大，算法不会稳定收敛在距离目标点很远的局部最优处，会想办法跳出来</li>\n</ul>\n</li>\n<li>优化模型时，何时用$\\tau^c$?<ul>\n<li>1，当两条同胞轨迹的终态距离小于$\\epsilon$时；2，当$\\tau^c$的终态已足以完成目标时</li>\n<li>猜想：当两条轨迹的终态距离小于一定阈值时，认为轨迹质量差不多，都可以用来更新</li>\n<li>距离目标点$g$近的轨迹已经足够近，是可以获得全局最优解的轨迹，要学习</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"实验分析\"><a href=\"#实验分析\" class=\"headerlink\" title=\"实验分析\"></a>实验分析</h1><p>作者使用PPO算法在四种类型的任务场景中进行了实验：</p>\n<ol>\n<li>连续动作任务</li>\n<li>分层决策任务</li>\n<li>离散动作任务</li>\n<li>《我的世界》3D构造任务，这个任务主要用来测试SR的可扩展性</li>\n</ol>\n<p>任务的细节设置以及实验结果详情请看原论文。</p>\n<p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/experiment1.png\" alt=\"\"></p>\n<p>在这两个实验中，可以看出SR比ICM和HER的效果都要好，任务完成的成功率也必将高，且方差比较小。</p>\n<p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/experiment2.png\" alt=\"\"></p>\n<p>在这个离散的任务中，从图像看出纯DQN即可以解决，但是却没有看到蓝色的纯PPO曲线，按道理来说PPO应该也能解决。</p>\n<p><img src=\"./keeping-your-distance-solving-sparse-reward-tasks/experiment3.png\" alt=\"\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><blockquote>\n<p>We introduce Sibling Rivalry, a simple and effective method for learning goal-reaching tasks from a generic class of distance-based shaped rewards. Sibling Rivalry makes use of sibling rollouts and self-balancing rewards to prevent the learning dynamics from stabilizing around local optima. By leveraging the distance metric used to deﬁne the underlying sparse reward, our technique enables robust learning from shaped rewards without relying on carefully-designed, problem-speciﬁc reward functions. We demonstrate the applicability of our method across a variety of goal-reaching tasks where naive distance-to-goal reward shaping consistently fails and techniques to learn from sparse rewards struggle to explore properly and/or generalize from failed rollouts. Our experiments show that Sibling Rivalry can be readily applied to both continuous and discrete domains, incorporated into hierarchical RL, and scaled to demanding environments.</p>\n</blockquote>"},{"title":"Maximum Entropy-Regularized Multi-Goal Reinforcement-Learning","copyright":true,"mathjax":true,"top":1,"date":"2019-06-12T12:49:32.000Z","keywords":null,"description":null,"_content":"\n这篇论文将强化学习的目标与最大熵结合了起来，提出了简称为MEP的经验池机制。许多将熵与强化学习结合的方法都是考虑可选动作分布的熵，该篇论文很新颖的使用的是“迹”的熵。\n\n推荐程度中等偏下：\n\n- 有些地方解释的不是很清楚\n- 熵的结合方式特殊，可以一看\n- 有些公式推导过于复杂，难懂\n- 有些参考文献标注不准，如A3C算法的论文并没有使用熵的概念，却在熵相关的语句进行了标注\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1905.08786.pdf](https://arxiv.org/pdf/1905.08786.pdf)\n\n原作者代码地址：[https://github.com/ruizhaogit/mep.git](https://github.com/ruizhaogit/mep.git)\n\n该文章发于2019年的ICML，与之前写过的《Energy-Based Hindsight Experience Prioritization》为同一作者。\n\n本文主要做了三个贡献：\n\n1. 修改了目标函数，提出了最大熵正则化多目标强化学习(Maximum Entropy-Regularized Multi-Goal RL)的想法\n2. 推导出替代(surrogate)目标函数，是第1步目标函数的一个下界，可以使算法稳定优化\n3. 提出了Maximum Entropy-based Prioritization(MEP)的经验池框架\n\n# 文中精要\n\n文中目标函数的构造主要受Guiasu于1971年提出的加权熵(Weighted Entropy)启发。加权熵表示为：\n$$\n\\mathcal{H}_{p}^{w}=-\\sum_{k=1}^{K} w_{k} p_{k} \\log p_{k}\n$$\n$w_{k}$表示权重。\n\n## 多目标强化学习的符号表示\n\n用$p\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right)$表示一个迹出现的概率：\n\n- $\\boldsymbol{\\tau}=s_{1}, a_{1}, s_{2}, a_{2}, \\ldots, s_{T-1}, a_{T-1}, s_{T}$代表迹\n- $g^{e}$代表一个真实的目标，即不是“事后诸葛亮”假定的目标，$g^{e} \\in \\operatorname{Val}\\left(G^{e}\\right)$，后一项为目标空间，一般情况下，可以视为状态空间$\\mathcal{S}$的子集\n- $\\theta$代表策略参数\n\n展开来写，一个迹在策略$\\theta$被采样到的概率为\n$$\np\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right)=p\\left(s_{1}\\right) \\prod_{t=1}^{T-1} p\\left(a_{t} | s_{t}, g^{e}, \\boldsymbol{\\theta}\\right) p\\left(s_{t+1} | s_{t}, a_{t}\\right)\n$$\n由此定义策略$\\theta$下的期望奖励回报，也就是目标函数，表示为\n$$\n\\begin{aligned} \\eta(\\boldsymbol{\\theta}) &=\\mathbb{E}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\ &=\\sum_{g^{e}} p\\left(g^{e}\\right) \\sum_{\\boldsymbol{\\tau}} p\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\end{aligned}\n$$\n很容易理解，也就是在传统的目标函数前边加了一项关于每个目标求积分的步骤。\n\n如果使用off-policy算法且用经验池机制来提升采样效率，那么目标函数为\n$$\n\\eta^{\\mathcal{R}}(\\boldsymbol{\\theta})=\\sum_{\\boldsymbol{\\tau}, g^{e}} p_{\\mathcal{R}}\\left(\\boldsymbol{\\tau}, g^{e} | \\boldsymbol{\\theta}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right)\n$$\n其中$\\mathcal{R}$表示经验池。注意，$\\eta^{\\mathcal{R}}(\\boldsymbol{\\theta})$将$\\eta(\\boldsymbol{\\theta})$的前两个积分项合在一起写了，所以是联合概率而不是条件概率。\n\n## 最大熵正则化目标函数\n\n将前文提到的$\\eta(\\boldsymbol{\\theta})$与加权熵结合起来，就构造出了本文中新的目标函数，即\n$$\n\\begin{aligned} \\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) &=\\mathcal{H}_{p}^{w}\\left(\\mathcal{T}^{g}\\right) \\\\ &=\\mathbb{E}_{p}\\left[\\color{red} {\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)}} \\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\end{aligned}\n$$\n$\\color{red} {p\\left(\\boldsymbol{\\tau}^{g}\\right)}$代表$\\sum_{g^{e}} p_{\\mathcal{R}}\\left(\\tau^{g}, g^{e} | \\boldsymbol{\\theta} \\right )$，期望右下角的$p$也是$p\\left(\\boldsymbol{\\tau}^{g}\\right)$的意思。\n\n**与传统的结合方式不同的是，这种结合方式并没有将熵作为一个加和的项，而是相乘。**\n\n仔细想一下，如果将这个式子视为加权熵，那么权重系数是累计奖励$\\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right)$，这样做的直观解释是：**对于各种各样的迹，给与累计回报大的以更多权重，使算法直到要朝哪个迹的方向优化。**\n\n反而，如果将前一个对数项视为传统强化学习目标函数的权重系数，那么这样的直观解释是：**迹出现的概率越低，就越新颖，反而要使其权重增加，从而驱使算法向探索的方向优化。**\n\n## 替代目标函数\n\n文中指出，$\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) $中的$\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)}$这一项是无界的，即取值范围为$[0,+\\infty]$，这会导致通用值函数近似的训练不稳定，因此提出了可靠地替代目标函数$\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})$，这个目标函数是原目标函数的一个下界。\n\n> the weight, $\\log \\left(1 / p\\left(\\boldsymbol{\\tau}^{g}\\right)\\right)$, is unbounded, which makes the training of the universal function approximator unstable. \n\n表示为\n$$\n\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})=Z \\cdot \\mathbb{E}_{\\color{red}{q}}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right]\n$$\n注意，期望积分的是迹分布函数$q$，而不是经验池中真实的迹分布函数$p$。\n\n那么，新的迹分布函数$q\\left(\\boldsymbol{\\tau}^{g}\\right)$是怎么得来的？\n\n首先，使用Latent Varibale Model(LVM)对$p\\left(\\boldsymbol{\\tau}^{g}\\right)$的潜在分布进行建模，因为LVM适合于对复杂的分布进行建模。\n\n> We use a Latent Variable Model(LVM) (Murphy, 2012) to model the underlying distribution of $p\\left(\\boldsymbol{\\tau}^{g}\\right)$, since LVM is suitable for modeling complex distributions.\n\n将分布用混合高斯模型MoG表示，\n$$\np\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)=\\frac{1}{Z} \\sum_{i=k}^{K} c_{k} \\mathcal{N}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)\n$$\n其中，\n\n- $K$为隐变量的个数\n- $\\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}$分布为均值与协方差矩阵\n- $c_{k}$为混合系数\n- $Z$为配分函数（归一化系数）\n- $\\phi$为模型参数，包含所有的均值、协方差矩阵和混合系数\n\n文中接着使用$p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)$的补作为经验重放的优先级，即\n$$\n\\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right) \\propto 1-p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)\n$$\n补越大，就代表迹出现的概率越低，那么就对该迹赋予更大的优先级。作者想通过过采样这些迹来增大训练时迹分布的熵。直观的解释就是，概率分布不均匀，那么让概率大的出现次数少，概率小的出现次数多，这样就会使采样的分布朝着均匀分布的方向移动，从而使熵值增加。\n\n文中由此引出了新的迹分布$q\\left(\\boldsymbol{\\tau}^{g}\\right)$，它表示为原始分布与其补的联合分布，\n$$\n\\begin{aligned} q\\left(\\boldsymbol{\\tau}^{g}\\right) & \\propto \\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right) p\\left(\\boldsymbol{\\tau}^{g}\\right) \\\\ & \\propto\\left(1-p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)\\right) p\\left(\\boldsymbol{\\tau}^{g}\\right) \\\\ & \\approx p\\left(\\boldsymbol{\\tau}^{g}\\right)-p\\left(\\boldsymbol{\\tau}^{g}\\right)^{2} \\end{aligned}\n$$\n文中将正比的比例设置为$\\color{blue}{\\frac{1}{Z}}$，即$q\\left(\\boldsymbol{\\tau}^{g}\\right)=\\frac{1}{Z} p\\left(\\boldsymbol{\\tau}^{g}\\right)\\left(1-p\\left(\\boldsymbol{\\tau}^{g}\\right)\\right)$，接下来就可以证明$\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})$为$\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) $的下界：\n$$\n\\begin{aligned} \n\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta}) &=Z \\cdot \\mathbb{E}_{q}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\ &=\\sum_{\\boldsymbol{\\tau}^{g}} Z \\cdot q\\left(\\boldsymbol{\\tau}^{g}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&=\\sum_{\\tau^{g}} \\frac{Z}{Z} p\\left(\\tau^{g}\\right)\\left(1-p\\left(\\tau^{g}\\right)\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&<\\sum_{\\tau^{g}}-p\\left(\\boldsymbol{\\tau}^{g}\\right) \\log p\\left(\\boldsymbol{\\tau}^{g}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&=\\mathbb{E}_{p}\\left[\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)} \\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\\n&=\\mathcal{H}_{p}^{w}\\left(\\mathcal{T}^{g}\\right) \\\\\n&=\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta})\n\\end{aligned}\n$$\n在小于号不等式那一步，使用了函数的性质：$\\log x<x-1$。很容易可以画出$f(x)=\\ln{x}-x+1$在区间[0,1]上的图像：\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/inequality.png)\n\n文中进一步证明了$q$分布的熵比$p$分布的熵更大，因此，由$q$分布来进行采样可以使采样更均匀（= =！那么直接使用均匀分布采样不更好吗？），使学习的目标更多样化。证明过程篇幅过长，详见原论文附录，\n$$\np\\left(\\boldsymbol{\\tau}^{g}\\right), \\text { where } p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right) \\in(0,1) \\text { and } \\sum_{i=1}^{N} p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=1\n$$\n\n$$\nq\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=\\frac{1}{Z} p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\left(1-p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\right), \\text { where } \\sum_{i=1}^{N} q\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=1\n$$\n\n$$\n\\mathcal{H}_{q}\\left(\\mathcal{T}^{g}\\right)-\\mathcal{H}_{p}\\left(\\mathcal{T}^{g}\\right) \\geq 0\n$$\n\n## 基于最大熵的优先级\n\n文中说是基于最大熵的优先经验回放，但是除了使用$q\\left(\\boldsymbol{\\tau}^{g}\\right)$分布之外，在这一部分没有体现出熵的影子，优先级的设置为\n$$\nq\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=\\frac{\\operatorname{rank}\\left(q\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\right)}{\\sum_{n=1}^{N} \\operatorname{rank}\\left(q\\left(\\boldsymbol{\\tau}_{n}^{g}\\right)\\right)}\n$$\n使用排序作为衡量优先级的标准是因为这种方式更具鲁棒性，对异常值不敏感。\n\n之前文中说想要使出现概率低的迹以更高的概率被从经验池中采样到，如果是按照新的$q$分布来定义迹出现的概率，那么到这里是有些说不通的，因为，前文提到$q\\left(\\boldsymbol{\\tau}^{g}\\right) \\approx p\\left(\\boldsymbol{\\tau}^{g}\\right)-p\\left(\\boldsymbol{\\tau}^{g}\\right)^{2} $，那么画出$f(x)=x-x^2$在区间[0，1]上的图像为：\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/x-x^2.png)\n\n由此可见，q值小的地方为p值小与p值大的地方，这就会导致出现概率最大、概率最小的迹被经验池重复的次数多，与前文所讲不同。\n\n而如果考虑以真实的p分布来定义迹出现的概率，那么此处不应该使用$\\operatorname{rank}\\left(q\\left(\\tau_{i}^{g}\\right)\\right)$作为排序的标准，而应该是$\\operatorname{rank}\\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)$，或者$\\operatorname{rank}p\\left(\\boldsymbol{\\tau}^{g}\\right)$。\n\n总之，这里关于优先级的解释不是很清楚。\n\n## 流程示意图\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/MEP.png)\n\n## 伪代码\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/pseudo.png)\n\n解析：\n\n- 每一次迭代，都重新构造优先采样分布$q\\left(\\tau^{g}\\right)$\n\n# 实验部分\n\n## 环境\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/env.png)\n\n- 算法：DDPG\n- 5个随机种子进行实验，取最好的结果\n- 19个CPU\n- 训练200个epoch\n\n## 实验结果\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/mean-success.png)\n\n- **以训练的epoch为标准**，使用了MEP的收敛速度更快\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/training-time.png)\n\n可以看到，结合MEP的效果最好，但是我觉得这种对比一点都不严谨，从数据上看，不使用MEP比使用MEP的训练时间更短，且效果也差不多，那么如果训练相同的时间，说不定使用MEP的效果并没有不使用的好。\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/sample-efficiency.png)\n\n固定成功率，在机器人实验中，提升了1.95倍采样效率，即使用更少的样本训练相同的效果。\n\n# 疑问\n\n前文提到原目标函数中的对数项会使训练值函数不稳定，为什么？\n\n为什么构造新的迹分布$q\\left(\\boldsymbol{\\tau}^{g}\\right)$为那样的形式？\n\n","source":"_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning.md","raw":"---\ntitle: Maximum Entropy-Regularized Multi-Goal Reinforcement-Learning\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2019-06-12 20:49:32\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n这篇论文将强化学习的目标与最大熵结合了起来，提出了简称为MEP的经验池机制。许多将熵与强化学习结合的方法都是考虑可选动作分布的熵，该篇论文很新颖的使用的是“迹”的熵。\n\n推荐程度中等偏下：\n\n- 有些地方解释的不是很清楚\n- 熵的结合方式特殊，可以一看\n- 有些公式推导过于复杂，难懂\n- 有些参考文献标注不准，如A3C算法的论文并没有使用熵的概念，却在熵相关的语句进行了标注\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1905.08786.pdf](https://arxiv.org/pdf/1905.08786.pdf)\n\n原作者代码地址：[https://github.com/ruizhaogit/mep.git](https://github.com/ruizhaogit/mep.git)\n\n该文章发于2019年的ICML，与之前写过的《Energy-Based Hindsight Experience Prioritization》为同一作者。\n\n本文主要做了三个贡献：\n\n1. 修改了目标函数，提出了最大熵正则化多目标强化学习(Maximum Entropy-Regularized Multi-Goal RL)的想法\n2. 推导出替代(surrogate)目标函数，是第1步目标函数的一个下界，可以使算法稳定优化\n3. 提出了Maximum Entropy-based Prioritization(MEP)的经验池框架\n\n# 文中精要\n\n文中目标函数的构造主要受Guiasu于1971年提出的加权熵(Weighted Entropy)启发。加权熵表示为：\n$$\n\\mathcal{H}_{p}^{w}=-\\sum_{k=1}^{K} w_{k} p_{k} \\log p_{k}\n$$\n$w_{k}$表示权重。\n\n## 多目标强化学习的符号表示\n\n用$p\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right)$表示一个迹出现的概率：\n\n- $\\boldsymbol{\\tau}=s_{1}, a_{1}, s_{2}, a_{2}, \\ldots, s_{T-1}, a_{T-1}, s_{T}$代表迹\n- $g^{e}$代表一个真实的目标，即不是“事后诸葛亮”假定的目标，$g^{e} \\in \\operatorname{Val}\\left(G^{e}\\right)$，后一项为目标空间，一般情况下，可以视为状态空间$\\mathcal{S}$的子集\n- $\\theta$代表策略参数\n\n展开来写，一个迹在策略$\\theta$被采样到的概率为\n$$\np\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right)=p\\left(s_{1}\\right) \\prod_{t=1}^{T-1} p\\left(a_{t} | s_{t}, g^{e}, \\boldsymbol{\\theta}\\right) p\\left(s_{t+1} | s_{t}, a_{t}\\right)\n$$\n由此定义策略$\\theta$下的期望奖励回报，也就是目标函数，表示为\n$$\n\\begin{aligned} \\eta(\\boldsymbol{\\theta}) &=\\mathbb{E}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\ &=\\sum_{g^{e}} p\\left(g^{e}\\right) \\sum_{\\boldsymbol{\\tau}} p\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\end{aligned}\n$$\n很容易理解，也就是在传统的目标函数前边加了一项关于每个目标求积分的步骤。\n\n如果使用off-policy算法且用经验池机制来提升采样效率，那么目标函数为\n$$\n\\eta^{\\mathcal{R}}(\\boldsymbol{\\theta})=\\sum_{\\boldsymbol{\\tau}, g^{e}} p_{\\mathcal{R}}\\left(\\boldsymbol{\\tau}, g^{e} | \\boldsymbol{\\theta}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right)\n$$\n其中$\\mathcal{R}$表示经验池。注意，$\\eta^{\\mathcal{R}}(\\boldsymbol{\\theta})$将$\\eta(\\boldsymbol{\\theta})$的前两个积分项合在一起写了，所以是联合概率而不是条件概率。\n\n## 最大熵正则化目标函数\n\n将前文提到的$\\eta(\\boldsymbol{\\theta})$与加权熵结合起来，就构造出了本文中新的目标函数，即\n$$\n\\begin{aligned} \\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) &=\\mathcal{H}_{p}^{w}\\left(\\mathcal{T}^{g}\\right) \\\\ &=\\mathbb{E}_{p}\\left[\\color{red} {\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)}} \\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\end{aligned}\n$$\n$\\color{red} {p\\left(\\boldsymbol{\\tau}^{g}\\right)}$代表$\\sum_{g^{e}} p_{\\mathcal{R}}\\left(\\tau^{g}, g^{e} | \\boldsymbol{\\theta} \\right )$，期望右下角的$p$也是$p\\left(\\boldsymbol{\\tau}^{g}\\right)$的意思。\n\n**与传统的结合方式不同的是，这种结合方式并没有将熵作为一个加和的项，而是相乘。**\n\n仔细想一下，如果将这个式子视为加权熵，那么权重系数是累计奖励$\\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right)$，这样做的直观解释是：**对于各种各样的迹，给与累计回报大的以更多权重，使算法直到要朝哪个迹的方向优化。**\n\n反而，如果将前一个对数项视为传统强化学习目标函数的权重系数，那么这样的直观解释是：**迹出现的概率越低，就越新颖，反而要使其权重增加，从而驱使算法向探索的方向优化。**\n\n## 替代目标函数\n\n文中指出，$\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) $中的$\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)}$这一项是无界的，即取值范围为$[0,+\\infty]$，这会导致通用值函数近似的训练不稳定，因此提出了可靠地替代目标函数$\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})$，这个目标函数是原目标函数的一个下界。\n\n> the weight, $\\log \\left(1 / p\\left(\\boldsymbol{\\tau}^{g}\\right)\\right)$, is unbounded, which makes the training of the universal function approximator unstable. \n\n表示为\n$$\n\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})=Z \\cdot \\mathbb{E}_{\\color{red}{q}}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right]\n$$\n注意，期望积分的是迹分布函数$q$，而不是经验池中真实的迹分布函数$p$。\n\n那么，新的迹分布函数$q\\left(\\boldsymbol{\\tau}^{g}\\right)$是怎么得来的？\n\n首先，使用Latent Varibale Model(LVM)对$p\\left(\\boldsymbol{\\tau}^{g}\\right)$的潜在分布进行建模，因为LVM适合于对复杂的分布进行建模。\n\n> We use a Latent Variable Model(LVM) (Murphy, 2012) to model the underlying distribution of $p\\left(\\boldsymbol{\\tau}^{g}\\right)$, since LVM is suitable for modeling complex distributions.\n\n将分布用混合高斯模型MoG表示，\n$$\np\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)=\\frac{1}{Z} \\sum_{i=k}^{K} c_{k} \\mathcal{N}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)\n$$\n其中，\n\n- $K$为隐变量的个数\n- $\\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}$分布为均值与协方差矩阵\n- $c_{k}$为混合系数\n- $Z$为配分函数（归一化系数）\n- $\\phi$为模型参数，包含所有的均值、协方差矩阵和混合系数\n\n文中接着使用$p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)$的补作为经验重放的优先级，即\n$$\n\\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right) \\propto 1-p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)\n$$\n补越大，就代表迹出现的概率越低，那么就对该迹赋予更大的优先级。作者想通过过采样这些迹来增大训练时迹分布的熵。直观的解释就是，概率分布不均匀，那么让概率大的出现次数少，概率小的出现次数多，这样就会使采样的分布朝着均匀分布的方向移动，从而使熵值增加。\n\n文中由此引出了新的迹分布$q\\left(\\boldsymbol{\\tau}^{g}\\right)$，它表示为原始分布与其补的联合分布，\n$$\n\\begin{aligned} q\\left(\\boldsymbol{\\tau}^{g}\\right) & \\propto \\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right) p\\left(\\boldsymbol{\\tau}^{g}\\right) \\\\ & \\propto\\left(1-p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)\\right) p\\left(\\boldsymbol{\\tau}^{g}\\right) \\\\ & \\approx p\\left(\\boldsymbol{\\tau}^{g}\\right)-p\\left(\\boldsymbol{\\tau}^{g}\\right)^{2} \\end{aligned}\n$$\n文中将正比的比例设置为$\\color{blue}{\\frac{1}{Z}}$，即$q\\left(\\boldsymbol{\\tau}^{g}\\right)=\\frac{1}{Z} p\\left(\\boldsymbol{\\tau}^{g}\\right)\\left(1-p\\left(\\boldsymbol{\\tau}^{g}\\right)\\right)$，接下来就可以证明$\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})$为$\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) $的下界：\n$$\n\\begin{aligned} \n\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta}) &=Z \\cdot \\mathbb{E}_{q}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\ &=\\sum_{\\boldsymbol{\\tau}^{g}} Z \\cdot q\\left(\\boldsymbol{\\tau}^{g}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&=\\sum_{\\tau^{g}} \\frac{Z}{Z} p\\left(\\tau^{g}\\right)\\left(1-p\\left(\\tau^{g}\\right)\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&<\\sum_{\\tau^{g}}-p\\left(\\boldsymbol{\\tau}^{g}\\right) \\log p\\left(\\boldsymbol{\\tau}^{g}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&=\\mathbb{E}_{p}\\left[\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)} \\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\\n&=\\mathcal{H}_{p}^{w}\\left(\\mathcal{T}^{g}\\right) \\\\\n&=\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta})\n\\end{aligned}\n$$\n在小于号不等式那一步，使用了函数的性质：$\\log x<x-1$。很容易可以画出$f(x)=\\ln{x}-x+1$在区间[0,1]上的图像：\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/inequality.png)\n\n文中进一步证明了$q$分布的熵比$p$分布的熵更大，因此，由$q$分布来进行采样可以使采样更均匀（= =！那么直接使用均匀分布采样不更好吗？），使学习的目标更多样化。证明过程篇幅过长，详见原论文附录，\n$$\np\\left(\\boldsymbol{\\tau}^{g}\\right), \\text { where } p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right) \\in(0,1) \\text { and } \\sum_{i=1}^{N} p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=1\n$$\n\n$$\nq\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=\\frac{1}{Z} p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\left(1-p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\right), \\text { where } \\sum_{i=1}^{N} q\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=1\n$$\n\n$$\n\\mathcal{H}_{q}\\left(\\mathcal{T}^{g}\\right)-\\mathcal{H}_{p}\\left(\\mathcal{T}^{g}\\right) \\geq 0\n$$\n\n## 基于最大熵的优先级\n\n文中说是基于最大熵的优先经验回放，但是除了使用$q\\left(\\boldsymbol{\\tau}^{g}\\right)$分布之外，在这一部分没有体现出熵的影子，优先级的设置为\n$$\nq\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=\\frac{\\operatorname{rank}\\left(q\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\right)}{\\sum_{n=1}^{N} \\operatorname{rank}\\left(q\\left(\\boldsymbol{\\tau}_{n}^{g}\\right)\\right)}\n$$\n使用排序作为衡量优先级的标准是因为这种方式更具鲁棒性，对异常值不敏感。\n\n之前文中说想要使出现概率低的迹以更高的概率被从经验池中采样到，如果是按照新的$q$分布来定义迹出现的概率，那么到这里是有些说不通的，因为，前文提到$q\\left(\\boldsymbol{\\tau}^{g}\\right) \\approx p\\left(\\boldsymbol{\\tau}^{g}\\right)-p\\left(\\boldsymbol{\\tau}^{g}\\right)^{2} $，那么画出$f(x)=x-x^2$在区间[0，1]上的图像为：\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/x-x^2.png)\n\n由此可见，q值小的地方为p值小与p值大的地方，这就会导致出现概率最大、概率最小的迹被经验池重复的次数多，与前文所讲不同。\n\n而如果考虑以真实的p分布来定义迹出现的概率，那么此处不应该使用$\\operatorname{rank}\\left(q\\left(\\tau_{i}^{g}\\right)\\right)$作为排序的标准，而应该是$\\operatorname{rank}\\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)$，或者$\\operatorname{rank}p\\left(\\boldsymbol{\\tau}^{g}\\right)$。\n\n总之，这里关于优先级的解释不是很清楚。\n\n## 流程示意图\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/MEP.png)\n\n## 伪代码\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/pseudo.png)\n\n解析：\n\n- 每一次迭代，都重新构造优先采样分布$q\\left(\\tau^{g}\\right)$\n\n# 实验部分\n\n## 环境\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/env.png)\n\n- 算法：DDPG\n- 5个随机种子进行实验，取最好的结果\n- 19个CPU\n- 训练200个epoch\n\n## 实验结果\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/mean-success.png)\n\n- **以训练的epoch为标准**，使用了MEP的收敛速度更快\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/training-time.png)\n\n可以看到，结合MEP的效果最好，但是我觉得这种对比一点都不严谨，从数据上看，不使用MEP比使用MEP的训练时间更短，且效果也差不多，那么如果训练相同的时间，说不定使用MEP的效果并没有不使用的好。\n\n![](./maximum-entropy-regularized-multi-goal-reinforcement-learning/sample-efficiency.png)\n\n固定成功率，在机器人实验中，提升了1.95倍采样效率，即使用更少的样本训练相同的效果。\n\n# 疑问\n\n前文提到原目标函数中的对数项会使训练值函数不稳定，为什么？\n\n为什么构造新的迹分布$q\\left(\\boldsymbol{\\tau}^{g}\\right)$为那样的形式？\n\n","slug":"maximum-entropy-regularized-multi-goal-reinforcement-learning","published":1,"updated":"2019-07-07T10:19:13.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut91005020cdr60ebfmk","content":"<p>这篇论文将强化学习的目标与最大熵结合了起来，提出了简称为MEP的经验池机制。许多将熵与强化学习结合的方法都是考虑可选动作分布的熵，该篇论文很新颖的使用的是“迹”的熵。</p>\n<p>推荐程度中等偏下：</p>\n<ul>\n<li>有些地方解释的不是很清楚</li>\n<li>熵的结合方式特殊，可以一看</li>\n<li>有些公式推导过于复杂，难懂</li>\n<li>有些参考文献标注不准，如A3C算法的论文并没有使用熵的概念，却在熵相关的语句进行了标注</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1905.08786.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1905.08786.pdf</a></p>\n<p>原作者代码地址：<a href=\"https://github.com/ruizhaogit/mep.git\" rel=\"external nofollow\" target=\"_blank\">https://github.com/ruizhaogit/mep.git</a></p>\n<p>该文章发于2019年的ICML，与之前写过的《Energy-Based Hindsight Experience Prioritization》为同一作者。</p>\n<p>本文主要做了三个贡献：</p>\n<ol>\n<li>修改了目标函数，提出了最大熵正则化多目标强化学习(Maximum Entropy-Regularized Multi-Goal RL)的想法</li>\n<li>推导出替代(surrogate)目标函数，是第1步目标函数的一个下界，可以使算法稳定优化</li>\n<li>提出了Maximum Entropy-based Prioritization(MEP)的经验池框架</li>\n</ol>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>文中目标函数的构造主要受Guiasu于1971年提出的加权熵(Weighted Entropy)启发。加权熵表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{H}_{p}^{w}=-\\sum_{k=1}^{K} w_{k} p_{k} \\log p_{k}</script><p>$w_{k}$表示权重。</p>\n<h2 id=\"多目标强化学习的符号表示\"><a href=\"#多目标强化学习的符号表示\" class=\"headerlink\" title=\"多目标强化学习的符号表示\"></a>多目标强化学习的符号表示</h2><p>用$p\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right)$表示一个迹出现的概率：</p>\n<ul>\n<li>$\\boldsymbol{\\tau}=s_{1}, a_{1}, s_{2}, a_{2}, \\ldots, s_{T-1}, a_{T-1}, s_{T}$代表迹</li>\n<li>$g^{e}$代表一个真实的目标，即不是“事后诸葛亮”假定的目标，$g^{e} \\in \\operatorname{Val}\\left(G^{e}\\right)$，后一项为目标空间，一般情况下，可以视为状态空间$\\mathcal{S}$的子集</li>\n<li>$\\theta$代表策略参数</li>\n</ul>\n<p>展开来写，一个迹在策略$\\theta$被采样到的概率为</p>\n<script type=\"math/tex; mode=display\">\np\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right)=p\\left(s_{1}\\right) \\prod_{t=1}^{T-1} p\\left(a_{t} | s_{t}, g^{e}, \\boldsymbol{\\theta}\\right) p\\left(s_{t+1} | s_{t}, a_{t}\\right)</script><p>由此定义策略$\\theta$下的期望奖励回报，也就是目标函数，表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \\eta(\\boldsymbol{\\theta}) &=\\mathbb{E}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\ &=\\sum_{g^{e}} p\\left(g^{e}\\right) \\sum_{\\boldsymbol{\\tau}} p\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\end{aligned}</script><p>很容易理解，也就是在传统的目标函数前边加了一项关于每个目标求积分的步骤。</p>\n<p>如果使用off-policy算法且用经验池机制来提升采样效率，那么目标函数为</p>\n<script type=\"math/tex; mode=display\">\n\\eta^{\\mathcal{R}}(\\boldsymbol{\\theta})=\\sum_{\\boldsymbol{\\tau}, g^{e}} p_{\\mathcal{R}}\\left(\\boldsymbol{\\tau}, g^{e} | \\boldsymbol{\\theta}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right)</script><p>其中$\\mathcal{R}$表示经验池。注意，$\\eta^{\\mathcal{R}}(\\boldsymbol{\\theta})$将$\\eta(\\boldsymbol{\\theta})$的前两个积分项合在一起写了，所以是联合概率而不是条件概率。</p>\n<h2 id=\"最大熵正则化目标函数\"><a href=\"#最大熵正则化目标函数\" class=\"headerlink\" title=\"最大熵正则化目标函数\"></a>最大熵正则化目标函数</h2><p>将前文提到的$\\eta(\\boldsymbol{\\theta})$与加权熵结合起来，就构造出了本文中新的目标函数，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) &=\\mathcal{H}_{p}^{w}\\left(\\mathcal{T}^{g}\\right) \\\\ &=\\mathbb{E}_{p}\\left[\\color{red} {\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)}} \\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\end{aligned}</script><p>$\\color{red} {p\\left(\\boldsymbol{\\tau}^{g}\\right)}$代表$\\sum_{g^{e}} p_{\\mathcal{R}}\\left(\\tau^{g}, g^{e} | \\boldsymbol{\\theta} \\right )$，期望右下角的$p$也是$p\\left(\\boldsymbol{\\tau}^{g}\\right)$的意思。</p>\n<p><strong>与传统的结合方式不同的是，这种结合方式并没有将熵作为一个加和的项，而是相乘。</strong></p>\n<p>仔细想一下，如果将这个式子视为加权熵，那么权重系数是累计奖励$\\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right)$，这样做的直观解释是：<strong>对于各种各样的迹，给与累计回报大的以更多权重，使算法直到要朝哪个迹的方向优化。</strong></p>\n<p>反而，如果将前一个对数项视为传统强化学习目标函数的权重系数，那么这样的直观解释是：<strong>迹出现的概率越低，就越新颖，反而要使其权重增加，从而驱使算法向探索的方向优化。</strong></p>\n<h2 id=\"替代目标函数\"><a href=\"#替代目标函数\" class=\"headerlink\" title=\"替代目标函数\"></a>替代目标函数</h2><p>文中指出，$\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) $中的$\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)}$这一项是无界的，即取值范围为$[0,+\\infty]$，这会导致通用值函数近似的训练不稳定，因此提出了可靠地替代目标函数$\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})$，这个目标函数是原目标函数的一个下界。</p>\n<blockquote>\n<p>the weight, $\\log \\left(1 / p\\left(\\boldsymbol{\\tau}^{g}\\right)\\right)$, is unbounded, which makes the training of the universal function approximator unstable. </p>\n</blockquote>\n<p>表示为</p>\n<script type=\"math/tex; mode=display\">\n\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})=Z \\cdot \\mathbb{E}_{\\color{red}{q}}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right]</script><p>注意，期望积分的是迹分布函数$q$，而不是经验池中真实的迹分布函数$p$。</p>\n<p>那么，新的迹分布函数$q\\left(\\boldsymbol{\\tau}^{g}\\right)$是怎么得来的？</p>\n<p>首先，使用Latent Varibale Model(LVM)对$p\\left(\\boldsymbol{\\tau}^{g}\\right)$的潜在分布进行建模，因为LVM适合于对复杂的分布进行建模。</p>\n<blockquote>\n<p>We use a Latent Variable Model(LVM) (Murphy, 2012) to model the underlying distribution of $p\\left(\\boldsymbol{\\tau}^{g}\\right)$, since LVM is suitable for modeling complex distributions.</p>\n</blockquote>\n<p>将分布用混合高斯模型MoG表示，</p>\n<script type=\"math/tex; mode=display\">\np\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)=\\frac{1}{Z} \\sum_{i=k}^{K} c_{k} \\mathcal{N}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)</script><p>其中，</p>\n<ul>\n<li>$K$为隐变量的个数</li>\n<li>$\\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}$分布为均值与协方差矩阵</li>\n<li>$c_{k}$为混合系数</li>\n<li>$Z$为配分函数（归一化系数）</li>\n<li>$\\phi$为模型参数，包含所有的均值、协方差矩阵和混合系数</li>\n</ul>\n<p>文中接着使用$p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)$的补作为经验重放的优先级，即</p>\n<script type=\"math/tex; mode=display\">\n\\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right) \\propto 1-p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)</script><p>补越大，就代表迹出现的概率越低，那么就对该迹赋予更大的优先级。作者想通过过采样这些迹来增大训练时迹分布的熵。直观的解释就是，概率分布不均匀，那么让概率大的出现次数少，概率小的出现次数多，这样就会使采样的分布朝着均匀分布的方向移动，从而使熵值增加。</p>\n<p>文中由此引出了新的迹分布$q\\left(\\boldsymbol{\\tau}^{g}\\right)$，它表示为原始分布与其补的联合分布，</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} q\\left(\\boldsymbol{\\tau}^{g}\\right) & \\propto \\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right) p\\left(\\boldsymbol{\\tau}^{g}\\right) \\\\ & \\propto\\left(1-p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)\\right) p\\left(\\boldsymbol{\\tau}^{g}\\right) \\\\ & \\approx p\\left(\\boldsymbol{\\tau}^{g}\\right)-p\\left(\\boldsymbol{\\tau}^{g}\\right)^{2} \\end{aligned}</script><p>文中将正比的比例设置为$\\color{blue}{\\frac{1}{Z}}$，即$q\\left(\\boldsymbol{\\tau}^{g}\\right)=\\frac{1}{Z} p\\left(\\boldsymbol{\\tau}^{g}\\right)\\left(1-p\\left(\\boldsymbol{\\tau}^{g}\\right)\\right)$，接下来就可以证明$\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})$为$\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) $的下界：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \n\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta}) &=Z \\cdot \\mathbb{E}_{q}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\ &=\\sum_{\\boldsymbol{\\tau}^{g}} Z \\cdot q\\left(\\boldsymbol{\\tau}^{g}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&=\\sum_{\\tau^{g}} \\frac{Z}{Z} p\\left(\\tau^{g}\\right)\\left(1-p\\left(\\tau^{g}\\right)\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&<\\sum_{\\tau^{g}}-p\\left(\\boldsymbol{\\tau}^{g}\\right) \\log p\\left(\\boldsymbol{\\tau}^{g}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&=\\mathbb{E}_{p}\\left[\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)} \\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\\n&=\\mathcal{H}_{p}^{w}\\left(\\mathcal{T}^{g}\\right) \\\\\n&=\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta})\n\\end{aligned}</script><p>在小于号不等式那一步，使用了函数的性质：$\\log x&lt;x-1$。很容易可以画出$f(x)=\\ln{x}-x+1$在区间[0,1]上的图像：</p>\n<p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/inequality.png\" alt=\"\"></p>\n<p>文中进一步证明了$q$分布的熵比$p$分布的熵更大，因此，由$q$分布来进行采样可以使采样更均匀（= =！那么直接使用均匀分布采样不更好吗？），使学习的目标更多样化。证明过程篇幅过长，详见原论文附录，</p>\n<script type=\"math/tex; mode=display\">\np\\left(\\boldsymbol{\\tau}^{g}\\right), \\text { where } p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right) \\in(0,1) \\text { and } \\sum_{i=1}^{N} p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=1</script><script type=\"math/tex; mode=display\">\nq\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=\\frac{1}{Z} p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\left(1-p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\right), \\text { where } \\sum_{i=1}^{N} q\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=1</script><script type=\"math/tex; mode=display\">\n\\mathcal{H}_{q}\\left(\\mathcal{T}^{g}\\right)-\\mathcal{H}_{p}\\left(\\mathcal{T}^{g}\\right) \\geq 0</script><h2 id=\"基于最大熵的优先级\"><a href=\"#基于最大熵的优先级\" class=\"headerlink\" title=\"基于最大熵的优先级\"></a>基于最大熵的优先级</h2><p>文中说是基于最大熵的优先经验回放，但是除了使用$q\\left(\\boldsymbol{\\tau}^{g}\\right)$分布之外，在这一部分没有体现出熵的影子，优先级的设置为</p>\n<script type=\"math/tex; mode=display\">\nq\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=\\frac{\\operatorname{rank}\\left(q\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\right)}{\\sum_{n=1}^{N} \\operatorname{rank}\\left(q\\left(\\boldsymbol{\\tau}_{n}^{g}\\right)\\right)}</script><p>使用排序作为衡量优先级的标准是因为这种方式更具鲁棒性，对异常值不敏感。</p>\n<p>之前文中说想要使出现概率低的迹以更高的概率被从经验池中采样到，如果是按照新的$q$分布来定义迹出现的概率，那么到这里是有些说不通的，因为，前文提到$q\\left(\\boldsymbol{\\tau}^{g}\\right) \\approx p\\left(\\boldsymbol{\\tau}^{g}\\right)-p\\left(\\boldsymbol{\\tau}^{g}\\right)^{2} $，那么画出$f(x)=x-x^2$在区间[0，1]上的图像为：</p>\n<p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/x-x^2.png\" alt=\"\"></p>\n<p>由此可见，q值小的地方为p值小与p值大的地方，这就会导致出现概率最大、概率最小的迹被经验池重复的次数多，与前文所讲不同。</p>\n<p>而如果考虑以真实的p分布来定义迹出现的概率，那么此处不应该使用$\\operatorname{rank}\\left(q\\left(\\tau_{i}^{g}\\right)\\right)$作为排序的标准，而应该是$\\operatorname{rank}\\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)$，或者$\\operatorname{rank}p\\left(\\boldsymbol{\\tau}^{g}\\right)$。</p>\n<p>总之，这里关于优先级的解释不是很清楚。</p>\n<h2 id=\"流程示意图\"><a href=\"#流程示意图\" class=\"headerlink\" title=\"流程示意图\"></a>流程示意图</h2><p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/MEP.png\" alt=\"\"></p>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>每一次迭代，都重新构造优先采样分布$q\\left(\\tau^{g}\\right)$</li>\n</ul>\n<h1 id=\"实验部分\"><a href=\"#实验部分\" class=\"headerlink\" title=\"实验部分\"></a>实验部分</h1><h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/env.png\" alt=\"\"></p>\n<ul>\n<li>算法：DDPG</li>\n<li>5个随机种子进行实验，取最好的结果</li>\n<li>19个CPU</li>\n<li>训练200个epoch</li>\n</ul>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/mean-success.png\" alt=\"\"></p>\n<ul>\n<li><strong>以训练的epoch为标准</strong>，使用了MEP的收敛速度更快</li>\n</ul>\n<p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/training-time.png\" alt=\"\"></p>\n<p>可以看到，结合MEP的效果最好，但是我觉得这种对比一点都不严谨，从数据上看，不使用MEP比使用MEP的训练时间更短，且效果也差不多，那么如果训练相同的时间，说不定使用MEP的效果并没有不使用的好。</p>\n<p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/sample-efficiency.png\" alt=\"\"></p>\n<p>固定成功率，在机器人实验中，提升了1.95倍采样效率，即使用更少的样本训练相同的效果。</p>\n<h1 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h1><p>前文提到原目标函数中的对数项会使训练值函数不稳定，为什么？</p>\n<p>为什么构造新的迹分布$q\\left(\\boldsymbol{\\tau}^{g}\\right)$为那样的形式？</p>\n","site":{"data":{}},"excerpt":"<p>这篇论文将强化学习的目标与最大熵结合了起来，提出了简称为MEP的经验池机制。许多将熵与强化学习结合的方法都是考虑可选动作分布的熵，该篇论文很新颖的使用的是“迹”的熵。</p>\n<p>推荐程度中等偏下：</p>\n<ul>\n<li>有些地方解释的不是很清楚</li>\n<li>熵的结合方式特殊，可以一看</li>\n<li>有些公式推导过于复杂，难懂</li>\n<li>有些参考文献标注不准，如A3C算法的论文并没有使用熵的概念，却在熵相关的语句进行了标注</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1905.08786.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1905.08786.pdf</a></p>\n<p>原作者代码地址：<a href=\"https://github.com/ruizhaogit/mep.git\" rel=\"external nofollow\" target=\"_blank\">https://github.com/ruizhaogit/mep.git</a></p>\n<p>该文章发于2019年的ICML，与之前写过的《Energy-Based Hindsight Experience Prioritization》为同一作者。</p>\n<p>本文主要做了三个贡献：</p>\n<ol>\n<li>修改了目标函数，提出了最大熵正则化多目标强化学习(Maximum Entropy-Regularized Multi-Goal RL)的想法</li>\n<li>推导出替代(surrogate)目标函数，是第1步目标函数的一个下界，可以使算法稳定优化</li>\n<li>提出了Maximum Entropy-based Prioritization(MEP)的经验池框架</li>\n</ol>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>文中目标函数的构造主要受Guiasu于1971年提出的加权熵(Weighted Entropy)启发。加权熵表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{H}_{p}^{w}=-\\sum_{k=1}^{K} w_{k} p_{k} \\log p_{k}</script><p>$w_{k}$表示权重。</p>\n<h2 id=\"多目标强化学习的符号表示\"><a href=\"#多目标强化学习的符号表示\" class=\"headerlink\" title=\"多目标强化学习的符号表示\"></a>多目标强化学习的符号表示</h2><p>用$p\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right)$表示一个迹出现的概率：</p>\n<ul>\n<li>$\\boldsymbol{\\tau}=s_{1}, a_{1}, s_{2}, a_{2}, \\ldots, s_{T-1}, a_{T-1}, s_{T}$代表迹</li>\n<li>$g^{e}$代表一个真实的目标，即不是“事后诸葛亮”假定的目标，$g^{e} \\in \\operatorname{Val}\\left(G^{e}\\right)$，后一项为目标空间，一般情况下，可以视为状态空间$\\mathcal{S}$的子集</li>\n<li>$\\theta$代表策略参数</li>\n</ul>\n<p>展开来写，一个迹在策略$\\theta$被采样到的概率为</p>\n<script type=\"math/tex; mode=display\">\np\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right)=p\\left(s_{1}\\right) \\prod_{t=1}^{T-1} p\\left(a_{t} | s_{t}, g^{e}, \\boldsymbol{\\theta}\\right) p\\left(s_{t+1} | s_{t}, a_{t}\\right)</script><p>由此定义策略$\\theta$下的期望奖励回报，也就是目标函数，表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \\eta(\\boldsymbol{\\theta}) &=\\mathbb{E}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\ &=\\sum_{g^{e}} p\\left(g^{e}\\right) \\sum_{\\boldsymbol{\\tau}} p\\left(\\boldsymbol{\\tau} | g^{e}, \\boldsymbol{\\theta}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\end{aligned}</script><p>很容易理解，也就是在传统的目标函数前边加了一项关于每个目标求积分的步骤。</p>\n<p>如果使用off-policy算法且用经验池机制来提升采样效率，那么目标函数为</p>\n<script type=\"math/tex; mode=display\">\n\\eta^{\\mathcal{R}}(\\boldsymbol{\\theta})=\\sum_{\\boldsymbol{\\tau}, g^{e}} p_{\\mathcal{R}}\\left(\\boldsymbol{\\tau}, g^{e} | \\boldsymbol{\\theta}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right)</script><p>其中$\\mathcal{R}$表示经验池。注意，$\\eta^{\\mathcal{R}}(\\boldsymbol{\\theta})$将$\\eta(\\boldsymbol{\\theta})$的前两个积分项合在一起写了，所以是联合概率而不是条件概率。</p>\n<h2 id=\"最大熵正则化目标函数\"><a href=\"#最大熵正则化目标函数\" class=\"headerlink\" title=\"最大熵正则化目标函数\"></a>最大熵正则化目标函数</h2><p>将前文提到的$\\eta(\\boldsymbol{\\theta})$与加权熵结合起来，就构造出了本文中新的目标函数，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) &=\\mathcal{H}_{p}^{w}\\left(\\mathcal{T}^{g}\\right) \\\\ &=\\mathbb{E}_{p}\\left[\\color{red} {\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)}} \\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\end{aligned}</script><p>$\\color{red} {p\\left(\\boldsymbol{\\tau}^{g}\\right)}$代表$\\sum_{g^{e}} p_{\\mathcal{R}}\\left(\\tau^{g}, g^{e} | \\boldsymbol{\\theta} \\right )$，期望右下角的$p$也是$p\\left(\\boldsymbol{\\tau}^{g}\\right)$的意思。</p>\n<p><strong>与传统的结合方式不同的是，这种结合方式并没有将熵作为一个加和的项，而是相乘。</strong></p>\n<p>仔细想一下，如果将这个式子视为加权熵，那么权重系数是累计奖励$\\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right)$，这样做的直观解释是：<strong>对于各种各样的迹，给与累计回报大的以更多权重，使算法直到要朝哪个迹的方向优化。</strong></p>\n<p>反而，如果将前一个对数项视为传统强化学习目标函数的权重系数，那么这样的直观解释是：<strong>迹出现的概率越低，就越新颖，反而要使其权重增加，从而驱使算法向探索的方向优化。</strong></p>\n<h2 id=\"替代目标函数\"><a href=\"#替代目标函数\" class=\"headerlink\" title=\"替代目标函数\"></a>替代目标函数</h2><p>文中指出，$\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) $中的$\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)}$这一项是无界的，即取值范围为$[0,+\\infty]$，这会导致通用值函数近似的训练不稳定，因此提出了可靠地替代目标函数$\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})$，这个目标函数是原目标函数的一个下界。</p>\n<blockquote>\n<p>the weight, $\\log \\left(1 / p\\left(\\boldsymbol{\\tau}^{g}\\right)\\right)$, is unbounded, which makes the training of the universal function approximator unstable. </p>\n</blockquote>\n<p>表示为</p>\n<script type=\"math/tex; mode=display\">\n\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})=Z \\cdot \\mathbb{E}_{\\color{red}{q}}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right]</script><p>注意，期望积分的是迹分布函数$q$，而不是经验池中真实的迹分布函数$p$。</p>\n<p>那么，新的迹分布函数$q\\left(\\boldsymbol{\\tau}^{g}\\right)$是怎么得来的？</p>\n<p>首先，使用Latent Varibale Model(LVM)对$p\\left(\\boldsymbol{\\tau}^{g}\\right)$的潜在分布进行建模，因为LVM适合于对复杂的分布进行建模。</p>\n<blockquote>\n<p>We use a Latent Variable Model(LVM) (Murphy, 2012) to model the underlying distribution of $p\\left(\\boldsymbol{\\tau}^{g}\\right)$, since LVM is suitable for modeling complex distributions.</p>\n</blockquote>\n<p>将分布用混合高斯模型MoG表示，</p>\n<script type=\"math/tex; mode=display\">\np\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)=\\frac{1}{Z} \\sum_{i=k}^{K} c_{k} \\mathcal{N}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)</script><p>其中，</p>\n<ul>\n<li>$K$为隐变量的个数</li>\n<li>$\\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}$分布为均值与协方差矩阵</li>\n<li>$c_{k}$为混合系数</li>\n<li>$Z$为配分函数（归一化系数）</li>\n<li>$\\phi$为模型参数，包含所有的均值、协方差矩阵和混合系数</li>\n</ul>\n<p>文中接着使用$p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)$的补作为经验重放的优先级，即</p>\n<script type=\"math/tex; mode=display\">\n\\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right) \\propto 1-p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)</script><p>补越大，就代表迹出现的概率越低，那么就对该迹赋予更大的优先级。作者想通过过采样这些迹来增大训练时迹分布的熵。直观的解释就是，概率分布不均匀，那么让概率大的出现次数少，概率小的出现次数多，这样就会使采样的分布朝着均匀分布的方向移动，从而使熵值增加。</p>\n<p>文中由此引出了新的迹分布$q\\left(\\boldsymbol{\\tau}^{g}\\right)$，它表示为原始分布与其补的联合分布，</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} q\\left(\\boldsymbol{\\tau}^{g}\\right) & \\propto \\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right) p\\left(\\boldsymbol{\\tau}^{g}\\right) \\\\ & \\propto\\left(1-p\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)\\right) p\\left(\\boldsymbol{\\tau}^{g}\\right) \\\\ & \\approx p\\left(\\boldsymbol{\\tau}^{g}\\right)-p\\left(\\boldsymbol{\\tau}^{g}\\right)^{2} \\end{aligned}</script><p>文中将正比的比例设置为$\\color{blue}{\\frac{1}{Z}}$，即$q\\left(\\boldsymbol{\\tau}^{g}\\right)=\\frac{1}{Z} p\\left(\\boldsymbol{\\tau}^{g}\\right)\\left(1-p\\left(\\boldsymbol{\\tau}^{g}\\right)\\right)$，接下来就可以证明$\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta})$为$\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta}) $的下界：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \n\\eta^{\\mathcal{L}}(\\boldsymbol{\\theta}) &=Z \\cdot \\mathbb{E}_{q}\\left[\\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\ &=\\sum_{\\boldsymbol{\\tau}^{g}} Z \\cdot q\\left(\\boldsymbol{\\tau}^{g}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&=\\sum_{\\tau^{g}} \\frac{Z}{Z} p\\left(\\tau^{g}\\right)\\left(1-p\\left(\\tau^{g}\\right)\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&<\\sum_{\\tau^{g}}-p\\left(\\boldsymbol{\\tau}^{g}\\right) \\log p\\left(\\boldsymbol{\\tau}^{g}\\right) \\sum_{t=1}^{T} r\\left(s_{t}, g^{e}\\right) \\\\\n&=\\mathbb{E}_{p}\\left[\\log \\frac{1}{p\\left(\\boldsymbol{\\tau}^{g}\\right)} \\sum_{t=1}^{T} r\\left(S_{t}, G^{e}\\right) | \\boldsymbol{\\theta}\\right] \\\\\n&=\\mathcal{H}_{p}^{w}\\left(\\mathcal{T}^{g}\\right) \\\\\n&=\\eta^{\\mathcal{H}}(\\boldsymbol{\\theta})\n\\end{aligned}</script><p>在小于号不等式那一步，使用了函数的性质：$\\log x&lt;x-1$。很容易可以画出$f(x)=\\ln{x}-x+1$在区间[0,1]上的图像：</p>\n<p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/inequality.png\" alt=\"\"></p>\n<p>文中进一步证明了$q$分布的熵比$p$分布的熵更大，因此，由$q$分布来进行采样可以使采样更均匀（= =！那么直接使用均匀分布采样不更好吗？），使学习的目标更多样化。证明过程篇幅过长，详见原论文附录，</p>\n<script type=\"math/tex; mode=display\">\np\\left(\\boldsymbol{\\tau}^{g}\\right), \\text { where } p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right) \\in(0,1) \\text { and } \\sum_{i=1}^{N} p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=1</script><script type=\"math/tex; mode=display\">\nq\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=\\frac{1}{Z} p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\left(1-p\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\right), \\text { where } \\sum_{i=1}^{N} q\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=1</script><script type=\"math/tex; mode=display\">\n\\mathcal{H}_{q}\\left(\\mathcal{T}^{g}\\right)-\\mathcal{H}_{p}\\left(\\mathcal{T}^{g}\\right) \\geq 0</script><h2 id=\"基于最大熵的优先级\"><a href=\"#基于最大熵的优先级\" class=\"headerlink\" title=\"基于最大熵的优先级\"></a>基于最大熵的优先级</h2><p>文中说是基于最大熵的优先经验回放，但是除了使用$q\\left(\\boldsymbol{\\tau}^{g}\\right)$分布之外，在这一部分没有体现出熵的影子，优先级的设置为</p>\n<script type=\"math/tex; mode=display\">\nq\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)=\\frac{\\operatorname{rank}\\left(q\\left(\\boldsymbol{\\tau}_{i}^{g}\\right)\\right)}{\\sum_{n=1}^{N} \\operatorname{rank}\\left(q\\left(\\boldsymbol{\\tau}_{n}^{g}\\right)\\right)}</script><p>使用排序作为衡量优先级的标准是因为这种方式更具鲁棒性，对异常值不敏感。</p>\n<p>之前文中说想要使出现概率低的迹以更高的概率被从经验池中采样到，如果是按照新的$q$分布来定义迹出现的概率，那么到这里是有些说不通的，因为，前文提到$q\\left(\\boldsymbol{\\tau}^{g}\\right) \\approx p\\left(\\boldsymbol{\\tau}^{g}\\right)-p\\left(\\boldsymbol{\\tau}^{g}\\right)^{2} $，那么画出$f(x)=x-x^2$在区间[0，1]上的图像为：</p>\n<p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/x-x^2.png\" alt=\"\"></p>\n<p>由此可见，q值小的地方为p值小与p值大的地方，这就会导致出现概率最大、概率最小的迹被经验池重复的次数多，与前文所讲不同。</p>\n<p>而如果考虑以真实的p分布来定义迹出现的概率，那么此处不应该使用$\\operatorname{rank}\\left(q\\left(\\tau_{i}^{g}\\right)\\right)$作为排序的标准，而应该是$\\operatorname{rank}\\overline{p}\\left(\\boldsymbol{\\tau}^{g} | \\boldsymbol{\\phi}\\right)$，或者$\\operatorname{rank}p\\left(\\boldsymbol{\\tau}^{g}\\right)$。</p>\n<p>总之，这里关于优先级的解释不是很清楚。</p>\n<h2 id=\"流程示意图\"><a href=\"#流程示意图\" class=\"headerlink\" title=\"流程示意图\"></a>流程示意图</h2><p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/MEP.png\" alt=\"\"></p>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>每一次迭代，都重新构造优先采样分布$q\\left(\\tau^{g}\\right)$</li>\n</ul>\n<h1 id=\"实验部分\"><a href=\"#实验部分\" class=\"headerlink\" title=\"实验部分\"></a>实验部分</h1><h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/env.png\" alt=\"\"></p>\n<ul>\n<li>算法：DDPG</li>\n<li>5个随机种子进行实验，取最好的结果</li>\n<li>19个CPU</li>\n<li>训练200个epoch</li>\n</ul>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/mean-success.png\" alt=\"\"></p>\n<ul>\n<li><strong>以训练的epoch为标准</strong>，使用了MEP的收敛速度更快</li>\n</ul>\n<p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/training-time.png\" alt=\"\"></p>\n<p>可以看到，结合MEP的效果最好，但是我觉得这种对比一点都不严谨，从数据上看，不使用MEP比使用MEP的训练时间更短，且效果也差不多，那么如果训练相同的时间，说不定使用MEP的效果并没有不使用的好。</p>\n<p><img src=\"./maximum-entropy-regularized-multi-goal-reinforcement-learning/sample-efficiency.png\" alt=\"\"></p>\n<p>固定成功率，在机器人实验中，提升了1.95倍采样效率，即使用更少的样本训练相同的效果。</p>\n<h1 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h1><p>前文提到原目标函数中的对数项会使训练值函数不稳定，为什么？</p>\n<p>为什么构造新的迹分布$q\\left(\\boldsymbol{\\tau}^{g}\\right)$为那样的形式？</p>"},{"title":"Tensorflow2.0中的高斯分布及其概率","copyright":true,"mathjax":true,"top":1,"date":"2020-04-08T02:50:12.000Z","keywords":null,"description":null,"_content":"\n此篇博文用于记录和描述一些高斯分布的基本特性以及在tensorflow2.0中的不同之处。\n\n<!--more-->\n\n# 对角协方差高斯分布\n\n对角协方差矩阵： Diagonal Covariance Matrix\n\n多元高斯分布：multivariate Gaussian distribution\n\n拥有对角协方差的多元高斯分布，其变量的概率密度等于各个变量的一元高斯概率密度之积。\n\n假设对角协方差矩阵是如下形式：\n$$\n\\Sigma =\n\\left(\n  \\begin{array}{cccc}\n    \\sigma_{1} & 0 & \\cdots & 0 \\\\\n    0 & \\sigma_{2} & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & \\cdots & \\sigma_{k}\n  \\end{array}\n\\right)\n$$\n那么，多元高斯函数的概率密度函数被定义为：\n$$\nf_{x}\\left(x_{1}, \\ldots, x_{k}\\right)=\\frac{\\exp \\left(-\\frac{1}{2}(\\vec{x}-\\vec{\\mu})^{T} \\Sigma^{-1}(\\vec{x}-\\vec{\\mu})\\right)}{\\sqrt{|2 \\pi \\Sigma|}}\n$$\n变量替换：\n$$\n\\vec{y}=\\vec{x}-\\vec{\\mu}\n$$\n对角协方差的逆可以表示为：\n$$\n\\begin{aligned}\n\\Sigma^{-1} &=\\left(\\begin{array}{cccc}\n\\sigma_{1}^{2} & 0 & \\cdots & 0 \\\\\n0 & \\sigma_{2}^{2} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & \\sigma_{k}^{2}\n\\end{array}\\right)^{-1} \\\\\n&=\\left(\\begin{array}{cccc}\n\\frac{1}{\\sigma_{1}^{2}} & 0 & \\cdots & 0 \\\\\n0 & \\frac{1}{\\sigma_{2}^{2}} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & \\frac{1}{\\sigma_{k}^{2}}\n\\end{array}\\right)\n\\end{aligned}\n$$\n代入上面式子，可以得到：\n$$\n\\begin{align}\n\tf_x(x_1, \\ldots, x_k) = \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{(2\\pi)^{k}|\\Sigma|}}\n\\end{align}\n$$\n其中，分母的变化是由于矩阵秩的性质。对角协方差矩阵的秩可以展开写成：\n$$\n\\begin{align}\n\t|\\Sigma| &=\n\t\t\\begin{vmatrix}\n\t\t\t\\sigma_1^2 & 0 & \\cdots & 0 \\\\\n\t\t\t0 & \\sigma_2^2 & \\cdots & 0 \\\\\n\t\t\t\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\t\t\t0 & 0 & \\cdots & \\sigma_k^2 \\\\\n\t\t\\end{vmatrix} \\\\\n\t\t&= \\sigma_1^2 \\cdot \\sigma_2^2 \\cdots \\sigma_k^2\n\t\t\\end{align} %]]>\n$$\n最后，代入原概率密度方程并化简：\n$$\n\\begin{align}\n\tf_x(x_1, \\ldots, x_k) &= \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{(2\\pi)^{k}\\sigma_1^2 \\cdot \\sigma_2^2 \\cdots \\sigma_k^2}} \\\\\n\t&= \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{2\\pi\\sigma_1^2 \\cdot 2\\pi\\sigma_2^2 \\cdots 2\\pi\\sigma_k^2}} \\\\\n\t&= \\frac{\\exp\\Big(-\\frac{y_1^2}{2\\sigma_1^2} \\Big)}{\\sqrt{2\\pi\\sigma_1^2}}  \\cdot \\frac{\\exp\\Big(-\\frac{y_2^2}{2\\sigma_2^2} \\Big)}{\\sqrt{2\\pi\\sigma_2^2}}  \\cdots \\frac{\\exp\\Big(-\\frac{y_k^2}{2\\sigma_k^2} \\Big)}{\\sqrt{2\\pi\\sigma_k^2}} \\\\\n\t&= \\frac{\\exp\\Big(-\\frac{(x_1-\\mu_1)^2}{2\\sigma_1^2} \\Big)}{\\sqrt{2\\pi\\sigma_1^2}}  \\cdot \\frac{\\exp\\Big(-\\frac{(x_2-\\mu_2)^2}{2\\sigma_2^2} \\Big)}{\\sqrt{2\\pi\\sigma_2^2}}  \\cdots \\frac{\\exp\\Big(-\\frac{(x_k-\\mu_k)^2}{2\\sigma_k^2} \\Big)}{\\sqrt{2\\pi\\sigma_k^2}} \\\\\n\t&= f_1(x_1) \\cdot f_2(x_2) \\cdots f_k(x_k)\n\\end{align} %]]>\n$$\n这样就得到了，对角协方差矩阵的多元高斯分布，其变量的联合概率密度等于各个变量独立高斯分布概率密度的连积。\n\n# TensorFlow 2.0 Gaussian Functions\n\n```python\nimport numpy as np\nimport tensorflow as tf\nimport tensorflow_probability as tfp\n\ndt = tf.float32\n\nmu = tf.constant([1., 2.], dtype=dt)\t\t# 均值\nsigma = tf.constant([1., 2.], dtype=dt)\t# 标准差\ncovariance = tf.constant([\t\t\t\t\t\t\t# 协方差矩阵\n  [1., 0.],\n  [0., 4.]\n])\nx = tf.constant([0.92, 2.03], dtype=dt)\t# 模拟一个样本\n```\n\n测试一下TF中几个不同高斯分布的1. 采样形式；2. 样本概率的表示。定义一个函数：\n\n```python\ndef test_gaussian(dist, y):\n  '''\n  param dist: 传入的高斯分布\n  param y: 传入的样本\n  '''\n  x = dist.sample()\n  print(x)\t# 输出分布的采样\n  p = dist.prob(x)\n  print(p)\t# 输出采样样本的概率\n  p_y = dist.prob(y)\n  print('prob: ', p_y)\t# 输出样本的概率\n  print('sum_prob: ', tf.reduce_sum(p_y))\t# 输出样本的概率之和\n  print('prod_prob: ', tf.reduce_prod(p_y))\t# 输出样本的概率之积\n  log_p_y = dist.log_prob(y)\n  print('log_prob: ', log_p_y)\t# 输出样本的概率对数\n  print('sum_log_prob: ', tf.reduce_sum(log_p_y))\t# 输出样本的概率对数之和\n  print('prod_log_prob: ', tf.reduce_prod(log_p_y))\t# 输出样本的概率对数之积\n```\n\n\n\n## Normal\n\n`test_gaussian(tfp.distributions.Normal(loc=mu, scale=sigma), x)`，其参数中的scale为标准差。\n\n输出为：\n\n```\ntf.Tensor([-0.24812889  2.8150756 ], shape=(2,), dtype=float32)\ntf.Tensor([0.18307646 0.1835755 ], shape=(2,), dtype=float32)\nprob:  tf.Tensor([0.3976677  0.19944869], shape=(2,), dtype=float32)\nsum_prob:  tf.Tensor(0.5971164, shape=(), dtype=float32)\nprod_prob:  tf.Tensor(0.07931431, shape=(), dtype=float32)\nlog_prob:  tf.Tensor([-0.9221385 -1.6121982], shape=(2,), dtype=float32)\nsum_log_prob:  tf.Tensor(-2.5343368, shape=(), dtype=float32)\nprod_log_prob:  tf.Tensor(1.4866701, shape=(), dtype=float32)\n```\n\n这个分布为各个变量的独立高斯分布，有$n$个变量，则采样出$n$个值，其概率为每个变量各自的概率，如$n=2$，上面结果给出概率为：prob:  tf.Tensor([0.3976677  0.19944869], shape=(2,), dtype=float32)。\n\n## MultivariateNormalDiag\n\n`test_gaussian(tfp.distributions.MultivariateNormalDiag(loc=mu, scale_diag=sigma), x)`，其参数中的scale_diag为协方差矩阵对角线的平方根，也就是每个变量对应的标准差。\n\n输出为：\n\n```\ntf.Tensor([2.550062  1.5906484], shape=(2,), dtype=float32)\ntf.Tensor(0.02343988, shape=(), dtype=float32)\nprob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nsum_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nprod_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nlog_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\nsum_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\nprod_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\n```\n\n这个分布于各变量独立的高斯分布相同，其协方差矩阵为对角矩阵，与Normal不同的是，其概率为每个变量各自概率之积，即联合概率。其概率对数为每个变量各自概率对数之和。\n\nprob = Normal: prod_prob\n\nlog_prob = Normal: sum_log_prob\n\n## MultivariateNormalFullCovariance\n\n`test_gaussian(tfp.distributions.MultivariateNormalFullCovariance(loc=mu, covariance_matrix=covariance), x)`，其参数中的covariance_matrix为协方差矩阵，因此如果使用`MultivariateNormalDiag`并指定对角线参数为`scale_diag=[1,2]`，那么实现相同的分布使用`MultivariateNormalFullCovariance`应指定协方差矩阵参数为`covariance_matrix=[[1,0],[0,2]]`。\n\n输出为：\n\n```\ntf.Tensor([3.1393874 1.2191284], shape=(2,), dtype=float32)\ntf.Tensor(0.007478423, shape=(), dtype=float32)\nprob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nsum_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nprod_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nlog_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\nsum_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\nprod_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\n```\n\n这个分布为多个变量的联合高斯分布，如果设置协方差矩阵为对角矩阵，且为`MultivariateNormalDiag`对角参数的平方，则两个分布一致。\n\n## TruncatedNormal\n\n```python\ntfp.distributions.TruncatedNormal(\n    loc, scale, low, high, validate_args=False, allow_nan_stats=True,\n    name='TruncatedNormal'\n)\n```\n\n这个分布相比`Normal`多了两个参数：low和high，如果样本＞high或者＜low，则其概率为0，对数概率为-inf。使用这个分布采样的样本也在low和high之间。\n\n```python\ndist = tfp.distributions.TruncatedNormal(loc=[0., 1.], scale=1.0, low=[-1., 0.], high=[1., 1.])\nprint(dist.prob([1.1, -0.1]))\nprint(dist.log_prob([1.1, -0.1]))\n\n结果：\ntf.Tensor([0. 0.], shape=(2,), dtype=float32)\ntf.Tensor([-inf -inf], shape=(2,), dtype=float32)\n```\n\n","source":"_posts/tf2-gaussian-distribution.md","raw":"---\ntitle: Tensorflow2.0中的高斯分布及其概率\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-04-08 10:50:12\ncategories: TensorFlow\ntags:\n- tf2\n- rl\nkeywords:\ndescription:\n---\n\n此篇博文用于记录和描述一些高斯分布的基本特性以及在tensorflow2.0中的不同之处。\n\n<!--more-->\n\n# 对角协方差高斯分布\n\n对角协方差矩阵： Diagonal Covariance Matrix\n\n多元高斯分布：multivariate Gaussian distribution\n\n拥有对角协方差的多元高斯分布，其变量的概率密度等于各个变量的一元高斯概率密度之积。\n\n假设对角协方差矩阵是如下形式：\n$$\n\\Sigma =\n\\left(\n  \\begin{array}{cccc}\n    \\sigma_{1} & 0 & \\cdots & 0 \\\\\n    0 & \\sigma_{2} & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & \\cdots & \\sigma_{k}\n  \\end{array}\n\\right)\n$$\n那么，多元高斯函数的概率密度函数被定义为：\n$$\nf_{x}\\left(x_{1}, \\ldots, x_{k}\\right)=\\frac{\\exp \\left(-\\frac{1}{2}(\\vec{x}-\\vec{\\mu})^{T} \\Sigma^{-1}(\\vec{x}-\\vec{\\mu})\\right)}{\\sqrt{|2 \\pi \\Sigma|}}\n$$\n变量替换：\n$$\n\\vec{y}=\\vec{x}-\\vec{\\mu}\n$$\n对角协方差的逆可以表示为：\n$$\n\\begin{aligned}\n\\Sigma^{-1} &=\\left(\\begin{array}{cccc}\n\\sigma_{1}^{2} & 0 & \\cdots & 0 \\\\\n0 & \\sigma_{2}^{2} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & \\sigma_{k}^{2}\n\\end{array}\\right)^{-1} \\\\\n&=\\left(\\begin{array}{cccc}\n\\frac{1}{\\sigma_{1}^{2}} & 0 & \\cdots & 0 \\\\\n0 & \\frac{1}{\\sigma_{2}^{2}} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & \\frac{1}{\\sigma_{k}^{2}}\n\\end{array}\\right)\n\\end{aligned}\n$$\n代入上面式子，可以得到：\n$$\n\\begin{align}\n\tf_x(x_1, \\ldots, x_k) = \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{(2\\pi)^{k}|\\Sigma|}}\n\\end{align}\n$$\n其中，分母的变化是由于矩阵秩的性质。对角协方差矩阵的秩可以展开写成：\n$$\n\\begin{align}\n\t|\\Sigma| &=\n\t\t\\begin{vmatrix}\n\t\t\t\\sigma_1^2 & 0 & \\cdots & 0 \\\\\n\t\t\t0 & \\sigma_2^2 & \\cdots & 0 \\\\\n\t\t\t\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\t\t\t0 & 0 & \\cdots & \\sigma_k^2 \\\\\n\t\t\\end{vmatrix} \\\\\n\t\t&= \\sigma_1^2 \\cdot \\sigma_2^2 \\cdots \\sigma_k^2\n\t\t\\end{align} %]]>\n$$\n最后，代入原概率密度方程并化简：\n$$\n\\begin{align}\n\tf_x(x_1, \\ldots, x_k) &= \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{(2\\pi)^{k}\\sigma_1^2 \\cdot \\sigma_2^2 \\cdots \\sigma_k^2}} \\\\\n\t&= \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{2\\pi\\sigma_1^2 \\cdot 2\\pi\\sigma_2^2 \\cdots 2\\pi\\sigma_k^2}} \\\\\n\t&= \\frac{\\exp\\Big(-\\frac{y_1^2}{2\\sigma_1^2} \\Big)}{\\sqrt{2\\pi\\sigma_1^2}}  \\cdot \\frac{\\exp\\Big(-\\frac{y_2^2}{2\\sigma_2^2} \\Big)}{\\sqrt{2\\pi\\sigma_2^2}}  \\cdots \\frac{\\exp\\Big(-\\frac{y_k^2}{2\\sigma_k^2} \\Big)}{\\sqrt{2\\pi\\sigma_k^2}} \\\\\n\t&= \\frac{\\exp\\Big(-\\frac{(x_1-\\mu_1)^2}{2\\sigma_1^2} \\Big)}{\\sqrt{2\\pi\\sigma_1^2}}  \\cdot \\frac{\\exp\\Big(-\\frac{(x_2-\\mu_2)^2}{2\\sigma_2^2} \\Big)}{\\sqrt{2\\pi\\sigma_2^2}}  \\cdots \\frac{\\exp\\Big(-\\frac{(x_k-\\mu_k)^2}{2\\sigma_k^2} \\Big)}{\\sqrt{2\\pi\\sigma_k^2}} \\\\\n\t&= f_1(x_1) \\cdot f_2(x_2) \\cdots f_k(x_k)\n\\end{align} %]]>\n$$\n这样就得到了，对角协方差矩阵的多元高斯分布，其变量的联合概率密度等于各个变量独立高斯分布概率密度的连积。\n\n# TensorFlow 2.0 Gaussian Functions\n\n```python\nimport numpy as np\nimport tensorflow as tf\nimport tensorflow_probability as tfp\n\ndt = tf.float32\n\nmu = tf.constant([1., 2.], dtype=dt)\t\t# 均值\nsigma = tf.constant([1., 2.], dtype=dt)\t# 标准差\ncovariance = tf.constant([\t\t\t\t\t\t\t# 协方差矩阵\n  [1., 0.],\n  [0., 4.]\n])\nx = tf.constant([0.92, 2.03], dtype=dt)\t# 模拟一个样本\n```\n\n测试一下TF中几个不同高斯分布的1. 采样形式；2. 样本概率的表示。定义一个函数：\n\n```python\ndef test_gaussian(dist, y):\n  '''\n  param dist: 传入的高斯分布\n  param y: 传入的样本\n  '''\n  x = dist.sample()\n  print(x)\t# 输出分布的采样\n  p = dist.prob(x)\n  print(p)\t# 输出采样样本的概率\n  p_y = dist.prob(y)\n  print('prob: ', p_y)\t# 输出样本的概率\n  print('sum_prob: ', tf.reduce_sum(p_y))\t# 输出样本的概率之和\n  print('prod_prob: ', tf.reduce_prod(p_y))\t# 输出样本的概率之积\n  log_p_y = dist.log_prob(y)\n  print('log_prob: ', log_p_y)\t# 输出样本的概率对数\n  print('sum_log_prob: ', tf.reduce_sum(log_p_y))\t# 输出样本的概率对数之和\n  print('prod_log_prob: ', tf.reduce_prod(log_p_y))\t# 输出样本的概率对数之积\n```\n\n\n\n## Normal\n\n`test_gaussian(tfp.distributions.Normal(loc=mu, scale=sigma), x)`，其参数中的scale为标准差。\n\n输出为：\n\n```\ntf.Tensor([-0.24812889  2.8150756 ], shape=(2,), dtype=float32)\ntf.Tensor([0.18307646 0.1835755 ], shape=(2,), dtype=float32)\nprob:  tf.Tensor([0.3976677  0.19944869], shape=(2,), dtype=float32)\nsum_prob:  tf.Tensor(0.5971164, shape=(), dtype=float32)\nprod_prob:  tf.Tensor(0.07931431, shape=(), dtype=float32)\nlog_prob:  tf.Tensor([-0.9221385 -1.6121982], shape=(2,), dtype=float32)\nsum_log_prob:  tf.Tensor(-2.5343368, shape=(), dtype=float32)\nprod_log_prob:  tf.Tensor(1.4866701, shape=(), dtype=float32)\n```\n\n这个分布为各个变量的独立高斯分布，有$n$个变量，则采样出$n$个值，其概率为每个变量各自的概率，如$n=2$，上面结果给出概率为：prob:  tf.Tensor([0.3976677  0.19944869], shape=(2,), dtype=float32)。\n\n## MultivariateNormalDiag\n\n`test_gaussian(tfp.distributions.MultivariateNormalDiag(loc=mu, scale_diag=sigma), x)`，其参数中的scale_diag为协方差矩阵对角线的平方根，也就是每个变量对应的标准差。\n\n输出为：\n\n```\ntf.Tensor([2.550062  1.5906484], shape=(2,), dtype=float32)\ntf.Tensor(0.02343988, shape=(), dtype=float32)\nprob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nsum_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nprod_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nlog_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\nsum_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\nprod_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\n```\n\n这个分布于各变量独立的高斯分布相同，其协方差矩阵为对角矩阵，与Normal不同的是，其概率为每个变量各自概率之积，即联合概率。其概率对数为每个变量各自概率对数之和。\n\nprob = Normal: prod_prob\n\nlog_prob = Normal: sum_log_prob\n\n## MultivariateNormalFullCovariance\n\n`test_gaussian(tfp.distributions.MultivariateNormalFullCovariance(loc=mu, covariance_matrix=covariance), x)`，其参数中的covariance_matrix为协方差矩阵，因此如果使用`MultivariateNormalDiag`并指定对角线参数为`scale_diag=[1,2]`，那么实现相同的分布使用`MultivariateNormalFullCovariance`应指定协方差矩阵参数为`covariance_matrix=[[1,0],[0,2]]`。\n\n输出为：\n\n```\ntf.Tensor([3.1393874 1.2191284], shape=(2,), dtype=float32)\ntf.Tensor(0.007478423, shape=(), dtype=float32)\nprob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nsum_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nprod_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)\nlog_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\nsum_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\nprod_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)\n```\n\n这个分布为多个变量的联合高斯分布，如果设置协方差矩阵为对角矩阵，且为`MultivariateNormalDiag`对角参数的平方，则两个分布一致。\n\n## TruncatedNormal\n\n```python\ntfp.distributions.TruncatedNormal(\n    loc, scale, low, high, validate_args=False, allow_nan_stats=True,\n    name='TruncatedNormal'\n)\n```\n\n这个分布相比`Normal`多了两个参数：low和high，如果样本＞high或者＜low，则其概率为0，对数概率为-inf。使用这个分布采样的样本也在low和high之间。\n\n```python\ndist = tfp.distributions.TruncatedNormal(loc=[0., 1.], scale=1.0, low=[-1., 0.], high=[1., 1.])\nprint(dist.prob([1.1, -0.1]))\nprint(dist.log_prob([1.1, -0.1]))\n\n结果：\ntf.Tensor([0. 0.], shape=(2,), dtype=float32)\ntf.Tensor([-inf -inf], shape=(2,), dtype=float32)\n```\n\n","slug":"tf2-gaussian-distribution","published":1,"updated":"2020-04-08T12:03:09.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut93005420cd8eeddnsn","content":"<p>此篇博文用于记录和描述一些高斯分布的基本特性以及在tensorflow2.0中的不同之处。</p>\n<a id=\"more\"></a>\n<h1 id=\"对角协方差高斯分布\"><a href=\"#对角协方差高斯分布\" class=\"headerlink\" title=\"对角协方差高斯分布\"></a>对角协方差高斯分布</h1><p>对角协方差矩阵： Diagonal Covariance Matrix</p>\n<p>多元高斯分布：multivariate Gaussian distribution</p>\n<p>拥有对角协方差的多元高斯分布，其变量的概率密度等于各个变量的一元高斯概率密度之积。</p>\n<p>假设对角协方差矩阵是如下形式：</p>\n<script type=\"math/tex; mode=display\">\n\\Sigma =\n\\left(\n  \\begin{array}{cccc}\n    \\sigma_{1} & 0 & \\cdots & 0 \\\\\n    0 & \\sigma_{2} & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & \\cdots & \\sigma_{k}\n  \\end{array}\n\\right)</script><p>那么，多元高斯函数的概率密度函数被定义为：</p>\n<script type=\"math/tex; mode=display\">\nf_{x}\\left(x_{1}, \\ldots, x_{k}\\right)=\\frac{\\exp \\left(-\\frac{1}{2}(\\vec{x}-\\vec{\\mu})^{T} \\Sigma^{-1}(\\vec{x}-\\vec{\\mu})\\right)}{\\sqrt{|2 \\pi \\Sigma|}}</script><p>变量替换：</p>\n<script type=\"math/tex; mode=display\">\n\\vec{y}=\\vec{x}-\\vec{\\mu}</script><p>对角协方差的逆可以表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\Sigma^{-1} &=\\left(\\begin{array}{cccc}\n\\sigma_{1}^{2} & 0 & \\cdots & 0 \\\\\n0 & \\sigma_{2}^{2} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & \\sigma_{k}^{2}\n\\end{array}\\right)^{-1} \\\\\n&=\\left(\\begin{array}{cccc}\n\\frac{1}{\\sigma_{1}^{2}} & 0 & \\cdots & 0 \\\\\n0 & \\frac{1}{\\sigma_{2}^{2}} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & \\frac{1}{\\sigma_{k}^{2}}\n\\end{array}\\right)\n\\end{aligned}</script><p>代入上面式子，可以得到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n    f_x(x_1, \\ldots, x_k) = \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{(2\\pi)^{k}|\\Sigma|}}\n\\end{align}</script><p>其中，分母的变化是由于矩阵秩的性质。对角协方差矩阵的秩可以展开写成：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n    |\\Sigma| &=\n        \\begin{vmatrix}\n            \\sigma_1^2 & 0 & \\cdots & 0 \\\\\n            0 & \\sigma_2^2 & \\cdots & 0 \\\\\n            \\vdots & \\vdots & \\ddots & \\vdots \\\\\n            0 & 0 & \\cdots & \\sigma_k^2 \\\\\n        \\end{vmatrix} \\\\\n        &= \\sigma_1^2 \\cdot \\sigma_2^2 \\cdots \\sigma_k^2\n        \\end{align} %]]></script><p>最后，代入原概率密度方程并化简：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n    f_x(x_1, \\ldots, x_k) &= \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{(2\\pi)^{k}\\sigma_1^2 \\cdot \\sigma_2^2 \\cdots \\sigma_k^2}} \\\\\n    &= \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{2\\pi\\sigma_1^2 \\cdot 2\\pi\\sigma_2^2 \\cdots 2\\pi\\sigma_k^2}} \\\\\n    &= \\frac{\\exp\\Big(-\\frac{y_1^2}{2\\sigma_1^2} \\Big)}{\\sqrt{2\\pi\\sigma_1^2}}  \\cdot \\frac{\\exp\\Big(-\\frac{y_2^2}{2\\sigma_2^2} \\Big)}{\\sqrt{2\\pi\\sigma_2^2}}  \\cdots \\frac{\\exp\\Big(-\\frac{y_k^2}{2\\sigma_k^2} \\Big)}{\\sqrt{2\\pi\\sigma_k^2}} \\\\\n    &= \\frac{\\exp\\Big(-\\frac{(x_1-\\mu_1)^2}{2\\sigma_1^2} \\Big)}{\\sqrt{2\\pi\\sigma_1^2}}  \\cdot \\frac{\\exp\\Big(-\\frac{(x_2-\\mu_2)^2}{2\\sigma_2^2} \\Big)}{\\sqrt{2\\pi\\sigma_2^2}}  \\cdots \\frac{\\exp\\Big(-\\frac{(x_k-\\mu_k)^2}{2\\sigma_k^2} \\Big)}{\\sqrt{2\\pi\\sigma_k^2}} \\\\\n    &= f_1(x_1) \\cdot f_2(x_2) \\cdots f_k(x_k)\n\\end{align} %]]></script><p>这样就得到了，对角协方差矩阵的多元高斯分布，其变量的联合概率密度等于各个变量独立高斯分布概率密度的连积。</p>\n<h1 id=\"TensorFlow-2-0-Gaussian-Functions\"><a href=\"#TensorFlow-2-0-Gaussian-Functions\" class=\"headerlink\" title=\"TensorFlow 2.0 Gaussian Functions\"></a>TensorFlow 2.0 Gaussian Functions</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow_probability <span class=\"keyword\">as</span> tfp</span><br><span class=\"line\"></span><br><span class=\"line\">dt = tf.float32</span><br><span class=\"line\"></span><br><span class=\"line\">mu = tf.constant([<span class=\"number\">1.</span>, <span class=\"number\">2.</span>], dtype=dt)\t\t<span class=\"comment\"># 均值</span></span><br><span class=\"line\">sigma = tf.constant([<span class=\"number\">1.</span>, <span class=\"number\">2.</span>], dtype=dt)\t<span class=\"comment\"># 标准差</span></span><br><span class=\"line\">covariance = tf.constant([\t\t\t\t\t\t\t<span class=\"comment\"># 协方差矩阵</span></span><br><span class=\"line\">  [<span class=\"number\">1.</span>, <span class=\"number\">0.</span>],</span><br><span class=\"line\">  [<span class=\"number\">0.</span>, <span class=\"number\">4.</span>]</span><br><span class=\"line\">])</span><br><span class=\"line\">x = tf.constant([<span class=\"number\">0.92</span>, <span class=\"number\">2.03</span>], dtype=dt)\t<span class=\"comment\"># 模拟一个样本</span></span><br></pre></td></tr></table></figure>\n<p>测试一下TF中几个不同高斯分布的1. 采样形式；2. 样本概率的表示。定义一个函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_gaussian</span><span class=\"params\">(dist, y)</span>:</span></span><br><span class=\"line\">  <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">  param dist: 传入的高斯分布</span></span><br><span class=\"line\"><span class=\"string\">  param y: 传入的样本</span></span><br><span class=\"line\"><span class=\"string\">  '''</span></span><br><span class=\"line\">  x = dist.sample()</span><br><span class=\"line\">  print(x)\t<span class=\"comment\"># 输出分布的采样</span></span><br><span class=\"line\">  p = dist.prob(x)</span><br><span class=\"line\">  print(p)\t<span class=\"comment\"># 输出采样样本的概率</span></span><br><span class=\"line\">  p_y = dist.prob(y)</span><br><span class=\"line\">  print(<span class=\"string\">'prob: '</span>, p_y)\t<span class=\"comment\"># 输出样本的概率</span></span><br><span class=\"line\">  print(<span class=\"string\">'sum_prob: '</span>, tf.reduce_sum(p_y))\t<span class=\"comment\"># 输出样本的概率之和</span></span><br><span class=\"line\">  print(<span class=\"string\">'prod_prob: '</span>, tf.reduce_prod(p_y))\t<span class=\"comment\"># 输出样本的概率之积</span></span><br><span class=\"line\">  log_p_y = dist.log_prob(y)</span><br><span class=\"line\">  print(<span class=\"string\">'log_prob: '</span>, log_p_y)\t<span class=\"comment\"># 输出样本的概率对数</span></span><br><span class=\"line\">  print(<span class=\"string\">'sum_log_prob: '</span>, tf.reduce_sum(log_p_y))\t<span class=\"comment\"># 输出样本的概率对数之和</span></span><br><span class=\"line\">  print(<span class=\"string\">'prod_log_prob: '</span>, tf.reduce_prod(log_p_y))\t<span class=\"comment\"># 输出样本的概率对数之积</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Normal\"><a href=\"#Normal\" class=\"headerlink\" title=\"Normal\"></a>Normal</h2><p><code>test_gaussian(tfp.distributions.Normal(loc=mu, scale=sigma), x)</code>，其参数中的scale为标准差。</p>\n<p>输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf.Tensor([-0.24812889  2.8150756 ], shape=(2,), dtype=float32)</span><br><span class=\"line\">tf.Tensor([0.18307646 0.1835755 ], shape=(2,), dtype=float32)</span><br><span class=\"line\">prob:  tf.Tensor([0.3976677  0.19944869], shape=(2,), dtype=float32)</span><br><span class=\"line\">sum_prob:  tf.Tensor(0.5971164, shape=(), dtype=float32)</span><br><span class=\"line\">prod_prob:  tf.Tensor(0.07931431, shape=(), dtype=float32)</span><br><span class=\"line\">log_prob:  tf.Tensor([-0.9221385 -1.6121982], shape=(2,), dtype=float32)</span><br><span class=\"line\">sum_log_prob:  tf.Tensor(-2.5343368, shape=(), dtype=float32)</span><br><span class=\"line\">prod_log_prob:  tf.Tensor(1.4866701, shape=(), dtype=float32)</span><br></pre></td></tr></table></figure>\n<p>这个分布为各个变量的独立高斯分布，有$n$个变量，则采样出$n$个值，其概率为每个变量各自的概率，如$n=2$，上面结果给出概率为：prob:  tf.Tensor([0.3976677  0.19944869], shape=(2,), dtype=float32)。</p>\n<h2 id=\"MultivariateNormalDiag\"><a href=\"#MultivariateNormalDiag\" class=\"headerlink\" title=\"MultivariateNormalDiag\"></a>MultivariateNormalDiag</h2><p><code>test_gaussian(tfp.distributions.MultivariateNormalDiag(loc=mu, scale_diag=sigma), x)</code>，其参数中的scale_diag为协方差矩阵对角线的平方根，也就是每个变量对应的标准差。</p>\n<p>输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf.Tensor([2.550062  1.5906484], shape=(2,), dtype=float32)</span><br><span class=\"line\">tf.Tensor(0.02343988, shape=(), dtype=float32)</span><br><span class=\"line\">prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">sum_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">prod_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br><span class=\"line\">sum_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br><span class=\"line\">prod_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br></pre></td></tr></table></figure>\n<p>这个分布于各变量独立的高斯分布相同，其协方差矩阵为对角矩阵，与Normal不同的是，其概率为每个变量各自概率之积，即联合概率。其概率对数为每个变量各自概率对数之和。</p>\n<p>prob = Normal: prod_prob</p>\n<p>log_prob = Normal: sum_log_prob</p>\n<h2 id=\"MultivariateNormalFullCovariance\"><a href=\"#MultivariateNormalFullCovariance\" class=\"headerlink\" title=\"MultivariateNormalFullCovariance\"></a>MultivariateNormalFullCovariance</h2><p><code>test_gaussian(tfp.distributions.MultivariateNormalFullCovariance(loc=mu, covariance_matrix=covariance), x)</code>，其参数中的covariance_matrix为协方差矩阵，因此如果使用<code>MultivariateNormalDiag</code>并指定对角线参数为<code>scale_diag=[1,2]</code>，那么实现相同的分布使用<code>MultivariateNormalFullCovariance</code>应指定协方差矩阵参数为<code>covariance_matrix=[[1,0],[0,2]]</code>。</p>\n<p>输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf.Tensor([3.1393874 1.2191284], shape=(2,), dtype=float32)</span><br><span class=\"line\">tf.Tensor(0.007478423, shape=(), dtype=float32)</span><br><span class=\"line\">prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">sum_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">prod_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br><span class=\"line\">sum_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br><span class=\"line\">prod_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br></pre></td></tr></table></figure>\n<p>这个分布为多个变量的联合高斯分布，如果设置协方差矩阵为对角矩阵，且为<code>MultivariateNormalDiag</code>对角参数的平方，则两个分布一致。</p>\n<h2 id=\"TruncatedNormal\"><a href=\"#TruncatedNormal\" class=\"headerlink\" title=\"TruncatedNormal\"></a>TruncatedNormal</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tfp.distributions.TruncatedNormal(</span><br><span class=\"line\">    loc, scale, low, high, validate_args=<span class=\"keyword\">False</span>, allow_nan_stats=<span class=\"keyword\">True</span>,</span><br><span class=\"line\">    name=<span class=\"string\">'TruncatedNormal'</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>这个分布相比<code>Normal</code>多了两个参数：low和high，如果样本＞high或者＜low，则其概率为0，对数概率为-inf。使用这个分布采样的样本也在low和high之间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dist = tfp.distributions.TruncatedNormal(loc=[<span class=\"number\">0.</span>, <span class=\"number\">1.</span>], scale=<span class=\"number\">1.0</span>, low=[<span class=\"number\">-1.</span>, <span class=\"number\">0.</span>], high=[<span class=\"number\">1.</span>, <span class=\"number\">1.</span>])</span><br><span class=\"line\">print(dist.prob([<span class=\"number\">1.1</span>, <span class=\"number\">-0.1</span>]))</span><br><span class=\"line\">print(dist.log_prob([<span class=\"number\">1.1</span>, <span class=\"number\">-0.1</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">tf.Tensor([<span class=\"number\">0.</span> <span class=\"number\">0.</span>], shape=(<span class=\"number\">2</span>,), dtype=float32)</span><br><span class=\"line\">tf.Tensor([-inf -inf], shape=(<span class=\"number\">2</span>,), dtype=float32)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>此篇博文用于记录和描述一些高斯分布的基本特性以及在tensorflow2.0中的不同之处。</p>","more":"<h1 id=\"对角协方差高斯分布\"><a href=\"#对角协方差高斯分布\" class=\"headerlink\" title=\"对角协方差高斯分布\"></a>对角协方差高斯分布</h1><p>对角协方差矩阵： Diagonal Covariance Matrix</p>\n<p>多元高斯分布：multivariate Gaussian distribution</p>\n<p>拥有对角协方差的多元高斯分布，其变量的概率密度等于各个变量的一元高斯概率密度之积。</p>\n<p>假设对角协方差矩阵是如下形式：</p>\n<script type=\"math/tex; mode=display\">\n\\Sigma =\n\\left(\n  \\begin{array}{cccc}\n    \\sigma_{1} & 0 & \\cdots & 0 \\\\\n    0 & \\sigma_{2} & \\cdots & 0 \\\\\n    \\vdots & \\vdots & \\ddots & \\vdots \\\\\n    0 & 0 & \\cdots & \\sigma_{k}\n  \\end{array}\n\\right)</script><p>那么，多元高斯函数的概率密度函数被定义为：</p>\n<script type=\"math/tex; mode=display\">\nf_{x}\\left(x_{1}, \\ldots, x_{k}\\right)=\\frac{\\exp \\left(-\\frac{1}{2}(\\vec{x}-\\vec{\\mu})^{T} \\Sigma^{-1}(\\vec{x}-\\vec{\\mu})\\right)}{\\sqrt{|2 \\pi \\Sigma|}}</script><p>变量替换：</p>\n<script type=\"math/tex; mode=display\">\n\\vec{y}=\\vec{x}-\\vec{\\mu}</script><p>对角协方差的逆可以表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\Sigma^{-1} &=\\left(\\begin{array}{cccc}\n\\sigma_{1}^{2} & 0 & \\cdots & 0 \\\\\n0 & \\sigma_{2}^{2} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & \\sigma_{k}^{2}\n\\end{array}\\right)^{-1} \\\\\n&=\\left(\\begin{array}{cccc}\n\\frac{1}{\\sigma_{1}^{2}} & 0 & \\cdots & 0 \\\\\n0 & \\frac{1}{\\sigma_{2}^{2}} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & \\frac{1}{\\sigma_{k}^{2}}\n\\end{array}\\right)\n\\end{aligned}</script><p>代入上面式子，可以得到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n    f_x(x_1, \\ldots, x_k) = \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{(2\\pi)^{k}|\\Sigma|}}\n\\end{align}</script><p>其中，分母的变化是由于矩阵秩的性质。对角协方差矩阵的秩可以展开写成：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n    |\\Sigma| &=\n        \\begin{vmatrix}\n            \\sigma_1^2 & 0 & \\cdots & 0 \\\\\n            0 & \\sigma_2^2 & \\cdots & 0 \\\\\n            \\vdots & \\vdots & \\ddots & \\vdots \\\\\n            0 & 0 & \\cdots & \\sigma_k^2 \\\\\n        \\end{vmatrix} \\\\\n        &= \\sigma_1^2 \\cdot \\sigma_2^2 \\cdots \\sigma_k^2\n        \\end{align} %]]></script><p>最后，代入原概率密度方程并化简：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n    f_x(x_1, \\ldots, x_k) &= \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{(2\\pi)^{k}\\sigma_1^2 \\cdot \\sigma_2^2 \\cdots \\sigma_k^2}} \\\\\n    &= \\frac{\\exp \\Big(-\\frac{1}{2} ( \\frac{y_1^2}{\\sigma_1^2} + \\frac{y_2^2}{\\sigma_2^2} + \\ldots + \\frac{y_k^2}{\\sigma_k^2} ) \\Big)}{\\sqrt{2\\pi\\sigma_1^2 \\cdot 2\\pi\\sigma_2^2 \\cdots 2\\pi\\sigma_k^2}} \\\\\n    &= \\frac{\\exp\\Big(-\\frac{y_1^2}{2\\sigma_1^2} \\Big)}{\\sqrt{2\\pi\\sigma_1^2}}  \\cdot \\frac{\\exp\\Big(-\\frac{y_2^2}{2\\sigma_2^2} \\Big)}{\\sqrt{2\\pi\\sigma_2^2}}  \\cdots \\frac{\\exp\\Big(-\\frac{y_k^2}{2\\sigma_k^2} \\Big)}{\\sqrt{2\\pi\\sigma_k^2}} \\\\\n    &= \\frac{\\exp\\Big(-\\frac{(x_1-\\mu_1)^2}{2\\sigma_1^2} \\Big)}{\\sqrt{2\\pi\\sigma_1^2}}  \\cdot \\frac{\\exp\\Big(-\\frac{(x_2-\\mu_2)^2}{2\\sigma_2^2} \\Big)}{\\sqrt{2\\pi\\sigma_2^2}}  \\cdots \\frac{\\exp\\Big(-\\frac{(x_k-\\mu_k)^2}{2\\sigma_k^2} \\Big)}{\\sqrt{2\\pi\\sigma_k^2}} \\\\\n    &= f_1(x_1) \\cdot f_2(x_2) \\cdots f_k(x_k)\n\\end{align} %]]></script><p>这样就得到了，对角协方差矩阵的多元高斯分布，其变量的联合概率密度等于各个变量独立高斯分布概率密度的连积。</p>\n<h1 id=\"TensorFlow-2-0-Gaussian-Functions\"><a href=\"#TensorFlow-2-0-Gaussian-Functions\" class=\"headerlink\" title=\"TensorFlow 2.0 Gaussian Functions\"></a>TensorFlow 2.0 Gaussian Functions</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">import</span> tensorflow_probability <span class=\"keyword\">as</span> tfp</span><br><span class=\"line\"></span><br><span class=\"line\">dt = tf.float32</span><br><span class=\"line\"></span><br><span class=\"line\">mu = tf.constant([<span class=\"number\">1.</span>, <span class=\"number\">2.</span>], dtype=dt)\t\t<span class=\"comment\"># 均值</span></span><br><span class=\"line\">sigma = tf.constant([<span class=\"number\">1.</span>, <span class=\"number\">2.</span>], dtype=dt)\t<span class=\"comment\"># 标准差</span></span><br><span class=\"line\">covariance = tf.constant([\t\t\t\t\t\t\t<span class=\"comment\"># 协方差矩阵</span></span><br><span class=\"line\">  [<span class=\"number\">1.</span>, <span class=\"number\">0.</span>],</span><br><span class=\"line\">  [<span class=\"number\">0.</span>, <span class=\"number\">4.</span>]</span><br><span class=\"line\">])</span><br><span class=\"line\">x = tf.constant([<span class=\"number\">0.92</span>, <span class=\"number\">2.03</span>], dtype=dt)\t<span class=\"comment\"># 模拟一个样本</span></span><br></pre></td></tr></table></figure>\n<p>测试一下TF中几个不同高斯分布的1. 采样形式；2. 样本概率的表示。定义一个函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_gaussian</span><span class=\"params\">(dist, y)</span>:</span></span><br><span class=\"line\">  <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">  param dist: 传入的高斯分布</span></span><br><span class=\"line\"><span class=\"string\">  param y: 传入的样本</span></span><br><span class=\"line\"><span class=\"string\">  '''</span></span><br><span class=\"line\">  x = dist.sample()</span><br><span class=\"line\">  print(x)\t<span class=\"comment\"># 输出分布的采样</span></span><br><span class=\"line\">  p = dist.prob(x)</span><br><span class=\"line\">  print(p)\t<span class=\"comment\"># 输出采样样本的概率</span></span><br><span class=\"line\">  p_y = dist.prob(y)</span><br><span class=\"line\">  print(<span class=\"string\">'prob: '</span>, p_y)\t<span class=\"comment\"># 输出样本的概率</span></span><br><span class=\"line\">  print(<span class=\"string\">'sum_prob: '</span>, tf.reduce_sum(p_y))\t<span class=\"comment\"># 输出样本的概率之和</span></span><br><span class=\"line\">  print(<span class=\"string\">'prod_prob: '</span>, tf.reduce_prod(p_y))\t<span class=\"comment\"># 输出样本的概率之积</span></span><br><span class=\"line\">  log_p_y = dist.log_prob(y)</span><br><span class=\"line\">  print(<span class=\"string\">'log_prob: '</span>, log_p_y)\t<span class=\"comment\"># 输出样本的概率对数</span></span><br><span class=\"line\">  print(<span class=\"string\">'sum_log_prob: '</span>, tf.reduce_sum(log_p_y))\t<span class=\"comment\"># 输出样本的概率对数之和</span></span><br><span class=\"line\">  print(<span class=\"string\">'prod_log_prob: '</span>, tf.reduce_prod(log_p_y))\t<span class=\"comment\"># 输出样本的概率对数之积</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Normal\"><a href=\"#Normal\" class=\"headerlink\" title=\"Normal\"></a>Normal</h2><p><code>test_gaussian(tfp.distributions.Normal(loc=mu, scale=sigma), x)</code>，其参数中的scale为标准差。</p>\n<p>输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf.Tensor([-0.24812889  2.8150756 ], shape=(2,), dtype=float32)</span><br><span class=\"line\">tf.Tensor([0.18307646 0.1835755 ], shape=(2,), dtype=float32)</span><br><span class=\"line\">prob:  tf.Tensor([0.3976677  0.19944869], shape=(2,), dtype=float32)</span><br><span class=\"line\">sum_prob:  tf.Tensor(0.5971164, shape=(), dtype=float32)</span><br><span class=\"line\">prod_prob:  tf.Tensor(0.07931431, shape=(), dtype=float32)</span><br><span class=\"line\">log_prob:  tf.Tensor([-0.9221385 -1.6121982], shape=(2,), dtype=float32)</span><br><span class=\"line\">sum_log_prob:  tf.Tensor(-2.5343368, shape=(), dtype=float32)</span><br><span class=\"line\">prod_log_prob:  tf.Tensor(1.4866701, shape=(), dtype=float32)</span><br></pre></td></tr></table></figure>\n<p>这个分布为各个变量的独立高斯分布，有$n$个变量，则采样出$n$个值，其概率为每个变量各自的概率，如$n=2$，上面结果给出概率为：prob:  tf.Tensor([0.3976677  0.19944869], shape=(2,), dtype=float32)。</p>\n<h2 id=\"MultivariateNormalDiag\"><a href=\"#MultivariateNormalDiag\" class=\"headerlink\" title=\"MultivariateNormalDiag\"></a>MultivariateNormalDiag</h2><p><code>test_gaussian(tfp.distributions.MultivariateNormalDiag(loc=mu, scale_diag=sigma), x)</code>，其参数中的scale_diag为协方差矩阵对角线的平方根，也就是每个变量对应的标准差。</p>\n<p>输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf.Tensor([2.550062  1.5906484], shape=(2,), dtype=float32)</span><br><span class=\"line\">tf.Tensor(0.02343988, shape=(), dtype=float32)</span><br><span class=\"line\">prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">sum_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">prod_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br><span class=\"line\">sum_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br><span class=\"line\">prod_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br></pre></td></tr></table></figure>\n<p>这个分布于各变量独立的高斯分布相同，其协方差矩阵为对角矩阵，与Normal不同的是，其概率为每个变量各自概率之积，即联合概率。其概率对数为每个变量各自概率对数之和。</p>\n<p>prob = Normal: prod_prob</p>\n<p>log_prob = Normal: sum_log_prob</p>\n<h2 id=\"MultivariateNormalFullCovariance\"><a href=\"#MultivariateNormalFullCovariance\" class=\"headerlink\" title=\"MultivariateNormalFullCovariance\"></a>MultivariateNormalFullCovariance</h2><p><code>test_gaussian(tfp.distributions.MultivariateNormalFullCovariance(loc=mu, covariance_matrix=covariance), x)</code>，其参数中的covariance_matrix为协方差矩阵，因此如果使用<code>MultivariateNormalDiag</code>并指定对角线参数为<code>scale_diag=[1,2]</code>，那么实现相同的分布使用<code>MultivariateNormalFullCovariance</code>应指定协方差矩阵参数为<code>covariance_matrix=[[1,0],[0,2]]</code>。</p>\n<p>输出为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf.Tensor([3.1393874 1.2191284], shape=(2,), dtype=float32)</span><br><span class=\"line\">tf.Tensor(0.007478423, shape=(), dtype=float32)</span><br><span class=\"line\">prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">sum_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">prod_prob:  tf.Tensor(0.07931432, shape=(), dtype=float32)</span><br><span class=\"line\">log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br><span class=\"line\">sum_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br><span class=\"line\">prod_log_prob:  tf.Tensor(-2.5343366, shape=(), dtype=float32)</span><br></pre></td></tr></table></figure>\n<p>这个分布为多个变量的联合高斯分布，如果设置协方差矩阵为对角矩阵，且为<code>MultivariateNormalDiag</code>对角参数的平方，则两个分布一致。</p>\n<h2 id=\"TruncatedNormal\"><a href=\"#TruncatedNormal\" class=\"headerlink\" title=\"TruncatedNormal\"></a>TruncatedNormal</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tfp.distributions.TruncatedNormal(</span><br><span class=\"line\">    loc, scale, low, high, validate_args=<span class=\"keyword\">False</span>, allow_nan_stats=<span class=\"keyword\">True</span>,</span><br><span class=\"line\">    name=<span class=\"string\">'TruncatedNormal'</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>这个分布相比<code>Normal</code>多了两个参数：low和high，如果样本＞high或者＜low，则其概率为0，对数概率为-inf。使用这个分布采样的样本也在low和high之间。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dist = tfp.distributions.TruncatedNormal(loc=[<span class=\"number\">0.</span>, <span class=\"number\">1.</span>], scale=<span class=\"number\">1.0</span>, low=[<span class=\"number\">-1.</span>, <span class=\"number\">0.</span>], high=[<span class=\"number\">1.</span>, <span class=\"number\">1.</span>])</span><br><span class=\"line\">print(dist.prob([<span class=\"number\">1.1</span>, <span class=\"number\">-0.1</span>]))</span><br><span class=\"line\">print(dist.log_prob([<span class=\"number\">1.1</span>, <span class=\"number\">-0.1</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\">结果：</span><br><span class=\"line\">tf.Tensor([<span class=\"number\">0.</span> <span class=\"number\">0.</span>], shape=(<span class=\"number\">2</span>,), dtype=float32)</span><br><span class=\"line\">tf.Tensor([-inf -inf], shape=(<span class=\"number\">2</span>,), dtype=float32)</span><br></pre></td></tr></table></figure>"},{"title":"创建ML-Agents的Docker镜像","copyright":true,"top":1,"date":"2019-01-04T02:38:59.000Z","_content":"\n# 创建ML-Agents的Docker镜像\n\n<!--more-->\n\n## 前言\n\n  如果需要在镜像中使用GPU训练,可以将Nvidia的官方镜像作为基础镜像,`Dockerfile`如下:\n```\nFROM nvidia/cuda:9.0-base-ubuntu16.04\nLABEL maintainer \"NVIDIA CORPORATION <cudatools@nvidia.com>\"\n\nENV NCCL_VERSION 2.3.7\n\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n\tapt-utils \\\n        cuda-libraries-$CUDA_PKG_VERSION \\\n        cuda-cublas-9-0=9.0.176.4-1 \\\n        libnccl2=$NCCL_VERSION-1+cuda9.0 && \\\n    apt-mark hold libnccl2 && \\\n    rm -rf /var/lib/apt/lists/*\n\nRUN apt-get update && apt-get install -y openssh-server\n\nRUN apt-get install -y nano\n\nRUN mkdir /var/run/sshd\n\nRUN echo \"root:1234\" | chpasswd\n\nRUN sed -i 's/prohibit-password/yes/g' /etc/ssh/sshd_config\n\nEXPOSE 22\n\nENTRYPOINT [\"/usr/sbin/sshd\",\"-D\"]\n```\n\n## ML-Agents v0.6.0\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-44-58.png)\n\n### 环境\n\n本机环境\n\n- ML-Agents 0.6.0\n- Windows 10 专业版\n- docker client version 18.09.0\n- docker server version 18.09.0\n\n平台\n- [机器学习平台](http://10.0.4.228)\n\n### 创建镜像\n\n1. 打开`~/ml-agents-0.6.0/`目录,看到有一个官方给定的`Dockerfile`\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-52-49.png)\n2. 直接`Build`,在该目录下运行`docker build -t [name]:[tag] .`,一定要注意最后的`.`,很**重要**\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-29-30.png)\n3. 新建一个`sources.list`文件,为镜像内换源,因为将来有可能需要在容器内安装某些包,有一些国外的资源往往会下载失败,所以需要**换源**\n- 新建一个`sources.list`\n- 用文本编辑器打开,写入以下内容\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-36-31.png)\n```\n# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted\ndeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties\ndeb http://archive.canonical.com/ubuntu xenial partner\ndeb-src http://archive.canonical.com/ubuntu xenial partner\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse\n```\n- 保存退出\n4. 新建一个`DockerfilePlus`,在官方生成的基础镜像上安装一些可以在平台上运行的包,`openssh-server`,联网工具`net-tools`,心爱的`apt-file`等等\n- 新建一个`DockerfilePlus`\n- 用文本编辑器打开,输入以下内容\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-01-32.png)\n```\nFROM hub.hoc.ccshu.net/wjs/mlunityv060:v0.1\n\nRUN cp /etc/apt/sources.list /etc/apt/sources.list.bak\nCOPY sources.list /etc/apt/sources.list\n\nENV PYTHONPATH /ml-agents:$PYTHONPATH\n\nRUN apt-get update && apt-get install -y \\\n        apt-file \\\n        nano \\\n        net-tools \\\n        iputils-ping \\\n        openssh-server \\\n        apt-utils \\\n    && rm -rf /var/lib/apt/lists/* \\\n    && mkdir /var/run/sshd \\\n    && echo \"root:1234\" | chpasswd \\\n    && sed -i 's/prohibit-password/yes/g' /etc/ssh/sshd_config\n\nEXPOSE 22\n\nENTRYPOINT [\"/usr/sbin/sshd\",\"-D\"]\n```\n5. 在`DockerfilePlus`所在文件夹下,执行`build -t [name]:[tag] -f DockerfilePlus .`\n\n**为了使用GPU.改写完的Dockerfile如下(不需要看):**\n```\nFROM nvidia/cuda:9.0-base-ubuntu16.04\nLABEL maintainer \"Keavnn <https://stepneverstop.github.io>\"\n\nENV NCCL_VERSION 2.3.7\n\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n\tapt-utils \\\n        cuda-libraries-$CUDA_PKG_VERSION \\\n        cuda-cublas-9-0=9.0.176.4-1 \\\n        libnccl2=$NCCL_VERSION-1+cuda9.0 && \\\n    apt-mark hold libnccl2 && \\\n    rm -rf /var/lib/apt/lists/*\n\n\n# ensure local python is preferred over distribution python\nENV PATH /usr/local/bin:$PATH\n\n# http://bugs.python.org/issue19846\n# > At the moment, setting \"LANG=C\" on a Linux system *fundamentally breaks Python 3*, and that's not OK.\nENV LANG C.UTF-8\n\n# runtime dependencies\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n\t\tca-certificates \\\n\t\tlibexpat1 \\\n\t\tlibffi6 \\\n\t\tlibgdbm3 \\\n\t\tlibreadline6 \\\n\t\tlibsqlite3-0 \\\n\t\tlibssl1.0.0 \\\n\t&& rm -rf /var/lib/apt/lists/*\n\nENV GPG_KEY 0D96DF4D4110E5C43FBFB17F2D347EA6AA65421D\nENV PYTHON_VERSION 3.6.4\n\nRUN set -ex \\\n\t&& buildDeps=\" \\\n\t\tdpkg-dev \\\n\t\tgcc \\\n\t\tlibbz2-dev \\\n\t\tlibc6-dev \\\n\t\tlibexpat1-dev \\\n\t\tlibffi-dev \\\n\t\tlibgdbm-dev \\\n\t\tliblzma-dev \\\n\t\tlibncursesw5-dev \\\n\t\tlibreadline-dev \\\n\t\tlibsqlite3-dev \\\n\t\tlibssl-dev \\\n\t\tmake \\\n\t\ttcl-dev \\\n\t\ttk-dev \\\n\t\twget \\\n\t\txz-utils \\\n\t\tzlib1g-dev \\\n# as of Stretch, \"gpg\" is no longer included by default\n\t\t$(command -v gpg > /dev/null || echo 'gnupg dirmngr') \\\n\t\" \\\n\t&& apt-get update && apt-get install -y $buildDeps --no-install-recommends && rm -rf /var/lib/apt/lists/* \\\n\t\\\n\t&& wget -O python.tar.xz \"https://www.python.org/ftp/python/${PYTHON_VERSION%%[a-z]*}/Python-$PYTHON_VERSION.tar.xz\" \\\n\t&& wget -O python.tar.xz.asc \"https://www.python.org/ftp/python/${PYTHON_VERSION%%[a-z]*}/Python-$PYTHON_VERSION.tar.xz.asc\" \\\n\t&& export GNUPGHOME=\"$(mktemp -d)\" \\\n\t&& gpg --keyserver ha.pool.sks-keyservers.net --recv-keys \"$GPG_KEY\" \\\n\t&& gpg --batch --verify python.tar.xz.asc python.tar.xz \\\n\t&& rm -rf \"$GNUPGHOME\" python.tar.xz.asc \\\n\t&& mkdir -p /usr/src/python \\\n\t&& tar -xJC /usr/src/python --strip-components=1 -f python.tar.xz \\\n\t&& rm python.tar.xz \\\n\t\\\n\t&& cd /usr/src/python \\\n\t&& gnuArch=\"$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)\" \\\n\t&& ./configure \\\n\t\t--build=\"$gnuArch\" \\\n\t\t--enable-loadable-sqlite-extensions \\\n\t\t--enable-shared \\\n\t\t--with-system-expat \\\n\t\t--with-system-ffi \\\n\t\t--without-ensurepip \\\n\t&& make -j \"$(nproc)\" \\\n\t&& make install \\\n\t&& ldconfig \\\n\t\\\n\t&& apt-get purge -y --auto-remove $buildDeps \\\n\t\\\n\t&& find /usr/local -depth \\\n\t\t\\( \\\n\t\t\t\\( -type d -a \\( -name test -o -name tests \\) \\) \\\n\t\t\t-o \\\n\t\t\t\\( -type f -a \\( -name '*.pyc' -o -name '*.pyo' \\) \\) \\\n\t\t\\) -exec rm -rf '{}' + \\\n\t&& rm -rf /usr/src/python\n\n# make some useful symlinks that are expected to exist\nRUN cd /usr/local/bin \\\n\t&& ln -s idle3 idle \\\n\t&& ln -s pydoc3 pydoc \\\n\t&& ln -s python3 python \\\n\t&& ln -s python3-config python-config\n\n# if this is called \"PIP_VERSION\", pip explodes with \"ValueError: invalid truth value '<VERSION>'\"\nENV PYTHON_PIP_VERSION 9.0.3\n\nRUN set -ex; \\\n\t\\\n\tapt-get update; \\\n\tapt-get install -y --no-install-recommends wget; \\\n\trm -rf /var/lib/apt/lists/*; \\\n\t\\\n\twget -O get-pip.py 'https://bootstrap.pypa.io/get-pip.py'; \\\n\t\\\n\tapt-get purge -y --auto-remove wget; \\\n\t\\\n\tpython get-pip.py \\\n\t\t--disable-pip-version-check \\\n\t\t--no-cache-dir \\\n\t\t\"pip==$PYTHON_PIP_VERSION\" \\\n\t; \\\n\tpip --version; \\\n\t\\\n\tfind /usr/local -depth \\\n\t\t\\( \\\n\t\t\t\\( -type d -a \\( -name test -o -name tests \\) \\) \\\n\t\t\t-o \\\n\t\t\t\\( -type f -a \\( -name '*.pyc' -o -name '*.pyo' \\) \\) \\\n\t\t\\) -exec rm -rf '{}' +; \\\n\trm -f get-pip.py\n\n\nRUN apt-get update && apt-get -y upgrade\n\n# xvfb is used to do CPU based rendering of Unity\nRUN apt-get install -y xvfb\n\nCOPY ml-agents /ml-agents\nWORKDIR /ml-agents\nRUN pip install .\n\n# port 5005 is the port used in in Editor training.\nEXPOSE 5005\n\nRUN cp /etc/apt/sources.list /etc/apt/sources.list.bak\nCOPY sources.list /etc/apt/sources.list\n\nENV PYTHONPATH /ml-agents:$PYTHONPATH\n\nRUN apt-get update && apt-get install -y \\\n        apt-file \\\n        nano \\\n        net-tools \\\n        iputils-ping \\\n        openssh-server \\\n        apt-utils \\\n    && rm -rf /var/lib/apt/lists/* \\\n    && mkdir /var/run/sshd \\\n    && echo \"root:1234\" | chpasswd \\\n    && sed -i 's/prohibit-password/yes/g' /etc/ssh/sshd_config\n\nEXPOSE 22\n\nENTRYPOINT [\"/usr/sbin/sshd\",\"-D\"]\n```\n\n### PUSH镜像\n\n`docker push [name]:[tag]`\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-02-47.png)\n\n### 测试镜像\n\n- 登录[机器学习平台](http://10.0.4.228),没有使用平台的可以在本地使用`docker run`直接开启容器\n- 先测试使用容器的方式\n  - 创建容器\n  ![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-28-19.png)\n  将要运行和储存的文件夹放在数据卷`data`下,这个目录要在运行时由`--docker-target-name`指定\n  - 等待容器创建成功\n  ![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-15.png)\n  - 容器创建成功后进入容器\n  ![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-52.png)\n  - 执行`mlagents-learn trainer_config.yaml --docker-target-name=data/unity-volume --env=3dball --train --run-id=test --save-freq=5000 | tee /data/unity-volume/log.txt`,如果不想在屏幕输出,可以在后边加上`>/dev/null`\n  ![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-16-44.png)\n  ![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-18-40.png)\n  \n---\n\n## 安装Miniconda\n\n确保你的安装包放在了data文件夹下\n`apt-get update && apt-get install bzip2 -y && cd /data && bash Miniconda3-latest-Linux-x86_64.sh`\n\n一路按回车、yes等等就成功了.如果需要安装到指定目录,在安装过程中会有提示告诉你让你指定安装路径\n\n*注意*\n\n在[学校机器学习平台](http://10.0.4.228/)上使用时,如果是使用容器的方式,那么新开的容器就可以使用`conda`命令,不存在`conda:command not found`的错误信息.\n\n但是,如果在平台上以**提交任务**的形式来使用带conda的镜像所产生的容器时,就算是在镜像中配置了`echo 'export PATH=\"~/anaconda3/bin:$PATH\"' >> ~/.bashrc`,当提交任务时环境变量中仍然没有`~/anaconda3/bin`,这个问题目前没有找到比较方便的解决办法,目前所采用的方式是:\n\n在提交任务时, 首先加上命令`export PATH=\"~/anaconda3/bin:$PATH\" && `\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-25-17.png)\n\n接着又实验了一下`echo 'export PATH=\"~/anaconda3/bin:$PATH\"' >> /etc/profile`, 正常来说, 如果在容器中这样设置环境变量, 等待下次从镜像创建容器时, 这个环境变量一般并不会生效, 但是不知道这样设置对于提交任务方式来说有没有效, 索性试了一下\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-35-56.png)\n\n根据输出日志来看, 这种方式也并没有奏效\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-39-26.png)\n\n当然, 如果觉得上述配置比较麻烦的话,可以使用`Dockerfile`的`ENV`命令来设置环境变量, 这样设置99%是不会有问题的\n\n```\nFROM hub.hoc.ccshu.net/wjs/mlunityv060:v1.4.5\nENV PATH /usr/miniconda3/bin:$PATH\n```\n实验了一下,\n结果如下:\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_15-02-16.png)\n\n表示可以使用`conda`命令, 但是不能使用`conda activate`命令激活环境\n\n根据错误信息, 在`Dockerfile`中写入以下代码也不可行:\n\n`RUN ln -s /usr/miniconda3/etc/profile.d/conda.sh /etc/profile.d/conda.sh`\n\n查了一下相关资料,发现在4.5版本的conda是无解的\n[https://github.com/ContinuumIO/docker-images/issues/89](https://github.com/ContinuumIO/docker-images/issues/89)\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_22-38-42.png)\n\n希望4.6版本可以解决吧\n\n**更新2019年1月14日14:26:01**\n**已解决**\n\n4.6版本的确可以解决以提交任务模式运行时的问题, 需要使用命令`conda run -n [环境名字] [要执行的命令]`, 而不是使用`conda activate [环境名字]`先激活一个环境.\n\n不过, 更新至4.6版本需要相关配置\n```\nconda config --add channels conda-canary\nconda update conda\n```\n\n我使用Dockerfile来生成镜像, 代码如下:\n```\nFROM hub.hoc.ccshu.net/wjs/mlunityv060:v1.4.6\n\nENV PATH /usr/miniconda3/bin:$PATH\nRUN conda config --add channels conda-canary && conda update conda -y\n```\n原因是, 使用Dockerfile比较容易设置环境变量, 减少出错\n","source":"_posts/创建ML-Agents的Docker镜像.md","raw":"---\ntitle: 创建ML-Agents的Docker镜像\ncopyright: true\ntop: 1\ndate: 2019-01-04 10:38:59\ncategories:\n- Docker\n- Unity\ntags:\n- docker\n- unity\n- ml-agents\n\n---\n\n# 创建ML-Agents的Docker镜像\n\n<!--more-->\n\n## 前言\n\n  如果需要在镜像中使用GPU训练,可以将Nvidia的官方镜像作为基础镜像,`Dockerfile`如下:\n```\nFROM nvidia/cuda:9.0-base-ubuntu16.04\nLABEL maintainer \"NVIDIA CORPORATION <cudatools@nvidia.com>\"\n\nENV NCCL_VERSION 2.3.7\n\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n\tapt-utils \\\n        cuda-libraries-$CUDA_PKG_VERSION \\\n        cuda-cublas-9-0=9.0.176.4-1 \\\n        libnccl2=$NCCL_VERSION-1+cuda9.0 && \\\n    apt-mark hold libnccl2 && \\\n    rm -rf /var/lib/apt/lists/*\n\nRUN apt-get update && apt-get install -y openssh-server\n\nRUN apt-get install -y nano\n\nRUN mkdir /var/run/sshd\n\nRUN echo \"root:1234\" | chpasswd\n\nRUN sed -i 's/prohibit-password/yes/g' /etc/ssh/sshd_config\n\nEXPOSE 22\n\nENTRYPOINT [\"/usr/sbin/sshd\",\"-D\"]\n```\n\n## ML-Agents v0.6.0\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-44-58.png)\n\n### 环境\n\n本机环境\n\n- ML-Agents 0.6.0\n- Windows 10 专业版\n- docker client version 18.09.0\n- docker server version 18.09.0\n\n平台\n- [机器学习平台](http://10.0.4.228)\n\n### 创建镜像\n\n1. 打开`~/ml-agents-0.6.0/`目录,看到有一个官方给定的`Dockerfile`\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-52-49.png)\n2. 直接`Build`,在该目录下运行`docker build -t [name]:[tag] .`,一定要注意最后的`.`,很**重要**\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-29-30.png)\n3. 新建一个`sources.list`文件,为镜像内换源,因为将来有可能需要在容器内安装某些包,有一些国外的资源往往会下载失败,所以需要**换源**\n- 新建一个`sources.list`\n- 用文本编辑器打开,写入以下内容\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-36-31.png)\n```\n# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted\ndeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties\ndeb http://archive.canonical.com/ubuntu xenial partner\ndeb-src http://archive.canonical.com/ubuntu xenial partner\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse\n```\n- 保存退出\n4. 新建一个`DockerfilePlus`,在官方生成的基础镜像上安装一些可以在平台上运行的包,`openssh-server`,联网工具`net-tools`,心爱的`apt-file`等等\n- 新建一个`DockerfilePlus`\n- 用文本编辑器打开,输入以下内容\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-01-32.png)\n```\nFROM hub.hoc.ccshu.net/wjs/mlunityv060:v0.1\n\nRUN cp /etc/apt/sources.list /etc/apt/sources.list.bak\nCOPY sources.list /etc/apt/sources.list\n\nENV PYTHONPATH /ml-agents:$PYTHONPATH\n\nRUN apt-get update && apt-get install -y \\\n        apt-file \\\n        nano \\\n        net-tools \\\n        iputils-ping \\\n        openssh-server \\\n        apt-utils \\\n    && rm -rf /var/lib/apt/lists/* \\\n    && mkdir /var/run/sshd \\\n    && echo \"root:1234\" | chpasswd \\\n    && sed -i 's/prohibit-password/yes/g' /etc/ssh/sshd_config\n\nEXPOSE 22\n\nENTRYPOINT [\"/usr/sbin/sshd\",\"-D\"]\n```\n5. 在`DockerfilePlus`所在文件夹下,执行`build -t [name]:[tag] -f DockerfilePlus .`\n\n**为了使用GPU.改写完的Dockerfile如下(不需要看):**\n```\nFROM nvidia/cuda:9.0-base-ubuntu16.04\nLABEL maintainer \"Keavnn <https://stepneverstop.github.io>\"\n\nENV NCCL_VERSION 2.3.7\n\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n\tapt-utils \\\n        cuda-libraries-$CUDA_PKG_VERSION \\\n        cuda-cublas-9-0=9.0.176.4-1 \\\n        libnccl2=$NCCL_VERSION-1+cuda9.0 && \\\n    apt-mark hold libnccl2 && \\\n    rm -rf /var/lib/apt/lists/*\n\n\n# ensure local python is preferred over distribution python\nENV PATH /usr/local/bin:$PATH\n\n# http://bugs.python.org/issue19846\n# > At the moment, setting \"LANG=C\" on a Linux system *fundamentally breaks Python 3*, and that's not OK.\nENV LANG C.UTF-8\n\n# runtime dependencies\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n\t\tca-certificates \\\n\t\tlibexpat1 \\\n\t\tlibffi6 \\\n\t\tlibgdbm3 \\\n\t\tlibreadline6 \\\n\t\tlibsqlite3-0 \\\n\t\tlibssl1.0.0 \\\n\t&& rm -rf /var/lib/apt/lists/*\n\nENV GPG_KEY 0D96DF4D4110E5C43FBFB17F2D347EA6AA65421D\nENV PYTHON_VERSION 3.6.4\n\nRUN set -ex \\\n\t&& buildDeps=\" \\\n\t\tdpkg-dev \\\n\t\tgcc \\\n\t\tlibbz2-dev \\\n\t\tlibc6-dev \\\n\t\tlibexpat1-dev \\\n\t\tlibffi-dev \\\n\t\tlibgdbm-dev \\\n\t\tliblzma-dev \\\n\t\tlibncursesw5-dev \\\n\t\tlibreadline-dev \\\n\t\tlibsqlite3-dev \\\n\t\tlibssl-dev \\\n\t\tmake \\\n\t\ttcl-dev \\\n\t\ttk-dev \\\n\t\twget \\\n\t\txz-utils \\\n\t\tzlib1g-dev \\\n# as of Stretch, \"gpg\" is no longer included by default\n\t\t$(command -v gpg > /dev/null || echo 'gnupg dirmngr') \\\n\t\" \\\n\t&& apt-get update && apt-get install -y $buildDeps --no-install-recommends && rm -rf /var/lib/apt/lists/* \\\n\t\\\n\t&& wget -O python.tar.xz \"https://www.python.org/ftp/python/${PYTHON_VERSION%%[a-z]*}/Python-$PYTHON_VERSION.tar.xz\" \\\n\t&& wget -O python.tar.xz.asc \"https://www.python.org/ftp/python/${PYTHON_VERSION%%[a-z]*}/Python-$PYTHON_VERSION.tar.xz.asc\" \\\n\t&& export GNUPGHOME=\"$(mktemp -d)\" \\\n\t&& gpg --keyserver ha.pool.sks-keyservers.net --recv-keys \"$GPG_KEY\" \\\n\t&& gpg --batch --verify python.tar.xz.asc python.tar.xz \\\n\t&& rm -rf \"$GNUPGHOME\" python.tar.xz.asc \\\n\t&& mkdir -p /usr/src/python \\\n\t&& tar -xJC /usr/src/python --strip-components=1 -f python.tar.xz \\\n\t&& rm python.tar.xz \\\n\t\\\n\t&& cd /usr/src/python \\\n\t&& gnuArch=\"$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)\" \\\n\t&& ./configure \\\n\t\t--build=\"$gnuArch\" \\\n\t\t--enable-loadable-sqlite-extensions \\\n\t\t--enable-shared \\\n\t\t--with-system-expat \\\n\t\t--with-system-ffi \\\n\t\t--without-ensurepip \\\n\t&& make -j \"$(nproc)\" \\\n\t&& make install \\\n\t&& ldconfig \\\n\t\\\n\t&& apt-get purge -y --auto-remove $buildDeps \\\n\t\\\n\t&& find /usr/local -depth \\\n\t\t\\( \\\n\t\t\t\\( -type d -a \\( -name test -o -name tests \\) \\) \\\n\t\t\t-o \\\n\t\t\t\\( -type f -a \\( -name '*.pyc' -o -name '*.pyo' \\) \\) \\\n\t\t\\) -exec rm -rf '{}' + \\\n\t&& rm -rf /usr/src/python\n\n# make some useful symlinks that are expected to exist\nRUN cd /usr/local/bin \\\n\t&& ln -s idle3 idle \\\n\t&& ln -s pydoc3 pydoc \\\n\t&& ln -s python3 python \\\n\t&& ln -s python3-config python-config\n\n# if this is called \"PIP_VERSION\", pip explodes with \"ValueError: invalid truth value '<VERSION>'\"\nENV PYTHON_PIP_VERSION 9.0.3\n\nRUN set -ex; \\\n\t\\\n\tapt-get update; \\\n\tapt-get install -y --no-install-recommends wget; \\\n\trm -rf /var/lib/apt/lists/*; \\\n\t\\\n\twget -O get-pip.py 'https://bootstrap.pypa.io/get-pip.py'; \\\n\t\\\n\tapt-get purge -y --auto-remove wget; \\\n\t\\\n\tpython get-pip.py \\\n\t\t--disable-pip-version-check \\\n\t\t--no-cache-dir \\\n\t\t\"pip==$PYTHON_PIP_VERSION\" \\\n\t; \\\n\tpip --version; \\\n\t\\\n\tfind /usr/local -depth \\\n\t\t\\( \\\n\t\t\t\\( -type d -a \\( -name test -o -name tests \\) \\) \\\n\t\t\t-o \\\n\t\t\t\\( -type f -a \\( -name '*.pyc' -o -name '*.pyo' \\) \\) \\\n\t\t\\) -exec rm -rf '{}' +; \\\n\trm -f get-pip.py\n\n\nRUN apt-get update && apt-get -y upgrade\n\n# xvfb is used to do CPU based rendering of Unity\nRUN apt-get install -y xvfb\n\nCOPY ml-agents /ml-agents\nWORKDIR /ml-agents\nRUN pip install .\n\n# port 5005 is the port used in in Editor training.\nEXPOSE 5005\n\nRUN cp /etc/apt/sources.list /etc/apt/sources.list.bak\nCOPY sources.list /etc/apt/sources.list\n\nENV PYTHONPATH /ml-agents:$PYTHONPATH\n\nRUN apt-get update && apt-get install -y \\\n        apt-file \\\n        nano \\\n        net-tools \\\n        iputils-ping \\\n        openssh-server \\\n        apt-utils \\\n    && rm -rf /var/lib/apt/lists/* \\\n    && mkdir /var/run/sshd \\\n    && echo \"root:1234\" | chpasswd \\\n    && sed -i 's/prohibit-password/yes/g' /etc/ssh/sshd_config\n\nEXPOSE 22\n\nENTRYPOINT [\"/usr/sbin/sshd\",\"-D\"]\n```\n\n### PUSH镜像\n\n`docker push [name]:[tag]`\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-02-47.png)\n\n### 测试镜像\n\n- 登录[机器学习平台](http://10.0.4.228),没有使用平台的可以在本地使用`docker run`直接开启容器\n- 先测试使用容器的方式\n  - 创建容器\n  ![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-28-19.png)\n  将要运行和储存的文件夹放在数据卷`data`下,这个目录要在运行时由`--docker-target-name`指定\n  - 等待容器创建成功\n  ![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-15.png)\n  - 容器创建成功后进入容器\n  ![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-52.png)\n  - 执行`mlagents-learn trainer_config.yaml --docker-target-name=data/unity-volume --env=3dball --train --run-id=test --save-freq=5000 | tee /data/unity-volume/log.txt`,如果不想在屏幕输出,可以在后边加上`>/dev/null`\n  ![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-16-44.png)\n  ![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-18-40.png)\n  \n---\n\n## 安装Miniconda\n\n确保你的安装包放在了data文件夹下\n`apt-get update && apt-get install bzip2 -y && cd /data && bash Miniconda3-latest-Linux-x86_64.sh`\n\n一路按回车、yes等等就成功了.如果需要安装到指定目录,在安装过程中会有提示告诉你让你指定安装路径\n\n*注意*\n\n在[学校机器学习平台](http://10.0.4.228/)上使用时,如果是使用容器的方式,那么新开的容器就可以使用`conda`命令,不存在`conda:command not found`的错误信息.\n\n但是,如果在平台上以**提交任务**的形式来使用带conda的镜像所产生的容器时,就算是在镜像中配置了`echo 'export PATH=\"~/anaconda3/bin:$PATH\"' >> ~/.bashrc`,当提交任务时环境变量中仍然没有`~/anaconda3/bin`,这个问题目前没有找到比较方便的解决办法,目前所采用的方式是:\n\n在提交任务时, 首先加上命令`export PATH=\"~/anaconda3/bin:$PATH\" && `\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-25-17.png)\n\n接着又实验了一下`echo 'export PATH=\"~/anaconda3/bin:$PATH\"' >> /etc/profile`, 正常来说, 如果在容器中这样设置环境变量, 等待下次从镜像创建容器时, 这个环境变量一般并不会生效, 但是不知道这样设置对于提交任务方式来说有没有效, 索性试了一下\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-35-56.png)\n\n根据输出日志来看, 这种方式也并没有奏效\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-39-26.png)\n\n当然, 如果觉得上述配置比较麻烦的话,可以使用`Dockerfile`的`ENV`命令来设置环境变量, 这样设置99%是不会有问题的\n\n```\nFROM hub.hoc.ccshu.net/wjs/mlunityv060:v1.4.5\nENV PATH /usr/miniconda3/bin:$PATH\n```\n实验了一下,\n结果如下:\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_15-02-16.png)\n\n表示可以使用`conda`命令, 但是不能使用`conda activate`命令激活环境\n\n根据错误信息, 在`Dockerfile`中写入以下代码也不可行:\n\n`RUN ln -s /usr/miniconda3/etc/profile.d/conda.sh /etc/profile.d/conda.sh`\n\n查了一下相关资料,发现在4.5版本的conda是无解的\n[https://github.com/ContinuumIO/docker-images/issues/89](https://github.com/ContinuumIO/docker-images/issues/89)\n\n![](./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_22-38-42.png)\n\n希望4.6版本可以解决吧\n\n**更新2019年1月14日14:26:01**\n**已解决**\n\n4.6版本的确可以解决以提交任务模式运行时的问题, 需要使用命令`conda run -n [环境名字] [要执行的命令]`, 而不是使用`conda activate [环境名字]`先激活一个环境.\n\n不过, 更新至4.6版本需要相关配置\n```\nconda config --add channels conda-canary\nconda update conda\n```\n\n我使用Dockerfile来生成镜像, 代码如下:\n```\nFROM hub.hoc.ccshu.net/wjs/mlunityv060:v1.4.6\n\nENV PATH /usr/miniconda3/bin:$PATH\nRUN conda config --add channels conda-canary && conda update conda -y\n```\n原因是, 使用Dockerfile比较容易设置环境变量, 减少出错\n","slug":"创建ML-Agents的Docker镜像","published":1,"updated":"2019-05-10T12:39:30.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut99005720cdvkrls0z2","content":"<h1 id=\"创建ML-Agents的Docker镜像\"><a href=\"#创建ML-Agents的Docker镜像\" class=\"headerlink\" title=\"创建ML-Agents的Docker镜像\"></a>创建ML-Agents的Docker镜像</h1><a id=\"more\"></a>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>  如果需要在镜像中使用GPU训练,可以将Nvidia的官方镜像作为基础镜像,<code>Dockerfile</code>如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nvidia/cuda:9.0-base-ubuntu16.04</span><br><span class=\"line\">LABEL maintainer &quot;NVIDIA CORPORATION &lt;cudatools@nvidia.com&gt;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">ENV NCCL_VERSION 2.3.7</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \\</span><br><span class=\"line\">\tapt-utils \\</span><br><span class=\"line\">        cuda-libraries-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-cublas-9-0=9.0.176.4-1 \\</span><br><span class=\"line\">        libnccl2=$NCCL_VERSION-1+cuda9.0 &amp;&amp; \\</span><br><span class=\"line\">    apt-mark hold libnccl2 &amp;&amp; \\</span><br><span class=\"line\">    rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y openssh-server</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get install -y nano</span><br><span class=\"line\"></span><br><span class=\"line\">RUN mkdir /var/run/sshd</span><br><span class=\"line\"></span><br><span class=\"line\">RUN echo &quot;root:1234&quot; | chpasswd</span><br><span class=\"line\"></span><br><span class=\"line\">RUN sed -i &apos;s/prohibit-password/yes/g&apos; /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 22</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ML-Agents-v0-6-0\"><a href=\"#ML-Agents-v0-6-0\" class=\"headerlink\" title=\"ML-Agents v0.6.0\"></a>ML-Agents v0.6.0</h2><p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-44-58.png\" alt=\"\"></p>\n<h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><p>本机环境</p>\n<ul>\n<li>ML-Agents 0.6.0</li>\n<li>Windows 10 专业版</li>\n<li>docker client version 18.09.0</li>\n<li>docker server version 18.09.0</li>\n</ul>\n<p>平台</p>\n<ul>\n<li><a href=\"http://10.0.4.228\" rel=\"external nofollow\" target=\"_blank\">机器学习平台</a></li>\n</ul>\n<h3 id=\"创建镜像\"><a href=\"#创建镜像\" class=\"headerlink\" title=\"创建镜像\"></a>创建镜像</h3><ol>\n<li>打开<code>~/ml-agents-0.6.0/</code>目录,看到有一个官方给定的<code>Dockerfile</code><br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-52-49.png\" alt=\"\"></li>\n<li>直接<code>Build</code>,在该目录下运行<code>docker build -t [name]:[tag] .</code>,一定要注意最后的<code>.</code>,很<strong>重要</strong><br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-29-30.png\" alt=\"\"></li>\n<li>新建一个<code>sources.list</code>文件,为镜像内换源,因为将来有可能需要在容器内安装某些包,有一些国外的资源往往会下载失败,所以需要<strong>换源</strong></li>\n</ol>\n<ul>\n<li>新建一个<code>sources.list</code></li>\n<li><p>用文本编辑器打开,写入以下内容<br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-36-31.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span><br><span class=\"line\">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class=\"line\">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存退出</p>\n</li>\n</ul>\n<ol>\n<li>新建一个<code>DockerfilePlus</code>,在官方生成的基础镜像上安装一些可以在平台上运行的包,<code>openssh-server</code>,联网工具<code>net-tools</code>,心爱的<code>apt-file</code>等等</li>\n</ol>\n<ul>\n<li>新建一个<code>DockerfilePlus</code></li>\n<li>用文本编辑器打开,输入以下内容<br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-01-32.png\" alt=\"\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM hub.hoc.ccshu.net/wjs/mlunityv060:v0.1</span><br><span class=\"line\"></span><br><span class=\"line\">RUN cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class=\"line\">COPY sources.list /etc/apt/sources.list</span><br><span class=\"line\"></span><br><span class=\"line\">ENV PYTHONPATH /ml-agents:$PYTHONPATH</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y \\</span><br><span class=\"line\">        apt-file \\</span><br><span class=\"line\">        nano \\</span><br><span class=\"line\">        net-tools \\</span><br><span class=\"line\">        iputils-ping \\</span><br><span class=\"line\">        openssh-server \\</span><br><span class=\"line\">        apt-utils \\</span><br><span class=\"line\">    &amp;&amp; rm -rf /var/lib/apt/lists/* \\</span><br><span class=\"line\">    &amp;&amp; mkdir /var/run/sshd \\</span><br><span class=\"line\">    &amp;&amp; echo &quot;root:1234&quot; | chpasswd \\</span><br><span class=\"line\">    &amp;&amp; sed -i &apos;s/prohibit-password/yes/g&apos; /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 22</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>在<code>DockerfilePlus</code>所在文件夹下,执行<code>build -t [name]:[tag] -f DockerfilePlus .</code></li>\n</ol>\n<p><strong>为了使用GPU.改写完的Dockerfile如下(不需要看):</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nvidia/cuda:9.0-base-ubuntu16.04</span><br><span class=\"line\">LABEL maintainer &quot;Keavnn &lt;https://stepneverstop.github.io&gt;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">ENV NCCL_VERSION 2.3.7</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \\</span><br><span class=\"line\">\tapt-utils \\</span><br><span class=\"line\">        cuda-libraries-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-cublas-9-0=9.0.176.4-1 \\</span><br><span class=\"line\">        libnccl2=$NCCL_VERSION-1+cuda9.0 &amp;&amp; \\</span><br><span class=\"line\">    apt-mark hold libnccl2 &amp;&amp; \\</span><br><span class=\"line\">    rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># ensure local python is preferred over distribution python</span><br><span class=\"line\">ENV PATH /usr/local/bin:$PATH</span><br><span class=\"line\"></span><br><span class=\"line\"># http://bugs.python.org/issue19846</span><br><span class=\"line\"># &gt; At the moment, setting &quot;LANG=C&quot; on a Linux system *fundamentally breaks Python 3*, and that&apos;s not OK.</span><br><span class=\"line\">ENV LANG C.UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\"># runtime dependencies</span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \\</span><br><span class=\"line\">\t\tca-certificates \\</span><br><span class=\"line\">\t\tlibexpat1 \\</span><br><span class=\"line\">\t\tlibffi6 \\</span><br><span class=\"line\">\t\tlibgdbm3 \\</span><br><span class=\"line\">\t\tlibreadline6 \\</span><br><span class=\"line\">\t\tlibsqlite3-0 \\</span><br><span class=\"line\">\t\tlibssl1.0.0 \\</span><br><span class=\"line\">\t&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\">ENV GPG_KEY 0D96DF4D4110E5C43FBFB17F2D347EA6AA65421D</span><br><span class=\"line\">ENV PYTHON_VERSION 3.6.4</span><br><span class=\"line\"></span><br><span class=\"line\">RUN set -ex \\</span><br><span class=\"line\">\t&amp;&amp; buildDeps=&quot; \\</span><br><span class=\"line\">\t\tdpkg-dev \\</span><br><span class=\"line\">\t\tgcc \\</span><br><span class=\"line\">\t\tlibbz2-dev \\</span><br><span class=\"line\">\t\tlibc6-dev \\</span><br><span class=\"line\">\t\tlibexpat1-dev \\</span><br><span class=\"line\">\t\tlibffi-dev \\</span><br><span class=\"line\">\t\tlibgdbm-dev \\</span><br><span class=\"line\">\t\tliblzma-dev \\</span><br><span class=\"line\">\t\tlibncursesw5-dev \\</span><br><span class=\"line\">\t\tlibreadline-dev \\</span><br><span class=\"line\">\t\tlibsqlite3-dev \\</span><br><span class=\"line\">\t\tlibssl-dev \\</span><br><span class=\"line\">\t\tmake \\</span><br><span class=\"line\">\t\ttcl-dev \\</span><br><span class=\"line\">\t\ttk-dev \\</span><br><span class=\"line\">\t\twget \\</span><br><span class=\"line\">\t\txz-utils \\</span><br><span class=\"line\">\t\tzlib1g-dev \\</span><br><span class=\"line\"># as of Stretch, &quot;gpg&quot; is no longer included by default</span><br><span class=\"line\">\t\t$(command -v gpg &gt; /dev/null || echo &apos;gnupg dirmngr&apos;) \\</span><br><span class=\"line\">\t&quot; \\</span><br><span class=\"line\">\t&amp;&amp; apt-get update &amp;&amp; apt-get install -y $buildDeps --no-install-recommends &amp;&amp; rm -rf /var/lib/apt/lists/* \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\t&amp;&amp; wget -O python.tar.xz &quot;https://www.python.org/ftp/python/$&#123;PYTHON_VERSION%%[a-z]*&#125;/Python-$PYTHON_VERSION.tar.xz&quot; \\</span><br><span class=\"line\">\t&amp;&amp; wget -O python.tar.xz.asc &quot;https://www.python.org/ftp/python/$&#123;PYTHON_VERSION%%[a-z]*&#125;/Python-$PYTHON_VERSION.tar.xz.asc&quot; \\</span><br><span class=\"line\">\t&amp;&amp; export GNUPGHOME=&quot;$(mktemp -d)&quot; \\</span><br><span class=\"line\">\t&amp;&amp; gpg --keyserver ha.pool.sks-keyservers.net --recv-keys &quot;$GPG_KEY&quot; \\</span><br><span class=\"line\">\t&amp;&amp; gpg --batch --verify python.tar.xz.asc python.tar.xz \\</span><br><span class=\"line\">\t&amp;&amp; rm -rf &quot;$GNUPGHOME&quot; python.tar.xz.asc \\</span><br><span class=\"line\">\t&amp;&amp; mkdir -p /usr/src/python \\</span><br><span class=\"line\">\t&amp;&amp; tar -xJC /usr/src/python --strip-components=1 -f python.tar.xz \\</span><br><span class=\"line\">\t&amp;&amp; rm python.tar.xz \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\t&amp;&amp; cd /usr/src/python \\</span><br><span class=\"line\">\t&amp;&amp; gnuArch=&quot;$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)&quot; \\</span><br><span class=\"line\">\t&amp;&amp; ./configure \\</span><br><span class=\"line\">\t\t--build=&quot;$gnuArch&quot; \\</span><br><span class=\"line\">\t\t--enable-loadable-sqlite-extensions \\</span><br><span class=\"line\">\t\t--enable-shared \\</span><br><span class=\"line\">\t\t--with-system-expat \\</span><br><span class=\"line\">\t\t--with-system-ffi \\</span><br><span class=\"line\">\t\t--without-ensurepip \\</span><br><span class=\"line\">\t&amp;&amp; make -j &quot;$(nproc)&quot; \\</span><br><span class=\"line\">\t&amp;&amp; make install \\</span><br><span class=\"line\">\t&amp;&amp; ldconfig \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\t&amp;&amp; apt-get purge -y --auto-remove $buildDeps \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\t&amp;&amp; find /usr/local -depth \\</span><br><span class=\"line\">\t\t\\( \\</span><br><span class=\"line\">\t\t\t\\( -type d -a \\( -name test -o -name tests \\) \\) \\</span><br><span class=\"line\">\t\t\t-o \\</span><br><span class=\"line\">\t\t\t\\( -type f -a \\( -name &apos;*.pyc&apos; -o -name &apos;*.pyo&apos; \\) \\) \\</span><br><span class=\"line\">\t\t\\) -exec rm -rf &apos;&#123;&#125;&apos; + \\</span><br><span class=\"line\">\t&amp;&amp; rm -rf /usr/src/python</span><br><span class=\"line\"></span><br><span class=\"line\"># make some useful symlinks that are expected to exist</span><br><span class=\"line\">RUN cd /usr/local/bin \\</span><br><span class=\"line\">\t&amp;&amp; ln -s idle3 idle \\</span><br><span class=\"line\">\t&amp;&amp; ln -s pydoc3 pydoc \\</span><br><span class=\"line\">\t&amp;&amp; ln -s python3 python \\</span><br><span class=\"line\">\t&amp;&amp; ln -s python3-config python-config</span><br><span class=\"line\"></span><br><span class=\"line\"># if this is called &quot;PIP_VERSION&quot;, pip explodes with &quot;ValueError: invalid truth value &apos;&lt;VERSION&gt;&apos;&quot;</span><br><span class=\"line\">ENV PYTHON_PIP_VERSION 9.0.3</span><br><span class=\"line\"></span><br><span class=\"line\">RUN set -ex; \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\tapt-get update; \\</span><br><span class=\"line\">\tapt-get install -y --no-install-recommends wget; \\</span><br><span class=\"line\">\trm -rf /var/lib/apt/lists/*; \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\twget -O get-pip.py &apos;https://bootstrap.pypa.io/get-pip.py&apos;; \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\tapt-get purge -y --auto-remove wget; \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\tpython get-pip.py \\</span><br><span class=\"line\">\t\t--disable-pip-version-check \\</span><br><span class=\"line\">\t\t--no-cache-dir \\</span><br><span class=\"line\">\t\t&quot;pip==$PYTHON_PIP_VERSION&quot; \\</span><br><span class=\"line\">\t; \\</span><br><span class=\"line\">\tpip --version; \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\tfind /usr/local -depth \\</span><br><span class=\"line\">\t\t\\( \\</span><br><span class=\"line\">\t\t\t\\( -type d -a \\( -name test -o -name tests \\) \\) \\</span><br><span class=\"line\">\t\t\t-o \\</span><br><span class=\"line\">\t\t\t\\( -type f -a \\( -name &apos;*.pyc&apos; -o -name &apos;*.pyo&apos; \\) \\) \\</span><br><span class=\"line\">\t\t\\) -exec rm -rf &apos;&#123;&#125;&apos; +; \\</span><br><span class=\"line\">\trm -f get-pip.py</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get -y upgrade</span><br><span class=\"line\"></span><br><span class=\"line\"># xvfb is used to do CPU based rendering of Unity</span><br><span class=\"line\">RUN apt-get install -y xvfb</span><br><span class=\"line\"></span><br><span class=\"line\">COPY ml-agents /ml-agents</span><br><span class=\"line\">WORKDIR /ml-agents</span><br><span class=\"line\">RUN pip install .</span><br><span class=\"line\"></span><br><span class=\"line\"># port 5005 is the port used in in Editor training.</span><br><span class=\"line\">EXPOSE 5005</span><br><span class=\"line\"></span><br><span class=\"line\">RUN cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class=\"line\">COPY sources.list /etc/apt/sources.list</span><br><span class=\"line\"></span><br><span class=\"line\">ENV PYTHONPATH /ml-agents:$PYTHONPATH</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y \\</span><br><span class=\"line\">        apt-file \\</span><br><span class=\"line\">        nano \\</span><br><span class=\"line\">        net-tools \\</span><br><span class=\"line\">        iputils-ping \\</span><br><span class=\"line\">        openssh-server \\</span><br><span class=\"line\">        apt-utils \\</span><br><span class=\"line\">    &amp;&amp; rm -rf /var/lib/apt/lists/* \\</span><br><span class=\"line\">    &amp;&amp; mkdir /var/run/sshd \\</span><br><span class=\"line\">    &amp;&amp; echo &quot;root:1234&quot; | chpasswd \\</span><br><span class=\"line\">    &amp;&amp; sed -i &apos;s/prohibit-password/yes/g&apos; /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 22</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"PUSH镜像\"><a href=\"#PUSH镜像\" class=\"headerlink\" title=\"PUSH镜像\"></a>PUSH镜像</h3><p><code>docker push [name]:[tag]</code><br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-02-47.png\" alt=\"\"></p>\n<h3 id=\"测试镜像\"><a href=\"#测试镜像\" class=\"headerlink\" title=\"测试镜像\"></a>测试镜像</h3><ul>\n<li>登录<a href=\"http://10.0.4.228\" rel=\"external nofollow\" target=\"_blank\">机器学习平台</a>,没有使用平台的可以在本地使用<code>docker run</code>直接开启容器</li>\n<li>先测试使用容器的方式<ul>\n<li>创建容器<br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-28-19.png\" alt=\"\"><br>将要运行和储存的文件夹放在数据卷<code>data</code>下,这个目录要在运行时由<code>--docker-target-name</code>指定</li>\n<li>等待容器创建成功<br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-15.png\" alt=\"\"></li>\n<li>容器创建成功后进入容器<br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-52.png\" alt=\"\"></li>\n<li>执行<code>mlagents-learn trainer_config.yaml --docker-target-name=data/unity-volume --env=3dball --train --run-id=test --save-freq=5000 | tee /data/unity-volume/log.txt</code>,如果不想在屏幕输出,可以在后边加上<code>&gt;/dev/null</code><br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-16-44.png\" alt=\"\"><br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-18-40.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"安装Miniconda\"><a href=\"#安装Miniconda\" class=\"headerlink\" title=\"安装Miniconda\"></a>安装Miniconda</h2><p>确保你的安装包放在了data文件夹下<br><code>apt-get update &amp;&amp; apt-get install bzip2 -y &amp;&amp; cd /data &amp;&amp; bash Miniconda3-latest-Linux-x86_64.sh</code></p>\n<p>一路按回车、yes等等就成功了.如果需要安装到指定目录,在安装过程中会有提示告诉你让你指定安装路径</p>\n<p><em>注意</em></p>\n<p>在<a href=\"http://10.0.4.228/\" rel=\"external nofollow\" target=\"_blank\">学校机器学习平台</a>上使用时,如果是使用容器的方式,那么新开的容器就可以使用<code>conda</code>命令,不存在<code>conda:command not found</code>的错误信息.</p>\n<p>但是,如果在平台上以<strong>提交任务</strong>的形式来使用带conda的镜像所产生的容器时,就算是在镜像中配置了<code>echo &#39;export PATH=&quot;~/anaconda3/bin:$PATH&quot;&#39; &gt;&gt; ~/.bashrc</code>,当提交任务时环境变量中仍然没有<code>~/anaconda3/bin</code>,这个问题目前没有找到比较方便的解决办法,目前所采用的方式是:</p>\n<p>在提交任务时, 首先加上命令<code>export PATH=&quot;~/anaconda3/bin:$PATH&quot; &amp;&amp;</code></p>\n<p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-25-17.png\" alt=\"\"></p>\n<p>接着又实验了一下<code>echo &#39;export PATH=&quot;~/anaconda3/bin:$PATH&quot;&#39; &gt;&gt; /etc/profile</code>, 正常来说, 如果在容器中这样设置环境变量, 等待下次从镜像创建容器时, 这个环境变量一般并不会生效, 但是不知道这样设置对于提交任务方式来说有没有效, 索性试了一下</p>\n<p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-35-56.png\" alt=\"\"></p>\n<p>根据输出日志来看, 这种方式也并没有奏效</p>\n<p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-39-26.png\" alt=\"\"></p>\n<p>当然, 如果觉得上述配置比较麻烦的话,可以使用<code>Dockerfile</code>的<code>ENV</code>命令来设置环境变量, 这样设置99%是不会有问题的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM hub.hoc.ccshu.net/wjs/mlunityv060:v1.4.5</span><br><span class=\"line\">ENV PATH /usr/miniconda3/bin:$PATH</span><br></pre></td></tr></table></figure>\n<p>实验了一下,<br>结果如下:</p>\n<p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_15-02-16.png\" alt=\"\"></p>\n<p>表示可以使用<code>conda</code>命令, 但是不能使用<code>conda activate</code>命令激活环境</p>\n<p>根据错误信息, 在<code>Dockerfile</code>中写入以下代码也不可行:</p>\n<p><code>RUN ln -s /usr/miniconda3/etc/profile.d/conda.sh /etc/profile.d/conda.sh</code></p>\n<p>查了一下相关资料,发现在4.5版本的conda是无解的<br><a href=\"https://github.com/ContinuumIO/docker-images/issues/89\" rel=\"external nofollow\" target=\"_blank\">https://github.com/ContinuumIO/docker-images/issues/89</a></p>\n<p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_22-38-42.png\" alt=\"\"></p>\n<p>希望4.6版本可以解决吧</p>\n<p><strong>更新2019年1月14日14:26:01</strong><br><strong>已解决</strong></p>\n<p>4.6版本的确可以解决以提交任务模式运行时的问题, 需要使用命令<code>conda run -n [环境名字] [要执行的命令]</code>, 而不是使用<code>conda activate [环境名字]</code>先激活一个环境.</p>\n<p>不过, 更新至4.6版本需要相关配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --add channels conda-canary</span><br><span class=\"line\">conda update conda</span><br></pre></td></tr></table></figure></p>\n<p>我使用Dockerfile来生成镜像, 代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM hub.hoc.ccshu.net/wjs/mlunityv060:v1.4.6</span><br><span class=\"line\"></span><br><span class=\"line\">ENV PATH /usr/miniconda3/bin:$PATH</span><br><span class=\"line\">RUN conda config --add channels conda-canary &amp;&amp; conda update conda -y</span><br></pre></td></tr></table></figure></p>\n<p>原因是, 使用Dockerfile比较容易设置环境变量, 减少出错</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"创建ML-Agents的Docker镜像\"><a href=\"#创建ML-Agents的Docker镜像\" class=\"headerlink\" title=\"创建ML-Agents的Docker镜像\"></a>创建ML-Agents的Docker镜像</h1>","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>  如果需要在镜像中使用GPU训练,可以将Nvidia的官方镜像作为基础镜像,<code>Dockerfile</code>如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nvidia/cuda:9.0-base-ubuntu16.04</span><br><span class=\"line\">LABEL maintainer &quot;NVIDIA CORPORATION &lt;cudatools@nvidia.com&gt;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">ENV NCCL_VERSION 2.3.7</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \\</span><br><span class=\"line\">\tapt-utils \\</span><br><span class=\"line\">        cuda-libraries-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-cublas-9-0=9.0.176.4-1 \\</span><br><span class=\"line\">        libnccl2=$NCCL_VERSION-1+cuda9.0 &amp;&amp; \\</span><br><span class=\"line\">    apt-mark hold libnccl2 &amp;&amp; \\</span><br><span class=\"line\">    rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y openssh-server</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get install -y nano</span><br><span class=\"line\"></span><br><span class=\"line\">RUN mkdir /var/run/sshd</span><br><span class=\"line\"></span><br><span class=\"line\">RUN echo &quot;root:1234&quot; | chpasswd</span><br><span class=\"line\"></span><br><span class=\"line\">RUN sed -i &apos;s/prohibit-password/yes/g&apos; /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 22</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ML-Agents-v0-6-0\"><a href=\"#ML-Agents-v0-6-0\" class=\"headerlink\" title=\"ML-Agents v0.6.0\"></a>ML-Agents v0.6.0</h2><p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-44-58.png\" alt=\"\"></p>\n<h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><p>本机环境</p>\n<ul>\n<li>ML-Agents 0.6.0</li>\n<li>Windows 10 专业版</li>\n<li>docker client version 18.09.0</li>\n<li>docker server version 18.09.0</li>\n</ul>\n<p>平台</p>\n<ul>\n<li><a href=\"http://10.0.4.228\" rel=\"external nofollow\" target=\"_blank\">机器学习平台</a></li>\n</ul>\n<h3 id=\"创建镜像\"><a href=\"#创建镜像\" class=\"headerlink\" title=\"创建镜像\"></a>创建镜像</h3><ol>\n<li>打开<code>~/ml-agents-0.6.0/</code>目录,看到有一个官方给定的<code>Dockerfile</code><br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-52-49.png\" alt=\"\"></li>\n<li>直接<code>Build</code>,在该目录下运行<code>docker build -t [name]:[tag] .</code>,一定要注意最后的<code>.</code>,很<strong>重要</strong><br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-29-30.png\" alt=\"\"></li>\n<li>新建一个<code>sources.list</code>文件,为镜像内换源,因为将来有可能需要在容器内安装某些包,有一些国外的资源往往会下载失败,所以需要<strong>换源</strong></li>\n</ol>\n<ul>\n<li>新建一个<code>sources.list</code></li>\n<li><p>用文本编辑器打开,写入以下内容<br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-36-31.png\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span><br><span class=\"line\">deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class=\"line\">deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class=\"line\">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class=\"line\">deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存退出</p>\n</li>\n</ul>\n<ol>\n<li>新建一个<code>DockerfilePlus</code>,在官方生成的基础镜像上安装一些可以在平台上运行的包,<code>openssh-server</code>,联网工具<code>net-tools</code>,心爱的<code>apt-file</code>等等</li>\n</ol>\n<ul>\n<li>新建一个<code>DockerfilePlus</code></li>\n<li>用文本编辑器打开,输入以下内容<br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-01-32.png\" alt=\"\"><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM hub.hoc.ccshu.net/wjs/mlunityv060:v0.1</span><br><span class=\"line\"></span><br><span class=\"line\">RUN cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class=\"line\">COPY sources.list /etc/apt/sources.list</span><br><span class=\"line\"></span><br><span class=\"line\">ENV PYTHONPATH /ml-agents:$PYTHONPATH</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y \\</span><br><span class=\"line\">        apt-file \\</span><br><span class=\"line\">        nano \\</span><br><span class=\"line\">        net-tools \\</span><br><span class=\"line\">        iputils-ping \\</span><br><span class=\"line\">        openssh-server \\</span><br><span class=\"line\">        apt-utils \\</span><br><span class=\"line\">    &amp;&amp; rm -rf /var/lib/apt/lists/* \\</span><br><span class=\"line\">    &amp;&amp; mkdir /var/run/sshd \\</span><br><span class=\"line\">    &amp;&amp; echo &quot;root:1234&quot; | chpasswd \\</span><br><span class=\"line\">    &amp;&amp; sed -i &apos;s/prohibit-password/yes/g&apos; /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 22</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>在<code>DockerfilePlus</code>所在文件夹下,执行<code>build -t [name]:[tag] -f DockerfilePlus .</code></li>\n</ol>\n<p><strong>为了使用GPU.改写完的Dockerfile如下(不需要看):</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM nvidia/cuda:9.0-base-ubuntu16.04</span><br><span class=\"line\">LABEL maintainer &quot;Keavnn &lt;https://stepneverstop.github.io&gt;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">ENV NCCL_VERSION 2.3.7</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \\</span><br><span class=\"line\">\tapt-utils \\</span><br><span class=\"line\">        cuda-libraries-$CUDA_PKG_VERSION \\</span><br><span class=\"line\">        cuda-cublas-9-0=9.0.176.4-1 \\</span><br><span class=\"line\">        libnccl2=$NCCL_VERSION-1+cuda9.0 &amp;&amp; \\</span><br><span class=\"line\">    apt-mark hold libnccl2 &amp;&amp; \\</span><br><span class=\"line\">    rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># ensure local python is preferred over distribution python</span><br><span class=\"line\">ENV PATH /usr/local/bin:$PATH</span><br><span class=\"line\"></span><br><span class=\"line\"># http://bugs.python.org/issue19846</span><br><span class=\"line\"># &gt; At the moment, setting &quot;LANG=C&quot; on a Linux system *fundamentally breaks Python 3*, and that&apos;s not OK.</span><br><span class=\"line\">ENV LANG C.UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\"># runtime dependencies</span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \\</span><br><span class=\"line\">\t\tca-certificates \\</span><br><span class=\"line\">\t\tlibexpat1 \\</span><br><span class=\"line\">\t\tlibffi6 \\</span><br><span class=\"line\">\t\tlibgdbm3 \\</span><br><span class=\"line\">\t\tlibreadline6 \\</span><br><span class=\"line\">\t\tlibsqlite3-0 \\</span><br><span class=\"line\">\t\tlibssl1.0.0 \\</span><br><span class=\"line\">\t&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\">ENV GPG_KEY 0D96DF4D4110E5C43FBFB17F2D347EA6AA65421D</span><br><span class=\"line\">ENV PYTHON_VERSION 3.6.4</span><br><span class=\"line\"></span><br><span class=\"line\">RUN set -ex \\</span><br><span class=\"line\">\t&amp;&amp; buildDeps=&quot; \\</span><br><span class=\"line\">\t\tdpkg-dev \\</span><br><span class=\"line\">\t\tgcc \\</span><br><span class=\"line\">\t\tlibbz2-dev \\</span><br><span class=\"line\">\t\tlibc6-dev \\</span><br><span class=\"line\">\t\tlibexpat1-dev \\</span><br><span class=\"line\">\t\tlibffi-dev \\</span><br><span class=\"line\">\t\tlibgdbm-dev \\</span><br><span class=\"line\">\t\tliblzma-dev \\</span><br><span class=\"line\">\t\tlibncursesw5-dev \\</span><br><span class=\"line\">\t\tlibreadline-dev \\</span><br><span class=\"line\">\t\tlibsqlite3-dev \\</span><br><span class=\"line\">\t\tlibssl-dev \\</span><br><span class=\"line\">\t\tmake \\</span><br><span class=\"line\">\t\ttcl-dev \\</span><br><span class=\"line\">\t\ttk-dev \\</span><br><span class=\"line\">\t\twget \\</span><br><span class=\"line\">\t\txz-utils \\</span><br><span class=\"line\">\t\tzlib1g-dev \\</span><br><span class=\"line\"># as of Stretch, &quot;gpg&quot; is no longer included by default</span><br><span class=\"line\">\t\t$(command -v gpg &gt; /dev/null || echo &apos;gnupg dirmngr&apos;) \\</span><br><span class=\"line\">\t&quot; \\</span><br><span class=\"line\">\t&amp;&amp; apt-get update &amp;&amp; apt-get install -y $buildDeps --no-install-recommends &amp;&amp; rm -rf /var/lib/apt/lists/* \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\t&amp;&amp; wget -O python.tar.xz &quot;https://www.python.org/ftp/python/$&#123;PYTHON_VERSION%%[a-z]*&#125;/Python-$PYTHON_VERSION.tar.xz&quot; \\</span><br><span class=\"line\">\t&amp;&amp; wget -O python.tar.xz.asc &quot;https://www.python.org/ftp/python/$&#123;PYTHON_VERSION%%[a-z]*&#125;/Python-$PYTHON_VERSION.tar.xz.asc&quot; \\</span><br><span class=\"line\">\t&amp;&amp; export GNUPGHOME=&quot;$(mktemp -d)&quot; \\</span><br><span class=\"line\">\t&amp;&amp; gpg --keyserver ha.pool.sks-keyservers.net --recv-keys &quot;$GPG_KEY&quot; \\</span><br><span class=\"line\">\t&amp;&amp; gpg --batch --verify python.tar.xz.asc python.tar.xz \\</span><br><span class=\"line\">\t&amp;&amp; rm -rf &quot;$GNUPGHOME&quot; python.tar.xz.asc \\</span><br><span class=\"line\">\t&amp;&amp; mkdir -p /usr/src/python \\</span><br><span class=\"line\">\t&amp;&amp; tar -xJC /usr/src/python --strip-components=1 -f python.tar.xz \\</span><br><span class=\"line\">\t&amp;&amp; rm python.tar.xz \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\t&amp;&amp; cd /usr/src/python \\</span><br><span class=\"line\">\t&amp;&amp; gnuArch=&quot;$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)&quot; \\</span><br><span class=\"line\">\t&amp;&amp; ./configure \\</span><br><span class=\"line\">\t\t--build=&quot;$gnuArch&quot; \\</span><br><span class=\"line\">\t\t--enable-loadable-sqlite-extensions \\</span><br><span class=\"line\">\t\t--enable-shared \\</span><br><span class=\"line\">\t\t--with-system-expat \\</span><br><span class=\"line\">\t\t--with-system-ffi \\</span><br><span class=\"line\">\t\t--without-ensurepip \\</span><br><span class=\"line\">\t&amp;&amp; make -j &quot;$(nproc)&quot; \\</span><br><span class=\"line\">\t&amp;&amp; make install \\</span><br><span class=\"line\">\t&amp;&amp; ldconfig \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\t&amp;&amp; apt-get purge -y --auto-remove $buildDeps \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\t&amp;&amp; find /usr/local -depth \\</span><br><span class=\"line\">\t\t\\( \\</span><br><span class=\"line\">\t\t\t\\( -type d -a \\( -name test -o -name tests \\) \\) \\</span><br><span class=\"line\">\t\t\t-o \\</span><br><span class=\"line\">\t\t\t\\( -type f -a \\( -name &apos;*.pyc&apos; -o -name &apos;*.pyo&apos; \\) \\) \\</span><br><span class=\"line\">\t\t\\) -exec rm -rf &apos;&#123;&#125;&apos; + \\</span><br><span class=\"line\">\t&amp;&amp; rm -rf /usr/src/python</span><br><span class=\"line\"></span><br><span class=\"line\"># make some useful symlinks that are expected to exist</span><br><span class=\"line\">RUN cd /usr/local/bin \\</span><br><span class=\"line\">\t&amp;&amp; ln -s idle3 idle \\</span><br><span class=\"line\">\t&amp;&amp; ln -s pydoc3 pydoc \\</span><br><span class=\"line\">\t&amp;&amp; ln -s python3 python \\</span><br><span class=\"line\">\t&amp;&amp; ln -s python3-config python-config</span><br><span class=\"line\"></span><br><span class=\"line\"># if this is called &quot;PIP_VERSION&quot;, pip explodes with &quot;ValueError: invalid truth value &apos;&lt;VERSION&gt;&apos;&quot;</span><br><span class=\"line\">ENV PYTHON_PIP_VERSION 9.0.3</span><br><span class=\"line\"></span><br><span class=\"line\">RUN set -ex; \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\tapt-get update; \\</span><br><span class=\"line\">\tapt-get install -y --no-install-recommends wget; \\</span><br><span class=\"line\">\trm -rf /var/lib/apt/lists/*; \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\twget -O get-pip.py &apos;https://bootstrap.pypa.io/get-pip.py&apos;; \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\tapt-get purge -y --auto-remove wget; \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\tpython get-pip.py \\</span><br><span class=\"line\">\t\t--disable-pip-version-check \\</span><br><span class=\"line\">\t\t--no-cache-dir \\</span><br><span class=\"line\">\t\t&quot;pip==$PYTHON_PIP_VERSION&quot; \\</span><br><span class=\"line\">\t; \\</span><br><span class=\"line\">\tpip --version; \\</span><br><span class=\"line\">\t\\</span><br><span class=\"line\">\tfind /usr/local -depth \\</span><br><span class=\"line\">\t\t\\( \\</span><br><span class=\"line\">\t\t\t\\( -type d -a \\( -name test -o -name tests \\) \\) \\</span><br><span class=\"line\">\t\t\t-o \\</span><br><span class=\"line\">\t\t\t\\( -type f -a \\( -name &apos;*.pyc&apos; -o -name &apos;*.pyo&apos; \\) \\) \\</span><br><span class=\"line\">\t\t\\) -exec rm -rf &apos;&#123;&#125;&apos; +; \\</span><br><span class=\"line\">\trm -f get-pip.py</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get -y upgrade</span><br><span class=\"line\"></span><br><span class=\"line\"># xvfb is used to do CPU based rendering of Unity</span><br><span class=\"line\">RUN apt-get install -y xvfb</span><br><span class=\"line\"></span><br><span class=\"line\">COPY ml-agents /ml-agents</span><br><span class=\"line\">WORKDIR /ml-agents</span><br><span class=\"line\">RUN pip install .</span><br><span class=\"line\"></span><br><span class=\"line\"># port 5005 is the port used in in Editor training.</span><br><span class=\"line\">EXPOSE 5005</span><br><span class=\"line\"></span><br><span class=\"line\">RUN cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class=\"line\">COPY sources.list /etc/apt/sources.list</span><br><span class=\"line\"></span><br><span class=\"line\">ENV PYTHONPATH /ml-agents:$PYTHONPATH</span><br><span class=\"line\"></span><br><span class=\"line\">RUN apt-get update &amp;&amp; apt-get install -y \\</span><br><span class=\"line\">        apt-file \\</span><br><span class=\"line\">        nano \\</span><br><span class=\"line\">        net-tools \\</span><br><span class=\"line\">        iputils-ping \\</span><br><span class=\"line\">        openssh-server \\</span><br><span class=\"line\">        apt-utils \\</span><br><span class=\"line\">    &amp;&amp; rm -rf /var/lib/apt/lists/* \\</span><br><span class=\"line\">    &amp;&amp; mkdir /var/run/sshd \\</span><br><span class=\"line\">    &amp;&amp; echo &quot;root:1234&quot; | chpasswd \\</span><br><span class=\"line\">    &amp;&amp; sed -i &apos;s/prohibit-password/yes/g&apos; /etc/ssh/sshd_config</span><br><span class=\"line\"></span><br><span class=\"line\">EXPOSE 22</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRYPOINT [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"PUSH镜像\"><a href=\"#PUSH镜像\" class=\"headerlink\" title=\"PUSH镜像\"></a>PUSH镜像</h3><p><code>docker push [name]:[tag]</code><br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-02-47.png\" alt=\"\"></p>\n<h3 id=\"测试镜像\"><a href=\"#测试镜像\" class=\"headerlink\" title=\"测试镜像\"></a>测试镜像</h3><ul>\n<li>登录<a href=\"http://10.0.4.228\" rel=\"external nofollow\" target=\"_blank\">机器学习平台</a>,没有使用平台的可以在本地使用<code>docker run</code>直接开启容器</li>\n<li>先测试使用容器的方式<ul>\n<li>创建容器<br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-28-19.png\" alt=\"\"><br>将要运行和储存的文件夹放在数据卷<code>data</code>下,这个目录要在运行时由<code>--docker-target-name</code>指定</li>\n<li>等待容器创建成功<br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-15.png\" alt=\"\"></li>\n<li>容器创建成功后进入容器<br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-52.png\" alt=\"\"></li>\n<li>执行<code>mlagents-learn trainer_config.yaml --docker-target-name=data/unity-volume --env=3dball --train --run-id=test --save-freq=5000 | tee /data/unity-volume/log.txt</code>,如果不想在屏幕输出,可以在后边加上<code>&gt;/dev/null</code><br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-16-44.png\" alt=\"\"><br><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-18-40.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"安装Miniconda\"><a href=\"#安装Miniconda\" class=\"headerlink\" title=\"安装Miniconda\"></a>安装Miniconda</h2><p>确保你的安装包放在了data文件夹下<br><code>apt-get update &amp;&amp; apt-get install bzip2 -y &amp;&amp; cd /data &amp;&amp; bash Miniconda3-latest-Linux-x86_64.sh</code></p>\n<p>一路按回车、yes等等就成功了.如果需要安装到指定目录,在安装过程中会有提示告诉你让你指定安装路径</p>\n<p><em>注意</em></p>\n<p>在<a href=\"http://10.0.4.228/\" rel=\"external nofollow\" target=\"_blank\">学校机器学习平台</a>上使用时,如果是使用容器的方式,那么新开的容器就可以使用<code>conda</code>命令,不存在<code>conda:command not found</code>的错误信息.</p>\n<p>但是,如果在平台上以<strong>提交任务</strong>的形式来使用带conda的镜像所产生的容器时,就算是在镜像中配置了<code>echo &#39;export PATH=&quot;~/anaconda3/bin:$PATH&quot;&#39; &gt;&gt; ~/.bashrc</code>,当提交任务时环境变量中仍然没有<code>~/anaconda3/bin</code>,这个问题目前没有找到比较方便的解决办法,目前所采用的方式是:</p>\n<p>在提交任务时, 首先加上命令<code>export PATH=&quot;~/anaconda3/bin:$PATH&quot; &amp;&amp;</code></p>\n<p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-25-17.png\" alt=\"\"></p>\n<p>接着又实验了一下<code>echo &#39;export PATH=&quot;~/anaconda3/bin:$PATH&quot;&#39; &gt;&gt; /etc/profile</code>, 正常来说, 如果在容器中这样设置环境变量, 等待下次从镜像创建容器时, 这个环境变量一般并不会生效, 但是不知道这样设置对于提交任务方式来说有没有效, 索性试了一下</p>\n<p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-35-56.png\" alt=\"\"></p>\n<p>根据输出日志来看, 这种方式也并没有奏效</p>\n<p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-39-26.png\" alt=\"\"></p>\n<p>当然, 如果觉得上述配置比较麻烦的话,可以使用<code>Dockerfile</code>的<code>ENV</code>命令来设置环境变量, 这样设置99%是不会有问题的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM hub.hoc.ccshu.net/wjs/mlunityv060:v1.4.5</span><br><span class=\"line\">ENV PATH /usr/miniconda3/bin:$PATH</span><br></pre></td></tr></table></figure>\n<p>实验了一下,<br>结果如下:</p>\n<p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_15-02-16.png\" alt=\"\"></p>\n<p>表示可以使用<code>conda</code>命令, 但是不能使用<code>conda activate</code>命令激活环境</p>\n<p>根据错误信息, 在<code>Dockerfile</code>中写入以下代码也不可行:</p>\n<p><code>RUN ln -s /usr/miniconda3/etc/profile.d/conda.sh /etc/profile.d/conda.sh</code></p>\n<p>查了一下相关资料,发现在4.5版本的conda是无解的<br><a href=\"https://github.com/ContinuumIO/docker-images/issues/89\" rel=\"external nofollow\" target=\"_blank\">https://github.com/ContinuumIO/docker-images/issues/89</a></p>\n<p><img src=\"./创建ML-Agents的Docker镜像/Snipaste_2019-01-11_22-38-42.png\" alt=\"\"></p>\n<p>希望4.6版本可以解决吧</p>\n<p><strong>更新2019年1月14日14:26:01</strong><br><strong>已解决</strong></p>\n<p>4.6版本的确可以解决以提交任务模式运行时的问题, 需要使用命令<code>conda run -n [环境名字] [要执行的命令]</code>, 而不是使用<code>conda activate [环境名字]</code>先激活一个环境.</p>\n<p>不过, 更新至4.6版本需要相关配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --add channels conda-canary</span><br><span class=\"line\">conda update conda</span><br></pre></td></tr></table></figure></p>\n<p>我使用Dockerfile来生成镜像, 代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM hub.hoc.ccshu.net/wjs/mlunityv060:v1.4.6</span><br><span class=\"line\"></span><br><span class=\"line\">ENV PATH /usr/miniconda3/bin:$PATH</span><br><span class=\"line\">RUN conda config --add channels conda-canary &amp;&amp; conda update conda -y</span><br></pre></td></tr></table></figure></p>\n<p>原因是, 使用Dockerfile比较容易设置环境变量, 减少出错</p>"},{"title":"价值与贝尔曼方程","copyright":true,"top":1,"date":"2019-05-09T10:09:02.000Z","mathjax":true,"_content":"\n# 价值与贝尔曼方程\n\n我们人在做决策的时候往往会判断做这件事的价值和后果，就像失恋了去喝不喝闷酒一样，不同的人有不同的选择，但是选择前肯定会判断这么做能给自己带来什么。\n\n选择去喝酒的人觉得这可以缓解自己的痛苦，这就是判断喝酒这个动作的价值。因为身体原因不选择去喝酒的人觉得喝醉之后身体很不舒服，还会说胡话、闹事，这就是衡量后果、判断喝酒后状态的价值。\n\n在乎过程的会根据动作的价值进行抉择，在乎结果的会根据状态的价值进行抉择。总之，衡量价值，毫无疑问是我们做决策的重要评判标准。\n\n机器也一样，我们想教会机器学会自主决策，必然得让它们有一个价值导向，毕竟它可不会、也决不能像人一样\"没有原因呀，就随便选择了一个而已\"。\n\n本文介绍了**绝大部分强化学习问题及算法**中值函数与贝尔曼方程的定义。因为有一些研究探索的，如好奇心、信息熵等方向的算法对值函数的定义有稍许不同。\n\n<!--more-->\n\n---\n\n注：以下公式及推导过程可能与其他博客、论文、书本上有稍许不同，不过都是经过细细分析，一步步推导的，或许有些公式难以理解，但都是尽可能细化每一处细节。使读者可以更清楚地了解每一个值的来龙去脉。\n\n---\n\n## 值函数\n\n值函数分为状态值函数与动作值函数，分别用来表示状态和状态下执行某动作的好坏程度、优劣程度。\n\n回顾一下回报：\n$$\n\\begin{align*}\nG_{t} &\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+\\gamma^{3}R_{t+4}+...\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma R_{t+3}+\\gamma^{2}R_{t+4}+...)\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma (R_{t+3}+\\gamma R_{t+4}+...))\\\\\n&=R_{t+1}+\\gamma G_{t+1}\n\\end{align*}\n$$\n\n$$\nG_{t}\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+...=\\begin{cases}\n\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\\\\n\\sum_{k=t+1}^{T}\\gamma^{k-t-1}R_{k}\n\\end{cases}\n$$\n\n回顾一下之前的MDP例子：\n\n![](./强化学习之MDP马尔科夫决策过程/MDP.jpg)\n\n将状态用符号表示为\n$$\n\\begin{bmatrix}\n玩游戏 & A\\\\ \n语文 & B\\\\ \n数学 & C\\\\ \n英语 & D\\\\ \n\\mathcal{Pass} & E\\\\ \n睡觉 & F\n\\end{bmatrix}\n$$\n将转移概率矩阵$\\mathcal{P}$写成如下形式\n\n\n\n\n\n|        |  A   |  B   |  C   |  D   |  E   |  F   |\n| :----: | :--: | :--: | :--: | :--: | :--: | :--: |\n| Reward |  -1  |  -2  |  -2  |  -2  |  10  |  0   |\n|   A    | 0.9  | 0.1  |      |      |      |      |\n|   B    | 0.5  |      | 0.5  |      |      |      |\n|   C    |      |      |      | 0.8  |      | 0.2  |\n| D,0.4  |      | 0.2  | 0.4  | 0.4  |      |      |\n| D,0.6  |      |      |      |      | 0.6  |      |\n|   E    |      |      |      |      |      | 1.0  |\n\n其中，D状态有两个动作，但是其0.4概率选到的动作并不一定确定地转移到另一个状态，所以将两个动作分开写，其实除了Reward的每一行都是一个$(s,a)$的状态-动作对，但是除了D状态有特殊外，其他状态的转移都是确定的，于是省略了动作。后续将会看到如果根据$(D,0.4)$这个状态-动作对去进行相应的计算。\n\n### 状态值函数$V(s)$\n\n$\\pi$策略下$s$状态的价值函数可以表示为$v_{\\pi}(s)$，由**期望回报**表示\n\n$$\nv_{\\pi}(s) \\doteq \\mathbb{E}_{\\pi}[G_{t}|S_{t}=s] = \\mathbb{E}_{\\pi}\\left [ \\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid S_{t}=s \\right ], \\ for \\ all \\ s\\in S\n$$\n\n有了这个公式，我们能根据上述表格计算出每个状态的价值吗？当然可以，只是很麻烦，如果对于连续状态空间的问题就不只是麻烦的问题，而是不能计算。\n\n为什么呢？因为要求期望需要遍历所有可能性的episode，连续状态空间根本无法遍历所有的情况。\n\n### 动作值函数$Q(s,a)$\n\n动作值函数与状态值函数在公式表示上差别不大，$\\pi$策略$s$状态下执行a动作的价值函数可以表示为$Q_{\\pi}(s，a)$，由**期望回报**表示\n$$\nQ_{\\pi}(s,a) \\doteq \\mathbb{E}_{\\pi}[G_{t}|S_{t}=s,A_{t}=a] = \\mathbb{E}_{\\pi}\\left [ \\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid S_{t}=s,A_{t}=a \\right ]\n$$\n\n## 贝尔曼方程\n\n> [贝尔曼方程（Bellman Equation）(百度百科)](https://baike.baidu.com/item/贝尔曼方程/5500990?fr=aladdin)也被称作动态规划方程（Dynamic Programming Equation），由理查·贝尔曼（Richard Bellman）发现。\n>\n> 贝尔曼方程是动态规划（Dynamic Programming）这些数学最佳化方法能够达到最佳化的必要条件。此方程把“决策问题在特定时间怎么的值”以“来自初始选择的报酬比从初始选择衍生的决策问题的值”的形式表示。借此这个方式把动态最佳化问题变成简单的子问题，而这些子问题遵守从贝尔曼所提出来的“最佳化还原理”。\n\n\n\n**贝尔曼方程将状态值函数$V(s)$与动作值函数$Q(s,a)$、将当前的值函数与之后状态$V(s‘)$或动作的值函数$Q(s’,a‘)$联系起来。**\n\n\n\n### 状态值函数$V(s)$与动作值函数$Q(s,a)$的关系\n\n![](./价值与贝尔曼方程/vs.jpg)\n$$\nv_{\\pi}(s)=\\sum_{a}\\pi(a\\mid s) q_{\\pi}(s,a)\n$$\n![](./价值与贝尔曼方程/qsa.jpg)\n$$\nq_{\\pi}(s,a) = \\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\n$$\n\n### 贝尔曼期望方程\n\n状态值函数$V(s)$可以写成如下形式：\n$$\n\\begin{align*}\nv_{\\pi}(s) & \\doteq \\mathbb{E}_{\\pi}\\left [ G_{t}\\mid S_{t}=s \\right ]\\\\\n&=\\mathbb{E}_{t} \\left [R_{t+1}+\\gamma G_{t+1} \\mid S_{t}=s \\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s)\\sum_{s'}\\sum_{r}p(s',r\\mid s,a)\\left[r+\\gamma \\mathbb{E}\\left[G_{t+1}\\mid S_{t+1}=s' \\right]\\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s)\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s) q_{\\pi}(s,a)\n\\end{align*},\nfor \\ all \\ s\\in S\n$$\n\n![](./价值与贝尔曼方程/v.jpg)\n\n看到没有，此时可以将当前状态的状态值$v_{\\pi}(s)$与下一个可到达状态的状态值$v_{\\pi}(s')$联系起来！\n\n动作值函数$Q_{\\pi}(s,a)$也可以进行类似推导：\n$$\n\\begin{align*}\nq_{\\pi}(s,a) & \\doteq \\mathbb{E}_{\\pi}\\left [ G_{t}\\mid S_{t}=s,A_{t}=a \\right ]\\\\\n&=\\mathbb{E}_{t} \\left [R_{t+1}+\\gamma G_{t+1} \\mid S_{t}=s,A_{t}=a \\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma \\sum_{a'}\\pi(a'\\mid s') \\mathbb{E}\\left[G_{t+1}\\mid S_{t+1}=s',A_{t+1}=a' \\right]\\right]\\\\\n&=\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma \\sum_{a'}\\pi(a'\\mid s') q_{\\pi}(s',a')\\right]\\\\\n&=\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\n\\end{align*}\n$$\n\n![](./价值与贝尔曼方程/q.jpg)\n\n### 最优值函数\n\n解决一个强化学习问题也就是意味着找到一种选择动作的策略能够获得足够多的回报。如果执行每个动作所产生的转移都是确定的（有限MDP），那么能够定义出一个最优策略，如果一个策略$\\pi'$的所有状态值函数都大于$\\pi$，那么就说策略$\\pi'$更好，但不一定是最好的，我们把最优策略用$\\pi_{*}$表示。\n\n最优状态值函数：\n\n$$\nv_{*}(s)=\\max_{\\pi} v_{\\pi}(s)\n$$\n\n最优动作值函数：\n\n$$\nq_{*}(s,a)=\\max_{\\pi} q_{\\pi}(s,a)\n$$\n\n### 贝尔曼最优方程\n\n$$\n\\begin{align*}\nv_{*}(s) &= \\max_{a} q_{*}(s,a)\\\\\n&=\\max_{a}\\mathbb{E}\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\max_{a}\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\right]\n\\end{align*}\n$$\n\n$$\n\\begin{align*}\nq_{*}(s,a) &= \\mathbb{E}\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\mathbb{E}\\left[r+\\gamma \\max_{a'} q_{*}(s',a')\\mid s,a\\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma \\max_{a'}q_{*}(s',a')\\right]\n\\end{align*}\n$$\n\n![](./价值与贝尔曼方程/vq.jpg)\n\n虽然我们已经定义出了最优值函数和最优策略，而且理论上也可以直接计算出来。但是通常情况下我们没法得到这么多的计算资源。与此同时内存溢出也是一个很大的问题，因为很多问题的状态数量太多超过存储范围。对于这些情况我们就不能够使用直接存储每个状态的值函数而是必须使用一种更精简的参数型函数表示的方法。\n\n强化学习的框架迫使我们进行近似求解，而且这个框架同时也很容易进行近似，比如对于很多小概率出现的状态，选择最优解和次优解区别不大。\n\n### 最优策略\n\n定义策略之间的偏序关系\n$$\n\\pi \\geq \\pi' \\ if \\ v_{\\pi}(s) \\geq v_{\\pi'}(s) \\ , \\ \\forall s\n$$\n那么有如下定理成立：\n\n对任意MDP：\n\n- 存在最优策略$\\pi_{\\ast}$，满足$\\pi_{\\ast} \\geq \\pi,\\forall \\pi$\n- 所有最优策略的状态值函数都等于最优状态值函数$v_{\\pi_{\\ast}}(s)=v_{\\ast}(s)$\n- 所有最优策略的动作值函数都等于最优动作值函数$q_{\\pi_{\\ast}}(s,a)=q_{\\ast}(s,a)$\n\n## 例子\n\n对于上述例子和表格，我们来试着计算一下$V(S)、Q(S,A)$。\n\n第一个问题，怎么计算这些值？初始化终态的状态值为0，然后从后向前递归？我们来试一下！\n\n### 只初始化终态\n\n根据上述公式，设$\\gamma =1$：\n$$\n\\begin{align*}\n&v(F)=r=0\\\\\n&q(E，)=1\\times (0+v(F))=0\\\\\n&1表示选择这个动作转移至另一个状态的概率\\\\\n&v(E)=1\\times q(E,)=0\\\\\n&q(D,0.6)=1\\times (10+v(E))=10\\\\\n&q(D,0.4)=0.2\\times(-2+v(B))+0.4\\times(-2+v(C))+0.4\\times(-2+v(D))=\\\\\n&v(D)=0.4\\times q(D,0.4)+0.6\\times q(D,0.6)=\\\\\n&q(C,0.8)=1\\times (-2+v(D))=\\\\\n&q(C,0.2)=1\\times (0+v(F))=0\\\\\n&v(C)=0.2\\times q(C,0.2)+0.8\\times q(C,0.8)=\\\\\n&q(B,0.5_{C})=1\\times (-2+v(C))=\\\\\n&q(B,0.5_{A})=1\\times (-1+v(A))=\\\\\n&v(B)=0.5\\times q(B,0.5_{C})+0.5 \\times q(B,0.5_{A})=\\\\\n&q(A,0.9)=1\\times (-1+v(A))=\\\\\n&q(A,0.1)=1\\times(-2+v(B))=\\\\\n&v(A)=0.1\\times q(A,0.1)+0.9\\times q(A,0.9)=\n\\end{align*}\n$$\n哎呀，卡住了，解不出来，$v(D)、v(A)、v(B)$互相依赖，解不出来，看来这样计算是行不通了。其实，很多问题中终态都很难定义，更别说使用这种方法了。\n\n### 初始化全部状态值\n\n初始化所有状态的值函数为0，即\n$$\nv(s)=0,\\ for\\ all\\ s\\in S\n$$\n\n先试验一下$\\gamma =0.5$，\n\n\n\n\n\n\n|                     V和Q，$\\gamma =0.5$                      | 初始化V计算Q | 迭代→V→Q | 第46轮完全收敛 |\n| :----------------------------------------------------------: | :----------: | :------: | -------------- |\n|                              A                               |      0       |    ……    | -2.171         |\n|                              B                               |      0       |    ……    | -1.880         |\n|                              C                               |      0       |    ……    | 0.651          |\n|                              D                               |      0       |    ……    | 5.627          |\n|                              E                               |      0       |    ……    | 0              |\n|                              F                               |      0       |    ……    | 0              |\n|                    $(A,0.1)\\rightarrow B$                    |      0       |    ……    | -2.940         |\n|                    $(A,0.9)\\rightarrow A$                    |      0       |    ……    | -2.085         |\n|                  $(B,0.5_{A})\\rightarrow A$                  |      0       |    ……    | -2.085         |\n|                  $(B,0.5_{C})\\rightarrow C$                  |      0       |    ……    | -1.675         |\n|                    $(C,0.2)\\rightarrow F$                    |      0       |    ……    | 0              |\n|                    $(C,0.8)\\rightarrow D$                    |      0       |    ……    | 0.814          |\n| $(D,0.4)\\rightarrow \\begin{cases}B,0.2\\\\C,0.4\\\\D,0.4\\end{cases}$ |      0       |    ……    | -0.932         |\n|                    $(D,0.6)\\rightarrow E$                    |      0       |    ……    | 10             |\n|                    $(E,1.0)\\rightarrow F$                    |      0       |    ……    | 0              |\n\n这是代码计算的结果，接下来我使$\\gamma =1$，计算结果如下，每迭代100次输出一下：\n\n![](./价值与贝尔曼方程/example1.png)\n\n可以发现，在700至800次迭代后值函数最终收敛。\n\n如果我将$\\gamma $设置为0.1呢？来看一下结果：\n\n![](./价值与贝尔曼方程/example2.png)\n\n仅仅需要十几次就可以迭代至收敛。\n\n如果设置为0呢？会怎么样？看结果：\n\n![](./价值与贝尔曼方程/example3.png)\n\n仅需一次迭代就可以收敛，而且就是转移状态的立即奖励值，这下可以理解$\\gamma$为什么表示对未来的看重程度了吧。\n\n一般我们是不会将$\\gamma$设置为0的，从这个例子的直观感受也可以得到，就拿$\\gamma =0$与$\\gamma =0.5来比较$：\n\n- $\\gamma =0$状态值最高的是$v(D)=5.2$，这很容易理解，D状态距离最大奖励值10最近，理应最好，这点与$\\gamma =0.5$时相同。\n\n- 但是对于状态C，$\\gamma =0$时认为这个状态最差，$v(C)=-1.6$，$\\gamma =0$时认为这个状态次优，$v(C)=0.651$，其实这就是目光短浅与目光长远的不同，$\\gamma =0$并没有考虑到其附近状态的临近状态的价值，导致其主观的认为最接近我的都是负的，于是状态肯定差。\n\n- 对于动作值也是一样，一个认为次优，一个认为最差。\n\n  \n\n**注意：并不是说$\\gamma$越接近于1越好，因为在有些问题上，$\\gamma=1$时其值函数永远不收敛，必须设置$0 \\leq \\gamma \\lt 1$，值函数才能收敛。为什么呢？试着计算一下$\\gamma^{n}$，看看对不同的$\\gamma$值，$n$取什么值时结果接近0。**\n\n试着计算一下这个例子，红色代表立即奖励，蓝色代表选择动作的概率以及状态转移的概率，小写字母代表动作，大写字母代表状态。\n\n![](./价值与贝尔曼方程/example4.png)\n\n$\\gamma =1$时，迭代100W次也不收敛：\n\n![](./价值与贝尔曼方程/example5.png)\n\n$\\gamma =0.5$时，迭代50多次即可收敛：\n\n![](./价值与贝尔曼方程/example6.png)\n\n","source":"_posts/价值与贝尔曼方程.md","raw":"---\ntitle: 价值与贝尔曼方程\ncopyright: true\ntop: 1\ndate: 2019-05-09 18:09:02\nmathjax: true\ncategories: ReinforcementLearning\ntags:\n- rl\n---\n\n# 价值与贝尔曼方程\n\n我们人在做决策的时候往往会判断做这件事的价值和后果，就像失恋了去喝不喝闷酒一样，不同的人有不同的选择，但是选择前肯定会判断这么做能给自己带来什么。\n\n选择去喝酒的人觉得这可以缓解自己的痛苦，这就是判断喝酒这个动作的价值。因为身体原因不选择去喝酒的人觉得喝醉之后身体很不舒服，还会说胡话、闹事，这就是衡量后果、判断喝酒后状态的价值。\n\n在乎过程的会根据动作的价值进行抉择，在乎结果的会根据状态的价值进行抉择。总之，衡量价值，毫无疑问是我们做决策的重要评判标准。\n\n机器也一样，我们想教会机器学会自主决策，必然得让它们有一个价值导向，毕竟它可不会、也决不能像人一样\"没有原因呀，就随便选择了一个而已\"。\n\n本文介绍了**绝大部分强化学习问题及算法**中值函数与贝尔曼方程的定义。因为有一些研究探索的，如好奇心、信息熵等方向的算法对值函数的定义有稍许不同。\n\n<!--more-->\n\n---\n\n注：以下公式及推导过程可能与其他博客、论文、书本上有稍许不同，不过都是经过细细分析，一步步推导的，或许有些公式难以理解，但都是尽可能细化每一处细节。使读者可以更清楚地了解每一个值的来龙去脉。\n\n---\n\n## 值函数\n\n值函数分为状态值函数与动作值函数，分别用来表示状态和状态下执行某动作的好坏程度、优劣程度。\n\n回顾一下回报：\n$$\n\\begin{align*}\nG_{t} &\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+\\gamma^{3}R_{t+4}+...\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma R_{t+3}+\\gamma^{2}R_{t+4}+...)\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma (R_{t+3}+\\gamma R_{t+4}+...))\\\\\n&=R_{t+1}+\\gamma G_{t+1}\n\\end{align*}\n$$\n\n$$\nG_{t}\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+...=\\begin{cases}\n\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\\\\n\\sum_{k=t+1}^{T}\\gamma^{k-t-1}R_{k}\n\\end{cases}\n$$\n\n回顾一下之前的MDP例子：\n\n![](./强化学习之MDP马尔科夫决策过程/MDP.jpg)\n\n将状态用符号表示为\n$$\n\\begin{bmatrix}\n玩游戏 & A\\\\ \n语文 & B\\\\ \n数学 & C\\\\ \n英语 & D\\\\ \n\\mathcal{Pass} & E\\\\ \n睡觉 & F\n\\end{bmatrix}\n$$\n将转移概率矩阵$\\mathcal{P}$写成如下形式\n\n\n\n\n\n|        |  A   |  B   |  C   |  D   |  E   |  F   |\n| :----: | :--: | :--: | :--: | :--: | :--: | :--: |\n| Reward |  -1  |  -2  |  -2  |  -2  |  10  |  0   |\n|   A    | 0.9  | 0.1  |      |      |      |      |\n|   B    | 0.5  |      | 0.5  |      |      |      |\n|   C    |      |      |      | 0.8  |      | 0.2  |\n| D,0.4  |      | 0.2  | 0.4  | 0.4  |      |      |\n| D,0.6  |      |      |      |      | 0.6  |      |\n|   E    |      |      |      |      |      | 1.0  |\n\n其中，D状态有两个动作，但是其0.4概率选到的动作并不一定确定地转移到另一个状态，所以将两个动作分开写，其实除了Reward的每一行都是一个$(s,a)$的状态-动作对，但是除了D状态有特殊外，其他状态的转移都是确定的，于是省略了动作。后续将会看到如果根据$(D,0.4)$这个状态-动作对去进行相应的计算。\n\n### 状态值函数$V(s)$\n\n$\\pi$策略下$s$状态的价值函数可以表示为$v_{\\pi}(s)$，由**期望回报**表示\n\n$$\nv_{\\pi}(s) \\doteq \\mathbb{E}_{\\pi}[G_{t}|S_{t}=s] = \\mathbb{E}_{\\pi}\\left [ \\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid S_{t}=s \\right ], \\ for \\ all \\ s\\in S\n$$\n\n有了这个公式，我们能根据上述表格计算出每个状态的价值吗？当然可以，只是很麻烦，如果对于连续状态空间的问题就不只是麻烦的问题，而是不能计算。\n\n为什么呢？因为要求期望需要遍历所有可能性的episode，连续状态空间根本无法遍历所有的情况。\n\n### 动作值函数$Q(s,a)$\n\n动作值函数与状态值函数在公式表示上差别不大，$\\pi$策略$s$状态下执行a动作的价值函数可以表示为$Q_{\\pi}(s，a)$，由**期望回报**表示\n$$\nQ_{\\pi}(s,a) \\doteq \\mathbb{E}_{\\pi}[G_{t}|S_{t}=s,A_{t}=a] = \\mathbb{E}_{\\pi}\\left [ \\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid S_{t}=s,A_{t}=a \\right ]\n$$\n\n## 贝尔曼方程\n\n> [贝尔曼方程（Bellman Equation）(百度百科)](https://baike.baidu.com/item/贝尔曼方程/5500990?fr=aladdin)也被称作动态规划方程（Dynamic Programming Equation），由理查·贝尔曼（Richard Bellman）发现。\n>\n> 贝尔曼方程是动态规划（Dynamic Programming）这些数学最佳化方法能够达到最佳化的必要条件。此方程把“决策问题在特定时间怎么的值”以“来自初始选择的报酬比从初始选择衍生的决策问题的值”的形式表示。借此这个方式把动态最佳化问题变成简单的子问题，而这些子问题遵守从贝尔曼所提出来的“最佳化还原理”。\n\n\n\n**贝尔曼方程将状态值函数$V(s)$与动作值函数$Q(s,a)$、将当前的值函数与之后状态$V(s‘)$或动作的值函数$Q(s’,a‘)$联系起来。**\n\n\n\n### 状态值函数$V(s)$与动作值函数$Q(s,a)$的关系\n\n![](./价值与贝尔曼方程/vs.jpg)\n$$\nv_{\\pi}(s)=\\sum_{a}\\pi(a\\mid s) q_{\\pi}(s,a)\n$$\n![](./价值与贝尔曼方程/qsa.jpg)\n$$\nq_{\\pi}(s,a) = \\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\n$$\n\n### 贝尔曼期望方程\n\n状态值函数$V(s)$可以写成如下形式：\n$$\n\\begin{align*}\nv_{\\pi}(s) & \\doteq \\mathbb{E}_{\\pi}\\left [ G_{t}\\mid S_{t}=s \\right ]\\\\\n&=\\mathbb{E}_{t} \\left [R_{t+1}+\\gamma G_{t+1} \\mid S_{t}=s \\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s)\\sum_{s'}\\sum_{r}p(s',r\\mid s,a)\\left[r+\\gamma \\mathbb{E}\\left[G_{t+1}\\mid S_{t+1}=s' \\right]\\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s)\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s) q_{\\pi}(s,a)\n\\end{align*},\nfor \\ all \\ s\\in S\n$$\n\n![](./价值与贝尔曼方程/v.jpg)\n\n看到没有，此时可以将当前状态的状态值$v_{\\pi}(s)$与下一个可到达状态的状态值$v_{\\pi}(s')$联系起来！\n\n动作值函数$Q_{\\pi}(s,a)$也可以进行类似推导：\n$$\n\\begin{align*}\nq_{\\pi}(s,a) & \\doteq \\mathbb{E}_{\\pi}\\left [ G_{t}\\mid S_{t}=s,A_{t}=a \\right ]\\\\\n&=\\mathbb{E}_{t} \\left [R_{t+1}+\\gamma G_{t+1} \\mid S_{t}=s,A_{t}=a \\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma \\sum_{a'}\\pi(a'\\mid s') \\mathbb{E}\\left[G_{t+1}\\mid S_{t+1}=s',A_{t+1}=a' \\right]\\right]\\\\\n&=\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma \\sum_{a'}\\pi(a'\\mid s') q_{\\pi}(s',a')\\right]\\\\\n&=\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\n\\end{align*}\n$$\n\n![](./价值与贝尔曼方程/q.jpg)\n\n### 最优值函数\n\n解决一个强化学习问题也就是意味着找到一种选择动作的策略能够获得足够多的回报。如果执行每个动作所产生的转移都是确定的（有限MDP），那么能够定义出一个最优策略，如果一个策略$\\pi'$的所有状态值函数都大于$\\pi$，那么就说策略$\\pi'$更好，但不一定是最好的，我们把最优策略用$\\pi_{*}$表示。\n\n最优状态值函数：\n\n$$\nv_{*}(s)=\\max_{\\pi} v_{\\pi}(s)\n$$\n\n最优动作值函数：\n\n$$\nq_{*}(s,a)=\\max_{\\pi} q_{\\pi}(s,a)\n$$\n\n### 贝尔曼最优方程\n\n$$\n\\begin{align*}\nv_{*}(s) &= \\max_{a} q_{*}(s,a)\\\\\n&=\\max_{a}\\mathbb{E}\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\max_{a}\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\right]\n\\end{align*}\n$$\n\n$$\n\\begin{align*}\nq_{*}(s,a) &= \\mathbb{E}\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\mathbb{E}\\left[r+\\gamma \\max_{a'} q_{*}(s',a')\\mid s,a\\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma \\max_{a'}q_{*}(s',a')\\right]\n\\end{align*}\n$$\n\n![](./价值与贝尔曼方程/vq.jpg)\n\n虽然我们已经定义出了最优值函数和最优策略，而且理论上也可以直接计算出来。但是通常情况下我们没法得到这么多的计算资源。与此同时内存溢出也是一个很大的问题，因为很多问题的状态数量太多超过存储范围。对于这些情况我们就不能够使用直接存储每个状态的值函数而是必须使用一种更精简的参数型函数表示的方法。\n\n强化学习的框架迫使我们进行近似求解，而且这个框架同时也很容易进行近似，比如对于很多小概率出现的状态，选择最优解和次优解区别不大。\n\n### 最优策略\n\n定义策略之间的偏序关系\n$$\n\\pi \\geq \\pi' \\ if \\ v_{\\pi}(s) \\geq v_{\\pi'}(s) \\ , \\ \\forall s\n$$\n那么有如下定理成立：\n\n对任意MDP：\n\n- 存在最优策略$\\pi_{\\ast}$，满足$\\pi_{\\ast} \\geq \\pi,\\forall \\pi$\n- 所有最优策略的状态值函数都等于最优状态值函数$v_{\\pi_{\\ast}}(s)=v_{\\ast}(s)$\n- 所有最优策略的动作值函数都等于最优动作值函数$q_{\\pi_{\\ast}}(s,a)=q_{\\ast}(s,a)$\n\n## 例子\n\n对于上述例子和表格，我们来试着计算一下$V(S)、Q(S,A)$。\n\n第一个问题，怎么计算这些值？初始化终态的状态值为0，然后从后向前递归？我们来试一下！\n\n### 只初始化终态\n\n根据上述公式，设$\\gamma =1$：\n$$\n\\begin{align*}\n&v(F)=r=0\\\\\n&q(E，)=1\\times (0+v(F))=0\\\\\n&1表示选择这个动作转移至另一个状态的概率\\\\\n&v(E)=1\\times q(E,)=0\\\\\n&q(D,0.6)=1\\times (10+v(E))=10\\\\\n&q(D,0.4)=0.2\\times(-2+v(B))+0.4\\times(-2+v(C))+0.4\\times(-2+v(D))=\\\\\n&v(D)=0.4\\times q(D,0.4)+0.6\\times q(D,0.6)=\\\\\n&q(C,0.8)=1\\times (-2+v(D))=\\\\\n&q(C,0.2)=1\\times (0+v(F))=0\\\\\n&v(C)=0.2\\times q(C,0.2)+0.8\\times q(C,0.8)=\\\\\n&q(B,0.5_{C})=1\\times (-2+v(C))=\\\\\n&q(B,0.5_{A})=1\\times (-1+v(A))=\\\\\n&v(B)=0.5\\times q(B,0.5_{C})+0.5 \\times q(B,0.5_{A})=\\\\\n&q(A,0.9)=1\\times (-1+v(A))=\\\\\n&q(A,0.1)=1\\times(-2+v(B))=\\\\\n&v(A)=0.1\\times q(A,0.1)+0.9\\times q(A,0.9)=\n\\end{align*}\n$$\n哎呀，卡住了，解不出来，$v(D)、v(A)、v(B)$互相依赖，解不出来，看来这样计算是行不通了。其实，很多问题中终态都很难定义，更别说使用这种方法了。\n\n### 初始化全部状态值\n\n初始化所有状态的值函数为0，即\n$$\nv(s)=0,\\ for\\ all\\ s\\in S\n$$\n\n先试验一下$\\gamma =0.5$，\n\n\n\n\n\n\n|                     V和Q，$\\gamma =0.5$                      | 初始化V计算Q | 迭代→V→Q | 第46轮完全收敛 |\n| :----------------------------------------------------------: | :----------: | :------: | -------------- |\n|                              A                               |      0       |    ……    | -2.171         |\n|                              B                               |      0       |    ……    | -1.880         |\n|                              C                               |      0       |    ……    | 0.651          |\n|                              D                               |      0       |    ……    | 5.627          |\n|                              E                               |      0       |    ……    | 0              |\n|                              F                               |      0       |    ……    | 0              |\n|                    $(A,0.1)\\rightarrow B$                    |      0       |    ……    | -2.940         |\n|                    $(A,0.9)\\rightarrow A$                    |      0       |    ……    | -2.085         |\n|                  $(B,0.5_{A})\\rightarrow A$                  |      0       |    ……    | -2.085         |\n|                  $(B,0.5_{C})\\rightarrow C$                  |      0       |    ……    | -1.675         |\n|                    $(C,0.2)\\rightarrow F$                    |      0       |    ……    | 0              |\n|                    $(C,0.8)\\rightarrow D$                    |      0       |    ……    | 0.814          |\n| $(D,0.4)\\rightarrow \\begin{cases}B,0.2\\\\C,0.4\\\\D,0.4\\end{cases}$ |      0       |    ……    | -0.932         |\n|                    $(D,0.6)\\rightarrow E$                    |      0       |    ……    | 10             |\n|                    $(E,1.0)\\rightarrow F$                    |      0       |    ……    | 0              |\n\n这是代码计算的结果，接下来我使$\\gamma =1$，计算结果如下，每迭代100次输出一下：\n\n![](./价值与贝尔曼方程/example1.png)\n\n可以发现，在700至800次迭代后值函数最终收敛。\n\n如果我将$\\gamma $设置为0.1呢？来看一下结果：\n\n![](./价值与贝尔曼方程/example2.png)\n\n仅仅需要十几次就可以迭代至收敛。\n\n如果设置为0呢？会怎么样？看结果：\n\n![](./价值与贝尔曼方程/example3.png)\n\n仅需一次迭代就可以收敛，而且就是转移状态的立即奖励值，这下可以理解$\\gamma$为什么表示对未来的看重程度了吧。\n\n一般我们是不会将$\\gamma$设置为0的，从这个例子的直观感受也可以得到，就拿$\\gamma =0$与$\\gamma =0.5来比较$：\n\n- $\\gamma =0$状态值最高的是$v(D)=5.2$，这很容易理解，D状态距离最大奖励值10最近，理应最好，这点与$\\gamma =0.5$时相同。\n\n- 但是对于状态C，$\\gamma =0$时认为这个状态最差，$v(C)=-1.6$，$\\gamma =0$时认为这个状态次优，$v(C)=0.651$，其实这就是目光短浅与目光长远的不同，$\\gamma =0$并没有考虑到其附近状态的临近状态的价值，导致其主观的认为最接近我的都是负的，于是状态肯定差。\n\n- 对于动作值也是一样，一个认为次优，一个认为最差。\n\n  \n\n**注意：并不是说$\\gamma$越接近于1越好，因为在有些问题上，$\\gamma=1$时其值函数永远不收敛，必须设置$0 \\leq \\gamma \\lt 1$，值函数才能收敛。为什么呢？试着计算一下$\\gamma^{n}$，看看对不同的$\\gamma$值，$n$取什么值时结果接近0。**\n\n试着计算一下这个例子，红色代表立即奖励，蓝色代表选择动作的概率以及状态转移的概率，小写字母代表动作，大写字母代表状态。\n\n![](./价值与贝尔曼方程/example4.png)\n\n$\\gamma =1$时，迭代100W次也不收敛：\n\n![](./价值与贝尔曼方程/example5.png)\n\n$\\gamma =0.5$时，迭代50多次即可收敛：\n\n![](./价值与贝尔曼方程/example6.png)\n\n","slug":"价值与贝尔曼方程","published":1,"updated":"2019-05-13T07:09:59.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzut9v005c20cdsuar141q","content":"<h1 id=\"价值与贝尔曼方程\"><a href=\"#价值与贝尔曼方程\" class=\"headerlink\" title=\"价值与贝尔曼方程\"></a>价值与贝尔曼方程</h1><p>我们人在做决策的时候往往会判断做这件事的价值和后果，就像失恋了去喝不喝闷酒一样，不同的人有不同的选择，但是选择前肯定会判断这么做能给自己带来什么。</p>\n<p>选择去喝酒的人觉得这可以缓解自己的痛苦，这就是判断喝酒这个动作的价值。因为身体原因不选择去喝酒的人觉得喝醉之后身体很不舒服，还会说胡话、闹事，这就是衡量后果、判断喝酒后状态的价值。</p>\n<p>在乎过程的会根据动作的价值进行抉择，在乎结果的会根据状态的价值进行抉择。总之，衡量价值，毫无疑问是我们做决策的重要评判标准。</p>\n<p>机器也一样，我们想教会机器学会自主决策，必然得让它们有一个价值导向，毕竟它可不会、也决不能像人一样”没有原因呀，就随便选择了一个而已”。</p>\n<p>本文介绍了<strong>绝大部分强化学习问题及算法</strong>中值函数与贝尔曼方程的定义。因为有一些研究探索的，如好奇心、信息熵等方向的算法对值函数的定义有稍许不同。</p>\n<a id=\"more\"></a>\n<hr>\n<p>注：以下公式及推导过程可能与其他博客、论文、书本上有稍许不同，不过都是经过细细分析，一步步推导的，或许有些公式难以理解，但都是尽可能细化每一处细节。使读者可以更清楚地了解每一个值的来龙去脉。</p>\n<hr>\n<h2 id=\"值函数\"><a href=\"#值函数\" class=\"headerlink\" title=\"值函数\"></a>值函数</h2><p>值函数分为状态值函数与动作值函数，分别用来表示状态和状态下执行某动作的好坏程度、优劣程度。</p>\n<p>回顾一下回报：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\nG_{t} &\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+\\gamma^{3}R_{t+4}+...\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma R_{t+3}+\\gamma^{2}R_{t+4}+...)\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma (R_{t+3}+\\gamma R_{t+4}+...))\\\\\n&=R_{t+1}+\\gamma G_{t+1}\n\\end{align*}</script><script type=\"math/tex; mode=display\">\nG_{t}\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+...=\\begin{cases}\n\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\\\\n\\sum_{k=t+1}^{T}\\gamma^{k-t-1}R_{k}\n\\end{cases}</script><p>回顾一下之前的MDP例子：</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/MDP.jpg\" alt=\"\"></p>\n<p>将状态用符号表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n玩游戏 & A\\\\ \n语文 & B\\\\ \n数学 & C\\\\ \n英语 & D\\\\ \n\\mathcal{Pass} & E\\\\ \n睡觉 & F\n\\end{bmatrix}</script><p>将转移概率矩阵$\\mathcal{P}$写成如下形式</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">A</th>\n<th style=\"text-align:center\">B</th>\n<th style=\"text-align:center\">C</th>\n<th style=\"text-align:center\">D</th>\n<th style=\"text-align:center\">E</th>\n<th style=\"text-align:center\">F</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Reward</td>\n<td style=\"text-align:center\">-1</td>\n<td style=\"text-align:center\">-2</td>\n<td style=\"text-align:center\">-2</td>\n<td style=\"text-align:center\">-2</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0.9</td>\n<td style=\"text-align:center\">0.1</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0.5</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">0.5</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">0.8</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">0.2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D,0.4</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">0.2</td>\n<td style=\"text-align:center\">0.4</td>\n<td style=\"text-align:center\">0.4</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D,0.6</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">0.6</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">1.0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>其中，D状态有两个动作，但是其0.4概率选到的动作并不一定确定地转移到另一个状态，所以将两个动作分开写，其实除了Reward的每一行都是一个$(s,a)$的状态-动作对，但是除了D状态有特殊外，其他状态的转移都是确定的，于是省略了动作。后续将会看到如果根据$(D,0.4)$这个状态-动作对去进行相应的计算。</p>\n<h3 id=\"状态值函数-V-s\"><a href=\"#状态值函数-V-s\" class=\"headerlink\" title=\"状态值函数$V(s)$\"></a>状态值函数$V(s)$</h3><p>$\\pi$策略下$s$状态的价值函数可以表示为$v_{\\pi}(s)$，由<strong>期望回报</strong>表示</p>\n<script type=\"math/tex; mode=display\">\nv_{\\pi}(s) \\doteq \\mathbb{E}_{\\pi}[G_{t}|S_{t}=s] = \\mathbb{E}_{\\pi}\\left [ \\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid S_{t}=s \\right ], \\ for \\ all \\ s\\in S</script><p>有了这个公式，我们能根据上述表格计算出每个状态的价值吗？当然可以，只是很麻烦，如果对于连续状态空间的问题就不只是麻烦的问题，而是不能计算。</p>\n<p>为什么呢？因为要求期望需要遍历所有可能性的episode，连续状态空间根本无法遍历所有的情况。</p>\n<h3 id=\"动作值函数-Q-s-a\"><a href=\"#动作值函数-Q-s-a\" class=\"headerlink\" title=\"动作值函数$Q(s,a)$\"></a>动作值函数$Q(s,a)$</h3><p>动作值函数与状态值函数在公式表示上差别不大，$\\pi$策略$s$状态下执行a动作的价值函数可以表示为$Q_{\\pi}(s，a)$，由<strong>期望回报</strong>表示</p>\n<script type=\"math/tex; mode=display\">\nQ_{\\pi}(s,a) \\doteq \\mathbb{E}_{\\pi}[G_{t}|S_{t}=s,A_{t}=a] = \\mathbb{E}_{\\pi}\\left [ \\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid S_{t}=s,A_{t}=a \\right ]</script><h2 id=\"贝尔曼方程\"><a href=\"#贝尔曼方程\" class=\"headerlink\" title=\"贝尔曼方程\"></a>贝尔曼方程</h2><blockquote>\n<p><a href=\"https://baike.baidu.com/item/贝尔曼方程/5500990?fr=aladdin\" rel=\"external nofollow\" target=\"_blank\">贝尔曼方程（Bellman Equation）(百度百科)</a>也被称作动态规划方程（Dynamic Programming Equation），由理查·贝尔曼（Richard Bellman）发现。</p>\n<p>贝尔曼方程是动态规划（Dynamic Programming）这些数学最佳化方法能够达到最佳化的必要条件。此方程把“决策问题在特定时间怎么的值”以“来自初始选择的报酬比从初始选择衍生的决策问题的值”的形式表示。借此这个方式把动态最佳化问题变成简单的子问题，而这些子问题遵守从贝尔曼所提出来的“最佳化还原理”。</p>\n</blockquote>\n<p><strong>贝尔曼方程将状态值函数$V(s)$与动作值函数$Q(s,a)$、将当前的值函数与之后状态$V(s‘)$或动作的值函数$Q(s’,a‘)$联系起来。</strong></p>\n<h3 id=\"状态值函数-V-s-与动作值函数-Q-s-a-的关系\"><a href=\"#状态值函数-V-s-与动作值函数-Q-s-a-的关系\" class=\"headerlink\" title=\"状态值函数$V(s)$与动作值函数$Q(s,a)$的关系\"></a>状态值函数$V(s)$与动作值函数$Q(s,a)$的关系</h3><p><img src=\"./价值与贝尔曼方程/vs.jpg\" alt=\"\"></p>\n<script type=\"math/tex; mode=display\">\nv_{\\pi}(s)=\\sum_{a}\\pi(a\\mid s) q_{\\pi}(s,a)</script><p><img src=\"./价值与贝尔曼方程/qsa.jpg\" alt=\"\"></p>\n<script type=\"math/tex; mode=display\">\nq_{\\pi}(s,a) = \\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]</script><h3 id=\"贝尔曼期望方程\"><a href=\"#贝尔曼期望方程\" class=\"headerlink\" title=\"贝尔曼期望方程\"></a>贝尔曼期望方程</h3><p>状态值函数$V(s)$可以写成如下形式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\nv_{\\pi}(s) & \\doteq \\mathbb{E}_{\\pi}\\left [ G_{t}\\mid S_{t}=s \\right ]\\\\\n&=\\mathbb{E}_{t} \\left [R_{t+1}+\\gamma G_{t+1} \\mid S_{t}=s \\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s)\\sum_{s'}\\sum_{r}p(s',r\\mid s,a)\\left[r+\\gamma \\mathbb{E}\\left[G_{t+1}\\mid S_{t+1}=s' \\right]\\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s)\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s) q_{\\pi}(s,a)\n\\end{align*},\nfor \\ all \\ s\\in S</script><p><img src=\"./价值与贝尔曼方程/v.jpg\" alt=\"\"></p>\n<p>看到没有，此时可以将当前状态的状态值$v_{\\pi}(s)$与下一个可到达状态的状态值$v_{\\pi}(s’)$联系起来！</p>\n<p>动作值函数$Q_{\\pi}(s,a)$也可以进行类似推导：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\nq_{\\pi}(s,a) & \\doteq \\mathbb{E}_{\\pi}\\left [ G_{t}\\mid S_{t}=s,A_{t}=a \\right ]\\\\\n&=\\mathbb{E}_{t} \\left [R_{t+1}+\\gamma G_{t+1} \\mid S_{t}=s,A_{t}=a \\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma \\sum_{a'}\\pi(a'\\mid s') \\mathbb{E}\\left[G_{t+1}\\mid S_{t+1}=s',A_{t+1}=a' \\right]\\right]\\\\\n&=\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma \\sum_{a'}\\pi(a'\\mid s') q_{\\pi}(s',a')\\right]\\\\\n&=\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\n\\end{align*}</script><p><img src=\"./价值与贝尔曼方程/q.jpg\" alt=\"\"></p>\n<h3 id=\"最优值函数\"><a href=\"#最优值函数\" class=\"headerlink\" title=\"最优值函数\"></a>最优值函数</h3><p>解决一个强化学习问题也就是意味着找到一种选择动作的策略能够获得足够多的回报。如果执行每个动作所产生的转移都是确定的（有限MDP），那么能够定义出一个最优策略，如果一个策略$\\pi’$的所有状态值函数都大于$\\pi$，那么就说策略$\\pi’$更好，但不一定是最好的，我们把最优策略用$\\pi_{*}$表示。</p>\n<p>最优状态值函数：</p>\n<script type=\"math/tex; mode=display\">\nv_{*}(s)=\\max_{\\pi} v_{\\pi}(s)</script><p>最优动作值函数：</p>\n<script type=\"math/tex; mode=display\">\nq_{*}(s,a)=\\max_{\\pi} q_{\\pi}(s,a)</script><h3 id=\"贝尔曼最优方程\"><a href=\"#贝尔曼最优方程\" class=\"headerlink\" title=\"贝尔曼最优方程\"></a>贝尔曼最优方程</h3><script type=\"math/tex; mode=display\">\n\\begin{align*}\nv_{*}(s) &= \\max_{a} q_{*}(s,a)\\\\\n&=\\max_{a}\\mathbb{E}\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\max_{a}\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\right]\n\\end{align*}</script><script type=\"math/tex; mode=display\">\n\\begin{align*}\nq_{*}(s,a) &= \\mathbb{E}\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\mathbb{E}\\left[r+\\gamma \\max_{a'} q_{*}(s',a')\\mid s,a\\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma \\max_{a'}q_{*}(s',a')\\right]\n\\end{align*}</script><p><img src=\"./价值与贝尔曼方程/vq.jpg\" alt=\"\"></p>\n<p>虽然我们已经定义出了最优值函数和最优策略，而且理论上也可以直接计算出来。但是通常情况下我们没法得到这么多的计算资源。与此同时内存溢出也是一个很大的问题，因为很多问题的状态数量太多超过存储范围。对于这些情况我们就不能够使用直接存储每个状态的值函数而是必须使用一种更精简的参数型函数表示的方法。</p>\n<p>强化学习的框架迫使我们进行近似求解，而且这个框架同时也很容易进行近似，比如对于很多小概率出现的状态，选择最优解和次优解区别不大。</p>\n<h3 id=\"最优策略\"><a href=\"#最优策略\" class=\"headerlink\" title=\"最优策略\"></a>最优策略</h3><p>定义策略之间的偏序关系</p>\n<script type=\"math/tex; mode=display\">\n\\pi \\geq \\pi' \\ if \\ v_{\\pi}(s) \\geq v_{\\pi'}(s) \\ , \\ \\forall s</script><p>那么有如下定理成立：</p>\n<p>对任意MDP：</p>\n<ul>\n<li>存在最优策略$\\pi_{\\ast}$，满足$\\pi_{\\ast} \\geq \\pi,\\forall \\pi$</li>\n<li>所有最优策略的状态值函数都等于最优状态值函数$v_{\\pi_{\\ast}}(s)=v_{\\ast}(s)$</li>\n<li>所有最优策略的动作值函数都等于最优动作值函数$q_{\\pi_{\\ast}}(s,a)=q_{\\ast}(s,a)$</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>对于上述例子和表格，我们来试着计算一下$V(S)、Q(S,A)$。</p>\n<p>第一个问题，怎么计算这些值？初始化终态的状态值为0，然后从后向前递归？我们来试一下！</p>\n<h3 id=\"只初始化终态\"><a href=\"#只初始化终态\" class=\"headerlink\" title=\"只初始化终态\"></a>只初始化终态</h3><p>根据上述公式，设$\\gamma =1$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\n&v(F)=r=0\\\\\n&q(E，)=1\\times (0+v(F))=0\\\\\n&1表示选择这个动作转移至另一个状态的概率\\\\\n&v(E)=1\\times q(E,)=0\\\\\n&q(D,0.6)=1\\times (10+v(E))=10\\\\\n&q(D,0.4)=0.2\\times(-2+v(B))+0.4\\times(-2+v(C))+0.4\\times(-2+v(D))=\\\\\n&v(D)=0.4\\times q(D,0.4)+0.6\\times q(D,0.6)=\\\\\n&q(C,0.8)=1\\times (-2+v(D))=\\\\\n&q(C,0.2)=1\\times (0+v(F))=0\\\\\n&v(C)=0.2\\times q(C,0.2)+0.8\\times q(C,0.8)=\\\\\n&q(B,0.5_{C})=1\\times (-2+v(C))=\\\\\n&q(B,0.5_{A})=1\\times (-1+v(A))=\\\\\n&v(B)=0.5\\times q(B,0.5_{C})+0.5 \\times q(B,0.5_{A})=\\\\\n&q(A,0.9)=1\\times (-1+v(A))=\\\\\n&q(A,0.1)=1\\times(-2+v(B))=\\\\\n&v(A)=0.1\\times q(A,0.1)+0.9\\times q(A,0.9)=\n\\end{align*}</script><p>哎呀，卡住了，解不出来，$v(D)、v(A)、v(B)$互相依赖，解不出来，看来这样计算是行不通了。其实，很多问题中终态都很难定义，更别说使用这种方法了。</p>\n<h3 id=\"初始化全部状态值\"><a href=\"#初始化全部状态值\" class=\"headerlink\" title=\"初始化全部状态值\"></a>初始化全部状态值</h3><p>初始化所有状态的值函数为0，即</p>\n<script type=\"math/tex; mode=display\">\nv(s)=0,\\ for\\ all\\ s\\in S</script><p>先试验一下$\\gamma =0.5$，</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">V和Q，$\\gamma =0.5$</th>\n<th style=\"text-align:center\">初始化V计算Q</th>\n<th style=\"text-align:center\">迭代→V→Q</th>\n<th>第46轮完全收敛</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-2.171</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-1.880</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0.651</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>5.627</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(A,0.1)\\rightarrow B$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-2.940</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(A,0.9)\\rightarrow A$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-2.085</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(B,0.5_{A})\\rightarrow A$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-2.085</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(B,0.5_{C})\\rightarrow C$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-1.675</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(C,0.2)\\rightarrow F$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(C,0.8)\\rightarrow D$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0.814</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(D,0.4)\\rightarrow \\begin{cases}B,0.2\\\\C,0.4\\\\D,0.4\\end{cases}$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-0.932</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(D,0.6)\\rightarrow E$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(E,1.0)\\rightarrow F$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这是代码计算的结果，接下来我使$\\gamma =1$，计算结果如下，每迭代100次输出一下：</p>\n<p><img src=\"./价值与贝尔曼方程/example1.png\" alt=\"\"></p>\n<p>可以发现，在700至800次迭代后值函数最终收敛。</p>\n<p>如果我将$\\gamma $设置为0.1呢？来看一下结果：</p>\n<p><img src=\"./价值与贝尔曼方程/example2.png\" alt=\"\"></p>\n<p>仅仅需要十几次就可以迭代至收敛。</p>\n<p>如果设置为0呢？会怎么样？看结果：</p>\n<p><img src=\"./价值与贝尔曼方程/example3.png\" alt=\"\"></p>\n<p>仅需一次迭代就可以收敛，而且就是转移状态的立即奖励值，这下可以理解$\\gamma$为什么表示对未来的看重程度了吧。</p>\n<p>一般我们是不会将$\\gamma$设置为0的，从这个例子的直观感受也可以得到，就拿$\\gamma =0$与$\\gamma =0.5来比较$：</p>\n<ul>\n<li><p>$\\gamma =0$状态值最高的是$v(D)=5.2$，这很容易理解，D状态距离最大奖励值10最近，理应最好，这点与$\\gamma =0.5$时相同。</p>\n</li>\n<li><p>但是对于状态C，$\\gamma =0$时认为这个状态最差，$v(C)=-1.6$，$\\gamma =0$时认为这个状态次优，$v(C)=0.651$，其实这就是目光短浅与目光长远的不同，$\\gamma =0$并没有考虑到其附近状态的临近状态的价值，导致其主观的认为最接近我的都是负的，于是状态肯定差。</p>\n</li>\n<li><p>对于动作值也是一样，一个认为次优，一个认为最差。</p>\n</li>\n</ul>\n<p><strong>注意：并不是说$\\gamma$越接近于1越好，因为在有些问题上，$\\gamma=1$时其值函数永远不收敛，必须设置$0 \\leq \\gamma \\lt 1$，值函数才能收敛。为什么呢？试着计算一下$\\gamma^{n}$，看看对不同的$\\gamma$值，$n$取什么值时结果接近0。</strong></p>\n<p>试着计算一下这个例子，红色代表立即奖励，蓝色代表选择动作的概率以及状态转移的概率，小写字母代表动作，大写字母代表状态。</p>\n<p><img src=\"./价值与贝尔曼方程/example4.png\" alt=\"\"></p>\n<p>$\\gamma =1$时，迭代100W次也不收敛：</p>\n<p><img src=\"./价值与贝尔曼方程/example5.png\" alt=\"\"></p>\n<p>$\\gamma =0.5$时，迭代50多次即可收敛：</p>\n<p><img src=\"./价值与贝尔曼方程/example6.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"价值与贝尔曼方程\"><a href=\"#价值与贝尔曼方程\" class=\"headerlink\" title=\"价值与贝尔曼方程\"></a>价值与贝尔曼方程</h1><p>我们人在做决策的时候往往会判断做这件事的价值和后果，就像失恋了去喝不喝闷酒一样，不同的人有不同的选择，但是选择前肯定会判断这么做能给自己带来什么。</p>\n<p>选择去喝酒的人觉得这可以缓解自己的痛苦，这就是判断喝酒这个动作的价值。因为身体原因不选择去喝酒的人觉得喝醉之后身体很不舒服，还会说胡话、闹事，这就是衡量后果、判断喝酒后状态的价值。</p>\n<p>在乎过程的会根据动作的价值进行抉择，在乎结果的会根据状态的价值进行抉择。总之，衡量价值，毫无疑问是我们做决策的重要评判标准。</p>\n<p>机器也一样，我们想教会机器学会自主决策，必然得让它们有一个价值导向，毕竟它可不会、也决不能像人一样”没有原因呀，就随便选择了一个而已”。</p>\n<p>本文介绍了<strong>绝大部分强化学习问题及算法</strong>中值函数与贝尔曼方程的定义。因为有一些研究探索的，如好奇心、信息熵等方向的算法对值函数的定义有稍许不同。</p>","more":"<hr>\n<p>注：以下公式及推导过程可能与其他博客、论文、书本上有稍许不同，不过都是经过细细分析，一步步推导的，或许有些公式难以理解，但都是尽可能细化每一处细节。使读者可以更清楚地了解每一个值的来龙去脉。</p>\n<hr>\n<h2 id=\"值函数\"><a href=\"#值函数\" class=\"headerlink\" title=\"值函数\"></a>值函数</h2><p>值函数分为状态值函数与动作值函数，分别用来表示状态和状态下执行某动作的好坏程度、优劣程度。</p>\n<p>回顾一下回报：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\nG_{t} &\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+\\gamma^{3}R_{t+4}+...\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma R_{t+3}+\\gamma^{2}R_{t+4}+...)\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma (R_{t+3}+\\gamma R_{t+4}+...))\\\\\n&=R_{t+1}+\\gamma G_{t+1}\n\\end{align*}</script><script type=\"math/tex; mode=display\">\nG_{t}\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+...=\\begin{cases}\n\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\\\\n\\sum_{k=t+1}^{T}\\gamma^{k-t-1}R_{k}\n\\end{cases}</script><p>回顾一下之前的MDP例子：</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/MDP.jpg\" alt=\"\"></p>\n<p>将状态用符号表示为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n玩游戏 & A\\\\ \n语文 & B\\\\ \n数学 & C\\\\ \n英语 & D\\\\ \n\\mathcal{Pass} & E\\\\ \n睡觉 & F\n\\end{bmatrix}</script><p>将转移概率矩阵$\\mathcal{P}$写成如下形式</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">A</th>\n<th style=\"text-align:center\">B</th>\n<th style=\"text-align:center\">C</th>\n<th style=\"text-align:center\">D</th>\n<th style=\"text-align:center\">E</th>\n<th style=\"text-align:center\">F</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Reward</td>\n<td style=\"text-align:center\">-1</td>\n<td style=\"text-align:center\">-2</td>\n<td style=\"text-align:center\">-2</td>\n<td style=\"text-align:center\">-2</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0.9</td>\n<td style=\"text-align:center\">0.1</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0.5</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">0.5</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">0.8</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">0.2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D,0.4</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">0.2</td>\n<td style=\"text-align:center\">0.4</td>\n<td style=\"text-align:center\">0.4</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D,0.6</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">0.6</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\">1.0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>其中，D状态有两个动作，但是其0.4概率选到的动作并不一定确定地转移到另一个状态，所以将两个动作分开写，其实除了Reward的每一行都是一个$(s,a)$的状态-动作对，但是除了D状态有特殊外，其他状态的转移都是确定的，于是省略了动作。后续将会看到如果根据$(D,0.4)$这个状态-动作对去进行相应的计算。</p>\n<h3 id=\"状态值函数-V-s\"><a href=\"#状态值函数-V-s\" class=\"headerlink\" title=\"状态值函数$V(s)$\"></a>状态值函数$V(s)$</h3><p>$\\pi$策略下$s$状态的价值函数可以表示为$v_{\\pi}(s)$，由<strong>期望回报</strong>表示</p>\n<script type=\"math/tex; mode=display\">\nv_{\\pi}(s) \\doteq \\mathbb{E}_{\\pi}[G_{t}|S_{t}=s] = \\mathbb{E}_{\\pi}\\left [ \\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid S_{t}=s \\right ], \\ for \\ all \\ s\\in S</script><p>有了这个公式，我们能根据上述表格计算出每个状态的价值吗？当然可以，只是很麻烦，如果对于连续状态空间的问题就不只是麻烦的问题，而是不能计算。</p>\n<p>为什么呢？因为要求期望需要遍历所有可能性的episode，连续状态空间根本无法遍历所有的情况。</p>\n<h3 id=\"动作值函数-Q-s-a\"><a href=\"#动作值函数-Q-s-a\" class=\"headerlink\" title=\"动作值函数$Q(s,a)$\"></a>动作值函数$Q(s,a)$</h3><p>动作值函数与状态值函数在公式表示上差别不大，$\\pi$策略$s$状态下执行a动作的价值函数可以表示为$Q_{\\pi}(s，a)$，由<strong>期望回报</strong>表示</p>\n<script type=\"math/tex; mode=display\">\nQ_{\\pi}(s,a) \\doteq \\mathbb{E}_{\\pi}[G_{t}|S_{t}=s,A_{t}=a] = \\mathbb{E}_{\\pi}\\left [ \\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\mid S_{t}=s,A_{t}=a \\right ]</script><h2 id=\"贝尔曼方程\"><a href=\"#贝尔曼方程\" class=\"headerlink\" title=\"贝尔曼方程\"></a>贝尔曼方程</h2><blockquote>\n<p><a href=\"https://baike.baidu.com/item/贝尔曼方程/5500990?fr=aladdin\" rel=\"external nofollow\" target=\"_blank\">贝尔曼方程（Bellman Equation）(百度百科)</a>也被称作动态规划方程（Dynamic Programming Equation），由理查·贝尔曼（Richard Bellman）发现。</p>\n<p>贝尔曼方程是动态规划（Dynamic Programming）这些数学最佳化方法能够达到最佳化的必要条件。此方程把“决策问题在特定时间怎么的值”以“来自初始选择的报酬比从初始选择衍生的决策问题的值”的形式表示。借此这个方式把动态最佳化问题变成简单的子问题，而这些子问题遵守从贝尔曼所提出来的“最佳化还原理”。</p>\n</blockquote>\n<p><strong>贝尔曼方程将状态值函数$V(s)$与动作值函数$Q(s,a)$、将当前的值函数与之后状态$V(s‘)$或动作的值函数$Q(s’,a‘)$联系起来。</strong></p>\n<h3 id=\"状态值函数-V-s-与动作值函数-Q-s-a-的关系\"><a href=\"#状态值函数-V-s-与动作值函数-Q-s-a-的关系\" class=\"headerlink\" title=\"状态值函数$V(s)$与动作值函数$Q(s,a)$的关系\"></a>状态值函数$V(s)$与动作值函数$Q(s,a)$的关系</h3><p><img src=\"./价值与贝尔曼方程/vs.jpg\" alt=\"\"></p>\n<script type=\"math/tex; mode=display\">\nv_{\\pi}(s)=\\sum_{a}\\pi(a\\mid s) q_{\\pi}(s,a)</script><p><img src=\"./价值与贝尔曼方程/qsa.jpg\" alt=\"\"></p>\n<script type=\"math/tex; mode=display\">\nq_{\\pi}(s,a) = \\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]</script><h3 id=\"贝尔曼期望方程\"><a href=\"#贝尔曼期望方程\" class=\"headerlink\" title=\"贝尔曼期望方程\"></a>贝尔曼期望方程</h3><p>状态值函数$V(s)$可以写成如下形式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\nv_{\\pi}(s) & \\doteq \\mathbb{E}_{\\pi}\\left [ G_{t}\\mid S_{t}=s \\right ]\\\\\n&=\\mathbb{E}_{t} \\left [R_{t+1}+\\gamma G_{t+1} \\mid S_{t}=s \\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s)\\sum_{s'}\\sum_{r}p(s',r\\mid s,a)\\left[r+\\gamma \\mathbb{E}\\left[G_{t+1}\\mid S_{t+1}=s' \\right]\\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s)\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\\\\\n&=\\sum_{a}\\pi(a\\mid s) q_{\\pi}(s,a)\n\\end{align*},\nfor \\ all \\ s\\in S</script><p><img src=\"./价值与贝尔曼方程/v.jpg\" alt=\"\"></p>\n<p>看到没有，此时可以将当前状态的状态值$v_{\\pi}(s)$与下一个可到达状态的状态值$v_{\\pi}(s’)$联系起来！</p>\n<p>动作值函数$Q_{\\pi}(s,a)$也可以进行类似推导：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\nq_{\\pi}(s,a) & \\doteq \\mathbb{E}_{\\pi}\\left [ G_{t}\\mid S_{t}=s,A_{t}=a \\right ]\\\\\n&=\\mathbb{E}_{t} \\left [R_{t+1}+\\gamma G_{t+1} \\mid S_{t}=s,A_{t}=a \\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma \\sum_{a'}\\pi(a'\\mid s') \\mathbb{E}\\left[G_{t+1}\\mid S_{t+1}=s',A_{t+1}=a' \\right]\\right]\\\\\n&=\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma \\sum_{a'}\\pi(a'\\mid s') q_{\\pi}(s',a')\\right]\\\\\n&=\\sum_{s',r}p(s',r \\mid s,a)\\left[r+\\gamma v_{\\pi}(s')\\right]\n\\end{align*}</script><p><img src=\"./价值与贝尔曼方程/q.jpg\" alt=\"\"></p>\n<h3 id=\"最优值函数\"><a href=\"#最优值函数\" class=\"headerlink\" title=\"最优值函数\"></a>最优值函数</h3><p>解决一个强化学习问题也就是意味着找到一种选择动作的策略能够获得足够多的回报。如果执行每个动作所产生的转移都是确定的（有限MDP），那么能够定义出一个最优策略，如果一个策略$\\pi’$的所有状态值函数都大于$\\pi$，那么就说策略$\\pi’$更好，但不一定是最好的，我们把最优策略用$\\pi_{*}$表示。</p>\n<p>最优状态值函数：</p>\n<script type=\"math/tex; mode=display\">\nv_{*}(s)=\\max_{\\pi} v_{\\pi}(s)</script><p>最优动作值函数：</p>\n<script type=\"math/tex; mode=display\">\nq_{*}(s,a)=\\max_{\\pi} q_{\\pi}(s,a)</script><h3 id=\"贝尔曼最优方程\"><a href=\"#贝尔曼最优方程\" class=\"headerlink\" title=\"贝尔曼最优方程\"></a>贝尔曼最优方程</h3><script type=\"math/tex; mode=display\">\n\\begin{align*}\nv_{*}(s) &= \\max_{a} q_{*}(s,a)\\\\\n&=\\max_{a}\\mathbb{E}\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\max_{a}\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\right]\n\\end{align*}</script><script type=\"math/tex; mode=display\">\n\\begin{align*}\nq_{*}(s,a) &= \\mathbb{E}\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\mathbb{E}\\left[r+\\gamma \\max_{a'} q_{*}(s',a')\\mid s,a\\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma v_{*}(s')\\mid s,a\\right]\\\\\n&=\\sum_{s',r}p(s',r\\mid s,a)\\left[r+\\gamma \\max_{a'}q_{*}(s',a')\\right]\n\\end{align*}</script><p><img src=\"./价值与贝尔曼方程/vq.jpg\" alt=\"\"></p>\n<p>虽然我们已经定义出了最优值函数和最优策略，而且理论上也可以直接计算出来。但是通常情况下我们没法得到这么多的计算资源。与此同时内存溢出也是一个很大的问题，因为很多问题的状态数量太多超过存储范围。对于这些情况我们就不能够使用直接存储每个状态的值函数而是必须使用一种更精简的参数型函数表示的方法。</p>\n<p>强化学习的框架迫使我们进行近似求解，而且这个框架同时也很容易进行近似，比如对于很多小概率出现的状态，选择最优解和次优解区别不大。</p>\n<h3 id=\"最优策略\"><a href=\"#最优策略\" class=\"headerlink\" title=\"最优策略\"></a>最优策略</h3><p>定义策略之间的偏序关系</p>\n<script type=\"math/tex; mode=display\">\n\\pi \\geq \\pi' \\ if \\ v_{\\pi}(s) \\geq v_{\\pi'}(s) \\ , \\ \\forall s</script><p>那么有如下定理成立：</p>\n<p>对任意MDP：</p>\n<ul>\n<li>存在最优策略$\\pi_{\\ast}$，满足$\\pi_{\\ast} \\geq \\pi,\\forall \\pi$</li>\n<li>所有最优策略的状态值函数都等于最优状态值函数$v_{\\pi_{\\ast}}(s)=v_{\\ast}(s)$</li>\n<li>所有最优策略的动作值函数都等于最优动作值函数$q_{\\pi_{\\ast}}(s,a)=q_{\\ast}(s,a)$</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>对于上述例子和表格，我们来试着计算一下$V(S)、Q(S,A)$。</p>\n<p>第一个问题，怎么计算这些值？初始化终态的状态值为0，然后从后向前递归？我们来试一下！</p>\n<h3 id=\"只初始化终态\"><a href=\"#只初始化终态\" class=\"headerlink\" title=\"只初始化终态\"></a>只初始化终态</h3><p>根据上述公式，设$\\gamma =1$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\n&v(F)=r=0\\\\\n&q(E，)=1\\times (0+v(F))=0\\\\\n&1表示选择这个动作转移至另一个状态的概率\\\\\n&v(E)=1\\times q(E,)=0\\\\\n&q(D,0.6)=1\\times (10+v(E))=10\\\\\n&q(D,0.4)=0.2\\times(-2+v(B))+0.4\\times(-2+v(C))+0.4\\times(-2+v(D))=\\\\\n&v(D)=0.4\\times q(D,0.4)+0.6\\times q(D,0.6)=\\\\\n&q(C,0.8)=1\\times (-2+v(D))=\\\\\n&q(C,0.2)=1\\times (0+v(F))=0\\\\\n&v(C)=0.2\\times q(C,0.2)+0.8\\times q(C,0.8)=\\\\\n&q(B,0.5_{C})=1\\times (-2+v(C))=\\\\\n&q(B,0.5_{A})=1\\times (-1+v(A))=\\\\\n&v(B)=0.5\\times q(B,0.5_{C})+0.5 \\times q(B,0.5_{A})=\\\\\n&q(A,0.9)=1\\times (-1+v(A))=\\\\\n&q(A,0.1)=1\\times(-2+v(B))=\\\\\n&v(A)=0.1\\times q(A,0.1)+0.9\\times q(A,0.9)=\n\\end{align*}</script><p>哎呀，卡住了，解不出来，$v(D)、v(A)、v(B)$互相依赖，解不出来，看来这样计算是行不通了。其实，很多问题中终态都很难定义，更别说使用这种方法了。</p>\n<h3 id=\"初始化全部状态值\"><a href=\"#初始化全部状态值\" class=\"headerlink\" title=\"初始化全部状态值\"></a>初始化全部状态值</h3><p>初始化所有状态的值函数为0，即</p>\n<script type=\"math/tex; mode=display\">\nv(s)=0,\\ for\\ all\\ s\\in S</script><p>先试验一下$\\gamma =0.5$，</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">V和Q，$\\gamma =0.5$</th>\n<th style=\"text-align:center\">初始化V计算Q</th>\n<th style=\"text-align:center\">迭代→V→Q</th>\n<th>第46轮完全收敛</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-2.171</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-1.880</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0.651</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>5.627</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(A,0.1)\\rightarrow B$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-2.940</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(A,0.9)\\rightarrow A$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-2.085</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(B,0.5_{A})\\rightarrow A$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-2.085</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(B,0.5_{C})\\rightarrow C$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-1.675</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(C,0.2)\\rightarrow F$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(C,0.8)\\rightarrow D$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0.814</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(D,0.4)\\rightarrow \\begin{cases}B,0.2\\\\C,0.4\\\\D,0.4\\end{cases}$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>-0.932</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(D,0.6)\\rightarrow E$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$(E,1.0)\\rightarrow F$</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">……</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这是代码计算的结果，接下来我使$\\gamma =1$，计算结果如下，每迭代100次输出一下：</p>\n<p><img src=\"./价值与贝尔曼方程/example1.png\" alt=\"\"></p>\n<p>可以发现，在700至800次迭代后值函数最终收敛。</p>\n<p>如果我将$\\gamma $设置为0.1呢？来看一下结果：</p>\n<p><img src=\"./价值与贝尔曼方程/example2.png\" alt=\"\"></p>\n<p>仅仅需要十几次就可以迭代至收敛。</p>\n<p>如果设置为0呢？会怎么样？看结果：</p>\n<p><img src=\"./价值与贝尔曼方程/example3.png\" alt=\"\"></p>\n<p>仅需一次迭代就可以收敛，而且就是转移状态的立即奖励值，这下可以理解$\\gamma$为什么表示对未来的看重程度了吧。</p>\n<p>一般我们是不会将$\\gamma$设置为0的，从这个例子的直观感受也可以得到，就拿$\\gamma =0$与$\\gamma =0.5来比较$：</p>\n<ul>\n<li><p>$\\gamma =0$状态值最高的是$v(D)=5.2$，这很容易理解，D状态距离最大奖励值10最近，理应最好，这点与$\\gamma =0.5$时相同。</p>\n</li>\n<li><p>但是对于状态C，$\\gamma =0$时认为这个状态最差，$v(C)=-1.6$，$\\gamma =0$时认为这个状态次优，$v(C)=0.651$，其实这就是目光短浅与目光长远的不同，$\\gamma =0$并没有考虑到其附近状态的临近状态的价值，导致其主观的认为最接近我的都是负的，于是状态肯定差。</p>\n</li>\n<li><p>对于动作值也是一样，一个认为次优，一个认为最差。</p>\n</li>\n</ul>\n<p><strong>注意：并不是说$\\gamma$越接近于1越好，因为在有些问题上，$\\gamma=1$时其值函数永远不收敛，必须设置$0 \\leq \\gamma \\lt 1$，值函数才能收敛。为什么呢？试着计算一下$\\gamma^{n}$，看看对不同的$\\gamma$值，$n$取什么值时结果接近0。</strong></p>\n<p>试着计算一下这个例子，红色代表立即奖励，蓝色代表选择动作的概率以及状态转移的概率，小写字母代表动作，大写字母代表状态。</p>\n<p><img src=\"./价值与贝尔曼方程/example4.png\" alt=\"\"></p>\n<p>$\\gamma =1$时，迭代100W次也不收敛：</p>\n<p><img src=\"./价值与贝尔曼方程/example5.png\" alt=\"\"></p>\n<p>$\\gamma =0.5$时，迭代50多次即可收敛：</p>\n<p><img src=\"./价值与贝尔曼方程/example6.png\" alt=\"\"></p>"},{"title":"强化学习基本概念","copyright":true,"top":1,"date":"2019-04-08T11:23:16.000Z","mathjax":true,"_content":"\n# 强化学习基本概念\n\n学习了这么久的强化学习, 不做笔记总是会忘记, 于是写在博客里方便自己复习, 也与同路人分享.\n\n## 强化学习是什么?\n\n强化学习是什么? 它的英文名字是*Reinforcement Learning*, 和*Machine Learning*一样, 都是以*'ing'*结尾的. 它是一个问题、一组解决这个问题的方案以及探求这些解决方案的方法. 对于问题和方法一定要有清晰的认识, 很多人在学习强化学习时遇到的各种困惑与不解都是因为不能清晰的认识问题和方法的区别和联系.\n\n<!--more-->\n\n强化学习与有监督学习(*supervised learning*)不同. 有监督学习是目前机器学习领域研究最多的方向, 它从由经验丰富的、学识渊博的专家(监督者)提供一系列带有标签(如每个样本被正确分类的类别)的样本数据中进行学习, 这种方法通常被用于分类问题. 有监督学习的目标是当给定一个没有在训练样本集出现的数据时, 可以准确推断出它的标签/类别. 这种有监督学习非常重要而且有用, 但是它没有能力从**交互**中进行学习, 而强化学习在智能体与环境进行交互的过程中进行学习. 为什么有监督学习不能从交互中学习呢? 因为有监督学习需要的近乎完全的样本以及其准确的信息都是在交互问题中很难获得的(不现实的). 在未知的交互场景中, 我们往往只能根据智能体的经验进行学习.\n\n强化学习与无监督学习(*unsupervised learning*)也是不同的. 无监督学习通常被用于发现无标签样本集的隐藏结构. 我们一般任务机器学习只分为有、无监督学习两种, 而且将强化学习分为无监督学习一类. 但其实强化学习与无监督学习有本质的区别. **强化学习的目的是最大化可获得的奖励值**, 而无监督学习是发现隐藏结构. 当然, 如果在强化学习问题中可以发现其样本内的隐藏结构, 这对于强化学习肯定是很有帮助的, 但是仅仅这些隐藏结构并不能处理强化学习最大化奖励值方法的问题. 因此, 我们通常将强化学习归为机器学习的第三个类别, 与有、无监督学习并列.\n\n*注: 在强化学习问题中, 任何可以反映当前动作所带来的影响的元素都可以被理解为奖励值.(个人见解)*\n\n> Reinforcement learning is learning what to do——how to map situations to actions——so as to maxmize a numerical reward signal.\t——《Reinforcement Learning: An Introduction》\n\n强化学习学习的是从状态*s*到要执行的最优动作*a*之间的映射关系, 也就是找到一个策略(函数/逻辑规则)使得在给定状态下通过该策略所产生的决策可以最终带来最大的回报. 学习者不被告知应该采取什么动作, 而是通过训练使它们发现采取什么样的动作可以产生最高的奖励值. 这与婴儿学习的方式很像, 你可能会说:\"瞎讲, 婴儿可以模仿你的动作进行学习.\". 但你要知道, 当你对婴儿的动作进行批评(吵)和奖励(笑)时, 这就已经是一个强化学习的过程了.\n\n## 强化学习的两个要素\n\n强化学习必不可少的两个要素是智能体`Agent`和环境`Environment`.\n既然强化学习是在交互过程中进行学习, 那么交互必定是双方或者多方的, 在强化学习问题中, 交互的双方是智能体和环境.\n\n1. 智能体\n- 智能体是环境的观察者\n- 智能体是策略的载体\n- 智能体是动作的执行者\n3. 环境\n- 环境是对智能体动作的评判者, 即给出立即奖励\n- 环境是智能体进行运动等行为的基本空间\n- 环境给出当前时刻的观察信息, 供智能体进行采集\n\n## 强化学习的两个特点\n\n1. **trial-and-error/试错学习**\n智能体在与环境交互的过程中进行学习时, 不会得到任何人为的或者示例的指导(如果进行指导, 则为有监督学习/模仿学习/逆强化学习等), 智能体只能通过在环境中不断地**试错**, 积累经验, 最终学到可以完成目标并获得最大奖励值的策略.\n2. **delayed reward/延迟奖励**\n在大多数强化学习问题中, 某一状态*s*下执行的动作*a*不仅会影响当前的立即奖励*r*, 而且还会影响后续的状态序列, 以及后续的奖励值. 当前的立即奖励值并不能反映出在这个动作对(*s,a*)对整个决策过程的影响, 只有等到这一决策过程结束时, 才能判断其在这个状态序列的奖励(价值), 所以, 延迟奖励也是强化学习过程中的一个特点.\n\n## 强化学习的难点(Challenge)\n\n相比其他学习, 强化学习中的一大难点是**探索与利用**, 也就是**exploration and exploitation**, 这个难题已经被数学家研究了几十年了, 但仍然没有解决. 为了获得尽量多的奖励, 智能体需要根据过去学习的经验选择产生立即奖励值最高的动作, 但是给定状态下可供选择的动作有很多, 有些被执行过, 有些没有被执行过, 为了去发现产生立即奖励值最高的动作, 必须尝试选择之前被选择过动作. 这个问题就出现了, **智能体必须利用它已经探索过的产生大奖励值的动作, 也必须探索未知奖励值的动作(有可能很小)为了以后可以选择更好的动作**. 只探索不利用、只利用不探索在强化学习问题中都是独木难支. 在随机任务中, 一个同样的动作往往需要被探索很多次才可能对它的期望奖励值有较准确的估计. \n\n## 强化学习的四个元素\n\n除了智能体与环境两个要素之外, 强化学习系统/框架中还有四个子元素: 策略、奖励机制、值函数、模型(未必有).\n\n1. 策略 Policy\n策略定义了智能体在当前时刻应该做出的行为. 与人类的刺激-反应机制很像, 策略是从感知到的环境信息到执行的行为之间的映射, 策略是强化学习智能体的**核心**, 它决定了智能体的行为. 在一般的强化学习问题中, 策略可能是随机的、非确定的, 它通常给出可选择执行的动作的概率或概率分布.\n\n2. 奖励机制 Reward Signal\n奖励机制定义了强化学习问题的**目标**, 在交互的每一步, 环境都会向智能体传递一个数字信息, 我们称之为\"奖励\". 智能体的唯一目标就是在整个交互过程中最大化总的奖励之和. 因此, 奖励定义了某个动作的好坏(但并不意味着坏的动作在交互过程中是坏的, 其作用由值函数来定义). 类比于我们人类, 奖励就像我们高兴或者痛苦一样, 它们是我们对当前环境-动作的立即反应和评价. \n奖励机制是智能体更新策略Policy的基础, 如果智能体成功进行了学习, 当在当前策略选择了一个较低回报的动作时, 之后它可能会选择其他动作. \n通常, 奖励机制由状态*s*和动作*a*的随机函数表示`R(s,a)`\n\n3. 值函数 Value Function\n立即奖励表示着当前动作或状态带来的立即效果是好是坏, 但是值函数表示这个动作在整个交互过程中扮演的角色是好是坏. 一个状态的值是从该状态开始到交互结束所积累的立即奖励的总和.\n一个状态可能总是产生很低的立即奖励, 但是它有很高的值, 因为该状态之后的后续状态中会产生很大的立即奖励. 相反也是一样. 类比于我们人类, 立即奖励的高低相当于我们高兴或痛苦, 但是值函数给出的值则表示了在整个事件过程中我们有多高兴或不高兴的深刻判断. \n引入值函数的唯一目的就是为了训练智能体以获得更大的奖励, 当智能体做决策以及评估决策时, 我们一直关心的都是值函数而不是立即奖励, 对于动作的选择也是基于对值函数的判断/评估. 值比立即奖励更难以确定, 因为立即奖励可以由环境准确的给出, 但是值却需要评估甚至多次评估才可能相对准确(因为有可能交互过程永远不结束, 那么对值的估计会有偏差). 我们希望选择的动作带来最高的值, 而不是最高的立即奖励, 实际上, 几乎所有强化学习算法中最重要的部分就是对于值函数的有效估计方法. 关于值函数估计所扮演的核心角色在近60年被广泛研究. \n\n4. 模型 Model\n模型是对环境行为的仿真, 我们可以通过模型推断出动作对环境的改变, 给出准确的立即奖励和状态信息. 例如, 给定一个状态和动作, 模型可以预测出下一个要转移的状态以及下一个立即奖励值. 如果模型是确定的, 我们一般使用规划(*planning*)的方法来选择最优动作, 对于这种方式我们称之为基于模型**model-based**的方法, 相反, 如果模型是不确定的, 也就是**model-free**, 我们只能通过试错的方式进行学习并选择动作. \n\n*注: 对于什么是model-based和model-free将在以后进行深入讨论.*\n\n## 强化学习的目标\n\n与目标识别为了最小化误差损失不同，强化学习的目的是寻到一个策略，使得期望（折扣）奖励最大化。\n\n## 强化学习的通用符号表示 Notation\n\n$←$\t赋值\n\n$\\varepsilon$ 在$\\varepsilon-greedy$策略中随机选择动作的概率\n\n$\\gamma$ 计算总奖励的折扣因子\n\n$\\lambda$ 资格迹的衰减率或者GAE的权重因子\n\n$s,s'$ 状态，下一个状态\n\n$a$ 一个动作\n\n$r$ 一个奖励值（标量）\n\n$S$ 状态集（不包含终态）\n\n$S^{+}$ 状态集（包含终态）\n\n$A(s)$ $s$状态下可选择的动作\n\n$R$ 奖励集合\n\n$|S|$ 状态集中的元素数\n\n$t$ 单个时间步\n\n$T$ 一个episode的终态时间点\n\n$A_{t}$ $t$时刻选择的动作\n\n$S_{t}$ $t$时刻所在的状态\n\n$R_{t}$ $t$时刻获得的奖励\n\n$\\pi$ 策略（从状态到动作的映射）\n\n$\\pi(s)$ 在$s$状态下使用$\\pi$策略所选择的动作\n\n$\\pi(a|s)$ 在$s$状态下使用$\\pi$策略选择到动作$a$的概率\n\n$G_{t}$ 以$t$时刻为起始时间点，到终态所能获得的总奖励（回报）\n\n$p(s',r|s,a)$ 在$s$状态执行a动作转移到$s‘$状态并获得奖励值为$r$的概率\n\n$p(s'|s,a)$ 在$s$状态执行$a$动作转移到$s’$状态的概率\n\n$r(s,a)$ 在$s$状态执行$a$动作所获得的**期望**立即奖励（即时奖励）\n\n$r(s,a,s')$ 在$s$状态执行$a$动作转移到$s'$状态所获得的**期望**立即奖励\n\n$v_{\\pi}(s)$ $\\pi$策略下状态$s$的值（以该状态为始态的期望奖励回报）\n\n$v_{*}(s)$ **最优**策略下状态s的值\n\n$q_{\\pi}(s,a)$ $\\pi$策略下状态-行动对$(s,a)$的值\n\n$q_{*}(s,a)$ **最优**策略下状态-行动对$(s,a)$的值\n\n$V,V_{t}$ 状态值的矩阵估计，行和列分别是时间点$t$和每个状态的估计值$v_{\\pi}$或$v_{*}$\n\n$Q,Q_{t}$ 状态-行动对$(s,a)$的矩阵估计，一般为一个3维矩阵,行、列和深度分别为状态、动作、时间点\n\n$V_{t}(s)$ 状态$s$的期望估计值\n\n$\\delta_{t}$ $t$时刻的TD-error时间差分量\n\n$\\theta,\\theta_{t}$ 目标策略的参数（向量）\n\n$\\pi(a|s,\\theta)$ 目标策略的参数为$\\theta$时，在$s$状态选择到$a$动作的概率\n\n$\\pi_{\\theta}$ 表示参数为$\\theta$的策略\n\n$\\nabla{\\pi(a|s,\\theta)}$ $\\pi(a|s,\\theta)$对于参数$\\theta$的偏微分\n\n$J(\\theta)$ 参数为$\\theta$的策略的性能度量、期望奖励(performance measure)\n\n$\\nabla{J(\\theta)}$ 性能度量对于策略参数$\\theta$的偏导数","source":"_posts/强化学习基本概念.md","raw":"---\ntitle: 强化学习基本概念\ncopyright: true\ntop: 1\ndate: 2019-04-08 19:23:16\nmathjax: true\ncategories: ReinforcementLearning\ntags:\n- rl\n---\n\n# 强化学习基本概念\n\n学习了这么久的强化学习, 不做笔记总是会忘记, 于是写在博客里方便自己复习, 也与同路人分享.\n\n## 强化学习是什么?\n\n强化学习是什么? 它的英文名字是*Reinforcement Learning*, 和*Machine Learning*一样, 都是以*'ing'*结尾的. 它是一个问题、一组解决这个问题的方案以及探求这些解决方案的方法. 对于问题和方法一定要有清晰的认识, 很多人在学习强化学习时遇到的各种困惑与不解都是因为不能清晰的认识问题和方法的区别和联系.\n\n<!--more-->\n\n强化学习与有监督学习(*supervised learning*)不同. 有监督学习是目前机器学习领域研究最多的方向, 它从由经验丰富的、学识渊博的专家(监督者)提供一系列带有标签(如每个样本被正确分类的类别)的样本数据中进行学习, 这种方法通常被用于分类问题. 有监督学习的目标是当给定一个没有在训练样本集出现的数据时, 可以准确推断出它的标签/类别. 这种有监督学习非常重要而且有用, 但是它没有能力从**交互**中进行学习, 而强化学习在智能体与环境进行交互的过程中进行学习. 为什么有监督学习不能从交互中学习呢? 因为有监督学习需要的近乎完全的样本以及其准确的信息都是在交互问题中很难获得的(不现实的). 在未知的交互场景中, 我们往往只能根据智能体的经验进行学习.\n\n强化学习与无监督学习(*unsupervised learning*)也是不同的. 无监督学习通常被用于发现无标签样本集的隐藏结构. 我们一般任务机器学习只分为有、无监督学习两种, 而且将强化学习分为无监督学习一类. 但其实强化学习与无监督学习有本质的区别. **强化学习的目的是最大化可获得的奖励值**, 而无监督学习是发现隐藏结构. 当然, 如果在强化学习问题中可以发现其样本内的隐藏结构, 这对于强化学习肯定是很有帮助的, 但是仅仅这些隐藏结构并不能处理强化学习最大化奖励值方法的问题. 因此, 我们通常将强化学习归为机器学习的第三个类别, 与有、无监督学习并列.\n\n*注: 在强化学习问题中, 任何可以反映当前动作所带来的影响的元素都可以被理解为奖励值.(个人见解)*\n\n> Reinforcement learning is learning what to do——how to map situations to actions——so as to maxmize a numerical reward signal.\t——《Reinforcement Learning: An Introduction》\n\n强化学习学习的是从状态*s*到要执行的最优动作*a*之间的映射关系, 也就是找到一个策略(函数/逻辑规则)使得在给定状态下通过该策略所产生的决策可以最终带来最大的回报. 学习者不被告知应该采取什么动作, 而是通过训练使它们发现采取什么样的动作可以产生最高的奖励值. 这与婴儿学习的方式很像, 你可能会说:\"瞎讲, 婴儿可以模仿你的动作进行学习.\". 但你要知道, 当你对婴儿的动作进行批评(吵)和奖励(笑)时, 这就已经是一个强化学习的过程了.\n\n## 强化学习的两个要素\n\n强化学习必不可少的两个要素是智能体`Agent`和环境`Environment`.\n既然强化学习是在交互过程中进行学习, 那么交互必定是双方或者多方的, 在强化学习问题中, 交互的双方是智能体和环境.\n\n1. 智能体\n- 智能体是环境的观察者\n- 智能体是策略的载体\n- 智能体是动作的执行者\n3. 环境\n- 环境是对智能体动作的评判者, 即给出立即奖励\n- 环境是智能体进行运动等行为的基本空间\n- 环境给出当前时刻的观察信息, 供智能体进行采集\n\n## 强化学习的两个特点\n\n1. **trial-and-error/试错学习**\n智能体在与环境交互的过程中进行学习时, 不会得到任何人为的或者示例的指导(如果进行指导, 则为有监督学习/模仿学习/逆强化学习等), 智能体只能通过在环境中不断地**试错**, 积累经验, 最终学到可以完成目标并获得最大奖励值的策略.\n2. **delayed reward/延迟奖励**\n在大多数强化学习问题中, 某一状态*s*下执行的动作*a*不仅会影响当前的立即奖励*r*, 而且还会影响后续的状态序列, 以及后续的奖励值. 当前的立即奖励值并不能反映出在这个动作对(*s,a*)对整个决策过程的影响, 只有等到这一决策过程结束时, 才能判断其在这个状态序列的奖励(价值), 所以, 延迟奖励也是强化学习过程中的一个特点.\n\n## 强化学习的难点(Challenge)\n\n相比其他学习, 强化学习中的一大难点是**探索与利用**, 也就是**exploration and exploitation**, 这个难题已经被数学家研究了几十年了, 但仍然没有解决. 为了获得尽量多的奖励, 智能体需要根据过去学习的经验选择产生立即奖励值最高的动作, 但是给定状态下可供选择的动作有很多, 有些被执行过, 有些没有被执行过, 为了去发现产生立即奖励值最高的动作, 必须尝试选择之前被选择过动作. 这个问题就出现了, **智能体必须利用它已经探索过的产生大奖励值的动作, 也必须探索未知奖励值的动作(有可能很小)为了以后可以选择更好的动作**. 只探索不利用、只利用不探索在强化学习问题中都是独木难支. 在随机任务中, 一个同样的动作往往需要被探索很多次才可能对它的期望奖励值有较准确的估计. \n\n## 强化学习的四个元素\n\n除了智能体与环境两个要素之外, 强化学习系统/框架中还有四个子元素: 策略、奖励机制、值函数、模型(未必有).\n\n1. 策略 Policy\n策略定义了智能体在当前时刻应该做出的行为. 与人类的刺激-反应机制很像, 策略是从感知到的环境信息到执行的行为之间的映射, 策略是强化学习智能体的**核心**, 它决定了智能体的行为. 在一般的强化学习问题中, 策略可能是随机的、非确定的, 它通常给出可选择执行的动作的概率或概率分布.\n\n2. 奖励机制 Reward Signal\n奖励机制定义了强化学习问题的**目标**, 在交互的每一步, 环境都会向智能体传递一个数字信息, 我们称之为\"奖励\". 智能体的唯一目标就是在整个交互过程中最大化总的奖励之和. 因此, 奖励定义了某个动作的好坏(但并不意味着坏的动作在交互过程中是坏的, 其作用由值函数来定义). 类比于我们人类, 奖励就像我们高兴或者痛苦一样, 它们是我们对当前环境-动作的立即反应和评价. \n奖励机制是智能体更新策略Policy的基础, 如果智能体成功进行了学习, 当在当前策略选择了一个较低回报的动作时, 之后它可能会选择其他动作. \n通常, 奖励机制由状态*s*和动作*a*的随机函数表示`R(s,a)`\n\n3. 值函数 Value Function\n立即奖励表示着当前动作或状态带来的立即效果是好是坏, 但是值函数表示这个动作在整个交互过程中扮演的角色是好是坏. 一个状态的值是从该状态开始到交互结束所积累的立即奖励的总和.\n一个状态可能总是产生很低的立即奖励, 但是它有很高的值, 因为该状态之后的后续状态中会产生很大的立即奖励. 相反也是一样. 类比于我们人类, 立即奖励的高低相当于我们高兴或痛苦, 但是值函数给出的值则表示了在整个事件过程中我们有多高兴或不高兴的深刻判断. \n引入值函数的唯一目的就是为了训练智能体以获得更大的奖励, 当智能体做决策以及评估决策时, 我们一直关心的都是值函数而不是立即奖励, 对于动作的选择也是基于对值函数的判断/评估. 值比立即奖励更难以确定, 因为立即奖励可以由环境准确的给出, 但是值却需要评估甚至多次评估才可能相对准确(因为有可能交互过程永远不结束, 那么对值的估计会有偏差). 我们希望选择的动作带来最高的值, 而不是最高的立即奖励, 实际上, 几乎所有强化学习算法中最重要的部分就是对于值函数的有效估计方法. 关于值函数估计所扮演的核心角色在近60年被广泛研究. \n\n4. 模型 Model\n模型是对环境行为的仿真, 我们可以通过模型推断出动作对环境的改变, 给出准确的立即奖励和状态信息. 例如, 给定一个状态和动作, 模型可以预测出下一个要转移的状态以及下一个立即奖励值. 如果模型是确定的, 我们一般使用规划(*planning*)的方法来选择最优动作, 对于这种方式我们称之为基于模型**model-based**的方法, 相反, 如果模型是不确定的, 也就是**model-free**, 我们只能通过试错的方式进行学习并选择动作. \n\n*注: 对于什么是model-based和model-free将在以后进行深入讨论.*\n\n## 强化学习的目标\n\n与目标识别为了最小化误差损失不同，强化学习的目的是寻到一个策略，使得期望（折扣）奖励最大化。\n\n## 强化学习的通用符号表示 Notation\n\n$←$\t赋值\n\n$\\varepsilon$ 在$\\varepsilon-greedy$策略中随机选择动作的概率\n\n$\\gamma$ 计算总奖励的折扣因子\n\n$\\lambda$ 资格迹的衰减率或者GAE的权重因子\n\n$s,s'$ 状态，下一个状态\n\n$a$ 一个动作\n\n$r$ 一个奖励值（标量）\n\n$S$ 状态集（不包含终态）\n\n$S^{+}$ 状态集（包含终态）\n\n$A(s)$ $s$状态下可选择的动作\n\n$R$ 奖励集合\n\n$|S|$ 状态集中的元素数\n\n$t$ 单个时间步\n\n$T$ 一个episode的终态时间点\n\n$A_{t}$ $t$时刻选择的动作\n\n$S_{t}$ $t$时刻所在的状态\n\n$R_{t}$ $t$时刻获得的奖励\n\n$\\pi$ 策略（从状态到动作的映射）\n\n$\\pi(s)$ 在$s$状态下使用$\\pi$策略所选择的动作\n\n$\\pi(a|s)$ 在$s$状态下使用$\\pi$策略选择到动作$a$的概率\n\n$G_{t}$ 以$t$时刻为起始时间点，到终态所能获得的总奖励（回报）\n\n$p(s',r|s,a)$ 在$s$状态执行a动作转移到$s‘$状态并获得奖励值为$r$的概率\n\n$p(s'|s,a)$ 在$s$状态执行$a$动作转移到$s’$状态的概率\n\n$r(s,a)$ 在$s$状态执行$a$动作所获得的**期望**立即奖励（即时奖励）\n\n$r(s,a,s')$ 在$s$状态执行$a$动作转移到$s'$状态所获得的**期望**立即奖励\n\n$v_{\\pi}(s)$ $\\pi$策略下状态$s$的值（以该状态为始态的期望奖励回报）\n\n$v_{*}(s)$ **最优**策略下状态s的值\n\n$q_{\\pi}(s,a)$ $\\pi$策略下状态-行动对$(s,a)$的值\n\n$q_{*}(s,a)$ **最优**策略下状态-行动对$(s,a)$的值\n\n$V,V_{t}$ 状态值的矩阵估计，行和列分别是时间点$t$和每个状态的估计值$v_{\\pi}$或$v_{*}$\n\n$Q,Q_{t}$ 状态-行动对$(s,a)$的矩阵估计，一般为一个3维矩阵,行、列和深度分别为状态、动作、时间点\n\n$V_{t}(s)$ 状态$s$的期望估计值\n\n$\\delta_{t}$ $t$时刻的TD-error时间差分量\n\n$\\theta,\\theta_{t}$ 目标策略的参数（向量）\n\n$\\pi(a|s,\\theta)$ 目标策略的参数为$\\theta$时，在$s$状态选择到$a$动作的概率\n\n$\\pi_{\\theta}$ 表示参数为$\\theta$的策略\n\n$\\nabla{\\pi(a|s,\\theta)}$ $\\pi(a|s,\\theta)$对于参数$\\theta$的偏微分\n\n$J(\\theta)$ 参数为$\\theta$的策略的性能度量、期望奖励(performance measure)\n\n$\\nabla{J(\\theta)}$ 性能度量对于策略参数$\\theta$的偏导数","slug":"强化学习基本概念","published":1,"updated":"2019-05-12T14:59:28.294Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzutah005f20cd2nzzgh03","content":"<h1 id=\"强化学习基本概念\"><a href=\"#强化学习基本概念\" class=\"headerlink\" title=\"强化学习基本概念\"></a>强化学习基本概念</h1><p>学习了这么久的强化学习, 不做笔记总是会忘记, 于是写在博客里方便自己复习, 也与同路人分享.</p>\n<h2 id=\"强化学习是什么\"><a href=\"#强化学习是什么\" class=\"headerlink\" title=\"强化学习是什么?\"></a>强化学习是什么?</h2><p>强化学习是什么? 它的英文名字是<em>Reinforcement Learning</em>, 和<em>Machine Learning</em>一样, 都是以<em>‘ing’</em>结尾的. 它是一个问题、一组解决这个问题的方案以及探求这些解决方案的方法. 对于问题和方法一定要有清晰的认识, 很多人在学习强化学习时遇到的各种困惑与不解都是因为不能清晰的认识问题和方法的区别和联系.</p>\n<a id=\"more\"></a>\n<p>强化学习与有监督学习(<em>supervised learning</em>)不同. 有监督学习是目前机器学习领域研究最多的方向, 它从由经验丰富的、学识渊博的专家(监督者)提供一系列带有标签(如每个样本被正确分类的类别)的样本数据中进行学习, 这种方法通常被用于分类问题. 有监督学习的目标是当给定一个没有在训练样本集出现的数据时, 可以准确推断出它的标签/类别. 这种有监督学习非常重要而且有用, 但是它没有能力从<strong>交互</strong>中进行学习, 而强化学习在智能体与环境进行交互的过程中进行学习. 为什么有监督学习不能从交互中学习呢? 因为有监督学习需要的近乎完全的样本以及其准确的信息都是在交互问题中很难获得的(不现实的). 在未知的交互场景中, 我们往往只能根据智能体的经验进行学习.</p>\n<p>强化学习与无监督学习(<em>unsupervised learning</em>)也是不同的. 无监督学习通常被用于发现无标签样本集的隐藏结构. 我们一般任务机器学习只分为有、无监督学习两种, 而且将强化学习分为无监督学习一类. 但其实强化学习与无监督学习有本质的区别. <strong>强化学习的目的是最大化可获得的奖励值</strong>, 而无监督学习是发现隐藏结构. 当然, 如果在强化学习问题中可以发现其样本内的隐藏结构, 这对于强化学习肯定是很有帮助的, 但是仅仅这些隐藏结构并不能处理强化学习最大化奖励值方法的问题. 因此, 我们通常将强化学习归为机器学习的第三个类别, 与有、无监督学习并列.</p>\n<p><em>注: 在强化学习问题中, 任何可以反映当前动作所带来的影响的元素都可以被理解为奖励值.(个人见解)</em></p>\n<blockquote>\n<p>Reinforcement learning is learning what to do——how to map situations to actions——so as to maxmize a numerical reward signal.    ——《Reinforcement Learning: An Introduction》</p>\n</blockquote>\n<p>强化学习学习的是从状态<em>s</em>到要执行的最优动作<em>a</em>之间的映射关系, 也就是找到一个策略(函数/逻辑规则)使得在给定状态下通过该策略所产生的决策可以最终带来最大的回报. 学习者不被告知应该采取什么动作, 而是通过训练使它们发现采取什么样的动作可以产生最高的奖励值. 这与婴儿学习的方式很像, 你可能会说:”瞎讲, 婴儿可以模仿你的动作进行学习.”. 但你要知道, 当你对婴儿的动作进行批评(吵)和奖励(笑)时, 这就已经是一个强化学习的过程了.</p>\n<h2 id=\"强化学习的两个要素\"><a href=\"#强化学习的两个要素\" class=\"headerlink\" title=\"强化学习的两个要素\"></a>强化学习的两个要素</h2><p>强化学习必不可少的两个要素是智能体<code>Agent</code>和环境<code>Environment</code>.<br>既然强化学习是在交互过程中进行学习, 那么交互必定是双方或者多方的, 在强化学习问题中, 交互的双方是智能体和环境.</p>\n<ol>\n<li>智能体</li>\n</ol>\n<ul>\n<li>智能体是环境的观察者</li>\n<li>智能体是策略的载体</li>\n<li>智能体是动作的执行者</li>\n</ul>\n<ol>\n<li>环境</li>\n</ol>\n<ul>\n<li>环境是对智能体动作的评判者, 即给出立即奖励</li>\n<li>环境是智能体进行运动等行为的基本空间</li>\n<li>环境给出当前时刻的观察信息, 供智能体进行采集</li>\n</ul>\n<h2 id=\"强化学习的两个特点\"><a href=\"#强化学习的两个特点\" class=\"headerlink\" title=\"强化学习的两个特点\"></a>强化学习的两个特点</h2><ol>\n<li><strong>trial-and-error/试错学习</strong><br>智能体在与环境交互的过程中进行学习时, 不会得到任何人为的或者示例的指导(如果进行指导, 则为有监督学习/模仿学习/逆强化学习等), 智能体只能通过在环境中不断地<strong>试错</strong>, 积累经验, 最终学到可以完成目标并获得最大奖励值的策略.</li>\n<li><strong>delayed reward/延迟奖励</strong><br>在大多数强化学习问题中, 某一状态<em>s</em>下执行的动作<em>a</em>不仅会影响当前的立即奖励<em>r</em>, 而且还会影响后续的状态序列, 以及后续的奖励值. 当前的立即奖励值并不能反映出在这个动作对(<em>s,a</em>)对整个决策过程的影响, 只有等到这一决策过程结束时, 才能判断其在这个状态序列的奖励(价值), 所以, 延迟奖励也是强化学习过程中的一个特点.</li>\n</ol>\n<h2 id=\"强化学习的难点-Challenge\"><a href=\"#强化学习的难点-Challenge\" class=\"headerlink\" title=\"强化学习的难点(Challenge)\"></a>强化学习的难点(Challenge)</h2><p>相比其他学习, 强化学习中的一大难点是<strong>探索与利用</strong>, 也就是<strong>exploration and exploitation</strong>, 这个难题已经被数学家研究了几十年了, 但仍然没有解决. 为了获得尽量多的奖励, 智能体需要根据过去学习的经验选择产生立即奖励值最高的动作, 但是给定状态下可供选择的动作有很多, 有些被执行过, 有些没有被执行过, 为了去发现产生立即奖励值最高的动作, 必须尝试选择之前被选择过动作. 这个问题就出现了, <strong>智能体必须利用它已经探索过的产生大奖励值的动作, 也必须探索未知奖励值的动作(有可能很小)为了以后可以选择更好的动作</strong>. 只探索不利用、只利用不探索在强化学习问题中都是独木难支. 在随机任务中, 一个同样的动作往往需要被探索很多次才可能对它的期望奖励值有较准确的估计. </p>\n<h2 id=\"强化学习的四个元素\"><a href=\"#强化学习的四个元素\" class=\"headerlink\" title=\"强化学习的四个元素\"></a>强化学习的四个元素</h2><p>除了智能体与环境两个要素之外, 强化学习系统/框架中还有四个子元素: 策略、奖励机制、值函数、模型(未必有).</p>\n<ol>\n<li><p>策略 Policy<br>策略定义了智能体在当前时刻应该做出的行为. 与人类的刺激-反应机制很像, 策略是从感知到的环境信息到执行的行为之间的映射, 策略是强化学习智能体的<strong>核心</strong>, 它决定了智能体的行为. 在一般的强化学习问题中, 策略可能是随机的、非确定的, 它通常给出可选择执行的动作的概率或概率分布.</p>\n</li>\n<li><p>奖励机制 Reward Signal<br>奖励机制定义了强化学习问题的<strong>目标</strong>, 在交互的每一步, 环境都会向智能体传递一个数字信息, 我们称之为”奖励”. 智能体的唯一目标就是在整个交互过程中最大化总的奖励之和. 因此, 奖励定义了某个动作的好坏(但并不意味着坏的动作在交互过程中是坏的, 其作用由值函数来定义). 类比于我们人类, 奖励就像我们高兴或者痛苦一样, 它们是我们对当前环境-动作的立即反应和评价.<br>奖励机制是智能体更新策略Policy的基础, 如果智能体成功进行了学习, 当在当前策略选择了一个较低回报的动作时, 之后它可能会选择其他动作.<br>通常, 奖励机制由状态<em>s</em>和动作<em>a</em>的随机函数表示<code>R(s,a)</code></p>\n</li>\n<li><p>值函数 Value Function<br>立即奖励表示着当前动作或状态带来的立即效果是好是坏, 但是值函数表示这个动作在整个交互过程中扮演的角色是好是坏. 一个状态的值是从该状态开始到交互结束所积累的立即奖励的总和.<br>一个状态可能总是产生很低的立即奖励, 但是它有很高的值, 因为该状态之后的后续状态中会产生很大的立即奖励. 相反也是一样. 类比于我们人类, 立即奖励的高低相当于我们高兴或痛苦, 但是值函数给出的值则表示了在整个事件过程中我们有多高兴或不高兴的深刻判断.<br>引入值函数的唯一目的就是为了训练智能体以获得更大的奖励, 当智能体做决策以及评估决策时, 我们一直关心的都是值函数而不是立即奖励, 对于动作的选择也是基于对值函数的判断/评估. 值比立即奖励更难以确定, 因为立即奖励可以由环境准确的给出, 但是值却需要评估甚至多次评估才可能相对准确(因为有可能交互过程永远不结束, 那么对值的估计会有偏差). 我们希望选择的动作带来最高的值, 而不是最高的立即奖励, 实际上, 几乎所有强化学习算法中最重要的部分就是对于值函数的有效估计方法. 关于值函数估计所扮演的核心角色在近60年被广泛研究. </p>\n</li>\n<li><p>模型 Model<br>模型是对环境行为的仿真, 我们可以通过模型推断出动作对环境的改变, 给出准确的立即奖励和状态信息. 例如, 给定一个状态和动作, 模型可以预测出下一个要转移的状态以及下一个立即奖励值. 如果模型是确定的, 我们一般使用规划(<em>planning</em>)的方法来选择最优动作, 对于这种方式我们称之为基于模型<strong>model-based</strong>的方法, 相反, 如果模型是不确定的, 也就是<strong>model-free</strong>, 我们只能通过试错的方式进行学习并选择动作. </p>\n</li>\n</ol>\n<p><em>注: 对于什么是model-based和model-free将在以后进行深入讨论.</em></p>\n<h2 id=\"强化学习的目标\"><a href=\"#强化学习的目标\" class=\"headerlink\" title=\"强化学习的目标\"></a>强化学习的目标</h2><p>与目标识别为了最小化误差损失不同，强化学习的目的是寻到一个策略，使得期望（折扣）奖励最大化。</p>\n<h2 id=\"强化学习的通用符号表示-Notation\"><a href=\"#强化学习的通用符号表示-Notation\" class=\"headerlink\" title=\"强化学习的通用符号表示 Notation\"></a>强化学习的通用符号表示 Notation</h2><p>$←$    赋值</p>\n<p>$\\varepsilon$ 在$\\varepsilon-greedy$策略中随机选择动作的概率</p>\n<p>$\\gamma$ 计算总奖励的折扣因子</p>\n<p>$\\lambda$ 资格迹的衰减率或者GAE的权重因子</p>\n<p>$s,s’$ 状态，下一个状态</p>\n<p>$a$ 一个动作</p>\n<p>$r$ 一个奖励值（标量）</p>\n<p>$S$ 状态集（不包含终态）</p>\n<p>$S^{+}$ 状态集（包含终态）</p>\n<p>$A(s)$ $s$状态下可选择的动作</p>\n<p>$R$ 奖励集合</p>\n<p>$|S|$ 状态集中的元素数</p>\n<p>$t$ 单个时间步</p>\n<p>$T$ 一个episode的终态时间点</p>\n<p>$A_{t}$ $t$时刻选择的动作</p>\n<p>$S_{t}$ $t$时刻所在的状态</p>\n<p>$R_{t}$ $t$时刻获得的奖励</p>\n<p>$\\pi$ 策略（从状态到动作的映射）</p>\n<p>$\\pi(s)$ 在$s$状态下使用$\\pi$策略所选择的动作</p>\n<p>$\\pi(a|s)$ 在$s$状态下使用$\\pi$策略选择到动作$a$的概率</p>\n<p>$G_{t}$ 以$t$时刻为起始时间点，到终态所能获得的总奖励（回报）</p>\n<p>$p(s’,r|s,a)$ 在$s$状态执行a动作转移到$s‘$状态并获得奖励值为$r$的概率</p>\n<p>$p(s’|s,a)$ 在$s$状态执行$a$动作转移到$s’$状态的概率</p>\n<p>$r(s,a)$ 在$s$状态执行$a$动作所获得的<strong>期望</strong>立即奖励（即时奖励）</p>\n<p>$r(s,a,s’)$ 在$s$状态执行$a$动作转移到$s’$状态所获得的<strong>期望</strong>立即奖励</p>\n<p>$v_{\\pi}(s)$ $\\pi$策略下状态$s$的值（以该状态为始态的期望奖励回报）</p>\n<p>$v_{<em>}(s)$ <em>*最优</em></em>策略下状态s的值</p>\n<p>$q_{\\pi}(s,a)$ $\\pi$策略下状态-行动对$(s,a)$的值</p>\n<p>$q_{<em>}(s,a)$ <em>*最优</em></em>策略下状态-行动对$(s,a)$的值</p>\n<p>$V,V_{t}$ 状态值的矩阵估计，行和列分别是时间点$t$和每个状态的估计值$v_{\\pi}$或$v_{*}$</p>\n<p>$Q,Q_{t}$ 状态-行动对$(s,a)$的矩阵估计，一般为一个3维矩阵,行、列和深度分别为状态、动作、时间点</p>\n<p>$V_{t}(s)$ 状态$s$的期望估计值</p>\n<p>$\\delta_{t}$ $t$时刻的TD-error时间差分量</p>\n<p>$\\theta,\\theta_{t}$ 目标策略的参数（向量）</p>\n<p>$\\pi(a|s,\\theta)$ 目标策略的参数为$\\theta$时，在$s$状态选择到$a$动作的概率</p>\n<p>$\\pi_{\\theta}$ 表示参数为$\\theta$的策略</p>\n<p>$\\nabla{\\pi(a|s,\\theta)}$ $\\pi(a|s,\\theta)$对于参数$\\theta$的偏微分</p>\n<p>$J(\\theta)$ 参数为$\\theta$的策略的性能度量、期望奖励(performance measure)</p>\n<p>$\\nabla{J(\\theta)}$ 性能度量对于策略参数$\\theta$的偏导数</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"强化学习基本概念\"><a href=\"#强化学习基本概念\" class=\"headerlink\" title=\"强化学习基本概念\"></a>强化学习基本概念</h1><p>学习了这么久的强化学习, 不做笔记总是会忘记, 于是写在博客里方便自己复习, 也与同路人分享.</p>\n<h2 id=\"强化学习是什么\"><a href=\"#强化学习是什么\" class=\"headerlink\" title=\"强化学习是什么?\"></a>强化学习是什么?</h2><p>强化学习是什么? 它的英文名字是<em>Reinforcement Learning</em>, 和<em>Machine Learning</em>一样, 都是以<em>‘ing’</em>结尾的. 它是一个问题、一组解决这个问题的方案以及探求这些解决方案的方法. 对于问题和方法一定要有清晰的认识, 很多人在学习强化学习时遇到的各种困惑与不解都是因为不能清晰的认识问题和方法的区别和联系.</p>","more":"<p>强化学习与有监督学习(<em>supervised learning</em>)不同. 有监督学习是目前机器学习领域研究最多的方向, 它从由经验丰富的、学识渊博的专家(监督者)提供一系列带有标签(如每个样本被正确分类的类别)的样本数据中进行学习, 这种方法通常被用于分类问题. 有监督学习的目标是当给定一个没有在训练样本集出现的数据时, 可以准确推断出它的标签/类别. 这种有监督学习非常重要而且有用, 但是它没有能力从<strong>交互</strong>中进行学习, 而强化学习在智能体与环境进行交互的过程中进行学习. 为什么有监督学习不能从交互中学习呢? 因为有监督学习需要的近乎完全的样本以及其准确的信息都是在交互问题中很难获得的(不现实的). 在未知的交互场景中, 我们往往只能根据智能体的经验进行学习.</p>\n<p>强化学习与无监督学习(<em>unsupervised learning</em>)也是不同的. 无监督学习通常被用于发现无标签样本集的隐藏结构. 我们一般任务机器学习只分为有、无监督学习两种, 而且将强化学习分为无监督学习一类. 但其实强化学习与无监督学习有本质的区别. <strong>强化学习的目的是最大化可获得的奖励值</strong>, 而无监督学习是发现隐藏结构. 当然, 如果在强化学习问题中可以发现其样本内的隐藏结构, 这对于强化学习肯定是很有帮助的, 但是仅仅这些隐藏结构并不能处理强化学习最大化奖励值方法的问题. 因此, 我们通常将强化学习归为机器学习的第三个类别, 与有、无监督学习并列.</p>\n<p><em>注: 在强化学习问题中, 任何可以反映当前动作所带来的影响的元素都可以被理解为奖励值.(个人见解)</em></p>\n<blockquote>\n<p>Reinforcement learning is learning what to do——how to map situations to actions——so as to maxmize a numerical reward signal.    ——《Reinforcement Learning: An Introduction》</p>\n</blockquote>\n<p>强化学习学习的是从状态<em>s</em>到要执行的最优动作<em>a</em>之间的映射关系, 也就是找到一个策略(函数/逻辑规则)使得在给定状态下通过该策略所产生的决策可以最终带来最大的回报. 学习者不被告知应该采取什么动作, 而是通过训练使它们发现采取什么样的动作可以产生最高的奖励值. 这与婴儿学习的方式很像, 你可能会说:”瞎讲, 婴儿可以模仿你的动作进行学习.”. 但你要知道, 当你对婴儿的动作进行批评(吵)和奖励(笑)时, 这就已经是一个强化学习的过程了.</p>\n<h2 id=\"强化学习的两个要素\"><a href=\"#强化学习的两个要素\" class=\"headerlink\" title=\"强化学习的两个要素\"></a>强化学习的两个要素</h2><p>强化学习必不可少的两个要素是智能体<code>Agent</code>和环境<code>Environment</code>.<br>既然强化学习是在交互过程中进行学习, 那么交互必定是双方或者多方的, 在强化学习问题中, 交互的双方是智能体和环境.</p>\n<ol>\n<li>智能体</li>\n</ol>\n<ul>\n<li>智能体是环境的观察者</li>\n<li>智能体是策略的载体</li>\n<li>智能体是动作的执行者</li>\n</ul>\n<ol>\n<li>环境</li>\n</ol>\n<ul>\n<li>环境是对智能体动作的评判者, 即给出立即奖励</li>\n<li>环境是智能体进行运动等行为的基本空间</li>\n<li>环境给出当前时刻的观察信息, 供智能体进行采集</li>\n</ul>\n<h2 id=\"强化学习的两个特点\"><a href=\"#强化学习的两个特点\" class=\"headerlink\" title=\"强化学习的两个特点\"></a>强化学习的两个特点</h2><ol>\n<li><strong>trial-and-error/试错学习</strong><br>智能体在与环境交互的过程中进行学习时, 不会得到任何人为的或者示例的指导(如果进行指导, 则为有监督学习/模仿学习/逆强化学习等), 智能体只能通过在环境中不断地<strong>试错</strong>, 积累经验, 最终学到可以完成目标并获得最大奖励值的策略.</li>\n<li><strong>delayed reward/延迟奖励</strong><br>在大多数强化学习问题中, 某一状态<em>s</em>下执行的动作<em>a</em>不仅会影响当前的立即奖励<em>r</em>, 而且还会影响后续的状态序列, 以及后续的奖励值. 当前的立即奖励值并不能反映出在这个动作对(<em>s,a</em>)对整个决策过程的影响, 只有等到这一决策过程结束时, 才能判断其在这个状态序列的奖励(价值), 所以, 延迟奖励也是强化学习过程中的一个特点.</li>\n</ol>\n<h2 id=\"强化学习的难点-Challenge\"><a href=\"#强化学习的难点-Challenge\" class=\"headerlink\" title=\"强化学习的难点(Challenge)\"></a>强化学习的难点(Challenge)</h2><p>相比其他学习, 强化学习中的一大难点是<strong>探索与利用</strong>, 也就是<strong>exploration and exploitation</strong>, 这个难题已经被数学家研究了几十年了, 但仍然没有解决. 为了获得尽量多的奖励, 智能体需要根据过去学习的经验选择产生立即奖励值最高的动作, 但是给定状态下可供选择的动作有很多, 有些被执行过, 有些没有被执行过, 为了去发现产生立即奖励值最高的动作, 必须尝试选择之前被选择过动作. 这个问题就出现了, <strong>智能体必须利用它已经探索过的产生大奖励值的动作, 也必须探索未知奖励值的动作(有可能很小)为了以后可以选择更好的动作</strong>. 只探索不利用、只利用不探索在强化学习问题中都是独木难支. 在随机任务中, 一个同样的动作往往需要被探索很多次才可能对它的期望奖励值有较准确的估计. </p>\n<h2 id=\"强化学习的四个元素\"><a href=\"#强化学习的四个元素\" class=\"headerlink\" title=\"强化学习的四个元素\"></a>强化学习的四个元素</h2><p>除了智能体与环境两个要素之外, 强化学习系统/框架中还有四个子元素: 策略、奖励机制、值函数、模型(未必有).</p>\n<ol>\n<li><p>策略 Policy<br>策略定义了智能体在当前时刻应该做出的行为. 与人类的刺激-反应机制很像, 策略是从感知到的环境信息到执行的行为之间的映射, 策略是强化学习智能体的<strong>核心</strong>, 它决定了智能体的行为. 在一般的强化学习问题中, 策略可能是随机的、非确定的, 它通常给出可选择执行的动作的概率或概率分布.</p>\n</li>\n<li><p>奖励机制 Reward Signal<br>奖励机制定义了强化学习问题的<strong>目标</strong>, 在交互的每一步, 环境都会向智能体传递一个数字信息, 我们称之为”奖励”. 智能体的唯一目标就是在整个交互过程中最大化总的奖励之和. 因此, 奖励定义了某个动作的好坏(但并不意味着坏的动作在交互过程中是坏的, 其作用由值函数来定义). 类比于我们人类, 奖励就像我们高兴或者痛苦一样, 它们是我们对当前环境-动作的立即反应和评价.<br>奖励机制是智能体更新策略Policy的基础, 如果智能体成功进行了学习, 当在当前策略选择了一个较低回报的动作时, 之后它可能会选择其他动作.<br>通常, 奖励机制由状态<em>s</em>和动作<em>a</em>的随机函数表示<code>R(s,a)</code></p>\n</li>\n<li><p>值函数 Value Function<br>立即奖励表示着当前动作或状态带来的立即效果是好是坏, 但是值函数表示这个动作在整个交互过程中扮演的角色是好是坏. 一个状态的值是从该状态开始到交互结束所积累的立即奖励的总和.<br>一个状态可能总是产生很低的立即奖励, 但是它有很高的值, 因为该状态之后的后续状态中会产生很大的立即奖励. 相反也是一样. 类比于我们人类, 立即奖励的高低相当于我们高兴或痛苦, 但是值函数给出的值则表示了在整个事件过程中我们有多高兴或不高兴的深刻判断.<br>引入值函数的唯一目的就是为了训练智能体以获得更大的奖励, 当智能体做决策以及评估决策时, 我们一直关心的都是值函数而不是立即奖励, 对于动作的选择也是基于对值函数的判断/评估. 值比立即奖励更难以确定, 因为立即奖励可以由环境准确的给出, 但是值却需要评估甚至多次评估才可能相对准确(因为有可能交互过程永远不结束, 那么对值的估计会有偏差). 我们希望选择的动作带来最高的值, 而不是最高的立即奖励, 实际上, 几乎所有强化学习算法中最重要的部分就是对于值函数的有效估计方法. 关于值函数估计所扮演的核心角色在近60年被广泛研究. </p>\n</li>\n<li><p>模型 Model<br>模型是对环境行为的仿真, 我们可以通过模型推断出动作对环境的改变, 给出准确的立即奖励和状态信息. 例如, 给定一个状态和动作, 模型可以预测出下一个要转移的状态以及下一个立即奖励值. 如果模型是确定的, 我们一般使用规划(<em>planning</em>)的方法来选择最优动作, 对于这种方式我们称之为基于模型<strong>model-based</strong>的方法, 相反, 如果模型是不确定的, 也就是<strong>model-free</strong>, 我们只能通过试错的方式进行学习并选择动作. </p>\n</li>\n</ol>\n<p><em>注: 对于什么是model-based和model-free将在以后进行深入讨论.</em></p>\n<h2 id=\"强化学习的目标\"><a href=\"#强化学习的目标\" class=\"headerlink\" title=\"强化学习的目标\"></a>强化学习的目标</h2><p>与目标识别为了最小化误差损失不同，强化学习的目的是寻到一个策略，使得期望（折扣）奖励最大化。</p>\n<h2 id=\"强化学习的通用符号表示-Notation\"><a href=\"#强化学习的通用符号表示-Notation\" class=\"headerlink\" title=\"强化学习的通用符号表示 Notation\"></a>强化学习的通用符号表示 Notation</h2><p>$←$    赋值</p>\n<p>$\\varepsilon$ 在$\\varepsilon-greedy$策略中随机选择动作的概率</p>\n<p>$\\gamma$ 计算总奖励的折扣因子</p>\n<p>$\\lambda$ 资格迹的衰减率或者GAE的权重因子</p>\n<p>$s,s’$ 状态，下一个状态</p>\n<p>$a$ 一个动作</p>\n<p>$r$ 一个奖励值（标量）</p>\n<p>$S$ 状态集（不包含终态）</p>\n<p>$S^{+}$ 状态集（包含终态）</p>\n<p>$A(s)$ $s$状态下可选择的动作</p>\n<p>$R$ 奖励集合</p>\n<p>$|S|$ 状态集中的元素数</p>\n<p>$t$ 单个时间步</p>\n<p>$T$ 一个episode的终态时间点</p>\n<p>$A_{t}$ $t$时刻选择的动作</p>\n<p>$S_{t}$ $t$时刻所在的状态</p>\n<p>$R_{t}$ $t$时刻获得的奖励</p>\n<p>$\\pi$ 策略（从状态到动作的映射）</p>\n<p>$\\pi(s)$ 在$s$状态下使用$\\pi$策略所选择的动作</p>\n<p>$\\pi(a|s)$ 在$s$状态下使用$\\pi$策略选择到动作$a$的概率</p>\n<p>$G_{t}$ 以$t$时刻为起始时间点，到终态所能获得的总奖励（回报）</p>\n<p>$p(s’,r|s,a)$ 在$s$状态执行a动作转移到$s‘$状态并获得奖励值为$r$的概率</p>\n<p>$p(s’|s,a)$ 在$s$状态执行$a$动作转移到$s’$状态的概率</p>\n<p>$r(s,a)$ 在$s$状态执行$a$动作所获得的<strong>期望</strong>立即奖励（即时奖励）</p>\n<p>$r(s,a,s’)$ 在$s$状态执行$a$动作转移到$s’$状态所获得的<strong>期望</strong>立即奖励</p>\n<p>$v_{\\pi}(s)$ $\\pi$策略下状态$s$的值（以该状态为始态的期望奖励回报）</p>\n<p>$v_{<em>}(s)$ <em>*最优</em></em>策略下状态s的值</p>\n<p>$q_{\\pi}(s,a)$ $\\pi$策略下状态-行动对$(s,a)$的值</p>\n<p>$q_{<em>}(s,a)$ <em>*最优</em></em>策略下状态-行动对$(s,a)$的值</p>\n<p>$V,V_{t}$ 状态值的矩阵估计，行和列分别是时间点$t$和每个状态的估计值$v_{\\pi}$或$v_{*}$</p>\n<p>$Q,Q_{t}$ 状态-行动对$(s,a)$的矩阵估计，一般为一个3维矩阵,行、列和深度分别为状态、动作、时间点</p>\n<p>$V_{t}(s)$ 状态$s$的期望估计值</p>\n<p>$\\delta_{t}$ $t$时刻的TD-error时间差分量</p>\n<p>$\\theta,\\theta_{t}$ 目标策略的参数（向量）</p>\n<p>$\\pi(a|s,\\theta)$ 目标策略的参数为$\\theta$时，在$s$状态选择到$a$动作的概率</p>\n<p>$\\pi_{\\theta}$ 表示参数为$\\theta$的策略</p>\n<p>$\\nabla{\\pi(a|s,\\theta)}$ $\\pi(a|s,\\theta)$对于参数$\\theta$的偏微分</p>\n<p>$J(\\theta)$ 参数为$\\theta$的策略的性能度量、期望奖励(performance measure)</p>\n<p>$\\nabla{J(\\theta)}$ 性能度量对于策略参数$\\theta$的偏导数</p>"},{"title":"PaStaNet: Toward Human Activity Knowledge Engine","copyright":true,"mathjax":true,"top":1,"date":"2020-04-11T17:23:03.000Z","keywords":null,"description":null,"_content":"\n这篇论文是上海交大[卢策吾](http://mvig.sjtu.edu.cn/)老师团队下[李永露](https://dirtyharrylyl.github.io/)博士在2020CVPR会议三连中中的其中一篇。方向为HOIs方向，即人物交互。\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/2004.00945](http://arxiv.org/abs/2004.00945)\n\n作者开源的代码和数据集：[http://hake-mvig.cn/](http://hake-mvig.cn/)\n\nPaSta是Part State的缩写，它是**细粒度动作语义标记**(ﬁne-grained action semantic tokens)，是人类活动/行为的更精细的表达，比如一个人类的行为是开汽车，那么这个行为的part state就包括手握方向盘、脚踩油门等等，这种part state用三元组形式表示，比如：&#60;hand, hold, something&#62;。\n\n这篇论文主要有两个比较大的贡献：\n\n1. 建立了一个大型知识库PaStaNet（其实是HAKE数据集），目前标注了700w+局部状态。\n2. 设计了一个分层的动作识别模型（为什么分层呢？因为作者提到现有的基于图像的动作识别理解方法主要采取直接映射/端到端的方式，可能会遇到性能瓶颈。）\n   1. 第一层是Activity2Vec模型，用来从原始图片中提取PaSta特征，PaSta是组成多种人类行为的通用表示，比如一个PaSta是hold，那么开汽车时有hold方向盘，吃苹果时有hold苹果，两种不同的行为共享同样的PaSta；\n   2. 第二层使用了PaSta-based Reasoning（PaSta-R，基于局部状态的推理）方法，用这种方法从第一层中识别的PaSta来推测图片中的人类行为活动。\n\n下文中以下概念术语等同：\n\n- PaStaNet——数据集\n- 人类行为理解——动作识别\n- PaSta——局部状态\n\n# 文中精要\n\n在大规模的基准中，基于**实例层次的语义（instance-level semantics）**使用one-stage从像素理解人类行为存在性能瓶颈，主要有以下几个原因：\n\n1. long-tail data distribution，长尾数据分布（少数类别有大部分数据，而多数类别只有小部分数据）\n\n   ![](./PaStaNet/Long_tailed_distribution.png)\n\n2. complex visual patterns，复杂的视觉模式\n\n作者认为(argue that)在人类局部的语义层次上进行感知是一个非常有前景的方向，这种方式之前被忽略了。\n\n**作者的核心思想是：人类动作由细粒度的原子主体部分状态（PaSta）组成。**\n\n> Our core idea is that human instance actions are composed of ﬁne-grained atomic body part states.\n\n![](./PaStaNet/fig1.png)\n\n先识别PaSta再推理行为有什么好处呢？\n\n1. 与简化理论(reductionism)有强烈的直接关系\n\n   > This lies in strong relationships with reductionism.\n\n2. 可以帮助我们选择有区别的部分，忽略不相关的部分\n\n   > the part-level path can help us to pick up discriminative parts and disregard irrelevant ones.\n\n3. 从人体局部编码知识是实现人类活动知识引擎的关键步骤\n\n   > encoding knowledge from human parts is a crucial step toward human activity knowledge engine.\n\n4. Reusability and Transferability——可重用性和可转移性，多个行为的局部状态存在共享，比如一个PaSta是hold，那么开汽车时有hold方向盘，吃苹果时有hold苹果，两种不同的行为共享同样的PaSta。因此，我们可以用更少的PaSta来描述和区分大量的行为。对于few-shot学习，可重用性可以极大地缓解其学习困难。\n\n   > PaSta are basic components of actions, their relationship can be in analogy with the amino acid and protein, letter and word, etc. Hence, PaSta are reusable, e.g., 〈 hand, hold, something 〉 is shared by various actions like “hold horse” and “eat apple”. Therefore, we get the capacity to describe and differentiate plenty of activities with a much smaller set of PaSta, i.e. one-time labeling and transferability. For fewshot learning, reusability can greatly alleviate its learning difﬁculty. Thus our approach shows signiﬁcant improvements, e.g. we boost 13.9 mAP on one-shot sets of HICO\n\n5. Interpretability——可解释性，当模型预测一个人在做什么时，我们很容易知道原因:它的身体的各个部分在做什么。\n\n   > we obtain not only more powerful activity representations, but also better interpretation. When the model predicts what a person is doing, we can easily know the reasons: what the body parts are doing.\n\n## PaStaNet数据集\n\n该数据集目前已经标注了11.8w张图片，包括28.5w个人物，25w个交互的实体对象（比如球之类的），72.4万个行为，以及700w个人类局部状态。\n\n该数据集目前有156个行为分类，76个PaSta分类。\n\n广泛的分析证明，一般来说，PaStaNet可以覆盖大部分的局部级知识，可以很好的概括大部分情况。\n\n![](./PaStaNet/fig6.png)\n\n下图为数据集中的行为和交互物体类别。\n\n![](./PaStaNet/table6.png)\n\n下图为数据集中的局部状态PaSta类别。\n\n![](./PaStaNet/table7.png)\n\n### PaSta的定义\n\n将人体解耦成十个部分：head, two upper arms, two hands, hip, two thighs, two feet，即\n\n1. 头\n2. 左臂\n3. 右臂\n4. 左手\n5. 右手\n6. 臀部\n7. 左腿\n8. 右腿\n9. 左脚\n10. 右脚\n\n每一个PaSta表示目标局部部分的表示，比如hand可以是hold something, push something；head可以是watch something, eat something。注意，当一个人同时有多个行为动作，他的某个局部身体部位可以有多个PaSta。\n\n### 数据收集\n\n两种方式：\n\n1. 通过众包收集以人为中心的行为图像(3万张图片，具有粗糙的活动标签)；\n2. 现有的设计良好的数据集(18.5万张)。\n\n其中的数据围绕丰富的语义本体论(semantic ontology)、多样性和行为的可变性构建。最终，收集了超过20万张的不同行为类别的图片。\n\n### 行为标签\n\n根据人类最常见的日常活动，与人和物的互动。从11.8万张图片中选择了156种行为，包括人与物体的互动和身体动作（包含bounding boxes）。\n\n### 身体局部的盒子\n\n> Estimation errors are addressed manually to ensure high-quality annotation. Each part box is centered with a joint, and the box size is pre-deﬁned by scaling the distance between the joints of the neck and pelvis. A joint with conﬁdence higher than 0.7 will be seen as visible. When not all joints can be detected, we use body knowledge-based rules. That is, if the neck or pelvis is invisible, we conﬁgure the part boxes according to other visible joint groups (head, main body, arms, legs), e.g., if only the upper body is visible, we set the size of the hand box to twice the pupil distance.\n\n### 局部状态PaSta标注\n\n通过众包方式进行标注，共收到224159条标注上传。\n\n过程如下：\n\n1. 基于156种行为的动词，从WordNet选取200个PaSta动词。如果某个局部部位没有可以的状态，则描述为\"no_action\"；\n2. 为了找到最通用的PaSta（可以作为可转移的行为知识），邀请了来自不同背景的150名注释者来标注156个行为的1w张图片；\n3. 基于它们的注释，使用规范化的**点对点互信息(Normalized Point-wise Mutual Information，NPMI，*Kenneth Ward Church and Patrick Hanks. Word association norms, mutual information, and lexicography. In Computational linguistics, 1990.*)**来计算行为和PaSta之间的共生/共现关系，最后选择76个具有最高NPMI值的候选局部状态为PaSta集合；\n4. 以之前的1w张打了标签的图片为种子，自动生成其余图片的初始PaSta标签，然后另外210名注释者仅需要去检查这些标注即可；\n5. 考虑到一个人可能有多个动作，对于每个动作，分别标注其对应的10个PaSta。然后把所有动作的PaSta组合在一起；\n6. 为了确保质量，每幅图像都将被标注两次，并由自动程序和主管进行检查。\n\n![](./PaStaNet/fig2.png)\n\n**疑问：为什么ride bicycle与head look at的共现如此之低呢？**\n\n### 行为解析树\n\n为了说明PaSta和行为之间的关系，作者使用它们的统计相关性来构建一个图：行为是根节点，PaSta是子节点，边是共现。\n\n> To illustrate the relationships between PaSta and activities, we use their statistical correlations to construct a graph (Fig. 2): activities are root nodes, PaSta are son nodes and edges are co-occurrence.\n\nPaStaNet可以为实例级和局部级提供丰富的行为知识，并帮助构建大型行为解析树。\n\n> PaStaNet can provide abundant activity knowledge for both instance and part levels and help construct a large-scale activity parsing tree\n\n![](./PaStaNet/fig8.png)\n\n作者将解析树表示为行为和PaSta的共现矩阵(看起来极其稀疏)。\n\n![](./PaStaNet/fig9.png)\n\n## 分层行为理解模型\n\n这一部分数学符号很多，而且似乎故意把符号设计的复杂，导致阅读理解起来有些不顺畅。\n\n对于行为的识别，有两种模型：\n\n1. 传统模式，采用直接映射。\n   $$\n   \\mathcal{S}_{i n s t}=\\mathcal{F}_{i n s t}\\left(I, b_{h}, \\mathcal{B}_{o}\\right)\n   $$\n   其中，$I$表示图像输入，$b_h$是人的box，$\\mathcal{B}_{o}=\\left\\{b_{o}^{i}\\right\\}_{i=1}^{m}$是与人交互的物体的box，假设有$m$个物体。$\\mathcal{S}_{i n s t}$代表实体级别的动作评分（评估结果）。\n\n2. 作者提出的PaStaNet模式，利用通用的局部知识，分成两步：\n\n   1. PaSta局部状态识别和特征提取（其实是识别层之前的隐特征）\n      $$\n      f_{P a S t a}=\\mathcal{R}_{A 2 V}\\left(I, \\mathcal{B}_{p}, b_{o}\\right) = \\left\\{f_{P a S t a}^{(i)}\\right\\}_{i=1}^{10}\n      $$\n      其中，$\\mathcal{B}_{p}=\\left\\{b_{p}^{(i)}\\right\\}_{i}^{10}$是人的局部部位的box，使用*Pairwise body-part attention for recognizing human-object interactions. In ECCV, 2018*自动生成。$\\mathcal{R}_{A 2 V}(\\cdot)$表示Activity2Vec模型，用于提取PaSta的特征表示，\n\n   2. PaSta-Based推理（PaSta-R），从局部状态推理行为语义\n      $$\n      \\mathcal{S}_{p a r t}=\\mathcal{F}_{P a S t a-R}\\left(f_{P a S t a}, f_{o}\\right)\n      $$\n      其中，$\\mathcal{F}_{P a S t a-R}(\\cdot)$代表PaSta-R方法，$f_{o}$是物体的特征表示，$\\mathcal{S}_{p a r t}$是局部状态层面的动作评分。*注意，如果场景中人没有与物进行交互，比如”跳舞“这个动作，那么使用图像的ROI池化特征来表示$f_o$。如果场景中存在多个交互物体，则依次处理human-object pair$\\left(f_{P a S t a}, f_{o}^{(i)}\\right)$，并且声称各自独立的Activity2Vec Embedding*。\n\n![](./PaStaNet/fig3.png)\n\n上图为PaSta的识别与特征表示部分的框架图。\n\n识别部分主要为红色线条部分，特征表示部分主要为蓝色线条部分。\n\n### 局部状态PaSta识别\n\n这部分的输入为$I, \\mathcal{B}_{p}, b_{o}$，输出为局部状态的视觉特征$f_{PaSta}^{V}$和识别结果$P_{PaSta}$。\n\n对于输入，$\\mathcal{B}_{p}, b_{o}$都是使用在COCO数据集上预训练的Faster R-CNN做特征提取：\n\n- 对于物体$b_o$，$b_o\\rightarrow Faster R-CNN \\rightarrow f_o$，如果图片内不存在与物体进行交互，则使用图像的特征，即$I\\rightarrow Faster R-CNN \\rightarrow f_c \\rightarrow f_o$\n- 对于人的身体的每一个部位（共10个）$b_{p}^{(i)}$，$b_{p}^{(i)} \\rightarrow Faster R-CNN \\rightarrow f_{p}^{(i)}$\n\n得到特征表示后，首先输入到一个被称为Part Relevance Predictor的结构中，去计算每一个部位的attention，这个PRP结构由全连接组成，最后激活为softmax函数，给每一个局部部位特征输出一个注意力权重：\n$$\na_{i}=\\mathcal{P}_{p a}\\left(f_{p}^{(i)}, f_{o}\\right)\n$$\n其中$\\mathcal{P}_{p a}(\\cdot)$即是局部注意力预测器。**在这里，我感觉这个注意力权重应该指的是某个身体部位与物体的相关性，比如，手跟茶杯很相关，而脚和苹果则不太相关。**然后，将注意力权重与原始局部特征表示进行加权：\n$$\nf_{p}^{(i) \\star}=f_{p}^{(i)} \\times a_{i}\n$$\n接下来进行局部状态PaSta的分类/识别，此时将$f_{p}^{(i) \\star}$与$f_o$进行concat操作之后，传入max池化层，以及两层512的全连接，最终获得PaSta的分类结果$\\mathcal{S}_{P a S t a}^{(i)}$。**这里的$\\mathcal{S}$应该是logits，而$P_{PaSta}$表示概率。**\n\n*注意，这里存在一个身体部位有多种状态的可能，比如头部可以同时进行\"吃\"和\"看\"的动作，因此是一个多标签分类任务。*\n\n识别部分的交叉熵损失函数如下：\n$$\n\\mathcal{L}_{P a S t a}=\\sum_{i}^{10}\\left(\\mathcal{L}_{P a S t a}^{(i)}+\\mathcal{L}_{a t t}^{(i)}\\right)\n$$\n\n### Activity2Vec\n\n这一部分的输入为局部状态的视觉特征$f_{PaSta}^{V}$、识别结果$P_{PaSta}$和PaSta的语言特征$f_{B e r t}^{(i, k)}$，输出为PaSta的最终特征表示$f_{PaSta}$。\n\n> With PaStaNet, we convert a human instance into a vector consisting of PaSta representations. Activity2Vec extracts part-level semantic representation via PaSta recognition and combines its language representation. Since PaSta encodes common knowledge of activities, Activity2Vec works as a general feature extractor for both seen and unseen activities.\n\nActivity2Vec将一个人类实例转换为一个由PaSta表示组成的向量。通过局部状态识别提取局部层次的语义表示，并且与该局部状态的语言表示相结合。\n\n在这一环节的主要任务是将局部状态PaSta的语义知识嵌入到它的特征向量表示中去，那么，如何结合呢？\n\n对于图像特征，在上一部分已经获得，提取PaSta的分类结果前一层的隐状态即可，$\\color{red}{f_{\\text {PaSta}}^{V(i)} \\in \\mathbb{R}^{512}}$。\n\n对于语言特征，作者使用**BERT-Base预训练模型**先将数据集中的token预转换为$\\color{red}{f_{B e r t}^{(i, k)} \\in \\mathbb{R}^{2304}}$，并且在整个过程中保持不变。token指的是三元组&#60;part, verb, object&#62;，object来自目标检测。所有的token即$\\left\\{t_{p}^{(i, k)}, t_{v}^{(i, k)}, t_{o}^{(i, k)}\\right\\}_{k=1}^{n}$，$i$代表身体部位的数量，这里为10，$n$代表每一个部位具有的PaSta数量，其中的每个$t$都是768的向量长度。\n$$\nf_{B e r t}^{(i, k)}=\\mathcal{R}_{B e r t}\\left(t_{p}^{(i, k)}, t_{v}^{(i, k)}, t_{o}^{(i, k)}\\right)\n$$\n\n$$\nf_{B e r t}^{(i)} \\in \\mathbb{R}^{2304 * n}\n$$\n\n将部分的BERT表示与该部分的分类结果相乘，即PaSta的语言特征表示：\n$$\nf_{P a S t a}^{L(i)}=f_{B e r t}^{(i)} \\times P_{P a S t a}^{(i)}, \\text { where } P_{P a S t a}^{(i)}=\\operatorname{Sigmoid}\\left(\\mathcal{S}_{P a S t a}^{(i)}\\right) \\in \\mathbb{R}^{n}\n$$\n\n$$\nP_{P a S t a}=\\left\\{P_{P a S t a}^{(i)}\\right\\}_{i=1}^{10}\n$$\n\n$$\nf_{P a S t a}^{L(i)} \\in \\mathbb{R}^{2304 * n}\n$$\n\n**最后**，池化、resize语言特征$f_{P a S t a}^{L(i)}$后再与图像特征$f_{PaSta}^{V}$concat即获得最终的PaSta特征表示$f_{P a S t a}^{(i)} \\in \\mathbb{R}^{m}$。输出的$f_{\\text {PaSta}}=\\left\\{f_{\\text {PaSta}}^{(i)}\\right\\}_{i=1}^{10}$是局部级别的行为特征表示，可用于下游任务，像行为检测，标题生成等等。\n\n### PaSta-R\n\n这一部分主要是从局部状态的特征表示推断出图片中人的行为。其输入为特征表示$f_{PaSta}$，输出为动作评分$\\mathcal{S}$。\n\n> A Part State Based Reasoning method (PaSta-R) is further presented. We construct a Hierarchical Activity Graph consisting of human instance and part semantic representations, and infer the activities by combining both instance and part level sub-graph states.\n\n作者构造了一个由人类实例和局部语义表示组成的层次行为图（Hierarchical Activity Graph），并结合实例和局部层次子图状态来推断行为。\n\n![](./PaStaNet/fig4.png)\n\nHAG如上图中间所示，节点为局部的状态特征或者物体的特征，边分两种，第一种是body part与object的边，表示为$e_{p o}=\\left(v_{p}^{i}, v_{o}\\right) \\in \\mathcal{V}_{p} \\times \\mathcal{V}_{o}$，第二种是body part与body part的边，表示为$e_{p p}^{i j}=\\left(v_{p}^{i}, v_{p}^{j}\\right) \\in \\mathcal{V}_{p} \\times \\mathcal{V}_{p}$。***说实话，边究竟是如何表示的，完全没有看懂-.-***。\n\n作者的目标是解析HAG，然后推理出图像中的行为。即\n$$\n\\mathcal{S}_{p a r t}=\\mathcal{F}_{P a S t a-R}\\left(f_{P a S t a}, f_{o}\\right)\n$$\n作者提出了三种结构和三种方式，如下图所示：\n\n![](./PaStaNet/fig10.png)\n\n三种结构：\n\n1. Linear Combination，说白了就是一层全连接，激活为softmax；\n2. MLP，说白了就是两层1024单元全连接（使用非线性激活函数），最后一层激活为softmax；\n3. Graph Convolution Network，GCN提取全局图特征，然后接MLP输出分类结果。\n\n三种方式：\n\n1. 上图(a)所示，将$f_{P a S t a}, f_{o}$直接concat然后输入后续网络；\n2. 上图(b)所示，按身体部位逐步输入到LSTM网络，改造成序列模型。有两种输入方式，1乱序，2固定顺序（比如从头到脚），作者说固定顺序更好；\n3. 上图(c)所示，将部位特征分层组合，例如：\n   1. 在第一层将左手左上臂特征合并为左臂，左脚左大腿特征合并为左腿，……，然后传入全连接进一步提取特征；\n   2. 将头、胳膊等合并为上肢，臀、腿等合并为下肢，……，然后传入全连接进行进一步特征提取；\n   3. 上下肢合并为整体，然后传入全连接，再接后续网络。\n\n如何得到最后的分类结果呢？作者提出两种方式：\n\n1. early fusion——前融合，将实例层次的语义特征表示$f_{inst}$与PaSta特征表示、物体特征表示结合后再做PaSta-R推理；\n2. late fusion——后融合，融合实例层次的分类结果和局部层次的分类结果，即$\\mathcal{S}=\\mathcal{S}_{i n s t}+\\mathcal{S}_{p a r t}$。作者说，实验下来，这种方式效果更好。\n\n最终，整个框架的交叉熵损失函数为：\n$$\n\\mathcal{L}_{\\text {total}}=\\mathcal{L}_{\\text {PaSta}}+\\mathcal{L}_{\\text {cls}}^{\\text {PaSta}}+\\mathcal{L}_{\\text {cls}}^{\\text {inst}}\n$$\n\n# 实验\n\n监督学习中，PaStaNet在HICO完整数据集上提升了6.4(16%)mAP，在HICO one-shot数据集上提升了13.9mAP。\n\n迁移学习中，PaStanet在V-COCO数据集上提升了3.2mAP，在基于图像的AVA数据集上提升了4.2mAP，在HICO-DET数据集上提升了3.2mAP。\n\n## 类比实验\n\n从MNIST数据集中采集0-9数字（28X28X1），组成（128X128X1）的图片，每个图片包含3-5个数字。将数字类比为身体的局部部位，将行为设置为图片中最大的两个数字之和。图片中所有数字的union box代表一个人。为了模仿任务的移动特征，数字随机分布在图像中，而且给图像加入了高斯噪声。\n\n最终实验结果（准确率）：\n\n- 端到端，10.0%\n- 前融合：43.7%\n- 后融合：**44.2%**\n- 不融合：41.4%\n\n![](./PaStaNet/fig5.png)\n\n## Image-based Activity Recognition\n\n![](./PaStaNet/table1.png)\n\n## Instance-based Activity Detection\n\n![](./PaStaNet/table2.png)\n\n## Transfer Learning with Activity2Vec\n\n![](./PaStaNet/table3.png)\n\n![](./PaStaNet/table4.png)\n\n\n\n## 可视化结果\n\n![](./PaStaNet/fig14.png)\n\n图中蓝、绿、红分别指示身体部位、局部行为、交互物体。作者发现他们的模型能够检测各种行为，包括与各种对象的交互。\n\n\n\n# mAP\n\nmAP：mean Average Precision，平均的平均精度（两个平均）。先是类内求平均精确度，再是对所有类别再求平均精确度。\n\n目标检测任务中将目标的分类结果分成四类（正即是真，负即是假）：\n\n1. TP——True Positive，正识别为正；\n2. FP——False Positive，负识别为正；\n3. TN——True Negative，负识别为负；\n4. FN——False Negative，负识别为正\n\n准确率Precision——**识别为正**的数据中，真实为正的：\n$$\nP=\\frac{T P}{T P+F P}=\\frac{T P}{N_{\\text {detection}}}\n$$\n\n召回率Recall——**原始为正**的数据中，识别为正的：\n$$\nR=\\frac{T P}{T P+F N}=\\frac{T P}{N_{g t}}\n$$\n平均精度AP即是在一组召回率阈值[0, 1]中，根据召回率计算相应准确率，然后准确率取平均。比如设置11个等间隔召回率阈值[0, 0.2, ..., 1]，那么AP的计算公式如下：\n$$\n\\begin{aligned}\nA P=& \\frac{1}{11} \\sum_{r \\in\\{0,0.1, \\ldots, 1.0\\}} \\rho_{\\text {interp}}(r) \\\\\n& \\rho_{\\text {interp}}(r)=\\max _{\\hat{r}: \\hat{r} \\geqslant r}(\\hat{r})\n\\end{aligned}\n$$\n实际上就是对于每个Recall值下的Precision，取所有比当前值大的Recall对应的Precision的最大值作为当前Recall值下的Precision。\n\nmAP是多个AP值的均值，AP衡量的是学出来的模型在每个类别上的好坏，mAP衡量的是学出的模型在所有类别上的好坏。\n\n# 结论\n\n> In this paper, to make a step toward human activity knowledge engine, we construct PaStaNet to provide novel body part-level activity representation (PaSta). Meanwhile, a knowledge transformer Activity2Vec and a part-based reasoning method PaSta-R are proposed. PaStaNet brings in interpretability and new possibility for activity understanding. It can effectively bridge the semantic gap between pixels and activities. With PaStaNet, we signiﬁcantly boost the performance in supervised and transfer learning tasks, especially under few-shot circumstances. In the future, we plan to enrich our PaStaNet with spatio-temporal PaSta.\n\n# 引用\n\n1. [目标检测测评指标——mAP](https://blog.csdn.net/xiezongsheng1990/article/details/89608923?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)\n\n2. [多标签图像分类任务的评价方法-mAP](http://blog.sina.com.cn/s/blog_9db078090102whzw.html)\n\n\n\n","source":"_posts/PaStaNet.md","raw":"---\ntitle: \"PaStaNet: Toward Human Activity Knowledge Engine\"\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2020-04-12 01:23:03\ncategories: DeepLearning\ntags:\n- dl\nkeywords:\ndescription:\n---\n\n这篇论文是上海交大[卢策吾](http://mvig.sjtu.edu.cn/)老师团队下[李永露](https://dirtyharrylyl.github.io/)博士在2020CVPR会议三连中中的其中一篇。方向为HOIs方向，即人物交互。\n\n<!--more-->\n\n# 简介\n\n论文地址：[http://arxiv.org/abs/2004.00945](http://arxiv.org/abs/2004.00945)\n\n作者开源的代码和数据集：[http://hake-mvig.cn/](http://hake-mvig.cn/)\n\nPaSta是Part State的缩写，它是**细粒度动作语义标记**(ﬁne-grained action semantic tokens)，是人类活动/行为的更精细的表达，比如一个人类的行为是开汽车，那么这个行为的part state就包括手握方向盘、脚踩油门等等，这种part state用三元组形式表示，比如：&#60;hand, hold, something&#62;。\n\n这篇论文主要有两个比较大的贡献：\n\n1. 建立了一个大型知识库PaStaNet（其实是HAKE数据集），目前标注了700w+局部状态。\n2. 设计了一个分层的动作识别模型（为什么分层呢？因为作者提到现有的基于图像的动作识别理解方法主要采取直接映射/端到端的方式，可能会遇到性能瓶颈。）\n   1. 第一层是Activity2Vec模型，用来从原始图片中提取PaSta特征，PaSta是组成多种人类行为的通用表示，比如一个PaSta是hold，那么开汽车时有hold方向盘，吃苹果时有hold苹果，两种不同的行为共享同样的PaSta；\n   2. 第二层使用了PaSta-based Reasoning（PaSta-R，基于局部状态的推理）方法，用这种方法从第一层中识别的PaSta来推测图片中的人类行为活动。\n\n下文中以下概念术语等同：\n\n- PaStaNet——数据集\n- 人类行为理解——动作识别\n- PaSta——局部状态\n\n# 文中精要\n\n在大规模的基准中，基于**实例层次的语义（instance-level semantics）**使用one-stage从像素理解人类行为存在性能瓶颈，主要有以下几个原因：\n\n1. long-tail data distribution，长尾数据分布（少数类别有大部分数据，而多数类别只有小部分数据）\n\n   ![](./PaStaNet/Long_tailed_distribution.png)\n\n2. complex visual patterns，复杂的视觉模式\n\n作者认为(argue that)在人类局部的语义层次上进行感知是一个非常有前景的方向，这种方式之前被忽略了。\n\n**作者的核心思想是：人类动作由细粒度的原子主体部分状态（PaSta）组成。**\n\n> Our core idea is that human instance actions are composed of ﬁne-grained atomic body part states.\n\n![](./PaStaNet/fig1.png)\n\n先识别PaSta再推理行为有什么好处呢？\n\n1. 与简化理论(reductionism)有强烈的直接关系\n\n   > This lies in strong relationships with reductionism.\n\n2. 可以帮助我们选择有区别的部分，忽略不相关的部分\n\n   > the part-level path can help us to pick up discriminative parts and disregard irrelevant ones.\n\n3. 从人体局部编码知识是实现人类活动知识引擎的关键步骤\n\n   > encoding knowledge from human parts is a crucial step toward human activity knowledge engine.\n\n4. Reusability and Transferability——可重用性和可转移性，多个行为的局部状态存在共享，比如一个PaSta是hold，那么开汽车时有hold方向盘，吃苹果时有hold苹果，两种不同的行为共享同样的PaSta。因此，我们可以用更少的PaSta来描述和区分大量的行为。对于few-shot学习，可重用性可以极大地缓解其学习困难。\n\n   > PaSta are basic components of actions, their relationship can be in analogy with the amino acid and protein, letter and word, etc. Hence, PaSta are reusable, e.g., 〈 hand, hold, something 〉 is shared by various actions like “hold horse” and “eat apple”. Therefore, we get the capacity to describe and differentiate plenty of activities with a much smaller set of PaSta, i.e. one-time labeling and transferability. For fewshot learning, reusability can greatly alleviate its learning difﬁculty. Thus our approach shows signiﬁcant improvements, e.g. we boost 13.9 mAP on one-shot sets of HICO\n\n5. Interpretability——可解释性，当模型预测一个人在做什么时，我们很容易知道原因:它的身体的各个部分在做什么。\n\n   > we obtain not only more powerful activity representations, but also better interpretation. When the model predicts what a person is doing, we can easily know the reasons: what the body parts are doing.\n\n## PaStaNet数据集\n\n该数据集目前已经标注了11.8w张图片，包括28.5w个人物，25w个交互的实体对象（比如球之类的），72.4万个行为，以及700w个人类局部状态。\n\n该数据集目前有156个行为分类，76个PaSta分类。\n\n广泛的分析证明，一般来说，PaStaNet可以覆盖大部分的局部级知识，可以很好的概括大部分情况。\n\n![](./PaStaNet/fig6.png)\n\n下图为数据集中的行为和交互物体类别。\n\n![](./PaStaNet/table6.png)\n\n下图为数据集中的局部状态PaSta类别。\n\n![](./PaStaNet/table7.png)\n\n### PaSta的定义\n\n将人体解耦成十个部分：head, two upper arms, two hands, hip, two thighs, two feet，即\n\n1. 头\n2. 左臂\n3. 右臂\n4. 左手\n5. 右手\n6. 臀部\n7. 左腿\n8. 右腿\n9. 左脚\n10. 右脚\n\n每一个PaSta表示目标局部部分的表示，比如hand可以是hold something, push something；head可以是watch something, eat something。注意，当一个人同时有多个行为动作，他的某个局部身体部位可以有多个PaSta。\n\n### 数据收集\n\n两种方式：\n\n1. 通过众包收集以人为中心的行为图像(3万张图片，具有粗糙的活动标签)；\n2. 现有的设计良好的数据集(18.5万张)。\n\n其中的数据围绕丰富的语义本体论(semantic ontology)、多样性和行为的可变性构建。最终，收集了超过20万张的不同行为类别的图片。\n\n### 行为标签\n\n根据人类最常见的日常活动，与人和物的互动。从11.8万张图片中选择了156种行为，包括人与物体的互动和身体动作（包含bounding boxes）。\n\n### 身体局部的盒子\n\n> Estimation errors are addressed manually to ensure high-quality annotation. Each part box is centered with a joint, and the box size is pre-deﬁned by scaling the distance between the joints of the neck and pelvis. A joint with conﬁdence higher than 0.7 will be seen as visible. When not all joints can be detected, we use body knowledge-based rules. That is, if the neck or pelvis is invisible, we conﬁgure the part boxes according to other visible joint groups (head, main body, arms, legs), e.g., if only the upper body is visible, we set the size of the hand box to twice the pupil distance.\n\n### 局部状态PaSta标注\n\n通过众包方式进行标注，共收到224159条标注上传。\n\n过程如下：\n\n1. 基于156种行为的动词，从WordNet选取200个PaSta动词。如果某个局部部位没有可以的状态，则描述为\"no_action\"；\n2. 为了找到最通用的PaSta（可以作为可转移的行为知识），邀请了来自不同背景的150名注释者来标注156个行为的1w张图片；\n3. 基于它们的注释，使用规范化的**点对点互信息(Normalized Point-wise Mutual Information，NPMI，*Kenneth Ward Church and Patrick Hanks. Word association norms, mutual information, and lexicography. In Computational linguistics, 1990.*)**来计算行为和PaSta之间的共生/共现关系，最后选择76个具有最高NPMI值的候选局部状态为PaSta集合；\n4. 以之前的1w张打了标签的图片为种子，自动生成其余图片的初始PaSta标签，然后另外210名注释者仅需要去检查这些标注即可；\n5. 考虑到一个人可能有多个动作，对于每个动作，分别标注其对应的10个PaSta。然后把所有动作的PaSta组合在一起；\n6. 为了确保质量，每幅图像都将被标注两次，并由自动程序和主管进行检查。\n\n![](./PaStaNet/fig2.png)\n\n**疑问：为什么ride bicycle与head look at的共现如此之低呢？**\n\n### 行为解析树\n\n为了说明PaSta和行为之间的关系，作者使用它们的统计相关性来构建一个图：行为是根节点，PaSta是子节点，边是共现。\n\n> To illustrate the relationships between PaSta and activities, we use their statistical correlations to construct a graph (Fig. 2): activities are root nodes, PaSta are son nodes and edges are co-occurrence.\n\nPaStaNet可以为实例级和局部级提供丰富的行为知识，并帮助构建大型行为解析树。\n\n> PaStaNet can provide abundant activity knowledge for both instance and part levels and help construct a large-scale activity parsing tree\n\n![](./PaStaNet/fig8.png)\n\n作者将解析树表示为行为和PaSta的共现矩阵(看起来极其稀疏)。\n\n![](./PaStaNet/fig9.png)\n\n## 分层行为理解模型\n\n这一部分数学符号很多，而且似乎故意把符号设计的复杂，导致阅读理解起来有些不顺畅。\n\n对于行为的识别，有两种模型：\n\n1. 传统模式，采用直接映射。\n   $$\n   \\mathcal{S}_{i n s t}=\\mathcal{F}_{i n s t}\\left(I, b_{h}, \\mathcal{B}_{o}\\right)\n   $$\n   其中，$I$表示图像输入，$b_h$是人的box，$\\mathcal{B}_{o}=\\left\\{b_{o}^{i}\\right\\}_{i=1}^{m}$是与人交互的物体的box，假设有$m$个物体。$\\mathcal{S}_{i n s t}$代表实体级别的动作评分（评估结果）。\n\n2. 作者提出的PaStaNet模式，利用通用的局部知识，分成两步：\n\n   1. PaSta局部状态识别和特征提取（其实是识别层之前的隐特征）\n      $$\n      f_{P a S t a}=\\mathcal{R}_{A 2 V}\\left(I, \\mathcal{B}_{p}, b_{o}\\right) = \\left\\{f_{P a S t a}^{(i)}\\right\\}_{i=1}^{10}\n      $$\n      其中，$\\mathcal{B}_{p}=\\left\\{b_{p}^{(i)}\\right\\}_{i}^{10}$是人的局部部位的box，使用*Pairwise body-part attention for recognizing human-object interactions. In ECCV, 2018*自动生成。$\\mathcal{R}_{A 2 V}(\\cdot)$表示Activity2Vec模型，用于提取PaSta的特征表示，\n\n   2. PaSta-Based推理（PaSta-R），从局部状态推理行为语义\n      $$\n      \\mathcal{S}_{p a r t}=\\mathcal{F}_{P a S t a-R}\\left(f_{P a S t a}, f_{o}\\right)\n      $$\n      其中，$\\mathcal{F}_{P a S t a-R}(\\cdot)$代表PaSta-R方法，$f_{o}$是物体的特征表示，$\\mathcal{S}_{p a r t}$是局部状态层面的动作评分。*注意，如果场景中人没有与物进行交互，比如”跳舞“这个动作，那么使用图像的ROI池化特征来表示$f_o$。如果场景中存在多个交互物体，则依次处理human-object pair$\\left(f_{P a S t a}, f_{o}^{(i)}\\right)$，并且声称各自独立的Activity2Vec Embedding*。\n\n![](./PaStaNet/fig3.png)\n\n上图为PaSta的识别与特征表示部分的框架图。\n\n识别部分主要为红色线条部分，特征表示部分主要为蓝色线条部分。\n\n### 局部状态PaSta识别\n\n这部分的输入为$I, \\mathcal{B}_{p}, b_{o}$，输出为局部状态的视觉特征$f_{PaSta}^{V}$和识别结果$P_{PaSta}$。\n\n对于输入，$\\mathcal{B}_{p}, b_{o}$都是使用在COCO数据集上预训练的Faster R-CNN做特征提取：\n\n- 对于物体$b_o$，$b_o\\rightarrow Faster R-CNN \\rightarrow f_o$，如果图片内不存在与物体进行交互，则使用图像的特征，即$I\\rightarrow Faster R-CNN \\rightarrow f_c \\rightarrow f_o$\n- 对于人的身体的每一个部位（共10个）$b_{p}^{(i)}$，$b_{p}^{(i)} \\rightarrow Faster R-CNN \\rightarrow f_{p}^{(i)}$\n\n得到特征表示后，首先输入到一个被称为Part Relevance Predictor的结构中，去计算每一个部位的attention，这个PRP结构由全连接组成，最后激活为softmax函数，给每一个局部部位特征输出一个注意力权重：\n$$\na_{i}=\\mathcal{P}_{p a}\\left(f_{p}^{(i)}, f_{o}\\right)\n$$\n其中$\\mathcal{P}_{p a}(\\cdot)$即是局部注意力预测器。**在这里，我感觉这个注意力权重应该指的是某个身体部位与物体的相关性，比如，手跟茶杯很相关，而脚和苹果则不太相关。**然后，将注意力权重与原始局部特征表示进行加权：\n$$\nf_{p}^{(i) \\star}=f_{p}^{(i)} \\times a_{i}\n$$\n接下来进行局部状态PaSta的分类/识别，此时将$f_{p}^{(i) \\star}$与$f_o$进行concat操作之后，传入max池化层，以及两层512的全连接，最终获得PaSta的分类结果$\\mathcal{S}_{P a S t a}^{(i)}$。**这里的$\\mathcal{S}$应该是logits，而$P_{PaSta}$表示概率。**\n\n*注意，这里存在一个身体部位有多种状态的可能，比如头部可以同时进行\"吃\"和\"看\"的动作，因此是一个多标签分类任务。*\n\n识别部分的交叉熵损失函数如下：\n$$\n\\mathcal{L}_{P a S t a}=\\sum_{i}^{10}\\left(\\mathcal{L}_{P a S t a}^{(i)}+\\mathcal{L}_{a t t}^{(i)}\\right)\n$$\n\n### Activity2Vec\n\n这一部分的输入为局部状态的视觉特征$f_{PaSta}^{V}$、识别结果$P_{PaSta}$和PaSta的语言特征$f_{B e r t}^{(i, k)}$，输出为PaSta的最终特征表示$f_{PaSta}$。\n\n> With PaStaNet, we convert a human instance into a vector consisting of PaSta representations. Activity2Vec extracts part-level semantic representation via PaSta recognition and combines its language representation. Since PaSta encodes common knowledge of activities, Activity2Vec works as a general feature extractor for both seen and unseen activities.\n\nActivity2Vec将一个人类实例转换为一个由PaSta表示组成的向量。通过局部状态识别提取局部层次的语义表示，并且与该局部状态的语言表示相结合。\n\n在这一环节的主要任务是将局部状态PaSta的语义知识嵌入到它的特征向量表示中去，那么，如何结合呢？\n\n对于图像特征，在上一部分已经获得，提取PaSta的分类结果前一层的隐状态即可，$\\color{red}{f_{\\text {PaSta}}^{V(i)} \\in \\mathbb{R}^{512}}$。\n\n对于语言特征，作者使用**BERT-Base预训练模型**先将数据集中的token预转换为$\\color{red}{f_{B e r t}^{(i, k)} \\in \\mathbb{R}^{2304}}$，并且在整个过程中保持不变。token指的是三元组&#60;part, verb, object&#62;，object来自目标检测。所有的token即$\\left\\{t_{p}^{(i, k)}, t_{v}^{(i, k)}, t_{o}^{(i, k)}\\right\\}_{k=1}^{n}$，$i$代表身体部位的数量，这里为10，$n$代表每一个部位具有的PaSta数量，其中的每个$t$都是768的向量长度。\n$$\nf_{B e r t}^{(i, k)}=\\mathcal{R}_{B e r t}\\left(t_{p}^{(i, k)}, t_{v}^{(i, k)}, t_{o}^{(i, k)}\\right)\n$$\n\n$$\nf_{B e r t}^{(i)} \\in \\mathbb{R}^{2304 * n}\n$$\n\n将部分的BERT表示与该部分的分类结果相乘，即PaSta的语言特征表示：\n$$\nf_{P a S t a}^{L(i)}=f_{B e r t}^{(i)} \\times P_{P a S t a}^{(i)}, \\text { where } P_{P a S t a}^{(i)}=\\operatorname{Sigmoid}\\left(\\mathcal{S}_{P a S t a}^{(i)}\\right) \\in \\mathbb{R}^{n}\n$$\n\n$$\nP_{P a S t a}=\\left\\{P_{P a S t a}^{(i)}\\right\\}_{i=1}^{10}\n$$\n\n$$\nf_{P a S t a}^{L(i)} \\in \\mathbb{R}^{2304 * n}\n$$\n\n**最后**，池化、resize语言特征$f_{P a S t a}^{L(i)}$后再与图像特征$f_{PaSta}^{V}$concat即获得最终的PaSta特征表示$f_{P a S t a}^{(i)} \\in \\mathbb{R}^{m}$。输出的$f_{\\text {PaSta}}=\\left\\{f_{\\text {PaSta}}^{(i)}\\right\\}_{i=1}^{10}$是局部级别的行为特征表示，可用于下游任务，像行为检测，标题生成等等。\n\n### PaSta-R\n\n这一部分主要是从局部状态的特征表示推断出图片中人的行为。其输入为特征表示$f_{PaSta}$，输出为动作评分$\\mathcal{S}$。\n\n> A Part State Based Reasoning method (PaSta-R) is further presented. We construct a Hierarchical Activity Graph consisting of human instance and part semantic representations, and infer the activities by combining both instance and part level sub-graph states.\n\n作者构造了一个由人类实例和局部语义表示组成的层次行为图（Hierarchical Activity Graph），并结合实例和局部层次子图状态来推断行为。\n\n![](./PaStaNet/fig4.png)\n\nHAG如上图中间所示，节点为局部的状态特征或者物体的特征，边分两种，第一种是body part与object的边，表示为$e_{p o}=\\left(v_{p}^{i}, v_{o}\\right) \\in \\mathcal{V}_{p} \\times \\mathcal{V}_{o}$，第二种是body part与body part的边，表示为$e_{p p}^{i j}=\\left(v_{p}^{i}, v_{p}^{j}\\right) \\in \\mathcal{V}_{p} \\times \\mathcal{V}_{p}$。***说实话，边究竟是如何表示的，完全没有看懂-.-***。\n\n作者的目标是解析HAG，然后推理出图像中的行为。即\n$$\n\\mathcal{S}_{p a r t}=\\mathcal{F}_{P a S t a-R}\\left(f_{P a S t a}, f_{o}\\right)\n$$\n作者提出了三种结构和三种方式，如下图所示：\n\n![](./PaStaNet/fig10.png)\n\n三种结构：\n\n1. Linear Combination，说白了就是一层全连接，激活为softmax；\n2. MLP，说白了就是两层1024单元全连接（使用非线性激活函数），最后一层激活为softmax；\n3. Graph Convolution Network，GCN提取全局图特征，然后接MLP输出分类结果。\n\n三种方式：\n\n1. 上图(a)所示，将$f_{P a S t a}, f_{o}$直接concat然后输入后续网络；\n2. 上图(b)所示，按身体部位逐步输入到LSTM网络，改造成序列模型。有两种输入方式，1乱序，2固定顺序（比如从头到脚），作者说固定顺序更好；\n3. 上图(c)所示，将部位特征分层组合，例如：\n   1. 在第一层将左手左上臂特征合并为左臂，左脚左大腿特征合并为左腿，……，然后传入全连接进一步提取特征；\n   2. 将头、胳膊等合并为上肢，臀、腿等合并为下肢，……，然后传入全连接进行进一步特征提取；\n   3. 上下肢合并为整体，然后传入全连接，再接后续网络。\n\n如何得到最后的分类结果呢？作者提出两种方式：\n\n1. early fusion——前融合，将实例层次的语义特征表示$f_{inst}$与PaSta特征表示、物体特征表示结合后再做PaSta-R推理；\n2. late fusion——后融合，融合实例层次的分类结果和局部层次的分类结果，即$\\mathcal{S}=\\mathcal{S}_{i n s t}+\\mathcal{S}_{p a r t}$。作者说，实验下来，这种方式效果更好。\n\n最终，整个框架的交叉熵损失函数为：\n$$\n\\mathcal{L}_{\\text {total}}=\\mathcal{L}_{\\text {PaSta}}+\\mathcal{L}_{\\text {cls}}^{\\text {PaSta}}+\\mathcal{L}_{\\text {cls}}^{\\text {inst}}\n$$\n\n# 实验\n\n监督学习中，PaStaNet在HICO完整数据集上提升了6.4(16%)mAP，在HICO one-shot数据集上提升了13.9mAP。\n\n迁移学习中，PaStanet在V-COCO数据集上提升了3.2mAP，在基于图像的AVA数据集上提升了4.2mAP，在HICO-DET数据集上提升了3.2mAP。\n\n## 类比实验\n\n从MNIST数据集中采集0-9数字（28X28X1），组成（128X128X1）的图片，每个图片包含3-5个数字。将数字类比为身体的局部部位，将行为设置为图片中最大的两个数字之和。图片中所有数字的union box代表一个人。为了模仿任务的移动特征，数字随机分布在图像中，而且给图像加入了高斯噪声。\n\n最终实验结果（准确率）：\n\n- 端到端，10.0%\n- 前融合：43.7%\n- 后融合：**44.2%**\n- 不融合：41.4%\n\n![](./PaStaNet/fig5.png)\n\n## Image-based Activity Recognition\n\n![](./PaStaNet/table1.png)\n\n## Instance-based Activity Detection\n\n![](./PaStaNet/table2.png)\n\n## Transfer Learning with Activity2Vec\n\n![](./PaStaNet/table3.png)\n\n![](./PaStaNet/table4.png)\n\n\n\n## 可视化结果\n\n![](./PaStaNet/fig14.png)\n\n图中蓝、绿、红分别指示身体部位、局部行为、交互物体。作者发现他们的模型能够检测各种行为，包括与各种对象的交互。\n\n\n\n# mAP\n\nmAP：mean Average Precision，平均的平均精度（两个平均）。先是类内求平均精确度，再是对所有类别再求平均精确度。\n\n目标检测任务中将目标的分类结果分成四类（正即是真，负即是假）：\n\n1. TP——True Positive，正识别为正；\n2. FP——False Positive，负识别为正；\n3. TN——True Negative，负识别为负；\n4. FN——False Negative，负识别为正\n\n准确率Precision——**识别为正**的数据中，真实为正的：\n$$\nP=\\frac{T P}{T P+F P}=\\frac{T P}{N_{\\text {detection}}}\n$$\n\n召回率Recall——**原始为正**的数据中，识别为正的：\n$$\nR=\\frac{T P}{T P+F N}=\\frac{T P}{N_{g t}}\n$$\n平均精度AP即是在一组召回率阈值[0, 1]中，根据召回率计算相应准确率，然后准确率取平均。比如设置11个等间隔召回率阈值[0, 0.2, ..., 1]，那么AP的计算公式如下：\n$$\n\\begin{aligned}\nA P=& \\frac{1}{11} \\sum_{r \\in\\{0,0.1, \\ldots, 1.0\\}} \\rho_{\\text {interp}}(r) \\\\\n& \\rho_{\\text {interp}}(r)=\\max _{\\hat{r}: \\hat{r} \\geqslant r}(\\hat{r})\n\\end{aligned}\n$$\n实际上就是对于每个Recall值下的Precision，取所有比当前值大的Recall对应的Precision的最大值作为当前Recall值下的Precision。\n\nmAP是多个AP值的均值，AP衡量的是学出来的模型在每个类别上的好坏，mAP衡量的是学出的模型在所有类别上的好坏。\n\n# 结论\n\n> In this paper, to make a step toward human activity knowledge engine, we construct PaStaNet to provide novel body part-level activity representation (PaSta). Meanwhile, a knowledge transformer Activity2Vec and a part-based reasoning method PaSta-R are proposed. PaStaNet brings in interpretability and new possibility for activity understanding. It can effectively bridge the semantic gap between pixels and activities. With PaStaNet, we signiﬁcantly boost the performance in supervised and transfer learning tasks, especially under few-shot circumstances. In the future, we plan to enrich our PaStaNet with spatio-temporal PaSta.\n\n# 引用\n\n1. [目标检测测评指标——mAP](https://blog.csdn.net/xiezongsheng1990/article/details/89608923?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)\n\n2. [多标签图像分类任务的评价方法-mAP](http://blog.sina.com.cn/s/blog_9db078090102whzw.html)\n\n\n\n","slug":"PaStaNet","published":1,"updated":"2020-04-12T11:38:34.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzutl1005x20cdar27w44w","content":"<p>这篇论文是上海交大<a href=\"http://mvig.sjtu.edu.cn/\" rel=\"external nofollow\" target=\"_blank\">卢策吾</a>老师团队下<a href=\"https://dirtyharrylyl.github.io/\" rel=\"external nofollow\" target=\"_blank\">李永露</a>博士在2020CVPR会议三连中中的其中一篇。方向为HOIs方向，即人物交互。</p>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/2004.00945\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/2004.00945</a></p>\n<p>作者开源的代码和数据集：<a href=\"http://hake-mvig.cn/\" rel=\"external nofollow\" target=\"_blank\">http://hake-mvig.cn/</a></p>\n<p>PaSta是Part State的缩写，它是<strong>细粒度动作语义标记</strong>(ﬁne-grained action semantic tokens)，是人类活动/行为的更精细的表达，比如一个人类的行为是开汽车，那么这个行为的part state就包括手握方向盘、脚踩油门等等，这种part state用三元组形式表示，比如：&#60;hand, hold, something&#62;。</p>\n<p>这篇论文主要有两个比较大的贡献：</p>\n<ol>\n<li>建立了一个大型知识库PaStaNet（其实是HAKE数据集），目前标注了700w+局部状态。</li>\n<li>设计了一个分层的动作识别模型（为什么分层呢？因为作者提到现有的基于图像的动作识别理解方法主要采取直接映射/端到端的方式，可能会遇到性能瓶颈。）<ol>\n<li>第一层是Activity2Vec模型，用来从原始图片中提取PaSta特征，PaSta是组成多种人类行为的通用表示，比如一个PaSta是hold，那么开汽车时有hold方向盘，吃苹果时有hold苹果，两种不同的行为共享同样的PaSta；</li>\n<li>第二层使用了PaSta-based Reasoning（PaSta-R，基于局部状态的推理）方法，用这种方法从第一层中识别的PaSta来推测图片中的人类行为活动。</li>\n</ol>\n</li>\n</ol>\n<p>下文中以下概念术语等同：</p>\n<ul>\n<li>PaStaNet——数据集</li>\n<li>人类行为理解——动作识别</li>\n<li>PaSta——局部状态</li>\n</ul>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>在大规模的基准中，基于<strong>实例层次的语义（instance-level semantics）</strong>使用one-stage从像素理解人类行为存在性能瓶颈，主要有以下几个原因：</p>\n<ol>\n<li><p>long-tail data distribution，长尾数据分布（少数类别有大部分数据，而多数类别只有小部分数据）</p>\n<p><img src=\"./PaStaNet/Long_tailed_distribution.png\" alt=\"\"></p>\n</li>\n<li><p>complex visual patterns，复杂的视觉模式</p>\n</li>\n</ol>\n<p>作者认为(argue that)在人类局部的语义层次上进行感知是一个非常有前景的方向，这种方式之前被忽略了。</p>\n<p><strong>作者的核心思想是：人类动作由细粒度的原子主体部分状态（PaSta）组成。</strong></p>\n<blockquote>\n<p>Our core idea is that human instance actions are composed of ﬁne-grained atomic body part states.</p>\n</blockquote>\n<p><img src=\"./PaStaNet/fig1.png\" alt=\"\"></p>\n<p>先识别PaSta再推理行为有什么好处呢？</p>\n<ol>\n<li><p>与简化理论(reductionism)有强烈的直接关系</p>\n<blockquote>\n<p>This lies in strong relationships with reductionism.</p>\n</blockquote>\n</li>\n<li><p>可以帮助我们选择有区别的部分，忽略不相关的部分</p>\n<blockquote>\n<p>the part-level path can help us to pick up discriminative parts and disregard irrelevant ones.</p>\n</blockquote>\n</li>\n<li><p>从人体局部编码知识是实现人类活动知识引擎的关键步骤</p>\n<blockquote>\n<p>encoding knowledge from human parts is a crucial step toward human activity knowledge engine.</p>\n</blockquote>\n</li>\n<li><p>Reusability and Transferability——可重用性和可转移性，多个行为的局部状态存在共享，比如一个PaSta是hold，那么开汽车时有hold方向盘，吃苹果时有hold苹果，两种不同的行为共享同样的PaSta。因此，我们可以用更少的PaSta来描述和区分大量的行为。对于few-shot学习，可重用性可以极大地缓解其学习困难。</p>\n<blockquote>\n<p>PaSta are basic components of actions, their relationship can be in analogy with the amino acid and protein, letter and word, etc. Hence, PaSta are reusable, e.g., 〈 hand, hold, something 〉 is shared by various actions like “hold horse” and “eat apple”. Therefore, we get the capacity to describe and differentiate plenty of activities with a much smaller set of PaSta, i.e. one-time labeling and transferability. For fewshot learning, reusability can greatly alleviate its learning difﬁculty. Thus our approach shows signiﬁcant improvements, e.g. we boost 13.9 mAP on one-shot sets of HICO</p>\n</blockquote>\n</li>\n<li><p>Interpretability——可解释性，当模型预测一个人在做什么时，我们很容易知道原因:它的身体的各个部分在做什么。</p>\n<blockquote>\n<p>we obtain not only more powerful activity representations, but also better interpretation. When the model predicts what a person is doing, we can easily know the reasons: what the body parts are doing.</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"PaStaNet数据集\"><a href=\"#PaStaNet数据集\" class=\"headerlink\" title=\"PaStaNet数据集\"></a>PaStaNet数据集</h2><p>该数据集目前已经标注了11.8w张图片，包括28.5w个人物，25w个交互的实体对象（比如球之类的），72.4万个行为，以及700w个人类局部状态。</p>\n<p>该数据集目前有156个行为分类，76个PaSta分类。</p>\n<p>广泛的分析证明，一般来说，PaStaNet可以覆盖大部分的局部级知识，可以很好的概括大部分情况。</p>\n<p><img src=\"./PaStaNet/fig6.png\" alt=\"\"></p>\n<p>下图为数据集中的行为和交互物体类别。</p>\n<p><img src=\"./PaStaNet/table6.png\" alt=\"\"></p>\n<p>下图为数据集中的局部状态PaSta类别。</p>\n<p><img src=\"./PaStaNet/table7.png\" alt=\"\"></p>\n<h3 id=\"PaSta的定义\"><a href=\"#PaSta的定义\" class=\"headerlink\" title=\"PaSta的定义\"></a>PaSta的定义</h3><p>将人体解耦成十个部分：head, two upper arms, two hands, hip, two thighs, two feet，即</p>\n<ol>\n<li>头</li>\n<li>左臂</li>\n<li>右臂</li>\n<li>左手</li>\n<li>右手</li>\n<li>臀部</li>\n<li>左腿</li>\n<li>右腿</li>\n<li>左脚</li>\n<li>右脚</li>\n</ol>\n<p>每一个PaSta表示目标局部部分的表示，比如hand可以是hold something, push something；head可以是watch something, eat something。注意，当一个人同时有多个行为动作，他的某个局部身体部位可以有多个PaSta。</p>\n<h3 id=\"数据收集\"><a href=\"#数据收集\" class=\"headerlink\" title=\"数据收集\"></a>数据收集</h3><p>两种方式：</p>\n<ol>\n<li>通过众包收集以人为中心的行为图像(3万张图片，具有粗糙的活动标签)；</li>\n<li>现有的设计良好的数据集(18.5万张)。</li>\n</ol>\n<p>其中的数据围绕丰富的语义本体论(semantic ontology)、多样性和行为的可变性构建。最终，收集了超过20万张的不同行为类别的图片。</p>\n<h3 id=\"行为标签\"><a href=\"#行为标签\" class=\"headerlink\" title=\"行为标签\"></a>行为标签</h3><p>根据人类最常见的日常活动，与人和物的互动。从11.8万张图片中选择了156种行为，包括人与物体的互动和身体动作（包含bounding boxes）。</p>\n<h3 id=\"身体局部的盒子\"><a href=\"#身体局部的盒子\" class=\"headerlink\" title=\"身体局部的盒子\"></a>身体局部的盒子</h3><blockquote>\n<p>Estimation errors are addressed manually to ensure high-quality annotation. Each part box is centered with a joint, and the box size is pre-deﬁned by scaling the distance between the joints of the neck and pelvis. A joint with conﬁdence higher than 0.7 will be seen as visible. When not all joints can be detected, we use body knowledge-based rules. That is, if the neck or pelvis is invisible, we conﬁgure the part boxes according to other visible joint groups (head, main body, arms, legs), e.g., if only the upper body is visible, we set the size of the hand box to twice the pupil distance.</p>\n</blockquote>\n<h3 id=\"局部状态PaSta标注\"><a href=\"#局部状态PaSta标注\" class=\"headerlink\" title=\"局部状态PaSta标注\"></a>局部状态PaSta标注</h3><p>通过众包方式进行标注，共收到224159条标注上传。</p>\n<p>过程如下：</p>\n<ol>\n<li>基于156种行为的动词，从WordNet选取200个PaSta动词。如果某个局部部位没有可以的状态，则描述为”no_action”；</li>\n<li>为了找到最通用的PaSta（可以作为可转移的行为知识），邀请了来自不同背景的150名注释者来标注156个行为的1w张图片；</li>\n<li>基于它们的注释，使用规范化的<strong>点对点互信息(Normalized Point-wise Mutual Information，NPMI，<em>Kenneth Ward Church and Patrick Hanks. Word association norms, mutual information, and lexicography. In Computational linguistics, 1990.</em>)</strong>来计算行为和PaSta之间的共生/共现关系，最后选择76个具有最高NPMI值的候选局部状态为PaSta集合；</li>\n<li>以之前的1w张打了标签的图片为种子，自动生成其余图片的初始PaSta标签，然后另外210名注释者仅需要去检查这些标注即可；</li>\n<li>考虑到一个人可能有多个动作，对于每个动作，分别标注其对应的10个PaSta。然后把所有动作的PaSta组合在一起；</li>\n<li>为了确保质量，每幅图像都将被标注两次，并由自动程序和主管进行检查。</li>\n</ol>\n<p><img src=\"./PaStaNet/fig2.png\" alt=\"\"></p>\n<p><strong>疑问：为什么ride bicycle与head look at的共现如此之低呢？</strong></p>\n<h3 id=\"行为解析树\"><a href=\"#行为解析树\" class=\"headerlink\" title=\"行为解析树\"></a>行为解析树</h3><p>为了说明PaSta和行为之间的关系，作者使用它们的统计相关性来构建一个图：行为是根节点，PaSta是子节点，边是共现。</p>\n<blockquote>\n<p>To illustrate the relationships between PaSta and activities, we use their statistical correlations to construct a graph (Fig. 2): activities are root nodes, PaSta are son nodes and edges are co-occurrence.</p>\n</blockquote>\n<p>PaStaNet可以为实例级和局部级提供丰富的行为知识，并帮助构建大型行为解析树。</p>\n<blockquote>\n<p>PaStaNet can provide abundant activity knowledge for both instance and part levels and help construct a large-scale activity parsing tree</p>\n</blockquote>\n<p><img src=\"./PaStaNet/fig8.png\" alt=\"\"></p>\n<p>作者将解析树表示为行为和PaSta的共现矩阵(看起来极其稀疏)。</p>\n<p><img src=\"./PaStaNet/fig9.png\" alt=\"\"></p>\n<h2 id=\"分层行为理解模型\"><a href=\"#分层行为理解模型\" class=\"headerlink\" title=\"分层行为理解模型\"></a>分层行为理解模型</h2><p>这一部分数学符号很多，而且似乎故意把符号设计的复杂，导致阅读理解起来有些不顺畅。</p>\n<p>对于行为的识别，有两种模型：</p>\n<ol>\n<li><p>传统模式，采用直接映射。</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{S}_{i n s t}=\\mathcal{F}_{i n s t}\\left(I, b_{h}, \\mathcal{B}_{o}\\right)</script><p>其中，$I$表示图像输入，$b_h$是人的box，$\\mathcal{B}_{o}=\\left\\{b_{o}^{i}\\right\\}_{i=1}^{m}$是与人交互的物体的box，假设有$m$个物体。$\\mathcal{S}_{i n s t}$代表实体级别的动作评分（评估结果）。</p>\n</li>\n<li><p>作者提出的PaStaNet模式，利用通用的局部知识，分成两步：</p>\n<ol>\n<li><p>PaSta局部状态识别和特征提取（其实是识别层之前的隐特征）</p>\n<script type=\"math/tex; mode=display\">\nf_{P a S t a}=\\mathcal{R}_{A 2 V}\\left(I, \\mathcal{B}_{p}, b_{o}\\right) = \\left\\{f_{P a S t a}^{(i)}\\right\\}_{i=1}^{10}</script><p>其中，$\\mathcal{B}_{p}=\\left\\{b_{p}^{(i)}\\right\\}_{i}^{10}$是人的局部部位的box，使用<em>Pairwise body-part attention for recognizing human-object interactions. In ECCV, 2018</em>自动生成。$\\mathcal{R}_{A 2 V}(\\cdot)$表示Activity2Vec模型，用于提取PaSta的特征表示，</p>\n</li>\n<li><p>PaSta-Based推理（PaSta-R），从局部状态推理行为语义</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{S}_{p a r t}=\\mathcal{F}_{P a S t a-R}\\left(f_{P a S t a}, f_{o}\\right)</script><p>其中，$\\mathcal{F}_{P a S t a-R}(\\cdot)$代表PaSta-R方法，$f_{o}$是物体的特征表示，$\\mathcal{S}_{p a r t}$是局部状态层面的动作评分。<em>注意，如果场景中人没有与物进行交互，比如”跳舞“这个动作，那么使用图像的ROI池化特征来表示$f_o$。如果场景中存在多个交互物体，则依次处理human-object pair$\\left(f_{P a S t a}, f_{o}^{(i)}\\right)$，并且声称各自独立的Activity2Vec Embedding</em>。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"./PaStaNet/fig3.png\" alt=\"\"></p>\n<p>上图为PaSta的识别与特征表示部分的框架图。</p>\n<p>识别部分主要为红色线条部分，特征表示部分主要为蓝色线条部分。</p>\n<h3 id=\"局部状态PaSta识别\"><a href=\"#局部状态PaSta识别\" class=\"headerlink\" title=\"局部状态PaSta识别\"></a>局部状态PaSta识别</h3><p>这部分的输入为$I, \\mathcal{B}_{p}, b_{o}$，输出为局部状态的视觉特征$f_{PaSta}^{V}$和识别结果$P_{PaSta}$。</p>\n<p>对于输入，$\\mathcal{B}_{p}, b_{o}$都是使用在COCO数据集上预训练的Faster R-CNN做特征提取：</p>\n<ul>\n<li>对于物体$b_o$，$b_o\\rightarrow Faster R-CNN \\rightarrow f_o$，如果图片内不存在与物体进行交互，则使用图像的特征，即$I\\rightarrow Faster R-CNN \\rightarrow f_c \\rightarrow f_o$</li>\n<li>对于人的身体的每一个部位（共10个）$b_{p}^{(i)}$，$b_{p}^{(i)} \\rightarrow Faster R-CNN \\rightarrow f_{p}^{(i)}$</li>\n</ul>\n<p>得到特征表示后，首先输入到一个被称为Part Relevance Predictor的结构中，去计算每一个部位的attention，这个PRP结构由全连接组成，最后激活为softmax函数，给每一个局部部位特征输出一个注意力权重：</p>\n<script type=\"math/tex; mode=display\">\na_{i}=\\mathcal{P}_{p a}\\left(f_{p}^{(i)}, f_{o}\\right)</script><p>其中$\\mathcal{P}_{p a}(\\cdot)$即是局部注意力预测器。<strong>在这里，我感觉这个注意力权重应该指的是某个身体部位与物体的相关性，比如，手跟茶杯很相关，而脚和苹果则不太相关。</strong>然后，将注意力权重与原始局部特征表示进行加权：</p>\n<script type=\"math/tex; mode=display\">\nf_{p}^{(i) \\star}=f_{p}^{(i)} \\times a_{i}</script><p>接下来进行局部状态PaSta的分类/识别，此时将$f_{p}^{(i) \\star}$与$f_o$进行concat操作之后，传入max池化层，以及两层512的全连接，最终获得PaSta的分类结果$\\mathcal{S}_{P a S t a}^{(i)}$。<strong>这里的$\\mathcal{S}$应该是logits，而$P_{PaSta}$表示概率。</strong></p>\n<p><em>注意，这里存在一个身体部位有多种状态的可能，比如头部可以同时进行”吃”和”看”的动作，因此是一个多标签分类任务。</em></p>\n<p>识别部分的交叉熵损失函数如下：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{L}_{P a S t a}=\\sum_{i}^{10}\\left(\\mathcal{L}_{P a S t a}^{(i)}+\\mathcal{L}_{a t t}^{(i)}\\right)</script><h3 id=\"Activity2Vec\"><a href=\"#Activity2Vec\" class=\"headerlink\" title=\"Activity2Vec\"></a>Activity2Vec</h3><p>这一部分的输入为局部状态的视觉特征$f_{PaSta}^{V}$、识别结果$P_{PaSta}$和PaSta的语言特征$f_{B e r t}^{(i, k)}$，输出为PaSta的最终特征表示$f_{PaSta}$。</p>\n<blockquote>\n<p>With PaStaNet, we convert a human instance into a vector consisting of PaSta representations. Activity2Vec extracts part-level semantic representation via PaSta recognition and combines its language representation. Since PaSta encodes common knowledge of activities, Activity2Vec works as a general feature extractor for both seen and unseen activities.</p>\n</blockquote>\n<p>Activity2Vec将一个人类实例转换为一个由PaSta表示组成的向量。通过局部状态识别提取局部层次的语义表示，并且与该局部状态的语言表示相结合。</p>\n<p>在这一环节的主要任务是将局部状态PaSta的语义知识嵌入到它的特征向量表示中去，那么，如何结合呢？</p>\n<p>对于图像特征，在上一部分已经获得，提取PaSta的分类结果前一层的隐状态即可，$\\color{red}{f_{\\text {PaSta}}^{V(i)} \\in \\mathbb{R}^{512}}$。</p>\n<p>对于语言特征，作者使用<strong>BERT-Base预训练模型</strong>先将数据集中的token预转换为$\\color{red}{f_{B e r t}^{(i, k)} \\in \\mathbb{R}^{2304}}$，并且在整个过程中保持不变。token指的是三元组&#60;part, verb, object&#62;，object来自目标检测。所有的token即$\\left\\{t_{p}^{(i, k)}, t_{v}^{(i, k)}, t_{o}^{(i, k)}\\right\\}_{k=1}^{n}$，$i$代表身体部位的数量，这里为10，$n$代表每一个部位具有的PaSta数量，其中的每个$t$都是768的向量长度。</p>\n<script type=\"math/tex; mode=display\">\nf_{B e r t}^{(i, k)}=\\mathcal{R}_{B e r t}\\left(t_{p}^{(i, k)}, t_{v}^{(i, k)}, t_{o}^{(i, k)}\\right)</script><script type=\"math/tex; mode=display\">\nf_{B e r t}^{(i)} \\in \\mathbb{R}^{2304 * n}</script><p>将部分的BERT表示与该部分的分类结果相乘，即PaSta的语言特征表示：</p>\n<script type=\"math/tex; mode=display\">\nf_{P a S t a}^{L(i)}=f_{B e r t}^{(i)} \\times P_{P a S t a}^{(i)}, \\text { where } P_{P a S t a}^{(i)}=\\operatorname{Sigmoid}\\left(\\mathcal{S}_{P a S t a}^{(i)}\\right) \\in \\mathbb{R}^{n}</script><script type=\"math/tex; mode=display\">\nP_{P a S t a}=\\left\\{P_{P a S t a}^{(i)}\\right\\}_{i=1}^{10}</script><script type=\"math/tex; mode=display\">\nf_{P a S t a}^{L(i)} \\in \\mathbb{R}^{2304 * n}</script><p><strong>最后</strong>，池化、resize语言特征$f_{P a S t a}^{L(i)}$后再与图像特征$f_{PaSta}^{V}$concat即获得最终的PaSta特征表示$f_{P a S t a}^{(i)} \\in \\mathbb{R}^{m}$。输出的$f_{\\text {PaSta}}=\\left\\{f_{\\text {PaSta}}^{(i)}\\right\\}_{i=1}^{10}$是局部级别的行为特征表示，可用于下游任务，像行为检测，标题生成等等。</p>\n<h3 id=\"PaSta-R\"><a href=\"#PaSta-R\" class=\"headerlink\" title=\"PaSta-R\"></a>PaSta-R</h3><p>这一部分主要是从局部状态的特征表示推断出图片中人的行为。其输入为特征表示$f_{PaSta}$，输出为动作评分$\\mathcal{S}$。</p>\n<blockquote>\n<p>A Part State Based Reasoning method (PaSta-R) is further presented. We construct a Hierarchical Activity Graph consisting of human instance and part semantic representations, and infer the activities by combining both instance and part level sub-graph states.</p>\n</blockquote>\n<p>作者构造了一个由人类实例和局部语义表示组成的层次行为图（Hierarchical Activity Graph），并结合实例和局部层次子图状态来推断行为。</p>\n<p><img src=\"./PaStaNet/fig4.png\" alt=\"\"></p>\n<p>HAG如上图中间所示，节点为局部的状态特征或者物体的特征，边分两种，第一种是body part与object的边，表示为$e_{p o}=\\left(v_{p}^{i}, v_{o}\\right) \\in \\mathcal{V}_{p} \\times \\mathcal{V}_{o}$，第二种是body part与body part的边，表示为$e_{p p}^{i j}=\\left(v_{p}^{i}, v_{p}^{j}\\right) \\in \\mathcal{V}_{p} \\times \\mathcal{V}_{p}$。<strong><em>说实话，边究竟是如何表示的，完全没有看懂-.-</em></strong>。</p>\n<p>作者的目标是解析HAG，然后推理出图像中的行为。即</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{S}_{p a r t}=\\mathcal{F}_{P a S t a-R}\\left(f_{P a S t a}, f_{o}\\right)</script><p>作者提出了三种结构和三种方式，如下图所示：</p>\n<p><img src=\"./PaStaNet/fig10.png\" alt=\"\"></p>\n<p>三种结构：</p>\n<ol>\n<li>Linear Combination，说白了就是一层全连接，激活为softmax；</li>\n<li>MLP，说白了就是两层1024单元全连接（使用非线性激活函数），最后一层激活为softmax；</li>\n<li>Graph Convolution Network，GCN提取全局图特征，然后接MLP输出分类结果。</li>\n</ol>\n<p>三种方式：</p>\n<ol>\n<li>上图(a)所示，将$f_{P a S t a}, f_{o}$直接concat然后输入后续网络；</li>\n<li>上图(b)所示，按身体部位逐步输入到LSTM网络，改造成序列模型。有两种输入方式，1乱序，2固定顺序（比如从头到脚），作者说固定顺序更好；</li>\n<li>上图(c)所示，将部位特征分层组合，例如：<ol>\n<li>在第一层将左手左上臂特征合并为左臂，左脚左大腿特征合并为左腿，……，然后传入全连接进一步提取特征；</li>\n<li>将头、胳膊等合并为上肢，臀、腿等合并为下肢，……，然后传入全连接进行进一步特征提取；</li>\n<li>上下肢合并为整体，然后传入全连接，再接后续网络。</li>\n</ol>\n</li>\n</ol>\n<p>如何得到最后的分类结果呢？作者提出两种方式：</p>\n<ol>\n<li>early fusion——前融合，将实例层次的语义特征表示$f_{inst}$与PaSta特征表示、物体特征表示结合后再做PaSta-R推理；</li>\n<li>late fusion——后融合，融合实例层次的分类结果和局部层次的分类结果，即$\\mathcal{S}=\\mathcal{S}_{i n s t}+\\mathcal{S}_{p a r t}$。作者说，实验下来，这种方式效果更好。</li>\n</ol>\n<p>最终，整个框架的交叉熵损失函数为：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{L}_{\\text {total}}=\\mathcal{L}_{\\text {PaSta}}+\\mathcal{L}_{\\text {cls}}^{\\text {PaSta}}+\\mathcal{L}_{\\text {cls}}^{\\text {inst}}</script><h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><p>监督学习中，PaStaNet在HICO完整数据集上提升了6.4(16%)mAP，在HICO one-shot数据集上提升了13.9mAP。</p>\n<p>迁移学习中，PaStanet在V-COCO数据集上提升了3.2mAP，在基于图像的AVA数据集上提升了4.2mAP，在HICO-DET数据集上提升了3.2mAP。</p>\n<h2 id=\"类比实验\"><a href=\"#类比实验\" class=\"headerlink\" title=\"类比实验\"></a>类比实验</h2><p>从MNIST数据集中采集0-9数字（28X28X1），组成（128X128X1）的图片，每个图片包含3-5个数字。将数字类比为身体的局部部位，将行为设置为图片中最大的两个数字之和。图片中所有数字的union box代表一个人。为了模仿任务的移动特征，数字随机分布在图像中，而且给图像加入了高斯噪声。</p>\n<p>最终实验结果（准确率）：</p>\n<ul>\n<li>端到端，10.0%</li>\n<li>前融合：43.7%</li>\n<li>后融合：<strong>44.2%</strong></li>\n<li>不融合：41.4%</li>\n</ul>\n<p><img src=\"./PaStaNet/fig5.png\" alt=\"\"></p>\n<h2 id=\"Image-based-Activity-Recognition\"><a href=\"#Image-based-Activity-Recognition\" class=\"headerlink\" title=\"Image-based Activity Recognition\"></a>Image-based Activity Recognition</h2><p><img src=\"./PaStaNet/table1.png\" alt=\"\"></p>\n<h2 id=\"Instance-based-Activity-Detection\"><a href=\"#Instance-based-Activity-Detection\" class=\"headerlink\" title=\"Instance-based Activity Detection\"></a>Instance-based Activity Detection</h2><p><img src=\"./PaStaNet/table2.png\" alt=\"\"></p>\n<h2 id=\"Transfer-Learning-with-Activity2Vec\"><a href=\"#Transfer-Learning-with-Activity2Vec\" class=\"headerlink\" title=\"Transfer Learning with Activity2Vec\"></a>Transfer Learning with Activity2Vec</h2><p><img src=\"./PaStaNet/table3.png\" alt=\"\"></p>\n<p><img src=\"./PaStaNet/table4.png\" alt=\"\"></p>\n<h2 id=\"可视化结果\"><a href=\"#可视化结果\" class=\"headerlink\" title=\"可视化结果\"></a>可视化结果</h2><p><img src=\"./PaStaNet/fig14.png\" alt=\"\"></p>\n<p>图中蓝、绿、红分别指示身体部位、局部行为、交互物体。作者发现他们的模型能够检测各种行为，包括与各种对象的交互。</p>\n<h1 id=\"mAP\"><a href=\"#mAP\" class=\"headerlink\" title=\"mAP\"></a>mAP</h1><p>mAP：mean Average Precision，平均的平均精度（两个平均）。先是类内求平均精确度，再是对所有类别再求平均精确度。</p>\n<p>目标检测任务中将目标的分类结果分成四类（正即是真，负即是假）：</p>\n<ol>\n<li>TP——True Positive，正识别为正；</li>\n<li>FP——False Positive，负识别为正；</li>\n<li>TN——True Negative，负识别为负；</li>\n<li>FN——False Negative，负识别为正</li>\n</ol>\n<p>准确率Precision——<strong>识别为正</strong>的数据中，真实为正的：</p>\n<script type=\"math/tex; mode=display\">\nP=\\frac{T P}{T P+F P}=\\frac{T P}{N_{\\text {detection}}}</script><p>召回率Recall——<strong>原始为正</strong>的数据中，识别为正的：</p>\n<script type=\"math/tex; mode=display\">\nR=\\frac{T P}{T P+F N}=\\frac{T P}{N_{g t}}</script><p>平均精度AP即是在一组召回率阈值[0, 1]中，根据召回率计算相应准确率，然后准确率取平均。比如设置11个等间隔召回率阈值[0, 0.2, …, 1]，那么AP的计算公式如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nA P=& \\frac{1}{11} \\sum_{r \\in\\{0,0.1, \\ldots, 1.0\\}} \\rho_{\\text {interp}}(r) \\\\\n& \\rho_{\\text {interp}}(r)=\\max _{\\hat{r}: \\hat{r} \\geqslant r}(\\hat{r})\n\\end{aligned}</script><p>实际上就是对于每个Recall值下的Precision，取所有比当前值大的Recall对应的Precision的最大值作为当前Recall值下的Precision。</p>\n<p>mAP是多个AP值的均值，AP衡量的是学出来的模型在每个类别上的好坏，mAP衡量的是学出的模型在所有类别上的好坏。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><blockquote>\n<p>In this paper, to make a step toward human activity knowledge engine, we construct PaStaNet to provide novel body part-level activity representation (PaSta). Meanwhile, a knowledge transformer Activity2Vec and a part-based reasoning method PaSta-R are proposed. PaStaNet brings in interpretability and new possibility for activity understanding. It can effectively bridge the semantic gap between pixels and activities. With PaStaNet, we signiﬁcantly boost the performance in supervised and transfer learning tasks, especially under few-shot circumstances. In the future, we plan to enrich our PaStaNet with spatio-temporal PaSta.</p>\n</blockquote>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><p><a href=\"https://blog.csdn.net/xiezongsheng1990/article/details/89608923?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1\" rel=\"external nofollow\" target=\"_blank\">目标检测测评指标——mAP</a></p>\n</li>\n<li><p><a href=\"http://blog.sina.com.cn/s/blog_9db078090102whzw.html\" rel=\"external nofollow\" target=\"_blank\">多标签图像分类任务的评价方法-mAP</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>这篇论文是上海交大<a href=\"http://mvig.sjtu.edu.cn/\" rel=\"external nofollow\" target=\"_blank\">卢策吾</a>老师团队下<a href=\"https://dirtyharrylyl.github.io/\" rel=\"external nofollow\" target=\"_blank\">李永露</a>博士在2020CVPR会议三连中中的其中一篇。方向为HOIs方向，即人物交互。</p>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"http://arxiv.org/abs/2004.00945\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/2004.00945</a></p>\n<p>作者开源的代码和数据集：<a href=\"http://hake-mvig.cn/\" rel=\"external nofollow\" target=\"_blank\">http://hake-mvig.cn/</a></p>\n<p>PaSta是Part State的缩写，它是<strong>细粒度动作语义标记</strong>(ﬁne-grained action semantic tokens)，是人类活动/行为的更精细的表达，比如一个人类的行为是开汽车，那么这个行为的part state就包括手握方向盘、脚踩油门等等，这种part state用三元组形式表示，比如：&#60;hand, hold, something&#62;。</p>\n<p>这篇论文主要有两个比较大的贡献：</p>\n<ol>\n<li>建立了一个大型知识库PaStaNet（其实是HAKE数据集），目前标注了700w+局部状态。</li>\n<li>设计了一个分层的动作识别模型（为什么分层呢？因为作者提到现有的基于图像的动作识别理解方法主要采取直接映射/端到端的方式，可能会遇到性能瓶颈。）<ol>\n<li>第一层是Activity2Vec模型，用来从原始图片中提取PaSta特征，PaSta是组成多种人类行为的通用表示，比如一个PaSta是hold，那么开汽车时有hold方向盘，吃苹果时有hold苹果，两种不同的行为共享同样的PaSta；</li>\n<li>第二层使用了PaSta-based Reasoning（PaSta-R，基于局部状态的推理）方法，用这种方法从第一层中识别的PaSta来推测图片中的人类行为活动。</li>\n</ol>\n</li>\n</ol>\n<p>下文中以下概念术语等同：</p>\n<ul>\n<li>PaStaNet——数据集</li>\n<li>人类行为理解——动作识别</li>\n<li>PaSta——局部状态</li>\n</ul>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><p>在大规模的基准中，基于<strong>实例层次的语义（instance-level semantics）</strong>使用one-stage从像素理解人类行为存在性能瓶颈，主要有以下几个原因：</p>\n<ol>\n<li><p>long-tail data distribution，长尾数据分布（少数类别有大部分数据，而多数类别只有小部分数据）</p>\n<p><img src=\"./PaStaNet/Long_tailed_distribution.png\" alt=\"\"></p>\n</li>\n<li><p>complex visual patterns，复杂的视觉模式</p>\n</li>\n</ol>\n<p>作者认为(argue that)在人类局部的语义层次上进行感知是一个非常有前景的方向，这种方式之前被忽略了。</p>\n<p><strong>作者的核心思想是：人类动作由细粒度的原子主体部分状态（PaSta）组成。</strong></p>\n<blockquote>\n<p>Our core idea is that human instance actions are composed of ﬁne-grained atomic body part states.</p>\n</blockquote>\n<p><img src=\"./PaStaNet/fig1.png\" alt=\"\"></p>\n<p>先识别PaSta再推理行为有什么好处呢？</p>\n<ol>\n<li><p>与简化理论(reductionism)有强烈的直接关系</p>\n<blockquote>\n<p>This lies in strong relationships with reductionism.</p>\n</blockquote>\n</li>\n<li><p>可以帮助我们选择有区别的部分，忽略不相关的部分</p>\n<blockquote>\n<p>the part-level path can help us to pick up discriminative parts and disregard irrelevant ones.</p>\n</blockquote>\n</li>\n<li><p>从人体局部编码知识是实现人类活动知识引擎的关键步骤</p>\n<blockquote>\n<p>encoding knowledge from human parts is a crucial step toward human activity knowledge engine.</p>\n</blockquote>\n</li>\n<li><p>Reusability and Transferability——可重用性和可转移性，多个行为的局部状态存在共享，比如一个PaSta是hold，那么开汽车时有hold方向盘，吃苹果时有hold苹果，两种不同的行为共享同样的PaSta。因此，我们可以用更少的PaSta来描述和区分大量的行为。对于few-shot学习，可重用性可以极大地缓解其学习困难。</p>\n<blockquote>\n<p>PaSta are basic components of actions, their relationship can be in analogy with the amino acid and protein, letter and word, etc. Hence, PaSta are reusable, e.g., 〈 hand, hold, something 〉 is shared by various actions like “hold horse” and “eat apple”. Therefore, we get the capacity to describe and differentiate plenty of activities with a much smaller set of PaSta, i.e. one-time labeling and transferability. For fewshot learning, reusability can greatly alleviate its learning difﬁculty. Thus our approach shows signiﬁcant improvements, e.g. we boost 13.9 mAP on one-shot sets of HICO</p>\n</blockquote>\n</li>\n<li><p>Interpretability——可解释性，当模型预测一个人在做什么时，我们很容易知道原因:它的身体的各个部分在做什么。</p>\n<blockquote>\n<p>we obtain not only more powerful activity representations, but also better interpretation. When the model predicts what a person is doing, we can easily know the reasons: what the body parts are doing.</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"PaStaNet数据集\"><a href=\"#PaStaNet数据集\" class=\"headerlink\" title=\"PaStaNet数据集\"></a>PaStaNet数据集</h2><p>该数据集目前已经标注了11.8w张图片，包括28.5w个人物，25w个交互的实体对象（比如球之类的），72.4万个行为，以及700w个人类局部状态。</p>\n<p>该数据集目前有156个行为分类，76个PaSta分类。</p>\n<p>广泛的分析证明，一般来说，PaStaNet可以覆盖大部分的局部级知识，可以很好的概括大部分情况。</p>\n<p><img src=\"./PaStaNet/fig6.png\" alt=\"\"></p>\n<p>下图为数据集中的行为和交互物体类别。</p>\n<p><img src=\"./PaStaNet/table6.png\" alt=\"\"></p>\n<p>下图为数据集中的局部状态PaSta类别。</p>\n<p><img src=\"./PaStaNet/table7.png\" alt=\"\"></p>\n<h3 id=\"PaSta的定义\"><a href=\"#PaSta的定义\" class=\"headerlink\" title=\"PaSta的定义\"></a>PaSta的定义</h3><p>将人体解耦成十个部分：head, two upper arms, two hands, hip, two thighs, two feet，即</p>\n<ol>\n<li>头</li>\n<li>左臂</li>\n<li>右臂</li>\n<li>左手</li>\n<li>右手</li>\n<li>臀部</li>\n<li>左腿</li>\n<li>右腿</li>\n<li>左脚</li>\n<li>右脚</li>\n</ol>\n<p>每一个PaSta表示目标局部部分的表示，比如hand可以是hold something, push something；head可以是watch something, eat something。注意，当一个人同时有多个行为动作，他的某个局部身体部位可以有多个PaSta。</p>\n<h3 id=\"数据收集\"><a href=\"#数据收集\" class=\"headerlink\" title=\"数据收集\"></a>数据收集</h3><p>两种方式：</p>\n<ol>\n<li>通过众包收集以人为中心的行为图像(3万张图片，具有粗糙的活动标签)；</li>\n<li>现有的设计良好的数据集(18.5万张)。</li>\n</ol>\n<p>其中的数据围绕丰富的语义本体论(semantic ontology)、多样性和行为的可变性构建。最终，收集了超过20万张的不同行为类别的图片。</p>\n<h3 id=\"行为标签\"><a href=\"#行为标签\" class=\"headerlink\" title=\"行为标签\"></a>行为标签</h3><p>根据人类最常见的日常活动，与人和物的互动。从11.8万张图片中选择了156种行为，包括人与物体的互动和身体动作（包含bounding boxes）。</p>\n<h3 id=\"身体局部的盒子\"><a href=\"#身体局部的盒子\" class=\"headerlink\" title=\"身体局部的盒子\"></a>身体局部的盒子</h3><blockquote>\n<p>Estimation errors are addressed manually to ensure high-quality annotation. Each part box is centered with a joint, and the box size is pre-deﬁned by scaling the distance between the joints of the neck and pelvis. A joint with conﬁdence higher than 0.7 will be seen as visible. When not all joints can be detected, we use body knowledge-based rules. That is, if the neck or pelvis is invisible, we conﬁgure the part boxes according to other visible joint groups (head, main body, arms, legs), e.g., if only the upper body is visible, we set the size of the hand box to twice the pupil distance.</p>\n</blockquote>\n<h3 id=\"局部状态PaSta标注\"><a href=\"#局部状态PaSta标注\" class=\"headerlink\" title=\"局部状态PaSta标注\"></a>局部状态PaSta标注</h3><p>通过众包方式进行标注，共收到224159条标注上传。</p>\n<p>过程如下：</p>\n<ol>\n<li>基于156种行为的动词，从WordNet选取200个PaSta动词。如果某个局部部位没有可以的状态，则描述为”no_action”；</li>\n<li>为了找到最通用的PaSta（可以作为可转移的行为知识），邀请了来自不同背景的150名注释者来标注156个行为的1w张图片；</li>\n<li>基于它们的注释，使用规范化的<strong>点对点互信息(Normalized Point-wise Mutual Information，NPMI，<em>Kenneth Ward Church and Patrick Hanks. Word association norms, mutual information, and lexicography. In Computational linguistics, 1990.</em>)</strong>来计算行为和PaSta之间的共生/共现关系，最后选择76个具有最高NPMI值的候选局部状态为PaSta集合；</li>\n<li>以之前的1w张打了标签的图片为种子，自动生成其余图片的初始PaSta标签，然后另外210名注释者仅需要去检查这些标注即可；</li>\n<li>考虑到一个人可能有多个动作，对于每个动作，分别标注其对应的10个PaSta。然后把所有动作的PaSta组合在一起；</li>\n<li>为了确保质量，每幅图像都将被标注两次，并由自动程序和主管进行检查。</li>\n</ol>\n<p><img src=\"./PaStaNet/fig2.png\" alt=\"\"></p>\n<p><strong>疑问：为什么ride bicycle与head look at的共现如此之低呢？</strong></p>\n<h3 id=\"行为解析树\"><a href=\"#行为解析树\" class=\"headerlink\" title=\"行为解析树\"></a>行为解析树</h3><p>为了说明PaSta和行为之间的关系，作者使用它们的统计相关性来构建一个图：行为是根节点，PaSta是子节点，边是共现。</p>\n<blockquote>\n<p>To illustrate the relationships between PaSta and activities, we use their statistical correlations to construct a graph (Fig. 2): activities are root nodes, PaSta are son nodes and edges are co-occurrence.</p>\n</blockquote>\n<p>PaStaNet可以为实例级和局部级提供丰富的行为知识，并帮助构建大型行为解析树。</p>\n<blockquote>\n<p>PaStaNet can provide abundant activity knowledge for both instance and part levels and help construct a large-scale activity parsing tree</p>\n</blockquote>\n<p><img src=\"./PaStaNet/fig8.png\" alt=\"\"></p>\n<p>作者将解析树表示为行为和PaSta的共现矩阵(看起来极其稀疏)。</p>\n<p><img src=\"./PaStaNet/fig9.png\" alt=\"\"></p>\n<h2 id=\"分层行为理解模型\"><a href=\"#分层行为理解模型\" class=\"headerlink\" title=\"分层行为理解模型\"></a>分层行为理解模型</h2><p>这一部分数学符号很多，而且似乎故意把符号设计的复杂，导致阅读理解起来有些不顺畅。</p>\n<p>对于行为的识别，有两种模型：</p>\n<ol>\n<li><p>传统模式，采用直接映射。</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{S}_{i n s t}=\\mathcal{F}_{i n s t}\\left(I, b_{h}, \\mathcal{B}_{o}\\right)</script><p>其中，$I$表示图像输入，$b_h$是人的box，$\\mathcal{B}_{o}=\\left\\{b_{o}^{i}\\right\\}_{i=1}^{m}$是与人交互的物体的box，假设有$m$个物体。$\\mathcal{S}_{i n s t}$代表实体级别的动作评分（评估结果）。</p>\n</li>\n<li><p>作者提出的PaStaNet模式，利用通用的局部知识，分成两步：</p>\n<ol>\n<li><p>PaSta局部状态识别和特征提取（其实是识别层之前的隐特征）</p>\n<script type=\"math/tex; mode=display\">\nf_{P a S t a}=\\mathcal{R}_{A 2 V}\\left(I, \\mathcal{B}_{p}, b_{o}\\right) = \\left\\{f_{P a S t a}^{(i)}\\right\\}_{i=1}^{10}</script><p>其中，$\\mathcal{B}_{p}=\\left\\{b_{p}^{(i)}\\right\\}_{i}^{10}$是人的局部部位的box，使用<em>Pairwise body-part attention for recognizing human-object interactions. In ECCV, 2018</em>自动生成。$\\mathcal{R}_{A 2 V}(\\cdot)$表示Activity2Vec模型，用于提取PaSta的特征表示，</p>\n</li>\n<li><p>PaSta-Based推理（PaSta-R），从局部状态推理行为语义</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{S}_{p a r t}=\\mathcal{F}_{P a S t a-R}\\left(f_{P a S t a}, f_{o}\\right)</script><p>其中，$\\mathcal{F}_{P a S t a-R}(\\cdot)$代表PaSta-R方法，$f_{o}$是物体的特征表示，$\\mathcal{S}_{p a r t}$是局部状态层面的动作评分。<em>注意，如果场景中人没有与物进行交互，比如”跳舞“这个动作，那么使用图像的ROI池化特征来表示$f_o$。如果场景中存在多个交互物体，则依次处理human-object pair$\\left(f_{P a S t a}, f_{o}^{(i)}\\right)$，并且声称各自独立的Activity2Vec Embedding</em>。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"./PaStaNet/fig3.png\" alt=\"\"></p>\n<p>上图为PaSta的识别与特征表示部分的框架图。</p>\n<p>识别部分主要为红色线条部分，特征表示部分主要为蓝色线条部分。</p>\n<h3 id=\"局部状态PaSta识别\"><a href=\"#局部状态PaSta识别\" class=\"headerlink\" title=\"局部状态PaSta识别\"></a>局部状态PaSta识别</h3><p>这部分的输入为$I, \\mathcal{B}_{p}, b_{o}$，输出为局部状态的视觉特征$f_{PaSta}^{V}$和识别结果$P_{PaSta}$。</p>\n<p>对于输入，$\\mathcal{B}_{p}, b_{o}$都是使用在COCO数据集上预训练的Faster R-CNN做特征提取：</p>\n<ul>\n<li>对于物体$b_o$，$b_o\\rightarrow Faster R-CNN \\rightarrow f_o$，如果图片内不存在与物体进行交互，则使用图像的特征，即$I\\rightarrow Faster R-CNN \\rightarrow f_c \\rightarrow f_o$</li>\n<li>对于人的身体的每一个部位（共10个）$b_{p}^{(i)}$，$b_{p}^{(i)} \\rightarrow Faster R-CNN \\rightarrow f_{p}^{(i)}$</li>\n</ul>\n<p>得到特征表示后，首先输入到一个被称为Part Relevance Predictor的结构中，去计算每一个部位的attention，这个PRP结构由全连接组成，最后激活为softmax函数，给每一个局部部位特征输出一个注意力权重：</p>\n<script type=\"math/tex; mode=display\">\na_{i}=\\mathcal{P}_{p a}\\left(f_{p}^{(i)}, f_{o}\\right)</script><p>其中$\\mathcal{P}_{p a}(\\cdot)$即是局部注意力预测器。<strong>在这里，我感觉这个注意力权重应该指的是某个身体部位与物体的相关性，比如，手跟茶杯很相关，而脚和苹果则不太相关。</strong>然后，将注意力权重与原始局部特征表示进行加权：</p>\n<script type=\"math/tex; mode=display\">\nf_{p}^{(i) \\star}=f_{p}^{(i)} \\times a_{i}</script><p>接下来进行局部状态PaSta的分类/识别，此时将$f_{p}^{(i) \\star}$与$f_o$进行concat操作之后，传入max池化层，以及两层512的全连接，最终获得PaSta的分类结果$\\mathcal{S}_{P a S t a}^{(i)}$。<strong>这里的$\\mathcal{S}$应该是logits，而$P_{PaSta}$表示概率。</strong></p>\n<p><em>注意，这里存在一个身体部位有多种状态的可能，比如头部可以同时进行”吃”和”看”的动作，因此是一个多标签分类任务。</em></p>\n<p>识别部分的交叉熵损失函数如下：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{L}_{P a S t a}=\\sum_{i}^{10}\\left(\\mathcal{L}_{P a S t a}^{(i)}+\\mathcal{L}_{a t t}^{(i)}\\right)</script><h3 id=\"Activity2Vec\"><a href=\"#Activity2Vec\" class=\"headerlink\" title=\"Activity2Vec\"></a>Activity2Vec</h3><p>这一部分的输入为局部状态的视觉特征$f_{PaSta}^{V}$、识别结果$P_{PaSta}$和PaSta的语言特征$f_{B e r t}^{(i, k)}$，输出为PaSta的最终特征表示$f_{PaSta}$。</p>\n<blockquote>\n<p>With PaStaNet, we convert a human instance into a vector consisting of PaSta representations. Activity2Vec extracts part-level semantic representation via PaSta recognition and combines its language representation. Since PaSta encodes common knowledge of activities, Activity2Vec works as a general feature extractor for both seen and unseen activities.</p>\n</blockquote>\n<p>Activity2Vec将一个人类实例转换为一个由PaSta表示组成的向量。通过局部状态识别提取局部层次的语义表示，并且与该局部状态的语言表示相结合。</p>\n<p>在这一环节的主要任务是将局部状态PaSta的语义知识嵌入到它的特征向量表示中去，那么，如何结合呢？</p>\n<p>对于图像特征，在上一部分已经获得，提取PaSta的分类结果前一层的隐状态即可，$\\color{red}{f_{\\text {PaSta}}^{V(i)} \\in \\mathbb{R}^{512}}$。</p>\n<p>对于语言特征，作者使用<strong>BERT-Base预训练模型</strong>先将数据集中的token预转换为$\\color{red}{f_{B e r t}^{(i, k)} \\in \\mathbb{R}^{2304}}$，并且在整个过程中保持不变。token指的是三元组&#60;part, verb, object&#62;，object来自目标检测。所有的token即$\\left\\{t_{p}^{(i, k)}, t_{v}^{(i, k)}, t_{o}^{(i, k)}\\right\\}_{k=1}^{n}$，$i$代表身体部位的数量，这里为10，$n$代表每一个部位具有的PaSta数量，其中的每个$t$都是768的向量长度。</p>\n<script type=\"math/tex; mode=display\">\nf_{B e r t}^{(i, k)}=\\mathcal{R}_{B e r t}\\left(t_{p}^{(i, k)}, t_{v}^{(i, k)}, t_{o}^{(i, k)}\\right)</script><script type=\"math/tex; mode=display\">\nf_{B e r t}^{(i)} \\in \\mathbb{R}^{2304 * n}</script><p>将部分的BERT表示与该部分的分类结果相乘，即PaSta的语言特征表示：</p>\n<script type=\"math/tex; mode=display\">\nf_{P a S t a}^{L(i)}=f_{B e r t}^{(i)} \\times P_{P a S t a}^{(i)}, \\text { where } P_{P a S t a}^{(i)}=\\operatorname{Sigmoid}\\left(\\mathcal{S}_{P a S t a}^{(i)}\\right) \\in \\mathbb{R}^{n}</script><script type=\"math/tex; mode=display\">\nP_{P a S t a}=\\left\\{P_{P a S t a}^{(i)}\\right\\}_{i=1}^{10}</script><script type=\"math/tex; mode=display\">\nf_{P a S t a}^{L(i)} \\in \\mathbb{R}^{2304 * n}</script><p><strong>最后</strong>，池化、resize语言特征$f_{P a S t a}^{L(i)}$后再与图像特征$f_{PaSta}^{V}$concat即获得最终的PaSta特征表示$f_{P a S t a}^{(i)} \\in \\mathbb{R}^{m}$。输出的$f_{\\text {PaSta}}=\\left\\{f_{\\text {PaSta}}^{(i)}\\right\\}_{i=1}^{10}$是局部级别的行为特征表示，可用于下游任务，像行为检测，标题生成等等。</p>\n<h3 id=\"PaSta-R\"><a href=\"#PaSta-R\" class=\"headerlink\" title=\"PaSta-R\"></a>PaSta-R</h3><p>这一部分主要是从局部状态的特征表示推断出图片中人的行为。其输入为特征表示$f_{PaSta}$，输出为动作评分$\\mathcal{S}$。</p>\n<blockquote>\n<p>A Part State Based Reasoning method (PaSta-R) is further presented. We construct a Hierarchical Activity Graph consisting of human instance and part semantic representations, and infer the activities by combining both instance and part level sub-graph states.</p>\n</blockquote>\n<p>作者构造了一个由人类实例和局部语义表示组成的层次行为图（Hierarchical Activity Graph），并结合实例和局部层次子图状态来推断行为。</p>\n<p><img src=\"./PaStaNet/fig4.png\" alt=\"\"></p>\n<p>HAG如上图中间所示，节点为局部的状态特征或者物体的特征，边分两种，第一种是body part与object的边，表示为$e_{p o}=\\left(v_{p}^{i}, v_{o}\\right) \\in \\mathcal{V}_{p} \\times \\mathcal{V}_{o}$，第二种是body part与body part的边，表示为$e_{p p}^{i j}=\\left(v_{p}^{i}, v_{p}^{j}\\right) \\in \\mathcal{V}_{p} \\times \\mathcal{V}_{p}$。<strong><em>说实话，边究竟是如何表示的，完全没有看懂-.-</em></strong>。</p>\n<p>作者的目标是解析HAG，然后推理出图像中的行为。即</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{S}_{p a r t}=\\mathcal{F}_{P a S t a-R}\\left(f_{P a S t a}, f_{o}\\right)</script><p>作者提出了三种结构和三种方式，如下图所示：</p>\n<p><img src=\"./PaStaNet/fig10.png\" alt=\"\"></p>\n<p>三种结构：</p>\n<ol>\n<li>Linear Combination，说白了就是一层全连接，激活为softmax；</li>\n<li>MLP，说白了就是两层1024单元全连接（使用非线性激活函数），最后一层激活为softmax；</li>\n<li>Graph Convolution Network，GCN提取全局图特征，然后接MLP输出分类结果。</li>\n</ol>\n<p>三种方式：</p>\n<ol>\n<li>上图(a)所示，将$f_{P a S t a}, f_{o}$直接concat然后输入后续网络；</li>\n<li>上图(b)所示，按身体部位逐步输入到LSTM网络，改造成序列模型。有两种输入方式，1乱序，2固定顺序（比如从头到脚），作者说固定顺序更好；</li>\n<li>上图(c)所示，将部位特征分层组合，例如：<ol>\n<li>在第一层将左手左上臂特征合并为左臂，左脚左大腿特征合并为左腿，……，然后传入全连接进一步提取特征；</li>\n<li>将头、胳膊等合并为上肢，臀、腿等合并为下肢，……，然后传入全连接进行进一步特征提取；</li>\n<li>上下肢合并为整体，然后传入全连接，再接后续网络。</li>\n</ol>\n</li>\n</ol>\n<p>如何得到最后的分类结果呢？作者提出两种方式：</p>\n<ol>\n<li>early fusion——前融合，将实例层次的语义特征表示$f_{inst}$与PaSta特征表示、物体特征表示结合后再做PaSta-R推理；</li>\n<li>late fusion——后融合，融合实例层次的分类结果和局部层次的分类结果，即$\\mathcal{S}=\\mathcal{S}_{i n s t}+\\mathcal{S}_{p a r t}$。作者说，实验下来，这种方式效果更好。</li>\n</ol>\n<p>最终，整个框架的交叉熵损失函数为：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{L}_{\\text {total}}=\\mathcal{L}_{\\text {PaSta}}+\\mathcal{L}_{\\text {cls}}^{\\text {PaSta}}+\\mathcal{L}_{\\text {cls}}^{\\text {inst}}</script><h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><p>监督学习中，PaStaNet在HICO完整数据集上提升了6.4(16%)mAP，在HICO one-shot数据集上提升了13.9mAP。</p>\n<p>迁移学习中，PaStanet在V-COCO数据集上提升了3.2mAP，在基于图像的AVA数据集上提升了4.2mAP，在HICO-DET数据集上提升了3.2mAP。</p>\n<h2 id=\"类比实验\"><a href=\"#类比实验\" class=\"headerlink\" title=\"类比实验\"></a>类比实验</h2><p>从MNIST数据集中采集0-9数字（28X28X1），组成（128X128X1）的图片，每个图片包含3-5个数字。将数字类比为身体的局部部位，将行为设置为图片中最大的两个数字之和。图片中所有数字的union box代表一个人。为了模仿任务的移动特征，数字随机分布在图像中，而且给图像加入了高斯噪声。</p>\n<p>最终实验结果（准确率）：</p>\n<ul>\n<li>端到端，10.0%</li>\n<li>前融合：43.7%</li>\n<li>后融合：<strong>44.2%</strong></li>\n<li>不融合：41.4%</li>\n</ul>\n<p><img src=\"./PaStaNet/fig5.png\" alt=\"\"></p>\n<h2 id=\"Image-based-Activity-Recognition\"><a href=\"#Image-based-Activity-Recognition\" class=\"headerlink\" title=\"Image-based Activity Recognition\"></a>Image-based Activity Recognition</h2><p><img src=\"./PaStaNet/table1.png\" alt=\"\"></p>\n<h2 id=\"Instance-based-Activity-Detection\"><a href=\"#Instance-based-Activity-Detection\" class=\"headerlink\" title=\"Instance-based Activity Detection\"></a>Instance-based Activity Detection</h2><p><img src=\"./PaStaNet/table2.png\" alt=\"\"></p>\n<h2 id=\"Transfer-Learning-with-Activity2Vec\"><a href=\"#Transfer-Learning-with-Activity2Vec\" class=\"headerlink\" title=\"Transfer Learning with Activity2Vec\"></a>Transfer Learning with Activity2Vec</h2><p><img src=\"./PaStaNet/table3.png\" alt=\"\"></p>\n<p><img src=\"./PaStaNet/table4.png\" alt=\"\"></p>\n<h2 id=\"可视化结果\"><a href=\"#可视化结果\" class=\"headerlink\" title=\"可视化结果\"></a>可视化结果</h2><p><img src=\"./PaStaNet/fig14.png\" alt=\"\"></p>\n<p>图中蓝、绿、红分别指示身体部位、局部行为、交互物体。作者发现他们的模型能够检测各种行为，包括与各种对象的交互。</p>\n<h1 id=\"mAP\"><a href=\"#mAP\" class=\"headerlink\" title=\"mAP\"></a>mAP</h1><p>mAP：mean Average Precision，平均的平均精度（两个平均）。先是类内求平均精确度，再是对所有类别再求平均精确度。</p>\n<p>目标检测任务中将目标的分类结果分成四类（正即是真，负即是假）：</p>\n<ol>\n<li>TP——True Positive，正识别为正；</li>\n<li>FP——False Positive，负识别为正；</li>\n<li>TN——True Negative，负识别为负；</li>\n<li>FN——False Negative，负识别为正</li>\n</ol>\n<p>准确率Precision——<strong>识别为正</strong>的数据中，真实为正的：</p>\n<script type=\"math/tex; mode=display\">\nP=\\frac{T P}{T P+F P}=\\frac{T P}{N_{\\text {detection}}}</script><p>召回率Recall——<strong>原始为正</strong>的数据中，识别为正的：</p>\n<script type=\"math/tex; mode=display\">\nR=\\frac{T P}{T P+F N}=\\frac{T P}{N_{g t}}</script><p>平均精度AP即是在一组召回率阈值[0, 1]中，根据召回率计算相应准确率，然后准确率取平均。比如设置11个等间隔召回率阈值[0, 0.2, …, 1]，那么AP的计算公式如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nA P=& \\frac{1}{11} \\sum_{r \\in\\{0,0.1, \\ldots, 1.0\\}} \\rho_{\\text {interp}}(r) \\\\\n& \\rho_{\\text {interp}}(r)=\\max _{\\hat{r}: \\hat{r} \\geqslant r}(\\hat{r})\n\\end{aligned}</script><p>实际上就是对于每个Recall值下的Precision，取所有比当前值大的Recall对应的Precision的最大值作为当前Recall值下的Precision。</p>\n<p>mAP是多个AP值的均值，AP衡量的是学出来的模型在每个类别上的好坏，mAP衡量的是学出的模型在所有类别上的好坏。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><blockquote>\n<p>In this paper, to make a step toward human activity knowledge engine, we construct PaStaNet to provide novel body part-level activity representation (PaSta). Meanwhile, a knowledge transformer Activity2Vec and a part-based reasoning method PaSta-R are proposed. PaStaNet brings in interpretability and new possibility for activity understanding. It can effectively bridge the semantic gap between pixels and activities. With PaStaNet, we signiﬁcantly boost the performance in supervised and transfer learning tasks, especially under few-shot circumstances. In the future, we plan to enrich our PaStaNet with spatio-temporal PaSta.</p>\n</blockquote>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ol>\n<li><p><a href=\"https://blog.csdn.net/xiezongsheng1990/article/details/89608923?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1\" rel=\"external nofollow\" target=\"_blank\">目标检测测评指标——mAP</a></p>\n</li>\n<li><p><a href=\"http://blog.sina.com.cn/s/blog_9db078090102whzw.html\" rel=\"external nofollow\" target=\"_blank\">多标签图像分类任务的评价方法-mAP</a></p>\n</li>\n</ol>"},{"title":"Prioritized Experience Replay","copyright":true,"mathjax":true,"top":1,"date":"2019-05-22T00:54:44.000Z","keywords":null,"description":null,"_content":"\n这篇论文介绍了优先经验回放机制，它可以使学习过程更高效。\n\n推荐：\n\n- 实用技巧\n- 通俗易懂\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1511.05952.pdf](https://arxiv.org/pdf/1511.05952.pdf)\n\n之前重用经验（experience，transition转换五元组$\\lt s,a,r,s',done \\ or \\ \\gamma\\gt$都是从经验池中**均匀采样**，忽略了经验的重要程度，文中提到的优先经验回放框架按经验重要性增大其被采样到的概率，希望越重要的经验使用次数越多，从而增加学习效率。\n\n文中应用算法：DQN\n\n效果：相比传统经验池机制，Atari 49游戏中41胜，8负\n\n# 文中精要\n\n> Online reinforcement learning (RL) agents incrementally update their parameters (of the policy, value function or model) while they observe a stream of experience. In their simplest form, they discard incoming data immediately, after a single update. Two issues with this are (a) strongly correlated updates that break the i.i.d. assumption of many popular stochastic gradient-based algorithms, and (b) the rapid forgetting of possibly rare experiences that would be useful later on. \n>Experience replay  addresses both of these issues: with experience stored in a replay memory, it becomes possible to break the temporal correlations by mixing more and less recent experience for the updates, and rare experience will be used for more than just a single update.\n\n指出On-policy一般使用一个episode的数据进行参数更新，且数据用完即丢，这样做有两个缺点：\n\n- 数据（状态）相互关联，数据不具有独立同分布($i.i.d$)的性质，但许多流行的随机梯度算法往往有关于数据独立同分布的假设\n- 对罕见的（稀疏的）经验快速遗忘，忽略了这些罕见经验可能多次更新更有用的作用\n\n**经验池机制解决了上述两个问题**，通过混合近期经验打破它们关于时间的关联性，并从经验池中采样经验学习多次。\n\n经验池机制的优势：\n\n- 稳定了DQN值函数的训练\n- 一般情况下，经验回放可以减少训练所需的经验数量，但是需要加大计算量，消耗更多的内存，但是这往往比智能体与环境进行交互来得更方便、容易\n\n>In particular, we propose to more frequently replay transitions with high expected learning progress, s measured by the magnitude of their temporal-difference (TD) error. This prioritization can lead o a loss of diversity, which we alleviate with stochastic prioritization, and introduce bias, which e correct with importance sampling. \n\n文中根据TD-error设置优先经验回放的频率，这可能会引起两个问题：\n\n- 丢失样本多样性\n- 引入偏差\n\n分别解决方案：\n\n- 随机优先级 stochastic prioritization\n- 重要性采样\n\n>The central component of prioritized replay is the criterion by which the importance of each transition is measured. One idealised criterion would be the amount the RL agent can learn from a transition in its current state (expected learning progress). While this measure is not directly accessible,  reasonable proxy is the magnitude of a transition’s TD error $\\delta$ indicates how ‘surprising’  or unexpected the transition is: specifically, how far the value is from its next-step bootstrap estimate.\n\n优先经验回放的核心部分是如何衡量样本的重要性，并根据其重要性进行回放。\n\n最直观的衡量标准是从经验样本中可以学习的量，但是这个量不可知、不可得，于是使用TD-error $\\delta$作为这个量的替代品以衡量样本重要性。 \n\n>New transitions arrive without a known TD-error, so we put them at maximal priority in order to guarantee that all experience is seen at least once.  \n\n新的经验被存入经验池时不需计算TD-error，直接将其设置为当前经验池中最大的TD-error，保证其至少被抽中一次。\n\n---\n\n既然使用TD-error作为衡量可学习的度量，那么完全可以用贪婪的方式，选取TD-error最大的几个进行学习，但这会有几个问题：\n\n1. 由于只有在经验被重放**之后**，这个经验的TD-error才被更新，导致初始TD-error比较小的经验长时间不被使用，甚至永远不被使用。\n2. 贪婪策略聚焦于一小部分TD-error比较高的经验，当使用值函数近似时，这些经验的TD-error减小速度很慢，导致这些经验被高频重复使用，致使样本缺乏多样性而过拟合。\n\n文中提到使用**随机采样方法 stochastic sampling method**在贪婪策略与均匀采样之间“差值”来解决上述问题，其实它是一个在样本使用上的trade-off，由超参数$\\alpha$控制\n\n使用优先经验回放还有一个问题是改变了状态的分布，我们知道DQN中引入经验池是为了解决数据相关性，使数据（尽量）独立同分布的问题。但是使用优先经验回放又改变了状态的分布，这样势必会引入偏差bias，对此，文中使用**偏差退火——重要性采样结合退火因子**，来消除引入的偏差。\n\n## 随机采样方法\n\n$$\nP(i)=\\frac{p^{\\alpha}_{i}}{\\sum_{k}p^{\\alpha}_{k}}\n$$\n\n$\\alpha$超参数控制采样在uniform和greedy的偏好，是一个trade-off因子：\n\n- $\\alpha=0$，均匀采样\n- $\\alpha=1$，贪婪策略采样\n- $\\alpha \\in [0,1]$，文中没有明说$\\alpha$的取值范围\n- 引入$\\alpha$不改变优先级的单调性，只是适当调整高、低TD-error经验的优先级\n\n根据优先级$p_{i}$的设定可以将优先经验池的设计分为两种：\n\n- 直接的，基于比例的，proportional prioritization\n- 间接的，基于排名的，rank-based prioritization\n\n### Proportional Prioritization\n\n$$\np_{i}=\\left | \\delta_{i} \\right | + \\epsilon\n$$\n\n- $\\delta$表示TD-error\n- $\\epsilon$是一个小的正常数，防止TD-error为0的经验永远不被重放。\n\n### Rank-based Prioritization\n\n$$\np_{i}=\\frac{1}{rank(i)}\n$$\n\n- $rank(i)$是经验根据$\\left | \\delta_{i} \\right |$大小排序的排名\n- $P$为指数$\\alpha$的幂律分布power-law distribution\n- 这种方式更具鲁棒性，因为其对异常点不敏感，主要是因为异常点的TD-error过大或过小对rank值没有太大影响\n\n优点：\n\n- 其重尾性、厚尾性、heavy-tail property保证采样多样性\n- 分层采样使mini-batch的梯度稳定\n\n缺点：\n\n- 当在稀疏奖励场景想要使用TD-error分布结构时，会造成性能下降\n\n### 比较\n\n根据文中实验，两种方式效果基本相同，但不同场景可能一个效果很好，一个效果一般般。作者**猜想**效果相同的原因可能是因为对奖励和TD-error大量使用clip操作，消除了异常值，作者本以为Rank-based更具鲁棒性的。\n\n> Overhead is similar to rank-based prioritization.\n\n两者开销相同。\n\n## 偏差退火 Annealing The Bias\n\n我觉得应该译为消除偏差。\n\n引入重要性采样、引入退火因子$\\beta$消除偏差。将$w_{i}$除以$max_{i}w_{i}$向下缩放（减小）梯度更新幅度，稳定算法\n$$\nw_{i}=\\left ( \\frac{1}{N} \\cdot \\frac{1}{P(i)} \\right )^{\\beta}\n$$\n\n- $\\beta=0$，完全不用重要性采样\n- $\\beta=1$，常规重要性采样\n- **在训练接近尾声时，使$\\beta \\rightarrow 1$ **\n- $\\beta \\in [0,1]$，文中并没有明说$\\beta$的取值范围\n- $\\beta$的选择与$\\alpha$有关，但文中并没有说明这两个参数如何选择的关系\n\n作用：\n\n- 消除偏差\n\n> We therefore exploit the flexibility of annealing the amount of importance-sampling correction over time, by defining a schedule on the exponent β that reaches 1 only at the end of learning.\n\n应用退火重要性采样校正量的灵活性，使在学习快结束时，将$\\beta \\rightarrow 1$\n\n# 伪代码\n\n![](./Prioritized-Experience-Replay/pseudo.png)\n\n**解析**：\n\n- step-size $\\eta$可以看做是学习率，文中并没有说它具体的定义，只是说它可以调节参数更新幅度（不就是学习率嘛）\n- $K$代表采样与更新之间的步数差，也就是，先采样K次经验并存入经验池，再取mini-batch更新。\n- 采样方式：\n  - ![](./Prioritized-Experience-Replay/sum-tree.png)\n  - 采样与更新TD-error的时间复杂度为$O(log_{2}N)$\n- 学习完之后对学习使用的经验更新其TD-error\n- 重要性权重$w_{j}=\\left ( N \\cdot P(j)\\right )^{-\\beta}/max_{i}w_{i}$，由$max_{i}w_{i}=max_{i}\\left ( N \\cdot P(i)\\right )^{-\\beta}=\\left ( min_{i}N \\cdot P(i)\\right )^{-\\beta}=\\left ( N \\cdot P_{min}\\right )^{-\\beta}$,可以将其化简为$w_{j}=\\left ( \\frac{p_{min}}{p_{j}} \\right )^{\\beta}$\n- 第12行，赋值其实是$(\\left | \\delta_{i} \\right |+ \\epsilon)^{\\alpha}$，如果是rank-based，则为$rank(i)^{-\\alpha}$\n- 第6行，对于新采样到的经验，不必计算其TD-error，直接将其设置为最大即可，当使用该经验学习之后再计算其TD-error\n- $\\Delta$其实就是误差函数$\\delta^{2}$对$\\theta$的导数，只不过对于mini-batch中的各个经验使用重要性比率进行了加权求和。\n\n**注意**：\n\n> Our final  solution was to store transitions in a priority queue implemented with an array-based binary heap. The heap array was then directly used as an approximation of a sorted array, which is infrequently sorted once every $10^{6}$ steps to prevent the heap becoming too unbalanced. \n\n如果使用rank-based方法，则使用的不是sum-tree结构，而是二进制堆，由于我不了解这个结构，故目前不做阐述。\n\n# Sum Tree\n\n```python\nimport numpy as np\n\n\nclass Sum_Tree(object):\n    def __init__(self, capacity):\n        \"\"\"\n        capacity = 5，设置经验池大小\n        tree = [0,1,2,3,4,5,6,7,8,9,10,11,12] 8-12存放叶子结点p值，1-7存放父节点、根节点p值的和，0存放树节点的数量\n        data = [0,1,2,3,4,5] 1-5存放数据， 0存放capacity\n        Tree structure and array storage:\n        Tree index:\n                    1         -> storing priority sum\n              /          \\ \n             2            3\n            / \\          / \\\n          4     5       6   7\n         / \\   / \\     / \\  / \\\n        8   9 10   11 12                   -> storing priority for transitions\n        \"\"\"\n        assert capacity != 1\n        self.now = 0\n        self.parent_node_count = self.get_parent_node_count(capacity)\n        print(self.parent_node_count)\n        self.tree = np.zeros(self.parent_node_count + capacity + 1)\n        self.tree[0] = len(self.tree) - 1\n        self.data = np.zeros(capacity + 1, dtype=object)\n        self.data[0] = capacity\n\n    def add(self, p, data):\n        \"\"\"\n        p : 优先级\n        data : 数据元组\n        \"\"\"\n        tree_index = self.now + self.parent_node_count + 1\n        self.data[self.now + 1] = data\n        self._updatetree(tree_index, p)\n        self.now += 1\n        if self.now > self.data[0]:\n            self.now = 0\n\n    def _updatetree(self, tree_index, p):\n        diff = p - self.tree[tree_index]\n        self._propagate(tree_index, diff)\n        self.tree[tree_index] = p\n\n    def _propagate(self, tree_index, diff):\n        parent = tree_index // 2\n        self.tree[parent] += diff\n        if parent != 1:\n            self._propagate(parent, diff)\n    @property\n    def total(self):\n        return self.tree[1]\n\n    def get(self, seg_p_total):\n        \"\"\"\n        seg_p_total : 要采样的p的值\n        \"\"\"\n        tree_index = self._retrieve(1, seg_p_total)\n        data_index = tree_index - self.parent_node_count\n        return (tree_index, data_index, self.tree[tree_index], self.data[data_index])\n\n    def _retrieve(self, tree_index, seg_p_total):\n        left = 2 * tree_index\n        right = left + 1\n#         left = 2 * tree_index + 1\n#         right = 2 * (tree_index + 1)\n        if left >= self.tree[0]:\n            return tree_index\n        return self._retrieve(left, seg_p_total) if seg_p_total <= self.tree[left] else self._retrieve(right, seg_p_total - self.tree[left])\n\n    def pp(self):\n        print(self.tree, self.data)\n\n    def get_parent_node_count(self, capacity):\n        i = 0\n        while True:\n            if pow(2, i) < capacity <= pow(2, i + 1):\n                return pow(2, i + 1) - 1\n            i += 1\n\n\ntree = Sum_Tree(5)\ntree.add(1, 3)\ntree.add(2, 4)\ntree.add(3, 5)\ntree.add(4, 6)\ntree.add(6, 11)\ntree.pp()\nprint(tree.get(4))\n```\n\n\n\n# 优先经验回放的特点\n\n1. 新的transition被采样到时，需要将其TD-error设置为最大，以保证最近的经验更容易被采样到。\n2. 只有在从经验池中抽取到某个经验并进行学习后，才对其TD-error进行计算更新。\n\n# 实验结果\n\n算法：\n\n- DQN\n- 优化后的Double DQN\n- 为了算法稳定的原因，将reward和TD-error clip到[-1,1]\n\n优先经验池：\n\n- 经验池大小$10^{6}$\n\n- batch-size为32\n\n- K=4，即每采样4次学习一次\n\n- Rank-based：$\\alpha=0.7，\\beta_{0}=0.5$，Proportional：$\\alpha=0.6，\\beta_{0}=0.4$\n\n- > These choices are trading off aggressiveness with robustness, but it is easy to revert to a behavior closer to the baseline by reducing $\\alpha$ and/or increasing $\\beta$. \n\n## 效果\n\n### 学习速度\n\n![](./Prioritized-Experience-Replay/learning-speed.png)\n\n- 黑色代表不使用优先经验回放的DDQN\n- 蓝色代表使用Proportional Prioritization的DDQN\n- 红色代表使用Rank-based Prioritization的DDQN\n\n- 绿色的虚线为人类水平\n\n### 归一化得分\n\n这些度量不重要，重要的是使用了优先经验回放机制的确提升了2倍左右的性能。\n\n![](./Prioritized-Experience-Replay/normalized-score1.png)\n\n![](./Prioritized-Experience-Replay/normalized-score.png)\n\n# PER的代码\n\n```\nimport numpy as np\nfrom abc import ABC, abstractmethod\n\n\nclass Buffer(ABC):\n    @abstractmethod\n    def sample(self) -> list:\n        pass\n\nclass Sum_Tree(object):\n    def __init__(self, capacity):\n        \"\"\"\n        capacity = 5，设置经验池大小\n        tree = [0,1,2,3,4,5,6,7,8,9,10,11,12] 8-12存放叶子结点p值，1-7存放父节点、根节点p值的和，0存放树节点的数量\n        data = [0,1,2,3,4,5] 1-5存放数据， 0存放capacity\n        Tree structure and array storage:\n        Tree index:\n                    1         -> storing priority sum\n              /          \\ \n             2            3\n            / \\          / \\\n          4     5       6   7\n         / \\   / \\     / \\  / \\\n        8   9 10   11 12                   -> storing priority for transitions\n        \"\"\"\n        assert capacity > 0\n        self.now = 0\n        self.parent_node_count = self.get_parent_node_count(capacity)\n        print(self.parent_node_count)\n        self.tree = np.zeros(self.parent_node_count + capacity + 1)\n        self.tree[0] = len(self.tree) - 1\n        self.data = np.zeros(capacity + 1, dtype=object)\n        self.data[0] = capacity\n\n    def add(self, p, data):\n        \"\"\"\n        p : property\n        data : [s, a, r, s_, done]\n        \"\"\"\n        tree_index = self.now + self.parent_node_count + 1\n        self.data[self.now + 1] = data\n        self._updatetree(tree_index, p)\n        self.now += 1\n        if self.now > self.data[0]:\n            self.now = 0\n\n    def _updatetree(self, tree_index, p):\n        diff = p - self.tree[tree_index]\n        self._propagate(tree_index, diff)\n        self.tree[tree_index] = p\n\n    def _propagate(self, tree_index, diff):\n        parent = tree_index // 2\n        self.tree[parent] += diff\n        if parent != 1:\n            self._propagate(parent, diff)\n\n    @property\n    def total(self):\n        return self.tree[1]\n\n    def get(self, seg_p_total):\n        \"\"\"\n        seg_p_total : The value of priority to sample\n        \"\"\"\n        tree_index = self._retrieve(1, seg_p_total)\n        data_index = tree_index - self.parent_node_count\n        return (tree_index, data_index, self.tree[tree_index], self.data[data_index])\n\n    def _retrieve(self, tree_index, seg_p_total):\n        left = 2 * tree_index\n        right = left + 1\n#         left = 2 * tree_index + 1\n#         right = 2 * (tree_index + 1)\n        if left >= self.tree[0]:\n            return tree_index\n        return self._retrieve(left, seg_p_total) if seg_p_total <= self.tree[left] else self._retrieve(right, seg_p_total - self.tree[left])\n\n    def pp(self):\n        print(self.tree, self.data)\n\n    def get_parent_node_count(self, capacity):\n        i = 0\n        while True:\n            if pow(2, i) < capacity <= pow(2, i + 1):\n                return pow(2, i + 1) - 1\n            i += 1\n\n\nclass PrioritizedReplayBuffer(Buffer):\n    def __init__(self, batch_size, capacity, alpha, beta, epsilon):\n        self.batch_size = batch_size\n        self.capacity = capacity\n        self._size = 0\n        self.alpha = alpha\n        self.beta = beta\n        self.tree = Sum_Tree(capacity)\n        self.epsilon = epsilon\n        self.min_p = np.inf\n\n    def add(self, p, *args):\n        '''\n        input: priorities, [ss, as, rs, _ss, dones]\n        '''\n        p = np.power(np.abs(p) + self.epsilon, self.alpha)\n        min_p = p.min()\n        if min_p < self.min_p:\n            self.min_p = min_p\n        if hasattr(args[0], '__len__'):\n            for i in range(len(args[0])):\n                self.tree.add(p[i], tuple(arg[i] for arg in args))\n                if self._size < self.capacity:\n                    self._size += 1\n        else:\n            self.tree.add(p, args)\n            if self._size < self.capacity:\n                self._size += 1\n\n    def sample(self):\n        '''\n        output: weights, [ss, as, rs, _ss, dones]\n        '''\n        n_sample = self.batch_size if self.is_lg_batch_size else self._size\n        interval = self.tree.total / n_sample\n        segment = [self.tree.total - i * interval for i in range(n_sample + 1)]\n        t = [self.tree.get(np.random.uniform(segment[i], segment[i + 1], 1)) for i in range(n_sample)]\n        t = [np.array(e) for e in zip(*t)]\n        self.last_indexs = t[0]\n        return np.power(self.min_p / t[-2], self.beta), t[-1]\n\n    @property\n    def is_lg_batch_size(self):\n        return self._size > self.batch_size\n\n    def update_priority(self, priority):\n        '''\n        input: priorities\n        '''\n        assert hasattr(priority, '__len__')\n        assert len(priority) == len(self.last_indexs)\n        for i in range(len(priority)):\n            self.tree._updatetree(self.last_indexs[i], priority[i])\n```\n\n","source":"_posts/Prioritized-Experience-Replay.md","raw":"---\ntitle: Prioritized Experience Replay\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2019-05-22 08:54:44\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n这篇论文介绍了优先经验回放机制，它可以使学习过程更高效。\n\n推荐：\n\n- 实用技巧\n- 通俗易懂\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/pdf/1511.05952.pdf](https://arxiv.org/pdf/1511.05952.pdf)\n\n之前重用经验（experience，transition转换五元组$\\lt s,a,r,s',done \\ or \\ \\gamma\\gt$都是从经验池中**均匀采样**，忽略了经验的重要程度，文中提到的优先经验回放框架按经验重要性增大其被采样到的概率，希望越重要的经验使用次数越多，从而增加学习效率。\n\n文中应用算法：DQN\n\n效果：相比传统经验池机制，Atari 49游戏中41胜，8负\n\n# 文中精要\n\n> Online reinforcement learning (RL) agents incrementally update their parameters (of the policy, value function or model) while they observe a stream of experience. In their simplest form, they discard incoming data immediately, after a single update. Two issues with this are (a) strongly correlated updates that break the i.i.d. assumption of many popular stochastic gradient-based algorithms, and (b) the rapid forgetting of possibly rare experiences that would be useful later on. \n>Experience replay  addresses both of these issues: with experience stored in a replay memory, it becomes possible to break the temporal correlations by mixing more and less recent experience for the updates, and rare experience will be used for more than just a single update.\n\n指出On-policy一般使用一个episode的数据进行参数更新，且数据用完即丢，这样做有两个缺点：\n\n- 数据（状态）相互关联，数据不具有独立同分布($i.i.d$)的性质，但许多流行的随机梯度算法往往有关于数据独立同分布的假设\n- 对罕见的（稀疏的）经验快速遗忘，忽略了这些罕见经验可能多次更新更有用的作用\n\n**经验池机制解决了上述两个问题**，通过混合近期经验打破它们关于时间的关联性，并从经验池中采样经验学习多次。\n\n经验池机制的优势：\n\n- 稳定了DQN值函数的训练\n- 一般情况下，经验回放可以减少训练所需的经验数量，但是需要加大计算量，消耗更多的内存，但是这往往比智能体与环境进行交互来得更方便、容易\n\n>In particular, we propose to more frequently replay transitions with high expected learning progress, s measured by the magnitude of their temporal-difference (TD) error. This prioritization can lead o a loss of diversity, which we alleviate with stochastic prioritization, and introduce bias, which e correct with importance sampling. \n\n文中根据TD-error设置优先经验回放的频率，这可能会引起两个问题：\n\n- 丢失样本多样性\n- 引入偏差\n\n分别解决方案：\n\n- 随机优先级 stochastic prioritization\n- 重要性采样\n\n>The central component of prioritized replay is the criterion by which the importance of each transition is measured. One idealised criterion would be the amount the RL agent can learn from a transition in its current state (expected learning progress). While this measure is not directly accessible,  reasonable proxy is the magnitude of a transition’s TD error $\\delta$ indicates how ‘surprising’  or unexpected the transition is: specifically, how far the value is from its next-step bootstrap estimate.\n\n优先经验回放的核心部分是如何衡量样本的重要性，并根据其重要性进行回放。\n\n最直观的衡量标准是从经验样本中可以学习的量，但是这个量不可知、不可得，于是使用TD-error $\\delta$作为这个量的替代品以衡量样本重要性。 \n\n>New transitions arrive without a known TD-error, so we put them at maximal priority in order to guarantee that all experience is seen at least once.  \n\n新的经验被存入经验池时不需计算TD-error，直接将其设置为当前经验池中最大的TD-error，保证其至少被抽中一次。\n\n---\n\n既然使用TD-error作为衡量可学习的度量，那么完全可以用贪婪的方式，选取TD-error最大的几个进行学习，但这会有几个问题：\n\n1. 由于只有在经验被重放**之后**，这个经验的TD-error才被更新，导致初始TD-error比较小的经验长时间不被使用，甚至永远不被使用。\n2. 贪婪策略聚焦于一小部分TD-error比较高的经验，当使用值函数近似时，这些经验的TD-error减小速度很慢，导致这些经验被高频重复使用，致使样本缺乏多样性而过拟合。\n\n文中提到使用**随机采样方法 stochastic sampling method**在贪婪策略与均匀采样之间“差值”来解决上述问题，其实它是一个在样本使用上的trade-off，由超参数$\\alpha$控制\n\n使用优先经验回放还有一个问题是改变了状态的分布，我们知道DQN中引入经验池是为了解决数据相关性，使数据（尽量）独立同分布的问题。但是使用优先经验回放又改变了状态的分布，这样势必会引入偏差bias，对此，文中使用**偏差退火——重要性采样结合退火因子**，来消除引入的偏差。\n\n## 随机采样方法\n\n$$\nP(i)=\\frac{p^{\\alpha}_{i}}{\\sum_{k}p^{\\alpha}_{k}}\n$$\n\n$\\alpha$超参数控制采样在uniform和greedy的偏好，是一个trade-off因子：\n\n- $\\alpha=0$，均匀采样\n- $\\alpha=1$，贪婪策略采样\n- $\\alpha \\in [0,1]$，文中没有明说$\\alpha$的取值范围\n- 引入$\\alpha$不改变优先级的单调性，只是适当调整高、低TD-error经验的优先级\n\n根据优先级$p_{i}$的设定可以将优先经验池的设计分为两种：\n\n- 直接的，基于比例的，proportional prioritization\n- 间接的，基于排名的，rank-based prioritization\n\n### Proportional Prioritization\n\n$$\np_{i}=\\left | \\delta_{i} \\right | + \\epsilon\n$$\n\n- $\\delta$表示TD-error\n- $\\epsilon$是一个小的正常数，防止TD-error为0的经验永远不被重放。\n\n### Rank-based Prioritization\n\n$$\np_{i}=\\frac{1}{rank(i)}\n$$\n\n- $rank(i)$是经验根据$\\left | \\delta_{i} \\right |$大小排序的排名\n- $P$为指数$\\alpha$的幂律分布power-law distribution\n- 这种方式更具鲁棒性，因为其对异常点不敏感，主要是因为异常点的TD-error过大或过小对rank值没有太大影响\n\n优点：\n\n- 其重尾性、厚尾性、heavy-tail property保证采样多样性\n- 分层采样使mini-batch的梯度稳定\n\n缺点：\n\n- 当在稀疏奖励场景想要使用TD-error分布结构时，会造成性能下降\n\n### 比较\n\n根据文中实验，两种方式效果基本相同，但不同场景可能一个效果很好，一个效果一般般。作者**猜想**效果相同的原因可能是因为对奖励和TD-error大量使用clip操作，消除了异常值，作者本以为Rank-based更具鲁棒性的。\n\n> Overhead is similar to rank-based prioritization.\n\n两者开销相同。\n\n## 偏差退火 Annealing The Bias\n\n我觉得应该译为消除偏差。\n\n引入重要性采样、引入退火因子$\\beta$消除偏差。将$w_{i}$除以$max_{i}w_{i}$向下缩放（减小）梯度更新幅度，稳定算法\n$$\nw_{i}=\\left ( \\frac{1}{N} \\cdot \\frac{1}{P(i)} \\right )^{\\beta}\n$$\n\n- $\\beta=0$，完全不用重要性采样\n- $\\beta=1$，常规重要性采样\n- **在训练接近尾声时，使$\\beta \\rightarrow 1$ **\n- $\\beta \\in [0,1]$，文中并没有明说$\\beta$的取值范围\n- $\\beta$的选择与$\\alpha$有关，但文中并没有说明这两个参数如何选择的关系\n\n作用：\n\n- 消除偏差\n\n> We therefore exploit the flexibility of annealing the amount of importance-sampling correction over time, by defining a schedule on the exponent β that reaches 1 only at the end of learning.\n\n应用退火重要性采样校正量的灵活性，使在学习快结束时，将$\\beta \\rightarrow 1$\n\n# 伪代码\n\n![](./Prioritized-Experience-Replay/pseudo.png)\n\n**解析**：\n\n- step-size $\\eta$可以看做是学习率，文中并没有说它具体的定义，只是说它可以调节参数更新幅度（不就是学习率嘛）\n- $K$代表采样与更新之间的步数差，也就是，先采样K次经验并存入经验池，再取mini-batch更新。\n- 采样方式：\n  - ![](./Prioritized-Experience-Replay/sum-tree.png)\n  - 采样与更新TD-error的时间复杂度为$O(log_{2}N)$\n- 学习完之后对学习使用的经验更新其TD-error\n- 重要性权重$w_{j}=\\left ( N \\cdot P(j)\\right )^{-\\beta}/max_{i}w_{i}$，由$max_{i}w_{i}=max_{i}\\left ( N \\cdot P(i)\\right )^{-\\beta}=\\left ( min_{i}N \\cdot P(i)\\right )^{-\\beta}=\\left ( N \\cdot P_{min}\\right )^{-\\beta}$,可以将其化简为$w_{j}=\\left ( \\frac{p_{min}}{p_{j}} \\right )^{\\beta}$\n- 第12行，赋值其实是$(\\left | \\delta_{i} \\right |+ \\epsilon)^{\\alpha}$，如果是rank-based，则为$rank(i)^{-\\alpha}$\n- 第6行，对于新采样到的经验，不必计算其TD-error，直接将其设置为最大即可，当使用该经验学习之后再计算其TD-error\n- $\\Delta$其实就是误差函数$\\delta^{2}$对$\\theta$的导数，只不过对于mini-batch中的各个经验使用重要性比率进行了加权求和。\n\n**注意**：\n\n> Our final  solution was to store transitions in a priority queue implemented with an array-based binary heap. The heap array was then directly used as an approximation of a sorted array, which is infrequently sorted once every $10^{6}$ steps to prevent the heap becoming too unbalanced. \n\n如果使用rank-based方法，则使用的不是sum-tree结构，而是二进制堆，由于我不了解这个结构，故目前不做阐述。\n\n# Sum Tree\n\n```python\nimport numpy as np\n\n\nclass Sum_Tree(object):\n    def __init__(self, capacity):\n        \"\"\"\n        capacity = 5，设置经验池大小\n        tree = [0,1,2,3,4,5,6,7,8,9,10,11,12] 8-12存放叶子结点p值，1-7存放父节点、根节点p值的和，0存放树节点的数量\n        data = [0,1,2,3,4,5] 1-5存放数据， 0存放capacity\n        Tree structure and array storage:\n        Tree index:\n                    1         -> storing priority sum\n              /          \\ \n             2            3\n            / \\          / \\\n          4     5       6   7\n         / \\   / \\     / \\  / \\\n        8   9 10   11 12                   -> storing priority for transitions\n        \"\"\"\n        assert capacity != 1\n        self.now = 0\n        self.parent_node_count = self.get_parent_node_count(capacity)\n        print(self.parent_node_count)\n        self.tree = np.zeros(self.parent_node_count + capacity + 1)\n        self.tree[0] = len(self.tree) - 1\n        self.data = np.zeros(capacity + 1, dtype=object)\n        self.data[0] = capacity\n\n    def add(self, p, data):\n        \"\"\"\n        p : 优先级\n        data : 数据元组\n        \"\"\"\n        tree_index = self.now + self.parent_node_count + 1\n        self.data[self.now + 1] = data\n        self._updatetree(tree_index, p)\n        self.now += 1\n        if self.now > self.data[0]:\n            self.now = 0\n\n    def _updatetree(self, tree_index, p):\n        diff = p - self.tree[tree_index]\n        self._propagate(tree_index, diff)\n        self.tree[tree_index] = p\n\n    def _propagate(self, tree_index, diff):\n        parent = tree_index // 2\n        self.tree[parent] += diff\n        if parent != 1:\n            self._propagate(parent, diff)\n    @property\n    def total(self):\n        return self.tree[1]\n\n    def get(self, seg_p_total):\n        \"\"\"\n        seg_p_total : 要采样的p的值\n        \"\"\"\n        tree_index = self._retrieve(1, seg_p_total)\n        data_index = tree_index - self.parent_node_count\n        return (tree_index, data_index, self.tree[tree_index], self.data[data_index])\n\n    def _retrieve(self, tree_index, seg_p_total):\n        left = 2 * tree_index\n        right = left + 1\n#         left = 2 * tree_index + 1\n#         right = 2 * (tree_index + 1)\n        if left >= self.tree[0]:\n            return tree_index\n        return self._retrieve(left, seg_p_total) if seg_p_total <= self.tree[left] else self._retrieve(right, seg_p_total - self.tree[left])\n\n    def pp(self):\n        print(self.tree, self.data)\n\n    def get_parent_node_count(self, capacity):\n        i = 0\n        while True:\n            if pow(2, i) < capacity <= pow(2, i + 1):\n                return pow(2, i + 1) - 1\n            i += 1\n\n\ntree = Sum_Tree(5)\ntree.add(1, 3)\ntree.add(2, 4)\ntree.add(3, 5)\ntree.add(4, 6)\ntree.add(6, 11)\ntree.pp()\nprint(tree.get(4))\n```\n\n\n\n# 优先经验回放的特点\n\n1. 新的transition被采样到时，需要将其TD-error设置为最大，以保证最近的经验更容易被采样到。\n2. 只有在从经验池中抽取到某个经验并进行学习后，才对其TD-error进行计算更新。\n\n# 实验结果\n\n算法：\n\n- DQN\n- 优化后的Double DQN\n- 为了算法稳定的原因，将reward和TD-error clip到[-1,1]\n\n优先经验池：\n\n- 经验池大小$10^{6}$\n\n- batch-size为32\n\n- K=4，即每采样4次学习一次\n\n- Rank-based：$\\alpha=0.7，\\beta_{0}=0.5$，Proportional：$\\alpha=0.6，\\beta_{0}=0.4$\n\n- > These choices are trading off aggressiveness with robustness, but it is easy to revert to a behavior closer to the baseline by reducing $\\alpha$ and/or increasing $\\beta$. \n\n## 效果\n\n### 学习速度\n\n![](./Prioritized-Experience-Replay/learning-speed.png)\n\n- 黑色代表不使用优先经验回放的DDQN\n- 蓝色代表使用Proportional Prioritization的DDQN\n- 红色代表使用Rank-based Prioritization的DDQN\n\n- 绿色的虚线为人类水平\n\n### 归一化得分\n\n这些度量不重要，重要的是使用了优先经验回放机制的确提升了2倍左右的性能。\n\n![](./Prioritized-Experience-Replay/normalized-score1.png)\n\n![](./Prioritized-Experience-Replay/normalized-score.png)\n\n# PER的代码\n\n```\nimport numpy as np\nfrom abc import ABC, abstractmethod\n\n\nclass Buffer(ABC):\n    @abstractmethod\n    def sample(self) -> list:\n        pass\n\nclass Sum_Tree(object):\n    def __init__(self, capacity):\n        \"\"\"\n        capacity = 5，设置经验池大小\n        tree = [0,1,2,3,4,5,6,7,8,9,10,11,12] 8-12存放叶子结点p值，1-7存放父节点、根节点p值的和，0存放树节点的数量\n        data = [0,1,2,3,4,5] 1-5存放数据， 0存放capacity\n        Tree structure and array storage:\n        Tree index:\n                    1         -> storing priority sum\n              /          \\ \n             2            3\n            / \\          / \\\n          4     5       6   7\n         / \\   / \\     / \\  / \\\n        8   9 10   11 12                   -> storing priority for transitions\n        \"\"\"\n        assert capacity > 0\n        self.now = 0\n        self.parent_node_count = self.get_parent_node_count(capacity)\n        print(self.parent_node_count)\n        self.tree = np.zeros(self.parent_node_count + capacity + 1)\n        self.tree[0] = len(self.tree) - 1\n        self.data = np.zeros(capacity + 1, dtype=object)\n        self.data[0] = capacity\n\n    def add(self, p, data):\n        \"\"\"\n        p : property\n        data : [s, a, r, s_, done]\n        \"\"\"\n        tree_index = self.now + self.parent_node_count + 1\n        self.data[self.now + 1] = data\n        self._updatetree(tree_index, p)\n        self.now += 1\n        if self.now > self.data[0]:\n            self.now = 0\n\n    def _updatetree(self, tree_index, p):\n        diff = p - self.tree[tree_index]\n        self._propagate(tree_index, diff)\n        self.tree[tree_index] = p\n\n    def _propagate(self, tree_index, diff):\n        parent = tree_index // 2\n        self.tree[parent] += diff\n        if parent != 1:\n            self._propagate(parent, diff)\n\n    @property\n    def total(self):\n        return self.tree[1]\n\n    def get(self, seg_p_total):\n        \"\"\"\n        seg_p_total : The value of priority to sample\n        \"\"\"\n        tree_index = self._retrieve(1, seg_p_total)\n        data_index = tree_index - self.parent_node_count\n        return (tree_index, data_index, self.tree[tree_index], self.data[data_index])\n\n    def _retrieve(self, tree_index, seg_p_total):\n        left = 2 * tree_index\n        right = left + 1\n#         left = 2 * tree_index + 1\n#         right = 2 * (tree_index + 1)\n        if left >= self.tree[0]:\n            return tree_index\n        return self._retrieve(left, seg_p_total) if seg_p_total <= self.tree[left] else self._retrieve(right, seg_p_total - self.tree[left])\n\n    def pp(self):\n        print(self.tree, self.data)\n\n    def get_parent_node_count(self, capacity):\n        i = 0\n        while True:\n            if pow(2, i) < capacity <= pow(2, i + 1):\n                return pow(2, i + 1) - 1\n            i += 1\n\n\nclass PrioritizedReplayBuffer(Buffer):\n    def __init__(self, batch_size, capacity, alpha, beta, epsilon):\n        self.batch_size = batch_size\n        self.capacity = capacity\n        self._size = 0\n        self.alpha = alpha\n        self.beta = beta\n        self.tree = Sum_Tree(capacity)\n        self.epsilon = epsilon\n        self.min_p = np.inf\n\n    def add(self, p, *args):\n        '''\n        input: priorities, [ss, as, rs, _ss, dones]\n        '''\n        p = np.power(np.abs(p) + self.epsilon, self.alpha)\n        min_p = p.min()\n        if min_p < self.min_p:\n            self.min_p = min_p\n        if hasattr(args[0], '__len__'):\n            for i in range(len(args[0])):\n                self.tree.add(p[i], tuple(arg[i] for arg in args))\n                if self._size < self.capacity:\n                    self._size += 1\n        else:\n            self.tree.add(p, args)\n            if self._size < self.capacity:\n                self._size += 1\n\n    def sample(self):\n        '''\n        output: weights, [ss, as, rs, _ss, dones]\n        '''\n        n_sample = self.batch_size if self.is_lg_batch_size else self._size\n        interval = self.tree.total / n_sample\n        segment = [self.tree.total - i * interval for i in range(n_sample + 1)]\n        t = [self.tree.get(np.random.uniform(segment[i], segment[i + 1], 1)) for i in range(n_sample)]\n        t = [np.array(e) for e in zip(*t)]\n        self.last_indexs = t[0]\n        return np.power(self.min_p / t[-2], self.beta), t[-1]\n\n    @property\n    def is_lg_batch_size(self):\n        return self._size > self.batch_size\n\n    def update_priority(self, priority):\n        '''\n        input: priorities\n        '''\n        assert hasattr(priority, '__len__')\n        assert len(priority) == len(self.last_indexs)\n        for i in range(len(priority)):\n            self.tree._updatetree(self.last_indexs[i], priority[i])\n```\n\n","slug":"Prioritized-Experience-Replay","published":1,"updated":"2019-10-16T14:13:36.842Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzutl5005y20cdco9mod2h","content":"<p>这篇论文介绍了优先经验回放机制，它可以使学习过程更高效。</p>\n<p>推荐：</p>\n<ul>\n<li>实用技巧</li>\n<li>通俗易懂</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1511.05952.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1511.05952.pdf</a></p>\n<p>之前重用经验（experience，transition转换五元组$\\lt s,a,r,s’,done \\ or \\ \\gamma\\gt$都是从经验池中<strong>均匀采样</strong>，忽略了经验的重要程度，文中提到的优先经验回放框架按经验重要性增大其被采样到的概率，希望越重要的经验使用次数越多，从而增加学习效率。</p>\n<p>文中应用算法：DQN</p>\n<p>效果：相比传统经验池机制，Atari 49游戏中41胜，8负</p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><blockquote>\n<p>Online reinforcement learning (RL) agents incrementally update their parameters (of the policy, value function or model) while they observe a stream of experience. In their simplest form, they discard incoming data immediately, after a single update. Two issues with this are (a) strongly correlated updates that break the i.i.d. assumption of many popular stochastic gradient-based algorithms, and (b) the rapid forgetting of possibly rare experiences that would be useful later on.<br>Experience replay  addresses both of these issues: with experience stored in a replay memory, it becomes possible to break the temporal correlations by mixing more and less recent experience for the updates, and rare experience will be used for more than just a single update.</p>\n</blockquote>\n<p>指出On-policy一般使用一个episode的数据进行参数更新，且数据用完即丢，这样做有两个缺点：</p>\n<ul>\n<li>数据（状态）相互关联，数据不具有独立同分布($i.i.d$)的性质，但许多流行的随机梯度算法往往有关于数据独立同分布的假设</li>\n<li>对罕见的（稀疏的）经验快速遗忘，忽略了这些罕见经验可能多次更新更有用的作用</li>\n</ul>\n<p><strong>经验池机制解决了上述两个问题</strong>，通过混合近期经验打破它们关于时间的关联性，并从经验池中采样经验学习多次。</p>\n<p>经验池机制的优势：</p>\n<ul>\n<li>稳定了DQN值函数的训练</li>\n<li>一般情况下，经验回放可以减少训练所需的经验数量，但是需要加大计算量，消耗更多的内存，但是这往往比智能体与环境进行交互来得更方便、容易</li>\n</ul>\n<blockquote>\n<p>In particular, we propose to more frequently replay transitions with high expected learning progress, s measured by the magnitude of their temporal-difference (TD) error. This prioritization can lead o a loss of diversity, which we alleviate with stochastic prioritization, and introduce bias, which e correct with importance sampling. </p>\n</blockquote>\n<p>文中根据TD-error设置优先经验回放的频率，这可能会引起两个问题：</p>\n<ul>\n<li>丢失样本多样性</li>\n<li>引入偏差</li>\n</ul>\n<p>分别解决方案：</p>\n<ul>\n<li>随机优先级 stochastic prioritization</li>\n<li>重要性采样</li>\n</ul>\n<blockquote>\n<p>The central component of prioritized replay is the criterion by which the importance of each transition is measured. One idealised criterion would be the amount the RL agent can learn from a transition in its current state (expected learning progress). While this measure is not directly accessible,  reasonable proxy is the magnitude of a transition’s TD error $\\delta$ indicates how ‘surprising’  or unexpected the transition is: specifically, how far the value is from its next-step bootstrap estimate.</p>\n</blockquote>\n<p>优先经验回放的核心部分是如何衡量样本的重要性，并根据其重要性进行回放。</p>\n<p>最直观的衡量标准是从经验样本中可以学习的量，但是这个量不可知、不可得，于是使用TD-error $\\delta$作为这个量的替代品以衡量样本重要性。 </p>\n<blockquote>\n<p>New transitions arrive without a known TD-error, so we put them at maximal priority in order to guarantee that all experience is seen at least once.  </p>\n</blockquote>\n<p>新的经验被存入经验池时不需计算TD-error，直接将其设置为当前经验池中最大的TD-error，保证其至少被抽中一次。</p>\n<hr>\n<p>既然使用TD-error作为衡量可学习的度量，那么完全可以用贪婪的方式，选取TD-error最大的几个进行学习，但这会有几个问题：</p>\n<ol>\n<li>由于只有在经验被重放<strong>之后</strong>，这个经验的TD-error才被更新，导致初始TD-error比较小的经验长时间不被使用，甚至永远不被使用。</li>\n<li>贪婪策略聚焦于一小部分TD-error比较高的经验，当使用值函数近似时，这些经验的TD-error减小速度很慢，导致这些经验被高频重复使用，致使样本缺乏多样性而过拟合。</li>\n</ol>\n<p>文中提到使用<strong>随机采样方法 stochastic sampling method</strong>在贪婪策略与均匀采样之间“差值”来解决上述问题，其实它是一个在样本使用上的trade-off，由超参数$\\alpha$控制</p>\n<p>使用优先经验回放还有一个问题是改变了状态的分布，我们知道DQN中引入经验池是为了解决数据相关性，使数据（尽量）独立同分布的问题。但是使用优先经验回放又改变了状态的分布，这样势必会引入偏差bias，对此，文中使用<strong>偏差退火——重要性采样结合退火因子</strong>，来消除引入的偏差。</p>\n<h2 id=\"随机采样方法\"><a href=\"#随机采样方法\" class=\"headerlink\" title=\"随机采样方法\"></a>随机采样方法</h2><script type=\"math/tex; mode=display\">\nP(i)=\\frac{p^{\\alpha}_{i}}{\\sum_{k}p^{\\alpha}_{k}}</script><p>$\\alpha$超参数控制采样在uniform和greedy的偏好，是一个trade-off因子：</p>\n<ul>\n<li>$\\alpha=0$，均匀采样</li>\n<li>$\\alpha=1$，贪婪策略采样</li>\n<li>$\\alpha \\in [0,1]$，文中没有明说$\\alpha$的取值范围</li>\n<li>引入$\\alpha$不改变优先级的单调性，只是适当调整高、低TD-error经验的优先级</li>\n</ul>\n<p>根据优先级$p_{i}$的设定可以将优先经验池的设计分为两种：</p>\n<ul>\n<li>直接的，基于比例的，proportional prioritization</li>\n<li>间接的，基于排名的，rank-based prioritization</li>\n</ul>\n<h3 id=\"Proportional-Prioritization\"><a href=\"#Proportional-Prioritization\" class=\"headerlink\" title=\"Proportional Prioritization\"></a>Proportional Prioritization</h3><script type=\"math/tex; mode=display\">\np_{i}=\\left | \\delta_{i} \\right | + \\epsilon</script><ul>\n<li>$\\delta$表示TD-error</li>\n<li>$\\epsilon$是一个小的正常数，防止TD-error为0的经验永远不被重放。</li>\n</ul>\n<h3 id=\"Rank-based-Prioritization\"><a href=\"#Rank-based-Prioritization\" class=\"headerlink\" title=\"Rank-based Prioritization\"></a>Rank-based Prioritization</h3><script type=\"math/tex; mode=display\">\np_{i}=\\frac{1}{rank(i)}</script><ul>\n<li>$rank(i)$是经验根据$\\left | \\delta_{i} \\right |$大小排序的排名</li>\n<li>$P$为指数$\\alpha$的幂律分布power-law distribution</li>\n<li>这种方式更具鲁棒性，因为其对异常点不敏感，主要是因为异常点的TD-error过大或过小对rank值没有太大影响</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>其重尾性、厚尾性、heavy-tail property保证采样多样性</li>\n<li>分层采样使mini-batch的梯度稳定</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>当在稀疏奖励场景想要使用TD-error分布结构时，会造成性能下降</li>\n</ul>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>根据文中实验，两种方式效果基本相同，但不同场景可能一个效果很好，一个效果一般般。作者<strong>猜想</strong>效果相同的原因可能是因为对奖励和TD-error大量使用clip操作，消除了异常值，作者本以为Rank-based更具鲁棒性的。</p>\n<blockquote>\n<p>Overhead is similar to rank-based prioritization.</p>\n</blockquote>\n<p>两者开销相同。</p>\n<h2 id=\"偏差退火-Annealing-The-Bias\"><a href=\"#偏差退火-Annealing-The-Bias\" class=\"headerlink\" title=\"偏差退火 Annealing The Bias\"></a>偏差退火 Annealing The Bias</h2><p>我觉得应该译为消除偏差。</p>\n<p>引入重要性采样、引入退火因子$\\beta$消除偏差。将$w_{i}$除以$max_{i}w_{i}$向下缩放（减小）梯度更新幅度，稳定算法</p>\n<script type=\"math/tex; mode=display\">\nw_{i}=\\left ( \\frac{1}{N} \\cdot \\frac{1}{P(i)} \\right )^{\\beta}</script><ul>\n<li>$\\beta=0$，完全不用重要性采样</li>\n<li>$\\beta=1$，常规重要性采样</li>\n<li><strong>在训练接近尾声时，使$\\beta \\rightarrow 1$ </strong></li>\n<li>$\\beta \\in [0,1]$，文中并没有明说$\\beta$的取值范围</li>\n<li>$\\beta$的选择与$\\alpha$有关，但文中并没有说明这两个参数如何选择的关系</li>\n</ul>\n<p>作用：</p>\n<ul>\n<li>消除偏差</li>\n</ul>\n<blockquote>\n<p>We therefore exploit the flexibility of annealing the amount of importance-sampling correction over time, by defining a schedule on the exponent β that reaches 1 only at the end of learning.</p>\n</blockquote>\n<p>应用退火重要性采样校正量的灵活性，使在学习快结束时，将$\\beta \\rightarrow 1$</p>\n<h1 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h1><p><img src=\"./Prioritized-Experience-Replay/pseudo.png\" alt=\"\"></p>\n<p><strong>解析</strong>：</p>\n<ul>\n<li>step-size $\\eta$可以看做是学习率，文中并没有说它具体的定义，只是说它可以调节参数更新幅度（不就是学习率嘛）</li>\n<li>$K$代表采样与更新之间的步数差，也就是，先采样K次经验并存入经验池，再取mini-batch更新。</li>\n<li>采样方式：<ul>\n<li><img src=\"./Prioritized-Experience-Replay/sum-tree.png\" alt=\"\"></li>\n<li>采样与更新TD-error的时间复杂度为$O(log_{2}N)$</li>\n</ul>\n</li>\n<li>学习完之后对学习使用的经验更新其TD-error</li>\n<li>重要性权重$w_{j}=\\left ( N \\cdot P(j)\\right )^{-\\beta}/max_{i}w_{i}$，由$max_{i}w_{i}=max_{i}\\left ( N \\cdot P(i)\\right )^{-\\beta}=\\left ( min_{i}N \\cdot P(i)\\right )^{-\\beta}=\\left ( N \\cdot P_{min}\\right )^{-\\beta}$,可以将其化简为$w_{j}=\\left ( \\frac{p_{min}}{p_{j}} \\right )^{\\beta}$</li>\n<li>第12行，赋值其实是$(\\left | \\delta_{i} \\right |+ \\epsilon)^{\\alpha}$，如果是rank-based，则为$rank(i)^{-\\alpha}$</li>\n<li>第6行，对于新采样到的经验，不必计算其TD-error，直接将其设置为最大即可，当使用该经验学习之后再计算其TD-error</li>\n<li>$\\Delta$其实就是误差函数$\\delta^{2}$对$\\theta$的导数，只不过对于mini-batch中的各个经验使用重要性比率进行了加权求和。</li>\n</ul>\n<p><strong>注意</strong>：</p>\n<blockquote>\n<p>Our final  solution was to store transitions in a priority queue implemented with an array-based binary heap. The heap array was then directly used as an approximation of a sorted array, which is infrequently sorted once every $10^{6}$ steps to prevent the heap becoming too unbalanced. </p>\n</blockquote>\n<p>如果使用rank-based方法，则使用的不是sum-tree结构，而是二进制堆，由于我不了解这个结构，故目前不做阐述。</p>\n<h1 id=\"Sum-Tree\"><a href=\"#Sum-Tree\" class=\"headerlink\" title=\"Sum Tree\"></a>Sum Tree</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sum_Tree</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, capacity)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        capacity = 5，设置经验池大小</span></span><br><span class=\"line\"><span class=\"string\">        tree = [0,1,2,3,4,5,6,7,8,9,10,11,12] 8-12存放叶子结点p值，1-7存放父节点、根节点p值的和，0存放树节点的数量</span></span><br><span class=\"line\"><span class=\"string\">        data = [0,1,2,3,4,5] 1-5存放数据， 0存放capacity</span></span><br><span class=\"line\"><span class=\"string\">        Tree structure and array storage:</span></span><br><span class=\"line\"><span class=\"string\">        Tree index:</span></span><br><span class=\"line\"><span class=\"string\">                    1         -&gt; storing priority sum</span></span><br><span class=\"line\"><span class=\"string\">              /          \\ </span></span><br><span class=\"line\"><span class=\"string\">             2            3</span></span><br><span class=\"line\"><span class=\"string\">            / \\          / \\</span></span><br><span class=\"line\"><span class=\"string\">          4     5       6   7</span></span><br><span class=\"line\"><span class=\"string\">         / \\   / \\     / \\  / \\</span></span><br><span class=\"line\"><span class=\"string\">        8   9 10   11 12                   -&gt; storing priority for transitions</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> capacity != <span class=\"number\">1</span></span><br><span class=\"line\">        self.now = <span class=\"number\">0</span></span><br><span class=\"line\">        self.parent_node_count = self.get_parent_node_count(capacity)</span><br><span class=\"line\">        print(self.parent_node_count)</span><br><span class=\"line\">        self.tree = np.zeros(self.parent_node_count + capacity + <span class=\"number\">1</span>)</span><br><span class=\"line\">        self.tree[<span class=\"number\">0</span>] = len(self.tree) - <span class=\"number\">1</span></span><br><span class=\"line\">        self.data = np.zeros(capacity + <span class=\"number\">1</span>, dtype=object)</span><br><span class=\"line\">        self.data[<span class=\"number\">0</span>] = capacity</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(self, p, data)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        p : 优先级</span></span><br><span class=\"line\"><span class=\"string\">        data : 数据元组</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        tree_index = self.now + self.parent_node_count + <span class=\"number\">1</span></span><br><span class=\"line\">        self.data[self.now + <span class=\"number\">1</span>] = data</span><br><span class=\"line\">        self._updatetree(tree_index, p)</span><br><span class=\"line\">        self.now += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.now &gt; self.data[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            self.now = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_updatetree</span><span class=\"params\">(self, tree_index, p)</span>:</span></span><br><span class=\"line\">        diff = p - self.tree[tree_index]</span><br><span class=\"line\">        self._propagate(tree_index, diff)</span><br><span class=\"line\">        self.tree[tree_index] = p</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_propagate</span><span class=\"params\">(self, tree_index, diff)</span>:</span></span><br><span class=\"line\">        parent = tree_index // <span class=\"number\">2</span></span><br><span class=\"line\">        self.tree[parent] += diff</span><br><span class=\"line\">        <span class=\"keyword\">if</span> parent != <span class=\"number\">1</span>:</span><br><span class=\"line\">            self._propagate(parent, diff)</span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">total</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.tree[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, seg_p_total)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        seg_p_total : 要采样的p的值</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        tree_index = self._retrieve(<span class=\"number\">1</span>, seg_p_total)</span><br><span class=\"line\">        data_index = tree_index - self.parent_node_count</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (tree_index, data_index, self.tree[tree_index], self.data[data_index])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_retrieve</span><span class=\"params\">(self, tree_index, seg_p_total)</span>:</span></span><br><span class=\"line\">        left = <span class=\"number\">2</span> * tree_index</span><br><span class=\"line\">        right = left + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">#         left = 2 * tree_index + 1</span></span><br><span class=\"line\"><span class=\"comment\">#         right = 2 * (tree_index + 1)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &gt;= self.tree[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree_index</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._retrieve(left, seg_p_total) <span class=\"keyword\">if</span> seg_p_total &lt;= self.tree[left] <span class=\"keyword\">else</span> self._retrieve(right, seg_p_total - self.tree[left])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pp</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(self.tree, self.data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_parent_node_count</span><span class=\"params\">(self, capacity)</span>:</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> pow(<span class=\"number\">2</span>, i) &lt; capacity &lt;= pow(<span class=\"number\">2</span>, i + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> pow(<span class=\"number\">2</span>, i + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">tree = Sum_Tree(<span class=\"number\">5</span>)</span><br><span class=\"line\">tree.add(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">tree.add(<span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">tree.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">tree.add(<span class=\"number\">4</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">tree.add(<span class=\"number\">6</span>, <span class=\"number\">11</span>)</span><br><span class=\"line\">tree.pp()</span><br><span class=\"line\">print(tree.get(<span class=\"number\">4</span>))</span><br></pre></td></tr></table></figure>\n<h1 id=\"优先经验回放的特点\"><a href=\"#优先经验回放的特点\" class=\"headerlink\" title=\"优先经验回放的特点\"></a>优先经验回放的特点</h1><ol>\n<li>新的transition被采样到时，需要将其TD-error设置为最大，以保证最近的经验更容易被采样到。</li>\n<li>只有在从经验池中抽取到某个经验并进行学习后，才对其TD-error进行计算更新。</li>\n</ol>\n<h1 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h1><p>算法：</p>\n<ul>\n<li>DQN</li>\n<li>优化后的Double DQN</li>\n<li>为了算法稳定的原因，将reward和TD-error clip到[-1,1]</li>\n</ul>\n<p>优先经验池：</p>\n<ul>\n<li><p>经验池大小$10^{6}$</p>\n</li>\n<li><p>batch-size为32</p>\n</li>\n<li><p>K=4，即每采样4次学习一次</p>\n</li>\n<li><p>Rank-based：$\\alpha=0.7，\\beta_{0}=0.5$，Proportional：$\\alpha=0.6，\\beta_{0}=0.4$</p>\n</li>\n<li><blockquote>\n<p>These choices are trading off aggressiveness with robustness, but it is easy to revert to a behavior closer to the baseline by reducing $\\alpha$ and/or increasing $\\beta$. </p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><h3 id=\"学习速度\"><a href=\"#学习速度\" class=\"headerlink\" title=\"学习速度\"></a>学习速度</h3><p><img src=\"./Prioritized-Experience-Replay/learning-speed.png\" alt=\"\"></p>\n<ul>\n<li>黑色代表不使用优先经验回放的DDQN</li>\n<li>蓝色代表使用Proportional Prioritization的DDQN</li>\n<li><p>红色代表使用Rank-based Prioritization的DDQN</p>\n</li>\n<li><p>绿色的虚线为人类水平</p>\n</li>\n</ul>\n<h3 id=\"归一化得分\"><a href=\"#归一化得分\" class=\"headerlink\" title=\"归一化得分\"></a>归一化得分</h3><p>这些度量不重要，重要的是使用了优先经验回放机制的确提升了2倍左右的性能。</p>\n<p><img src=\"./Prioritized-Experience-Replay/normalized-score1.png\" alt=\"\"></p>\n<p><img src=\"./Prioritized-Experience-Replay/normalized-score.png\" alt=\"\"></p>\n<h1 id=\"PER的代码\"><a href=\"#PER的代码\" class=\"headerlink\" title=\"PER的代码\"></a>PER的代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import numpy as np</span><br><span class=\"line\">from abc import ABC, abstractmethod</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class Buffer(ABC):</span><br><span class=\"line\">    @abstractmethod</span><br><span class=\"line\">    def sample(self) -&gt; list:</span><br><span class=\"line\">        pass</span><br><span class=\"line\"></span><br><span class=\"line\">class Sum_Tree(object):</span><br><span class=\"line\">    def __init__(self, capacity):</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        capacity = 5，设置经验池大小</span><br><span class=\"line\">        tree = [0,1,2,3,4,5,6,7,8,9,10,11,12] 8-12存放叶子结点p值，1-7存放父节点、根节点p值的和，0存放树节点的数量</span><br><span class=\"line\">        data = [0,1,2,3,4,5] 1-5存放数据， 0存放capacity</span><br><span class=\"line\">        Tree structure and array storage:</span><br><span class=\"line\">        Tree index:</span><br><span class=\"line\">                    1         -&gt; storing priority sum</span><br><span class=\"line\">              /          \\ </span><br><span class=\"line\">             2            3</span><br><span class=\"line\">            / \\          / \\</span><br><span class=\"line\">          4     5       6   7</span><br><span class=\"line\">         / \\   / \\     / \\  / \\</span><br><span class=\"line\">        8   9 10   11 12                   -&gt; storing priority for transitions</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        assert capacity &gt; 0</span><br><span class=\"line\">        self.now = 0</span><br><span class=\"line\">        self.parent_node_count = self.get_parent_node_count(capacity)</span><br><span class=\"line\">        print(self.parent_node_count)</span><br><span class=\"line\">        self.tree = np.zeros(self.parent_node_count + capacity + 1)</span><br><span class=\"line\">        self.tree[0] = len(self.tree) - 1</span><br><span class=\"line\">        self.data = np.zeros(capacity + 1, dtype=object)</span><br><span class=\"line\">        self.data[0] = capacity</span><br><span class=\"line\"></span><br><span class=\"line\">    def add(self, p, data):</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        p : property</span><br><span class=\"line\">        data : [s, a, r, s_, done]</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        tree_index = self.now + self.parent_node_count + 1</span><br><span class=\"line\">        self.data[self.now + 1] = data</span><br><span class=\"line\">        self._updatetree(tree_index, p)</span><br><span class=\"line\">        self.now += 1</span><br><span class=\"line\">        if self.now &gt; self.data[0]:</span><br><span class=\"line\">            self.now = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    def _updatetree(self, tree_index, p):</span><br><span class=\"line\">        diff = p - self.tree[tree_index]</span><br><span class=\"line\">        self._propagate(tree_index, diff)</span><br><span class=\"line\">        self.tree[tree_index] = p</span><br><span class=\"line\"></span><br><span class=\"line\">    def _propagate(self, tree_index, diff):</span><br><span class=\"line\">        parent = tree_index // 2</span><br><span class=\"line\">        self.tree[parent] += diff</span><br><span class=\"line\">        if parent != 1:</span><br><span class=\"line\">            self._propagate(parent, diff)</span><br><span class=\"line\"></span><br><span class=\"line\">    @property</span><br><span class=\"line\">    def total(self):</span><br><span class=\"line\">        return self.tree[1]</span><br><span class=\"line\"></span><br><span class=\"line\">    def get(self, seg_p_total):</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        seg_p_total : The value of priority to sample</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        tree_index = self._retrieve(1, seg_p_total)</span><br><span class=\"line\">        data_index = tree_index - self.parent_node_count</span><br><span class=\"line\">        return (tree_index, data_index, self.tree[tree_index], self.data[data_index])</span><br><span class=\"line\"></span><br><span class=\"line\">    def _retrieve(self, tree_index, seg_p_total):</span><br><span class=\"line\">        left = 2 * tree_index</span><br><span class=\"line\">        right = left + 1</span><br><span class=\"line\">#         left = 2 * tree_index + 1</span><br><span class=\"line\">#         right = 2 * (tree_index + 1)</span><br><span class=\"line\">        if left &gt;= self.tree[0]:</span><br><span class=\"line\">            return tree_index</span><br><span class=\"line\">        return self._retrieve(left, seg_p_total) if seg_p_total &lt;= self.tree[left] else self._retrieve(right, seg_p_total - self.tree[left])</span><br><span class=\"line\"></span><br><span class=\"line\">    def pp(self):</span><br><span class=\"line\">        print(self.tree, self.data)</span><br><span class=\"line\"></span><br><span class=\"line\">    def get_parent_node_count(self, capacity):</span><br><span class=\"line\">        i = 0</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            if pow(2, i) &lt; capacity &lt;= pow(2, i + 1):</span><br><span class=\"line\">                return pow(2, i + 1) - 1</span><br><span class=\"line\">            i += 1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class PrioritizedReplayBuffer(Buffer):</span><br><span class=\"line\">    def __init__(self, batch_size, capacity, alpha, beta, epsilon):</span><br><span class=\"line\">        self.batch_size = batch_size</span><br><span class=\"line\">        self.capacity = capacity</span><br><span class=\"line\">        self._size = 0</span><br><span class=\"line\">        self.alpha = alpha</span><br><span class=\"line\">        self.beta = beta</span><br><span class=\"line\">        self.tree = Sum_Tree(capacity)</span><br><span class=\"line\">        self.epsilon = epsilon</span><br><span class=\"line\">        self.min_p = np.inf</span><br><span class=\"line\"></span><br><span class=\"line\">    def add(self, p, *args):</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        input: priorities, [ss, as, rs, _ss, dones]</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        p = np.power(np.abs(p) + self.epsilon, self.alpha)</span><br><span class=\"line\">        min_p = p.min()</span><br><span class=\"line\">        if min_p &lt; self.min_p:</span><br><span class=\"line\">            self.min_p = min_p</span><br><span class=\"line\">        if hasattr(args[0], &apos;__len__&apos;):</span><br><span class=\"line\">            for i in range(len(args[0])):</span><br><span class=\"line\">                self.tree.add(p[i], tuple(arg[i] for arg in args))</span><br><span class=\"line\">                if self._size &lt; self.capacity:</span><br><span class=\"line\">                    self._size += 1</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            self.tree.add(p, args)</span><br><span class=\"line\">            if self._size &lt; self.capacity:</span><br><span class=\"line\">                self._size += 1</span><br><span class=\"line\"></span><br><span class=\"line\">    def sample(self):</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        output: weights, [ss, as, rs, _ss, dones]</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        n_sample = self.batch_size if self.is_lg_batch_size else self._size</span><br><span class=\"line\">        interval = self.tree.total / n_sample</span><br><span class=\"line\">        segment = [self.tree.total - i * interval for i in range(n_sample + 1)]</span><br><span class=\"line\">        t = [self.tree.get(np.random.uniform(segment[i], segment[i + 1], 1)) for i in range(n_sample)]</span><br><span class=\"line\">        t = [np.array(e) for e in zip(*t)]</span><br><span class=\"line\">        self.last_indexs = t[0]</span><br><span class=\"line\">        return np.power(self.min_p / t[-2], self.beta), t[-1]</span><br><span class=\"line\"></span><br><span class=\"line\">    @property</span><br><span class=\"line\">    def is_lg_batch_size(self):</span><br><span class=\"line\">        return self._size &gt; self.batch_size</span><br><span class=\"line\"></span><br><span class=\"line\">    def update_priority(self, priority):</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        input: priorities</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        assert hasattr(priority, &apos;__len__&apos;)</span><br><span class=\"line\">        assert len(priority) == len(self.last_indexs)</span><br><span class=\"line\">        for i in range(len(priority)):</span><br><span class=\"line\">            self.tree._updatetree(self.last_indexs[i], priority[i])</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>这篇论文介绍了优先经验回放机制，它可以使学习过程更高效。</p>\n<p>推荐：</p>\n<ul>\n<li>实用技巧</li>\n<li>通俗易懂</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/pdf/1511.05952.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1511.05952.pdf</a></p>\n<p>之前重用经验（experience，transition转换五元组$\\lt s,a,r,s’,done \\ or \\ \\gamma\\gt$都是从经验池中<strong>均匀采样</strong>，忽略了经验的重要程度，文中提到的优先经验回放框架按经验重要性增大其被采样到的概率，希望越重要的经验使用次数越多，从而增加学习效率。</p>\n<p>文中应用算法：DQN</p>\n<p>效果：相比传统经验池机制，Atari 49游戏中41胜，8负</p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><blockquote>\n<p>Online reinforcement learning (RL) agents incrementally update their parameters (of the policy, value function or model) while they observe a stream of experience. In their simplest form, they discard incoming data immediately, after a single update. Two issues with this are (a) strongly correlated updates that break the i.i.d. assumption of many popular stochastic gradient-based algorithms, and (b) the rapid forgetting of possibly rare experiences that would be useful later on.<br>Experience replay  addresses both of these issues: with experience stored in a replay memory, it becomes possible to break the temporal correlations by mixing more and less recent experience for the updates, and rare experience will be used for more than just a single update.</p>\n</blockquote>\n<p>指出On-policy一般使用一个episode的数据进行参数更新，且数据用完即丢，这样做有两个缺点：</p>\n<ul>\n<li>数据（状态）相互关联，数据不具有独立同分布($i.i.d$)的性质，但许多流行的随机梯度算法往往有关于数据独立同分布的假设</li>\n<li>对罕见的（稀疏的）经验快速遗忘，忽略了这些罕见经验可能多次更新更有用的作用</li>\n</ul>\n<p><strong>经验池机制解决了上述两个问题</strong>，通过混合近期经验打破它们关于时间的关联性，并从经验池中采样经验学习多次。</p>\n<p>经验池机制的优势：</p>\n<ul>\n<li>稳定了DQN值函数的训练</li>\n<li>一般情况下，经验回放可以减少训练所需的经验数量，但是需要加大计算量，消耗更多的内存，但是这往往比智能体与环境进行交互来得更方便、容易</li>\n</ul>\n<blockquote>\n<p>In particular, we propose to more frequently replay transitions with high expected learning progress, s measured by the magnitude of their temporal-difference (TD) error. This prioritization can lead o a loss of diversity, which we alleviate with stochastic prioritization, and introduce bias, which e correct with importance sampling. </p>\n</blockquote>\n<p>文中根据TD-error设置优先经验回放的频率，这可能会引起两个问题：</p>\n<ul>\n<li>丢失样本多样性</li>\n<li>引入偏差</li>\n</ul>\n<p>分别解决方案：</p>\n<ul>\n<li>随机优先级 stochastic prioritization</li>\n<li>重要性采样</li>\n</ul>\n<blockquote>\n<p>The central component of prioritized replay is the criterion by which the importance of each transition is measured. One idealised criterion would be the amount the RL agent can learn from a transition in its current state (expected learning progress). While this measure is not directly accessible,  reasonable proxy is the magnitude of a transition’s TD error $\\delta$ indicates how ‘surprising’  or unexpected the transition is: specifically, how far the value is from its next-step bootstrap estimate.</p>\n</blockquote>\n<p>优先经验回放的核心部分是如何衡量样本的重要性，并根据其重要性进行回放。</p>\n<p>最直观的衡量标准是从经验样本中可以学习的量，但是这个量不可知、不可得，于是使用TD-error $\\delta$作为这个量的替代品以衡量样本重要性。 </p>\n<blockquote>\n<p>New transitions arrive without a known TD-error, so we put them at maximal priority in order to guarantee that all experience is seen at least once.  </p>\n</blockquote>\n<p>新的经验被存入经验池时不需计算TD-error，直接将其设置为当前经验池中最大的TD-error，保证其至少被抽中一次。</p>\n<hr>\n<p>既然使用TD-error作为衡量可学习的度量，那么完全可以用贪婪的方式，选取TD-error最大的几个进行学习，但这会有几个问题：</p>\n<ol>\n<li>由于只有在经验被重放<strong>之后</strong>，这个经验的TD-error才被更新，导致初始TD-error比较小的经验长时间不被使用，甚至永远不被使用。</li>\n<li>贪婪策略聚焦于一小部分TD-error比较高的经验，当使用值函数近似时，这些经验的TD-error减小速度很慢，导致这些经验被高频重复使用，致使样本缺乏多样性而过拟合。</li>\n</ol>\n<p>文中提到使用<strong>随机采样方法 stochastic sampling method</strong>在贪婪策略与均匀采样之间“差值”来解决上述问题，其实它是一个在样本使用上的trade-off，由超参数$\\alpha$控制</p>\n<p>使用优先经验回放还有一个问题是改变了状态的分布，我们知道DQN中引入经验池是为了解决数据相关性，使数据（尽量）独立同分布的问题。但是使用优先经验回放又改变了状态的分布，这样势必会引入偏差bias，对此，文中使用<strong>偏差退火——重要性采样结合退火因子</strong>，来消除引入的偏差。</p>\n<h2 id=\"随机采样方法\"><a href=\"#随机采样方法\" class=\"headerlink\" title=\"随机采样方法\"></a>随机采样方法</h2><script type=\"math/tex; mode=display\">\nP(i)=\\frac{p^{\\alpha}_{i}}{\\sum_{k}p^{\\alpha}_{k}}</script><p>$\\alpha$超参数控制采样在uniform和greedy的偏好，是一个trade-off因子：</p>\n<ul>\n<li>$\\alpha=0$，均匀采样</li>\n<li>$\\alpha=1$，贪婪策略采样</li>\n<li>$\\alpha \\in [0,1]$，文中没有明说$\\alpha$的取值范围</li>\n<li>引入$\\alpha$不改变优先级的单调性，只是适当调整高、低TD-error经验的优先级</li>\n</ul>\n<p>根据优先级$p_{i}$的设定可以将优先经验池的设计分为两种：</p>\n<ul>\n<li>直接的，基于比例的，proportional prioritization</li>\n<li>间接的，基于排名的，rank-based prioritization</li>\n</ul>\n<h3 id=\"Proportional-Prioritization\"><a href=\"#Proportional-Prioritization\" class=\"headerlink\" title=\"Proportional Prioritization\"></a>Proportional Prioritization</h3><script type=\"math/tex; mode=display\">\np_{i}=\\left | \\delta_{i} \\right | + \\epsilon</script><ul>\n<li>$\\delta$表示TD-error</li>\n<li>$\\epsilon$是一个小的正常数，防止TD-error为0的经验永远不被重放。</li>\n</ul>\n<h3 id=\"Rank-based-Prioritization\"><a href=\"#Rank-based-Prioritization\" class=\"headerlink\" title=\"Rank-based Prioritization\"></a>Rank-based Prioritization</h3><script type=\"math/tex; mode=display\">\np_{i}=\\frac{1}{rank(i)}</script><ul>\n<li>$rank(i)$是经验根据$\\left | \\delta_{i} \\right |$大小排序的排名</li>\n<li>$P$为指数$\\alpha$的幂律分布power-law distribution</li>\n<li>这种方式更具鲁棒性，因为其对异常点不敏感，主要是因为异常点的TD-error过大或过小对rank值没有太大影响</li>\n</ul>\n<p>优点：</p>\n<ul>\n<li>其重尾性、厚尾性、heavy-tail property保证采样多样性</li>\n<li>分层采样使mini-batch的梯度稳定</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>当在稀疏奖励场景想要使用TD-error分布结构时，会造成性能下降</li>\n</ul>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>根据文中实验，两种方式效果基本相同，但不同场景可能一个效果很好，一个效果一般般。作者<strong>猜想</strong>效果相同的原因可能是因为对奖励和TD-error大量使用clip操作，消除了异常值，作者本以为Rank-based更具鲁棒性的。</p>\n<blockquote>\n<p>Overhead is similar to rank-based prioritization.</p>\n</blockquote>\n<p>两者开销相同。</p>\n<h2 id=\"偏差退火-Annealing-The-Bias\"><a href=\"#偏差退火-Annealing-The-Bias\" class=\"headerlink\" title=\"偏差退火 Annealing The Bias\"></a>偏差退火 Annealing The Bias</h2><p>我觉得应该译为消除偏差。</p>\n<p>引入重要性采样、引入退火因子$\\beta$消除偏差。将$w_{i}$除以$max_{i}w_{i}$向下缩放（减小）梯度更新幅度，稳定算法</p>\n<script type=\"math/tex; mode=display\">\nw_{i}=\\left ( \\frac{1}{N} \\cdot \\frac{1}{P(i)} \\right )^{\\beta}</script><ul>\n<li>$\\beta=0$，完全不用重要性采样</li>\n<li>$\\beta=1$，常规重要性采样</li>\n<li><strong>在训练接近尾声时，使$\\beta \\rightarrow 1$ </strong></li>\n<li>$\\beta \\in [0,1]$，文中并没有明说$\\beta$的取值范围</li>\n<li>$\\beta$的选择与$\\alpha$有关，但文中并没有说明这两个参数如何选择的关系</li>\n</ul>\n<p>作用：</p>\n<ul>\n<li>消除偏差</li>\n</ul>\n<blockquote>\n<p>We therefore exploit the flexibility of annealing the amount of importance-sampling correction over time, by defining a schedule on the exponent β that reaches 1 only at the end of learning.</p>\n</blockquote>\n<p>应用退火重要性采样校正量的灵活性，使在学习快结束时，将$\\beta \\rightarrow 1$</p>\n<h1 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h1><p><img src=\"./Prioritized-Experience-Replay/pseudo.png\" alt=\"\"></p>\n<p><strong>解析</strong>：</p>\n<ul>\n<li>step-size $\\eta$可以看做是学习率，文中并没有说它具体的定义，只是说它可以调节参数更新幅度（不就是学习率嘛）</li>\n<li>$K$代表采样与更新之间的步数差，也就是，先采样K次经验并存入经验池，再取mini-batch更新。</li>\n<li>采样方式：<ul>\n<li><img src=\"./Prioritized-Experience-Replay/sum-tree.png\" alt=\"\"></li>\n<li>采样与更新TD-error的时间复杂度为$O(log_{2}N)$</li>\n</ul>\n</li>\n<li>学习完之后对学习使用的经验更新其TD-error</li>\n<li>重要性权重$w_{j}=\\left ( N \\cdot P(j)\\right )^{-\\beta}/max_{i}w_{i}$，由$max_{i}w_{i}=max_{i}\\left ( N \\cdot P(i)\\right )^{-\\beta}=\\left ( min_{i}N \\cdot P(i)\\right )^{-\\beta}=\\left ( N \\cdot P_{min}\\right )^{-\\beta}$,可以将其化简为$w_{j}=\\left ( \\frac{p_{min}}{p_{j}} \\right )^{\\beta}$</li>\n<li>第12行，赋值其实是$(\\left | \\delta_{i} \\right |+ \\epsilon)^{\\alpha}$，如果是rank-based，则为$rank(i)^{-\\alpha}$</li>\n<li>第6行，对于新采样到的经验，不必计算其TD-error，直接将其设置为最大即可，当使用该经验学习之后再计算其TD-error</li>\n<li>$\\Delta$其实就是误差函数$\\delta^{2}$对$\\theta$的导数，只不过对于mini-batch中的各个经验使用重要性比率进行了加权求和。</li>\n</ul>\n<p><strong>注意</strong>：</p>\n<blockquote>\n<p>Our final  solution was to store transitions in a priority queue implemented with an array-based binary heap. The heap array was then directly used as an approximation of a sorted array, which is infrequently sorted once every $10^{6}$ steps to prevent the heap becoming too unbalanced. </p>\n</blockquote>\n<p>如果使用rank-based方法，则使用的不是sum-tree结构，而是二进制堆，由于我不了解这个结构，故目前不做阐述。</p>\n<h1 id=\"Sum-Tree\"><a href=\"#Sum-Tree\" class=\"headerlink\" title=\"Sum Tree\"></a>Sum Tree</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sum_Tree</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, capacity)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        capacity = 5，设置经验池大小</span></span><br><span class=\"line\"><span class=\"string\">        tree = [0,1,2,3,4,5,6,7,8,9,10,11,12] 8-12存放叶子结点p值，1-7存放父节点、根节点p值的和，0存放树节点的数量</span></span><br><span class=\"line\"><span class=\"string\">        data = [0,1,2,3,4,5] 1-5存放数据， 0存放capacity</span></span><br><span class=\"line\"><span class=\"string\">        Tree structure and array storage:</span></span><br><span class=\"line\"><span class=\"string\">        Tree index:</span></span><br><span class=\"line\"><span class=\"string\">                    1         -&gt; storing priority sum</span></span><br><span class=\"line\"><span class=\"string\">              /          \\ </span></span><br><span class=\"line\"><span class=\"string\">             2            3</span></span><br><span class=\"line\"><span class=\"string\">            / \\          / \\</span></span><br><span class=\"line\"><span class=\"string\">          4     5       6   7</span></span><br><span class=\"line\"><span class=\"string\">         / \\   / \\     / \\  / \\</span></span><br><span class=\"line\"><span class=\"string\">        8   9 10   11 12                   -&gt; storing priority for transitions</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> capacity != <span class=\"number\">1</span></span><br><span class=\"line\">        self.now = <span class=\"number\">0</span></span><br><span class=\"line\">        self.parent_node_count = self.get_parent_node_count(capacity)</span><br><span class=\"line\">        print(self.parent_node_count)</span><br><span class=\"line\">        self.tree = np.zeros(self.parent_node_count + capacity + <span class=\"number\">1</span>)</span><br><span class=\"line\">        self.tree[<span class=\"number\">0</span>] = len(self.tree) - <span class=\"number\">1</span></span><br><span class=\"line\">        self.data = np.zeros(capacity + <span class=\"number\">1</span>, dtype=object)</span><br><span class=\"line\">        self.data[<span class=\"number\">0</span>] = capacity</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(self, p, data)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        p : 优先级</span></span><br><span class=\"line\"><span class=\"string\">        data : 数据元组</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        tree_index = self.now + self.parent_node_count + <span class=\"number\">1</span></span><br><span class=\"line\">        self.data[self.now + <span class=\"number\">1</span>] = data</span><br><span class=\"line\">        self._updatetree(tree_index, p)</span><br><span class=\"line\">        self.now += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.now &gt; self.data[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            self.now = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_updatetree</span><span class=\"params\">(self, tree_index, p)</span>:</span></span><br><span class=\"line\">        diff = p - self.tree[tree_index]</span><br><span class=\"line\">        self._propagate(tree_index, diff)</span><br><span class=\"line\">        self.tree[tree_index] = p</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_propagate</span><span class=\"params\">(self, tree_index, diff)</span>:</span></span><br><span class=\"line\">        parent = tree_index // <span class=\"number\">2</span></span><br><span class=\"line\">        self.tree[parent] += diff</span><br><span class=\"line\">        <span class=\"keyword\">if</span> parent != <span class=\"number\">1</span>:</span><br><span class=\"line\">            self._propagate(parent, diff)</span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">total</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.tree[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, seg_p_total)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        seg_p_total : 要采样的p的值</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        tree_index = self._retrieve(<span class=\"number\">1</span>, seg_p_total)</span><br><span class=\"line\">        data_index = tree_index - self.parent_node_count</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (tree_index, data_index, self.tree[tree_index], self.data[data_index])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_retrieve</span><span class=\"params\">(self, tree_index, seg_p_total)</span>:</span></span><br><span class=\"line\">        left = <span class=\"number\">2</span> * tree_index</span><br><span class=\"line\">        right = left + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"comment\">#         left = 2 * tree_index + 1</span></span><br><span class=\"line\"><span class=\"comment\">#         right = 2 * (tree_index + 1)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &gt;= self.tree[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tree_index</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._retrieve(left, seg_p_total) <span class=\"keyword\">if</span> seg_p_total &lt;= self.tree[left] <span class=\"keyword\">else</span> self._retrieve(right, seg_p_total - self.tree[left])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pp</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(self.tree, self.data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_parent_node_count</span><span class=\"params\">(self, capacity)</span>:</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> pow(<span class=\"number\">2</span>, i) &lt; capacity &lt;= pow(<span class=\"number\">2</span>, i + <span class=\"number\">1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> pow(<span class=\"number\">2</span>, i + <span class=\"number\">1</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">tree = Sum_Tree(<span class=\"number\">5</span>)</span><br><span class=\"line\">tree.add(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">tree.add(<span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">tree.add(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">tree.add(<span class=\"number\">4</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">tree.add(<span class=\"number\">6</span>, <span class=\"number\">11</span>)</span><br><span class=\"line\">tree.pp()</span><br><span class=\"line\">print(tree.get(<span class=\"number\">4</span>))</span><br></pre></td></tr></table></figure>\n<h1 id=\"优先经验回放的特点\"><a href=\"#优先经验回放的特点\" class=\"headerlink\" title=\"优先经验回放的特点\"></a>优先经验回放的特点</h1><ol>\n<li>新的transition被采样到时，需要将其TD-error设置为最大，以保证最近的经验更容易被采样到。</li>\n<li>只有在从经验池中抽取到某个经验并进行学习后，才对其TD-error进行计算更新。</li>\n</ol>\n<h1 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h1><p>算法：</p>\n<ul>\n<li>DQN</li>\n<li>优化后的Double DQN</li>\n<li>为了算法稳定的原因，将reward和TD-error clip到[-1,1]</li>\n</ul>\n<p>优先经验池：</p>\n<ul>\n<li><p>经验池大小$10^{6}$</p>\n</li>\n<li><p>batch-size为32</p>\n</li>\n<li><p>K=4，即每采样4次学习一次</p>\n</li>\n<li><p>Rank-based：$\\alpha=0.7，\\beta_{0}=0.5$，Proportional：$\\alpha=0.6，\\beta_{0}=0.4$</p>\n</li>\n<li><blockquote>\n<p>These choices are trading off aggressiveness with robustness, but it is easy to revert to a behavior closer to the baseline by reducing $\\alpha$ and/or increasing $\\beta$. </p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><h3 id=\"学习速度\"><a href=\"#学习速度\" class=\"headerlink\" title=\"学习速度\"></a>学习速度</h3><p><img src=\"./Prioritized-Experience-Replay/learning-speed.png\" alt=\"\"></p>\n<ul>\n<li>黑色代表不使用优先经验回放的DDQN</li>\n<li>蓝色代表使用Proportional Prioritization的DDQN</li>\n<li><p>红色代表使用Rank-based Prioritization的DDQN</p>\n</li>\n<li><p>绿色的虚线为人类水平</p>\n</li>\n</ul>\n<h3 id=\"归一化得分\"><a href=\"#归一化得分\" class=\"headerlink\" title=\"归一化得分\"></a>归一化得分</h3><p>这些度量不重要，重要的是使用了优先经验回放机制的确提升了2倍左右的性能。</p>\n<p><img src=\"./Prioritized-Experience-Replay/normalized-score1.png\" alt=\"\"></p>\n<p><img src=\"./Prioritized-Experience-Replay/normalized-score.png\" alt=\"\"></p>\n<h1 id=\"PER的代码\"><a href=\"#PER的代码\" class=\"headerlink\" title=\"PER的代码\"></a>PER的代码</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import numpy as np</span><br><span class=\"line\">from abc import ABC, abstractmethod</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class Buffer(ABC):</span><br><span class=\"line\">    @abstractmethod</span><br><span class=\"line\">    def sample(self) -&gt; list:</span><br><span class=\"line\">        pass</span><br><span class=\"line\"></span><br><span class=\"line\">class Sum_Tree(object):</span><br><span class=\"line\">    def __init__(self, capacity):</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        capacity = 5，设置经验池大小</span><br><span class=\"line\">        tree = [0,1,2,3,4,5,6,7,8,9,10,11,12] 8-12存放叶子结点p值，1-7存放父节点、根节点p值的和，0存放树节点的数量</span><br><span class=\"line\">        data = [0,1,2,3,4,5] 1-5存放数据， 0存放capacity</span><br><span class=\"line\">        Tree structure and array storage:</span><br><span class=\"line\">        Tree index:</span><br><span class=\"line\">                    1         -&gt; storing priority sum</span><br><span class=\"line\">              /          \\ </span><br><span class=\"line\">             2            3</span><br><span class=\"line\">            / \\          / \\</span><br><span class=\"line\">          4     5       6   7</span><br><span class=\"line\">         / \\   / \\     / \\  / \\</span><br><span class=\"line\">        8   9 10   11 12                   -&gt; storing priority for transitions</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        assert capacity &gt; 0</span><br><span class=\"line\">        self.now = 0</span><br><span class=\"line\">        self.parent_node_count = self.get_parent_node_count(capacity)</span><br><span class=\"line\">        print(self.parent_node_count)</span><br><span class=\"line\">        self.tree = np.zeros(self.parent_node_count + capacity + 1)</span><br><span class=\"line\">        self.tree[0] = len(self.tree) - 1</span><br><span class=\"line\">        self.data = np.zeros(capacity + 1, dtype=object)</span><br><span class=\"line\">        self.data[0] = capacity</span><br><span class=\"line\"></span><br><span class=\"line\">    def add(self, p, data):</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        p : property</span><br><span class=\"line\">        data : [s, a, r, s_, done]</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        tree_index = self.now + self.parent_node_count + 1</span><br><span class=\"line\">        self.data[self.now + 1] = data</span><br><span class=\"line\">        self._updatetree(tree_index, p)</span><br><span class=\"line\">        self.now += 1</span><br><span class=\"line\">        if self.now &gt; self.data[0]:</span><br><span class=\"line\">            self.now = 0</span><br><span class=\"line\"></span><br><span class=\"line\">    def _updatetree(self, tree_index, p):</span><br><span class=\"line\">        diff = p - self.tree[tree_index]</span><br><span class=\"line\">        self._propagate(tree_index, diff)</span><br><span class=\"line\">        self.tree[tree_index] = p</span><br><span class=\"line\"></span><br><span class=\"line\">    def _propagate(self, tree_index, diff):</span><br><span class=\"line\">        parent = tree_index // 2</span><br><span class=\"line\">        self.tree[parent] += diff</span><br><span class=\"line\">        if parent != 1:</span><br><span class=\"line\">            self._propagate(parent, diff)</span><br><span class=\"line\"></span><br><span class=\"line\">    @property</span><br><span class=\"line\">    def total(self):</span><br><span class=\"line\">        return self.tree[1]</span><br><span class=\"line\"></span><br><span class=\"line\">    def get(self, seg_p_total):</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        seg_p_total : The value of priority to sample</span><br><span class=\"line\">        &quot;&quot;&quot;</span><br><span class=\"line\">        tree_index = self._retrieve(1, seg_p_total)</span><br><span class=\"line\">        data_index = tree_index - self.parent_node_count</span><br><span class=\"line\">        return (tree_index, data_index, self.tree[tree_index], self.data[data_index])</span><br><span class=\"line\"></span><br><span class=\"line\">    def _retrieve(self, tree_index, seg_p_total):</span><br><span class=\"line\">        left = 2 * tree_index</span><br><span class=\"line\">        right = left + 1</span><br><span class=\"line\">#         left = 2 * tree_index + 1</span><br><span class=\"line\">#         right = 2 * (tree_index + 1)</span><br><span class=\"line\">        if left &gt;= self.tree[0]:</span><br><span class=\"line\">            return tree_index</span><br><span class=\"line\">        return self._retrieve(left, seg_p_total) if seg_p_total &lt;= self.tree[left] else self._retrieve(right, seg_p_total - self.tree[left])</span><br><span class=\"line\"></span><br><span class=\"line\">    def pp(self):</span><br><span class=\"line\">        print(self.tree, self.data)</span><br><span class=\"line\"></span><br><span class=\"line\">    def get_parent_node_count(self, capacity):</span><br><span class=\"line\">        i = 0</span><br><span class=\"line\">        while True:</span><br><span class=\"line\">            if pow(2, i) &lt; capacity &lt;= pow(2, i + 1):</span><br><span class=\"line\">                return pow(2, i + 1) - 1</span><br><span class=\"line\">            i += 1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class PrioritizedReplayBuffer(Buffer):</span><br><span class=\"line\">    def __init__(self, batch_size, capacity, alpha, beta, epsilon):</span><br><span class=\"line\">        self.batch_size = batch_size</span><br><span class=\"line\">        self.capacity = capacity</span><br><span class=\"line\">        self._size = 0</span><br><span class=\"line\">        self.alpha = alpha</span><br><span class=\"line\">        self.beta = beta</span><br><span class=\"line\">        self.tree = Sum_Tree(capacity)</span><br><span class=\"line\">        self.epsilon = epsilon</span><br><span class=\"line\">        self.min_p = np.inf</span><br><span class=\"line\"></span><br><span class=\"line\">    def add(self, p, *args):</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        input: priorities, [ss, as, rs, _ss, dones]</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        p = np.power(np.abs(p) + self.epsilon, self.alpha)</span><br><span class=\"line\">        min_p = p.min()</span><br><span class=\"line\">        if min_p &lt; self.min_p:</span><br><span class=\"line\">            self.min_p = min_p</span><br><span class=\"line\">        if hasattr(args[0], &apos;__len__&apos;):</span><br><span class=\"line\">            for i in range(len(args[0])):</span><br><span class=\"line\">                self.tree.add(p[i], tuple(arg[i] for arg in args))</span><br><span class=\"line\">                if self._size &lt; self.capacity:</span><br><span class=\"line\">                    self._size += 1</span><br><span class=\"line\">        else:</span><br><span class=\"line\">            self.tree.add(p, args)</span><br><span class=\"line\">            if self._size &lt; self.capacity:</span><br><span class=\"line\">                self._size += 1</span><br><span class=\"line\"></span><br><span class=\"line\">    def sample(self):</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        output: weights, [ss, as, rs, _ss, dones]</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        n_sample = self.batch_size if self.is_lg_batch_size else self._size</span><br><span class=\"line\">        interval = self.tree.total / n_sample</span><br><span class=\"line\">        segment = [self.tree.total - i * interval for i in range(n_sample + 1)]</span><br><span class=\"line\">        t = [self.tree.get(np.random.uniform(segment[i], segment[i + 1], 1)) for i in range(n_sample)]</span><br><span class=\"line\">        t = [np.array(e) for e in zip(*t)]</span><br><span class=\"line\">        self.last_indexs = t[0]</span><br><span class=\"line\">        return np.power(self.min_p / t[-2], self.beta), t[-1]</span><br><span class=\"line\"></span><br><span class=\"line\">    @property</span><br><span class=\"line\">    def is_lg_batch_size(self):</span><br><span class=\"line\">        return self._size &gt; self.batch_size</span><br><span class=\"line\"></span><br><span class=\"line\">    def update_priority(self, priority):</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        input: priorities</span><br><span class=\"line\">        &apos;&apos;&apos;</span><br><span class=\"line\">        assert hasattr(priority, &apos;__len__&apos;)</span><br><span class=\"line\">        assert len(priority) == len(self.last_indexs)</span><br><span class=\"line\">        for i in range(len(priority)):</span><br><span class=\"line\">            self.tree._updatetree(self.last_indexs[i], priority[i])</span><br></pre></td></tr></table></figure>"},{"title":"Reinforcement Learning with Deep Energy-Based Policies","copyright":true,"mathjax":true,"top":1,"date":"2019-06-26T07:12:39.000Z","keywords":null,"description":null,"_content":"\n本文提出了一个算法，用于学习连续空间下基于能量的策略：SQL，不是数据库的SQL，而是soft Q-Learning。该算法应用了最大熵理论，并且使用能量模型（EBM，Energy-Based Model）作为决策模型。\n\n推荐阅读该论文：\n\n- 公式复杂，但详尽吃透可以学习到SVGD、EBM等概念与算法\n- 文章充实，可以继续阅读后续算法SAC\n- 拓展在强化学习与熵进行结合方面的知识\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/abs/1702.08165](https://arxiv.org/abs/1702.08165)\n\n源代码：[https://github.com/rail-berkeley/softlearning](https://github.com/rail-berkeley/softlearning)\n\n该论文与2017年发于第34次ICML会议上，本文对v2版本进行分析。该论文作者为Tuomas Haarnoja，是伯克利大学BAIR实验室的博士生，SAC算法也是他的杰作。\n\n传统的RL方法主要是用分布拟合单峰分布，即\n\n![](./rl-with-deep-energy-based-policies/unimodal-policy.png)\n\n也有许多算法想要根据Q函数的值拟合出多峰分布，即\n\n![](./rl-with-deep-energy-based-policies/multimodal-policy.png)\n\n本文中就是针对拟合多峰分布提出了算法SQL。\n\n为什么要拟合多峰分布呢？当我们考虑最优控制和概率推理之间的联系时，随机策略才是最优解。\n\n> As discussed in prior work, a stochastic policy emerges as the optimal answer when we consider the connection between optimal control and probabilistic inference.\n\n随机策略有一些优点：\n\n- 如果可以全面地学习给定任务中的目标策略，那么结果策略可以作为很好的初始化策略，微调后以学习更高级的策略\n- 这种随机的探索机制，可以更好地寻求多峰任务中的最佳决策模型\n- 更好的鲁棒性，环境有干扰或者噪音时，有多种完成目标的行动可以选择，可以从干扰中“脱身”\n\n## 算法效果\n\n> The applications of training such stochastic policies include improved exploration in the case of multimodal objectives and compositionality via pretraining general-purpose stochastic policies that can then be efficiently finetuned into task-specific behaviors. \n\n在多峰目标任务中训练随机策略可以提升探索，也可以预训练出通用目的的随机策略以微调后运用至指定任务中进行训练（迁移学习、元学习）。\n\n# 文中精要\n\n## 标准强化学习的最优策略\n\n$$\n\\pi_{\\mathrm{std}}^{*}=\\arg \\max _{\\pi} \\sum_{t} \\mathbb{E}_{\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\sim \\rho_{\\pi}}\\left[r\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right] \\tag{1}\n$$\n\n- `std`下标代表标准的意思：standard，星号$\\ast$代表最优\n\n- $\\rho_{\\pi}$代表策略$\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right)$下的迹分布，$\\rho_{\\pi}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)$代表状态-行动对的边缘分布。\n\n> We will also use $\\rho_{\\pi}\\left(\\mathbf{s}_{t}\\right)$ and $\\rho_{\\pi}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)$ to denote the state and state-action marginals of the trajectory distribution induced by a policy $\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right)$. \n\n## 最大熵强化学习的最优策略\n\n最大熵强化学习在标准RL的目标函数上加入了一个关于状态下可选动作分布熵的项，这种目标希望智能体不仅能以获得最大奖励的方式完成目标，而且能够决策地尽可能随机。因为通过这种目标函数学到的策略**更具鲁棒性**，可以更好适用于环境的突然变化，或者从前没有遇到过得场景。\n$$\n\\pi_{\\mathrm{MaxEnt}}^{*}=\\arg \\max _{\\pi} \\sum_{t} \\mathbb{E}_{\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\sim \\rho_{\\pi}}\\left[r\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)+\\color{red}{\\alpha \\mathcal{H}\\left(\\pi\\left(\\cdot | \\mathbf{s}_{t}\\right)\\right)}\\right]\n\\tag{2}\n$$\n\n- `MaxEnt`下标代表最大熵的意思：Maximum entropy\n- 式中的系数$\\alpha$可以用来调节奖励项与熵值项的重要性比率。**一般将$\\alpha$表示为奖励范围（reward scale）的倒数，但在实际中通常将其作为超参数手动调节。**SAC算法中有介绍在训练过程中自动调节该系数的方法。\n- 本文中的SQL算法也是为了优化该目标函数\n\n## 最大熵目标的优点\n\n- 在多峰（即一个状态下有多个最优动作选择）问题中提升探索能力\n- 可以用于迁移学习，因为其“预训练”模型更好地适应之后的任务\n\n## soft 值函数\n\n文中，***定义***了最大熵RL下的Q函数与V函数，注意，是定义，不是推导出来的。\n\nsoft Q函数定义如下：\n$$\n{Q_{\\text { soft }}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+}  {\\mathbb{E}_{\\left(\\mathbf{s}_{t+1}, \\ldots\\right) \\sim \\rho_{\\pi}}\\left[\\sum_{l=1}^{\\infty} \\gamma^{l}\\left(r_{t+l}+\\alpha \\mathcal{H}\\left(\\pi_{\\text { MaxEnt }}^{*}\\left(\\cdot | \\mathbf{s}_{t+l}\\right)\\right)\\right)\\right]}\n\\tag{3}\n$$\nsoft V函数定义如下：\n$$\nV_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)=\\alpha \\log \\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}\n\\tag{4}\n$$\n乍一看这个值函数$V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)$的形式定义的很奇怪，的确很奇怪，严格来说，它的真实意义并不是为了构造状态值函数，而是构造一个配分函数使得后面推导最优策略时可以化简过程。当然，算法中也不需要用它的值去衡量状态的价值，只是作为计算的中间过程。\n\n作者说，值函数满足soft 贝尔曼方程，即\n$$\nQ_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t+1}\\right)\\right]\n\\tag{5}\n$$\n\n## 能量模型与策略\n\n文中提出能量模型（Energy-Based Models）的初衷是之前很多人在研究中使用了多项式分布（discrete multinomial distributions）、高斯分布（Gaussian distributions）来表示策略，这样的分布通常用来表示动作价值分布是单峰（unimodal）的情况，而且最终收敛结果往往是接近确定性（near-deterministic）的。即使拓展出多峰的形式，也各自有或多或少的不足。基于此，作者想使用更广泛、通用的分布用来表示复杂、多峰的动作选择。\n\n所以，作者选择使用基于能量的通用策略：\n$$\n\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right) \\propto \\exp \\left(-\\mathcal{E}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right)\n\\tag{6}\n$$\n\n- $\\mathcal{E}$是字母E的花体形式，代表能量函数，其可以被深度神经网络表示，如果使用通用值函数近似来表示能量函数，那么可以表示任意策略$\\pi\\left(\\boldsymbol{a}_{t} | \\mathbf{s}_{t}\\right)$\n\n- > where $\\mathcal{E}$ is an energy function that could be represented, for example, by a deep neural network. If we use a universal function approximator for $\\mathcal{E}$, we can represent any distribution $\\pi\\left(\\boldsymbol{a}_{t} | \\mathbf{s}_{t}\\right)$. \n\n- 文中将该能量函数设置为\n  $$\n  \\mathcal{E}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=-\\frac{1}{\\alpha} Q_{\\operatorname{soft}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\n  \\tag{7}\n  $$\n  其实也很容易就能理解，将负号抵消掉之后，Q值大的动作能量高嘛，指数分布又能更好的放大较大的值，使Q值大的动作更为突出，这样完全可以作为选择动作的策略\n\n但是有一个问题是，不能使能量无限大呀，假如超过了计算能力那就不好了，当然这种情况几乎不会发生。于是，可以将能量给归一化，即\n$$\n\\begin{aligned} \n\\pi_{\\text { MaxEnt }}^{*}\\left(a_{t} | s_{t}\\right) \n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right) \\mathrm{d} a^{\\prime}} \\\\ \n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\exp \\left(\\frac{1}{\\alpha} V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)} \\\\\n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\color{blue}{\\exp \\log} \\exp \\left(\\frac{1}{\\alpha} V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)} \\\\\n&=\\color{red}{\\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)-V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)\\right)}\n\\end{aligned}\n\\tag{8}\n$$\n\n<p align=\"center\" style=\"color:blue\" ><a href=\"https://bluefisher.github.io/2018/11/13/Reinforcement-Learning-with-Deep-Energy-Based-Policies/\">BlueFisher's Blog</a></p>\n论文中只给出了红色字体的部分，其实这才是作者想要表达的意思，文中就是基于此定义了状态值函数$V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)$的形式。\n\n在这个公式中就可以看出，策略是对动作值函数Q进行了一个softmax操作，这也是文中soft的含义。\n\n## 使用SQL优化目标函数\n\n像使用Q-Learning对网格世界问题进行优化求解一样，我们也可以使用迭代的方式进行优化，交互计算两个值函数，使其各自收敛，就可以导出最优策略。\n\n于是，作者定义了soft Q-Iteration。\n\n### Soft Q-Iteration\n\n先要假设值函数$Q_{\\mathrm{soft}}(\\cdot, \\cdot)$、$V_{\\text { soft }}(\\cdot)$有界，\n$$\n\\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}\\left(\\cdot, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}<\\infty \\ ，\\ Q_{\\mathrm{soft}}^{*}<\\infty\n\\tag{9}\n$$\n文中定义的交互迭代至收敛的方式其实跟SARSA算法比较像：\n$$\n\\begin{array}{c}\n{Q_{\\text { soft }}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\leftarrow r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\text { soft }}\\left(\\mathbf{s}_{t+1}\\right)\\right], \\forall \\mathbf{s}_{t}, \\mathbf{a}_{t}} \\\\ \n{V_{\\text { soft }}\\left(\\mathbf{s}_{t}\\right) \\leftarrow \\alpha \\log \\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}, \\forall \\mathbf{s}_{t}}\n\\end{array}\n\\tag{10}\n$$\n这种优化方式在理论上是可行的，但是在实际应用中存在两个问题：\n\n1. 连续空间无法求期望，或者计算不准确。**解决方案是重要性采样，使用采样多次后计算来代替积分，在初期进行随机均匀采样，后期根据policy来采样。**\n2. 迭代过程需要不断选择动作，问题是式（8）的分布形式无法进行采样。**解决方案是使用SVGD算法拟合后验分布，并输出采样的动作。**\n\n### Soft Q-Learning\n\n文中在这一部分引用了重要性采样，解决了上面提到的第一个问题，即，使用分布$q_{\\mathrm{a}^{\\prime}}$来代替真实策略分布\n$$\n\\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)-V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)\\right\n)\n$$\n进行采样。\n$$\nV_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}\\right)=\\alpha \\log \\mathbb{E}_{\\color{red}{q_{\\mathrm{a}^{\\prime}}}}\\left[\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right)}{q_{\\mathrm{a}^{\\prime}}\\left(\\mathbf{a}^{\\prime}\\right)}\\right]\n\\tag{11}\n$$\n采样分布$q_{\\mathrm{a}^{\\prime}}$可以使用任意的分布，但是由于重要性采样的性质，采样分布与原分布越接近，效果越好。式子中的$\\theta$为Q神经网络的参数。\n\n因为在训练初期，我们估计的真实分布是偏差很大的，几乎可以说是错误的，因此在训练初期将采样分布设置为均匀分布比较合理，在训练一段时间之后，可以将采样分布设置为接近原分布，甚至是原分布（如果原分布可以采样，如，使用神经网络等“黑匣子”进行表示）\n\n由此，可以定义Q神经网络的损失函数为：\n$$\nJ_{Q}(\\theta)=\\mathbb{E}_{\\mathbf{s}_{t} \\sim q_{\\mathbf{s}_{t}}, \\mathbf{a}_{t} \\sim q_{\\mathbf{a}_{t}}}\\left[\\frac{1}{2}\\left(\\hat{Q}_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)-Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right)^{2}\\right]\n\\tag{12}\n$$\n上式中期望的下标为环境和真实策略分布，$\\overline{\\theta}$代表target网络的参数，目标是最小化这个损失函数，其中，\n$$\n\\hat{Q}_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t+1}\\right)\\right]\n\\tag{13}\n$$\n### 近似采样与SVGD\n\nSVGD：Stein Vairational Gradient Descent，SVGD是一种确定性的、基于梯度的近似推理采样算法。\n\n文中在这一部分引用了SVGD的优化算法，并且使用SVGD近似策略的后验分布以进行采样，解决了上文提到的第二个问题。在百度上完全搜不到关于SVGD算法的信息，但是了解了这个算法之后，感觉它的能力还是很强的，最终，搜集了Google、Bing的检索结果，发现了原作者在SVGD方法上的一些资源分享，[Stein’s Method for Practical Machine Learning](https://www.cs.utexas.edu/~lqiang/stein.html)\n\n对于基于能量的模型、分布，有两类采样方式：\n\n1. MCMC采样，即马尔科夫链蒙特卡洛采样\n2. 学习一个采样网络去近似采样出符合目标分布的样本\n\n在需要不断更新策略的在线学习任务中，使用MCMC采样是不可行的，于是作者使用了基于SVGD和Amortized SVGD的采样网络。\n\nSVGD论文：[https://arxiv.org/abs/1608.04471](https://arxiv.org/abs/1608.04471)\n\nAmortized SVGD论文：[https://arxiv.org/abs/1707.06626](https://arxiv.org/abs/1707.06626)\n\n![](./rl-with-deep-energy-based-policies/1dgmm.gif)\n![](./rl-with-deep-energy-based-policies/vp.gif)\n\nAmortized SVGD有一些有趣的性质：\n\n- 可以训练随机采样网络非常快地采样\n- 可以准确收敛至EBM能量模型的后验估计分布\n- 文中结合了Amortized SVGD后，算法形式很像A-C模式\n\nSVGD算法的更新形式是这样的，\n$$\nx_{i} \\leftarrow x_{i}+\\frac{\\epsilon}{n} \\sum_{j=1}^{n}\\left[k\\left(x_{j}, x_{i}\\right) \\nabla_{x_{j}} \\log p\\left(x_{j}\\right)+\\nabla_{x_{j}} k\\left(x_{j}, x_{i}\\right)\\right], \\qquad \\forall i=1, \\ldots, n\n\\tag{14}\n$$\n- $\\epsilon$代表学习率\n- $k\\left(x_{j}, x_{i}\\right)$代表正定核，如径向基（RBF，Radial Basis Function）函数$k\\left(x, x^{\\prime}\\right)=\\exp \\left(-\\frac{1}{h}\\left\\|x-x^{\\prime}\\right\\|_{2}^{2}\\right)$，它可以被认为是变量之间的相似性度量\n- 包含对数项$\\log p\\left(x_{j}\\right)$的梯度驱使采样器朝着$p(x)$分布中高概率区域进行采样\n- 第二项核函数梯度驱使样本点之间产生间隙，相当于用一个排斥力使样本点尽可能分散开\n- 对数项梯度不依赖分布$p(x)$的归一化常数，使SVGD易于应用于图模型、贝叶斯推理和深层生成模型中出现的难以处理的分布。\n\n先定义我们采样网络（其实就是Actor）的目标函数：\n$$\nJ_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)=D_{\\mathrm{KL}}\\left(\\pi^{\\phi}\\left(\\cdot | \\mathbf{s}_{t}\\right) \\| \\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\cdot\\right)-V_{\\mathrm{soft}}^{\\theta}\\right)\\right)\\right)\n\\tag{15}\n$$\n- $\\phi$表示采样网络中的参数\n- 将产生动作的函数简写成$\\mathbf{a}_{t}^{(i)}=f^{\\phi}\\left(\\xi^{(i)} ; \\mathbf{s}_{t}\\right)$，也就是说神经网络的输入分为两部分，一部分是状态$s$，一部分是噪声扰乱“perturb”$\\xi$，一般从标准正态分布中采样，而且最好使噪声的维度与动作的维度一致\n\n计算梯度方向：\n$$\n\\begin{aligned}\n\\Delta f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)=& \\mathbb{E}_{\\mathbf{a}_{t} \\sim \\pi^{\\phi}}\\left[\\kappa\\left(\\mathbf{a}_{t}, f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)\\right) \\nabla_{\\mathbf{a}^{\\prime}} Q_{\\mathrm{soft}}^{\\theta}\\left.\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{t}}\\right.\\\\ &+\\alpha \\nabla_{\\mathbf{a}^{\\prime}} \\kappa\\left.\\left(\\mathbf{a}^{\\prime}, f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{t}} ] \\end{aligned}\n\\tag{16}\n$$\n- 严格来说，$\\Delta f^{\\phi}$是希尔伯特空间的最优梯度方向，并不是Actor目标函数$J_{\\pi}$的梯度\n\n- > To be precise, $\\Delta f^{\\phi}$ is the optimal direction in the reproducing kernel Hilbert space of $\\kappa$, and is thus not strictly speaking the gradient of $J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)$ \n\n根据链式法则，Stein变分梯度SVG为\n$$\n\\frac{\\partial J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)}{\\partial \\phi} \\propto \\mathbb{E}_{\\xi}\\left[\\Delta f^{\\phi}\\left(\\xi ; \\mathbf{s}_{t}\\right) \\frac{\\partial f^{\\phi}\\left(\\xi ; \\mathbf{s}_{t}\\right)}{\\partial \\phi}\\right]\n\\tag{17}\n$$\n## 伪代码\n\n![](./rl-with-deep-energy-based-policies/pseudo.png)\n\n解析：\n\n算法中更新Actor网络时，其实是使用了如下梯度公式：\n$$\n\\hat{\\nabla}_{\\phi} J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)=\\frac{1}{K M} \\sum_{j=1}^{K} \\sum_{i=1}^{M}\\left(\\kappa\\left(\\mathbf{a}_{t}^{(i)}, \\tilde{\\mathbf{a}}_{t}^{(j)}\\right) \\nabla_{\\mathbf{a}^{\\prime}} Q_{\\mathrm{soft}}\\left.\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{i}^{(i)}}+\\nabla_{\\mathbf{a}^{\\prime}} \\kappa\\left.\\left(\\mathbf{a}^{\\prime}, \\tilde{\\mathbf{a}}_{t}^{(j)}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{i}^{(i)}}\\right) \\nabla_{\\phi} f^{\\phi}\\left(\\tilde{\\xi}^{(j)} ; \\mathbf{s}_{t}\\right)\n\\tag{18}\n$$\n更新方向为mini-batch经验的梯度平均值，而不是累加和\n\n- 伪代码中定义了Actor的target网络，参数为$\\overline{\\theta}$。但是伪代码中并没有显示出其在何处使用，我**猜测**该网络代表采样分布$q_{\\mathbf{a}^{\\prime}}$\n  - $q_{\\mathbf{a}^{\\prime}}$在训练初期使用均匀分布\n  - $q_{\\mathbf{a}^{\\prime}}$在一段时间之后使用Actor真实分布，我猜测这里使用的就是Actor目标网络\n- 噪音$\\xi$从多维标准正态分布中采样，维度最好与动作空间维度一致\n- $\\left\\{\\mathbf{a}^{(i, j)}\\right\\}_{j=0}^{M} \\sim q_{\\mathbf{a}^{\\prime}}$其中的M用于设置采样多少个样本，以使用公式（11）计算V值，使用的网络为Q目标网络\n- 在更新Q网络时，使用了从经验池采样到的真实执行过的动作\n- $\\left\\{\\xi^{(i, j)}\\right\\}_{j=0}^{M} \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{I})$中其实少写了一个参数$K$，但实际上$K=M$，在这一步中需要采样两组噪音，当然也可以采样一组，使用两次。\n- 在更新Actor网络时，没有使用经验池中采样到的动作，而模拟采样了两组动作，即根据两组噪音生成的动作，用它们来计算梯度并更新。\n- Q网络的输入为状态与动作的连接，$(s||a)$，输出为Q值\n- Actor网络的输入为状态与噪音的连接，$(s||\\xi)$，输出为动作$a$\n- 伪代码中的式(10)、(11)、(13)、(14)分别代表本文中的式(11)、(12)、(16)、(17)\n\n# 实验\n\n## 实验设置\n\n- 比较算法：DDPG vs SQL\n- Actor和Q网络使用Adam优化器\n- Actor学习率为0.0001，Q网络学习率为0.001\n- 经验池大小为100W\n- 经验池填充1W条经验后开始训练\n- batch_size=64\n- Actor和Q网络都是2层隐藏层，每层200个隐藏节点，激活函数为ReLU\n- DDPG和SQL都使用了Ornstein-Uhlenbeck随机过程产生噪音来增加探索，它是一种序贯相关的随机过程，$\\theta=0.15 \\ , \\ \\sigma=0.3$\n  - OU随机过程可以在序贯模型中添加与时间相关的随机噪音，而且噪音也满足强马尔可夫性\n  \n  - 形式为$d x_{t}=\\theta\\left(\\mu-x_{t}\\right) d t+\\sigma d W_{t}$，是一个具有均值恢复属性的随机过程\n  \n  - $\\theta$表示变量$x$以多大幅度、多块恢复到平均值，$\\mu$代表平均值，$\\sigma$代表波动程度，$d W_{t}$代表维纳过程，一般通过高斯分布实现\n  \n  - OU随机过程产生的噪音只与上一次产生的噪音相关，它可以用于增加探索，也能够柔顺控制。比如在相邻的两个决策动作，一个为10，一个为-10，反复如此，智能体会产生震荡。在此使用OU过程可以使智能体在一个方向保持一定时间，不会瞬间过大地改变智能体的状态，相当于增加了时滞性。\n  \n  - 代码\n  \n    ```\n    x = 10\n    dx = theta * (mu - x) + sigma * numpy.random.randn(len(x))\n    x = x + dx\n    ```\n  \n  - 参考：\n  \n    - [https://www.quora.com/Why-do-we-use-the-Ornstein-Uhlenbeck-Process-in-the-exploration-of-DDPG](https://www.quora.com/Why-do-we-use-the-Ornstein-Uhlenbeck-Process-in-the-exploration-of-DDPG)\n    - [https://github.com/floodsung/DDPG-tensorflow/blob/master/ou_noise.py](https://github.com/floodsung/DDPG-tensorflow/blob/master/ou_noise.py)\n    - [https://zhuanlan.zhihu.com/p/51333694](https://zhuanlan.zhihu.com/p/51333694)\n- 核函数使用了径向基函数RBF，$\\kappa\\left(\\mathbf{a}, \\mathbf{a}^{\\prime}\\right)=\\exp \\left(-\\frac{1}{h}\\left\\|\\mathbf{a}-\\mathbf{a}^{\\prime}\\right\\|_{2}^{2}\\right)$，其中，$h=\\frac{d}{2 \\log (M+1)}$，$d$为各变量对之间距离的中位数\n- 目标网络的更新采样硬覆盖的模式\n- 超参数$\\alpha$根据任务设置为10，0.1等等\n- 训练的epoch、步长、系数$\\alpha$，采样动作的数量$K 和 M$根据任务（多目标，单目标，微调）的不同而不同，具体请看原论文附录D部分\n\n## 实验结果\n\n未完待续\n\n# 个人感想\n\n虽然文中用大量公式、篇幅结合最大熵进行介绍、推理，但是在伪代码以及目标函数中似乎并没有看到关于熵的影子，包含熵项的Q值也是通过Q网络的输出将熵的值包含在内，并没有显式地计算它。\n\n虽然算法的名字为soft Q-Learning，但其实它跟传统的Q-Learning算法思想并不相同，如果说有一点相同，那也是都是想使Q值收敛以推导出最优策略，但是这个优化过程也跟SARSA算法比较像，并没有使用传统Q-Learning中贪婪的选择最有价值下一个动作以自举的方法。","source":"_posts/rl-with-deep-energy-based-policies.md","raw":"---\ntitle: Reinforcement Learning with Deep Energy-Based Policies\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2019-06-26 15:12:39\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n本文提出了一个算法，用于学习连续空间下基于能量的策略：SQL，不是数据库的SQL，而是soft Q-Learning。该算法应用了最大熵理论，并且使用能量模型（EBM，Energy-Based Model）作为决策模型。\n\n推荐阅读该论文：\n\n- 公式复杂，但详尽吃透可以学习到SVGD、EBM等概念与算法\n- 文章充实，可以继续阅读后续算法SAC\n- 拓展在强化学习与熵进行结合方面的知识\n\n<!--more-->\n\n# 简介\n\n论文地址：[https://arxiv.org/abs/1702.08165](https://arxiv.org/abs/1702.08165)\n\n源代码：[https://github.com/rail-berkeley/softlearning](https://github.com/rail-berkeley/softlearning)\n\n该论文与2017年发于第34次ICML会议上，本文对v2版本进行分析。该论文作者为Tuomas Haarnoja，是伯克利大学BAIR实验室的博士生，SAC算法也是他的杰作。\n\n传统的RL方法主要是用分布拟合单峰分布，即\n\n![](./rl-with-deep-energy-based-policies/unimodal-policy.png)\n\n也有许多算法想要根据Q函数的值拟合出多峰分布，即\n\n![](./rl-with-deep-energy-based-policies/multimodal-policy.png)\n\n本文中就是针对拟合多峰分布提出了算法SQL。\n\n为什么要拟合多峰分布呢？当我们考虑最优控制和概率推理之间的联系时，随机策略才是最优解。\n\n> As discussed in prior work, a stochastic policy emerges as the optimal answer when we consider the connection between optimal control and probabilistic inference.\n\n随机策略有一些优点：\n\n- 如果可以全面地学习给定任务中的目标策略，那么结果策略可以作为很好的初始化策略，微调后以学习更高级的策略\n- 这种随机的探索机制，可以更好地寻求多峰任务中的最佳决策模型\n- 更好的鲁棒性，环境有干扰或者噪音时，有多种完成目标的行动可以选择，可以从干扰中“脱身”\n\n## 算法效果\n\n> The applications of training such stochastic policies include improved exploration in the case of multimodal objectives and compositionality via pretraining general-purpose stochastic policies that can then be efficiently finetuned into task-specific behaviors. \n\n在多峰目标任务中训练随机策略可以提升探索，也可以预训练出通用目的的随机策略以微调后运用至指定任务中进行训练（迁移学习、元学习）。\n\n# 文中精要\n\n## 标准强化学习的最优策略\n\n$$\n\\pi_{\\mathrm{std}}^{*}=\\arg \\max _{\\pi} \\sum_{t} \\mathbb{E}_{\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\sim \\rho_{\\pi}}\\left[r\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right] \\tag{1}\n$$\n\n- `std`下标代表标准的意思：standard，星号$\\ast$代表最优\n\n- $\\rho_{\\pi}$代表策略$\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right)$下的迹分布，$\\rho_{\\pi}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)$代表状态-行动对的边缘分布。\n\n> We will also use $\\rho_{\\pi}\\left(\\mathbf{s}_{t}\\right)$ and $\\rho_{\\pi}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)$ to denote the state and state-action marginals of the trajectory distribution induced by a policy $\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right)$. \n\n## 最大熵强化学习的最优策略\n\n最大熵强化学习在标准RL的目标函数上加入了一个关于状态下可选动作分布熵的项，这种目标希望智能体不仅能以获得最大奖励的方式完成目标，而且能够决策地尽可能随机。因为通过这种目标函数学到的策略**更具鲁棒性**，可以更好适用于环境的突然变化，或者从前没有遇到过得场景。\n$$\n\\pi_{\\mathrm{MaxEnt}}^{*}=\\arg \\max _{\\pi} \\sum_{t} \\mathbb{E}_{\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\sim \\rho_{\\pi}}\\left[r\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)+\\color{red}{\\alpha \\mathcal{H}\\left(\\pi\\left(\\cdot | \\mathbf{s}_{t}\\right)\\right)}\\right]\n\\tag{2}\n$$\n\n- `MaxEnt`下标代表最大熵的意思：Maximum entropy\n- 式中的系数$\\alpha$可以用来调节奖励项与熵值项的重要性比率。**一般将$\\alpha$表示为奖励范围（reward scale）的倒数，但在实际中通常将其作为超参数手动调节。**SAC算法中有介绍在训练过程中自动调节该系数的方法。\n- 本文中的SQL算法也是为了优化该目标函数\n\n## 最大熵目标的优点\n\n- 在多峰（即一个状态下有多个最优动作选择）问题中提升探索能力\n- 可以用于迁移学习，因为其“预训练”模型更好地适应之后的任务\n\n## soft 值函数\n\n文中，***定义***了最大熵RL下的Q函数与V函数，注意，是定义，不是推导出来的。\n\nsoft Q函数定义如下：\n$$\n{Q_{\\text { soft }}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+}  {\\mathbb{E}_{\\left(\\mathbf{s}_{t+1}, \\ldots\\right) \\sim \\rho_{\\pi}}\\left[\\sum_{l=1}^{\\infty} \\gamma^{l}\\left(r_{t+l}+\\alpha \\mathcal{H}\\left(\\pi_{\\text { MaxEnt }}^{*}\\left(\\cdot | \\mathbf{s}_{t+l}\\right)\\right)\\right)\\right]}\n\\tag{3}\n$$\nsoft V函数定义如下：\n$$\nV_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)=\\alpha \\log \\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}\n\\tag{4}\n$$\n乍一看这个值函数$V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)$的形式定义的很奇怪，的确很奇怪，严格来说，它的真实意义并不是为了构造状态值函数，而是构造一个配分函数使得后面推导最优策略时可以化简过程。当然，算法中也不需要用它的值去衡量状态的价值，只是作为计算的中间过程。\n\n作者说，值函数满足soft 贝尔曼方程，即\n$$\nQ_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t+1}\\right)\\right]\n\\tag{5}\n$$\n\n## 能量模型与策略\n\n文中提出能量模型（Energy-Based Models）的初衷是之前很多人在研究中使用了多项式分布（discrete multinomial distributions）、高斯分布（Gaussian distributions）来表示策略，这样的分布通常用来表示动作价值分布是单峰（unimodal）的情况，而且最终收敛结果往往是接近确定性（near-deterministic）的。即使拓展出多峰的形式，也各自有或多或少的不足。基于此，作者想使用更广泛、通用的分布用来表示复杂、多峰的动作选择。\n\n所以，作者选择使用基于能量的通用策略：\n$$\n\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right) \\propto \\exp \\left(-\\mathcal{E}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right)\n\\tag{6}\n$$\n\n- $\\mathcal{E}$是字母E的花体形式，代表能量函数，其可以被深度神经网络表示，如果使用通用值函数近似来表示能量函数，那么可以表示任意策略$\\pi\\left(\\boldsymbol{a}_{t} | \\mathbf{s}_{t}\\right)$\n\n- > where $\\mathcal{E}$ is an energy function that could be represented, for example, by a deep neural network. If we use a universal function approximator for $\\mathcal{E}$, we can represent any distribution $\\pi\\left(\\boldsymbol{a}_{t} | \\mathbf{s}_{t}\\right)$. \n\n- 文中将该能量函数设置为\n  $$\n  \\mathcal{E}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=-\\frac{1}{\\alpha} Q_{\\operatorname{soft}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\n  \\tag{7}\n  $$\n  其实也很容易就能理解，将负号抵消掉之后，Q值大的动作能量高嘛，指数分布又能更好的放大较大的值，使Q值大的动作更为突出，这样完全可以作为选择动作的策略\n\n但是有一个问题是，不能使能量无限大呀，假如超过了计算能力那就不好了，当然这种情况几乎不会发生。于是，可以将能量给归一化，即\n$$\n\\begin{aligned} \n\\pi_{\\text { MaxEnt }}^{*}\\left(a_{t} | s_{t}\\right) \n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right) \\mathrm{d} a^{\\prime}} \\\\ \n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\exp \\left(\\frac{1}{\\alpha} V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)} \\\\\n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\color{blue}{\\exp \\log} \\exp \\left(\\frac{1}{\\alpha} V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)} \\\\\n&=\\color{red}{\\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)-V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)\\right)}\n\\end{aligned}\n\\tag{8}\n$$\n\n<p align=\"center\" style=\"color:blue\" ><a href=\"https://bluefisher.github.io/2018/11/13/Reinforcement-Learning-with-Deep-Energy-Based-Policies/\">BlueFisher's Blog</a></p>\n论文中只给出了红色字体的部分，其实这才是作者想要表达的意思，文中就是基于此定义了状态值函数$V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)$的形式。\n\n在这个公式中就可以看出，策略是对动作值函数Q进行了一个softmax操作，这也是文中soft的含义。\n\n## 使用SQL优化目标函数\n\n像使用Q-Learning对网格世界问题进行优化求解一样，我们也可以使用迭代的方式进行优化，交互计算两个值函数，使其各自收敛，就可以导出最优策略。\n\n于是，作者定义了soft Q-Iteration。\n\n### Soft Q-Iteration\n\n先要假设值函数$Q_{\\mathrm{soft}}(\\cdot, \\cdot)$、$V_{\\text { soft }}(\\cdot)$有界，\n$$\n\\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}\\left(\\cdot, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}<\\infty \\ ，\\ Q_{\\mathrm{soft}}^{*}<\\infty\n\\tag{9}\n$$\n文中定义的交互迭代至收敛的方式其实跟SARSA算法比较像：\n$$\n\\begin{array}{c}\n{Q_{\\text { soft }}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\leftarrow r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\text { soft }}\\left(\\mathbf{s}_{t+1}\\right)\\right], \\forall \\mathbf{s}_{t}, \\mathbf{a}_{t}} \\\\ \n{V_{\\text { soft }}\\left(\\mathbf{s}_{t}\\right) \\leftarrow \\alpha \\log \\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}, \\forall \\mathbf{s}_{t}}\n\\end{array}\n\\tag{10}\n$$\n这种优化方式在理论上是可行的，但是在实际应用中存在两个问题：\n\n1. 连续空间无法求期望，或者计算不准确。**解决方案是重要性采样，使用采样多次后计算来代替积分，在初期进行随机均匀采样，后期根据policy来采样。**\n2. 迭代过程需要不断选择动作，问题是式（8）的分布形式无法进行采样。**解决方案是使用SVGD算法拟合后验分布，并输出采样的动作。**\n\n### Soft Q-Learning\n\n文中在这一部分引用了重要性采样，解决了上面提到的第一个问题，即，使用分布$q_{\\mathrm{a}^{\\prime}}$来代替真实策略分布\n$$\n\\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)-V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)\\right\n)\n$$\n进行采样。\n$$\nV_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}\\right)=\\alpha \\log \\mathbb{E}_{\\color{red}{q_{\\mathrm{a}^{\\prime}}}}\\left[\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right)}{q_{\\mathrm{a}^{\\prime}}\\left(\\mathbf{a}^{\\prime}\\right)}\\right]\n\\tag{11}\n$$\n采样分布$q_{\\mathrm{a}^{\\prime}}$可以使用任意的分布，但是由于重要性采样的性质，采样分布与原分布越接近，效果越好。式子中的$\\theta$为Q神经网络的参数。\n\n因为在训练初期，我们估计的真实分布是偏差很大的，几乎可以说是错误的，因此在训练初期将采样分布设置为均匀分布比较合理，在训练一段时间之后，可以将采样分布设置为接近原分布，甚至是原分布（如果原分布可以采样，如，使用神经网络等“黑匣子”进行表示）\n\n由此，可以定义Q神经网络的损失函数为：\n$$\nJ_{Q}(\\theta)=\\mathbb{E}_{\\mathbf{s}_{t} \\sim q_{\\mathbf{s}_{t}}, \\mathbf{a}_{t} \\sim q_{\\mathbf{a}_{t}}}\\left[\\frac{1}{2}\\left(\\hat{Q}_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)-Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right)^{2}\\right]\n\\tag{12}\n$$\n上式中期望的下标为环境和真实策略分布，$\\overline{\\theta}$代表target网络的参数，目标是最小化这个损失函数，其中，\n$$\n\\hat{Q}_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t+1}\\right)\\right]\n\\tag{13}\n$$\n### 近似采样与SVGD\n\nSVGD：Stein Vairational Gradient Descent，SVGD是一种确定性的、基于梯度的近似推理采样算法。\n\n文中在这一部分引用了SVGD的优化算法，并且使用SVGD近似策略的后验分布以进行采样，解决了上文提到的第二个问题。在百度上完全搜不到关于SVGD算法的信息，但是了解了这个算法之后，感觉它的能力还是很强的，最终，搜集了Google、Bing的检索结果，发现了原作者在SVGD方法上的一些资源分享，[Stein’s Method for Practical Machine Learning](https://www.cs.utexas.edu/~lqiang/stein.html)\n\n对于基于能量的模型、分布，有两类采样方式：\n\n1. MCMC采样，即马尔科夫链蒙特卡洛采样\n2. 学习一个采样网络去近似采样出符合目标分布的样本\n\n在需要不断更新策略的在线学习任务中，使用MCMC采样是不可行的，于是作者使用了基于SVGD和Amortized SVGD的采样网络。\n\nSVGD论文：[https://arxiv.org/abs/1608.04471](https://arxiv.org/abs/1608.04471)\n\nAmortized SVGD论文：[https://arxiv.org/abs/1707.06626](https://arxiv.org/abs/1707.06626)\n\n![](./rl-with-deep-energy-based-policies/1dgmm.gif)\n![](./rl-with-deep-energy-based-policies/vp.gif)\n\nAmortized SVGD有一些有趣的性质：\n\n- 可以训练随机采样网络非常快地采样\n- 可以准确收敛至EBM能量模型的后验估计分布\n- 文中结合了Amortized SVGD后，算法形式很像A-C模式\n\nSVGD算法的更新形式是这样的，\n$$\nx_{i} \\leftarrow x_{i}+\\frac{\\epsilon}{n} \\sum_{j=1}^{n}\\left[k\\left(x_{j}, x_{i}\\right) \\nabla_{x_{j}} \\log p\\left(x_{j}\\right)+\\nabla_{x_{j}} k\\left(x_{j}, x_{i}\\right)\\right], \\qquad \\forall i=1, \\ldots, n\n\\tag{14}\n$$\n- $\\epsilon$代表学习率\n- $k\\left(x_{j}, x_{i}\\right)$代表正定核，如径向基（RBF，Radial Basis Function）函数$k\\left(x, x^{\\prime}\\right)=\\exp \\left(-\\frac{1}{h}\\left\\|x-x^{\\prime}\\right\\|_{2}^{2}\\right)$，它可以被认为是变量之间的相似性度量\n- 包含对数项$\\log p\\left(x_{j}\\right)$的梯度驱使采样器朝着$p(x)$分布中高概率区域进行采样\n- 第二项核函数梯度驱使样本点之间产生间隙，相当于用一个排斥力使样本点尽可能分散开\n- 对数项梯度不依赖分布$p(x)$的归一化常数，使SVGD易于应用于图模型、贝叶斯推理和深层生成模型中出现的难以处理的分布。\n\n先定义我们采样网络（其实就是Actor）的目标函数：\n$$\nJ_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)=D_{\\mathrm{KL}}\\left(\\pi^{\\phi}\\left(\\cdot | \\mathbf{s}_{t}\\right) \\| \\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\cdot\\right)-V_{\\mathrm{soft}}^{\\theta}\\right)\\right)\\right)\n\\tag{15}\n$$\n- $\\phi$表示采样网络中的参数\n- 将产生动作的函数简写成$\\mathbf{a}_{t}^{(i)}=f^{\\phi}\\left(\\xi^{(i)} ; \\mathbf{s}_{t}\\right)$，也就是说神经网络的输入分为两部分，一部分是状态$s$，一部分是噪声扰乱“perturb”$\\xi$，一般从标准正态分布中采样，而且最好使噪声的维度与动作的维度一致\n\n计算梯度方向：\n$$\n\\begin{aligned}\n\\Delta f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)=& \\mathbb{E}_{\\mathbf{a}_{t} \\sim \\pi^{\\phi}}\\left[\\kappa\\left(\\mathbf{a}_{t}, f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)\\right) \\nabla_{\\mathbf{a}^{\\prime}} Q_{\\mathrm{soft}}^{\\theta}\\left.\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{t}}\\right.\\\\ &+\\alpha \\nabla_{\\mathbf{a}^{\\prime}} \\kappa\\left.\\left(\\mathbf{a}^{\\prime}, f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{t}} ] \\end{aligned}\n\\tag{16}\n$$\n- 严格来说，$\\Delta f^{\\phi}$是希尔伯特空间的最优梯度方向，并不是Actor目标函数$J_{\\pi}$的梯度\n\n- > To be precise, $\\Delta f^{\\phi}$ is the optimal direction in the reproducing kernel Hilbert space of $\\kappa$, and is thus not strictly speaking the gradient of $J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)$ \n\n根据链式法则，Stein变分梯度SVG为\n$$\n\\frac{\\partial J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)}{\\partial \\phi} \\propto \\mathbb{E}_{\\xi}\\left[\\Delta f^{\\phi}\\left(\\xi ; \\mathbf{s}_{t}\\right) \\frac{\\partial f^{\\phi}\\left(\\xi ; \\mathbf{s}_{t}\\right)}{\\partial \\phi}\\right]\n\\tag{17}\n$$\n## 伪代码\n\n![](./rl-with-deep-energy-based-policies/pseudo.png)\n\n解析：\n\n算法中更新Actor网络时，其实是使用了如下梯度公式：\n$$\n\\hat{\\nabla}_{\\phi} J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)=\\frac{1}{K M} \\sum_{j=1}^{K} \\sum_{i=1}^{M}\\left(\\kappa\\left(\\mathbf{a}_{t}^{(i)}, \\tilde{\\mathbf{a}}_{t}^{(j)}\\right) \\nabla_{\\mathbf{a}^{\\prime}} Q_{\\mathrm{soft}}\\left.\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{i}^{(i)}}+\\nabla_{\\mathbf{a}^{\\prime}} \\kappa\\left.\\left(\\mathbf{a}^{\\prime}, \\tilde{\\mathbf{a}}_{t}^{(j)}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{i}^{(i)}}\\right) \\nabla_{\\phi} f^{\\phi}\\left(\\tilde{\\xi}^{(j)} ; \\mathbf{s}_{t}\\right)\n\\tag{18}\n$$\n更新方向为mini-batch经验的梯度平均值，而不是累加和\n\n- 伪代码中定义了Actor的target网络，参数为$\\overline{\\theta}$。但是伪代码中并没有显示出其在何处使用，我**猜测**该网络代表采样分布$q_{\\mathbf{a}^{\\prime}}$\n  - $q_{\\mathbf{a}^{\\prime}}$在训练初期使用均匀分布\n  - $q_{\\mathbf{a}^{\\prime}}$在一段时间之后使用Actor真实分布，我猜测这里使用的就是Actor目标网络\n- 噪音$\\xi$从多维标准正态分布中采样，维度最好与动作空间维度一致\n- $\\left\\{\\mathbf{a}^{(i, j)}\\right\\}_{j=0}^{M} \\sim q_{\\mathbf{a}^{\\prime}}$其中的M用于设置采样多少个样本，以使用公式（11）计算V值，使用的网络为Q目标网络\n- 在更新Q网络时，使用了从经验池采样到的真实执行过的动作\n- $\\left\\{\\xi^{(i, j)}\\right\\}_{j=0}^{M} \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{I})$中其实少写了一个参数$K$，但实际上$K=M$，在这一步中需要采样两组噪音，当然也可以采样一组，使用两次。\n- 在更新Actor网络时，没有使用经验池中采样到的动作，而模拟采样了两组动作，即根据两组噪音生成的动作，用它们来计算梯度并更新。\n- Q网络的输入为状态与动作的连接，$(s||a)$，输出为Q值\n- Actor网络的输入为状态与噪音的连接，$(s||\\xi)$，输出为动作$a$\n- 伪代码中的式(10)、(11)、(13)、(14)分别代表本文中的式(11)、(12)、(16)、(17)\n\n# 实验\n\n## 实验设置\n\n- 比较算法：DDPG vs SQL\n- Actor和Q网络使用Adam优化器\n- Actor学习率为0.0001，Q网络学习率为0.001\n- 经验池大小为100W\n- 经验池填充1W条经验后开始训练\n- batch_size=64\n- Actor和Q网络都是2层隐藏层，每层200个隐藏节点，激活函数为ReLU\n- DDPG和SQL都使用了Ornstein-Uhlenbeck随机过程产生噪音来增加探索，它是一种序贯相关的随机过程，$\\theta=0.15 \\ , \\ \\sigma=0.3$\n  - OU随机过程可以在序贯模型中添加与时间相关的随机噪音，而且噪音也满足强马尔可夫性\n  \n  - 形式为$d x_{t}=\\theta\\left(\\mu-x_{t}\\right) d t+\\sigma d W_{t}$，是一个具有均值恢复属性的随机过程\n  \n  - $\\theta$表示变量$x$以多大幅度、多块恢复到平均值，$\\mu$代表平均值，$\\sigma$代表波动程度，$d W_{t}$代表维纳过程，一般通过高斯分布实现\n  \n  - OU随机过程产生的噪音只与上一次产生的噪音相关，它可以用于增加探索，也能够柔顺控制。比如在相邻的两个决策动作，一个为10，一个为-10，反复如此，智能体会产生震荡。在此使用OU过程可以使智能体在一个方向保持一定时间，不会瞬间过大地改变智能体的状态，相当于增加了时滞性。\n  \n  - 代码\n  \n    ```\n    x = 10\n    dx = theta * (mu - x) + sigma * numpy.random.randn(len(x))\n    x = x + dx\n    ```\n  \n  - 参考：\n  \n    - [https://www.quora.com/Why-do-we-use-the-Ornstein-Uhlenbeck-Process-in-the-exploration-of-DDPG](https://www.quora.com/Why-do-we-use-the-Ornstein-Uhlenbeck-Process-in-the-exploration-of-DDPG)\n    - [https://github.com/floodsung/DDPG-tensorflow/blob/master/ou_noise.py](https://github.com/floodsung/DDPG-tensorflow/blob/master/ou_noise.py)\n    - [https://zhuanlan.zhihu.com/p/51333694](https://zhuanlan.zhihu.com/p/51333694)\n- 核函数使用了径向基函数RBF，$\\kappa\\left(\\mathbf{a}, \\mathbf{a}^{\\prime}\\right)=\\exp \\left(-\\frac{1}{h}\\left\\|\\mathbf{a}-\\mathbf{a}^{\\prime}\\right\\|_{2}^{2}\\right)$，其中，$h=\\frac{d}{2 \\log (M+1)}$，$d$为各变量对之间距离的中位数\n- 目标网络的更新采样硬覆盖的模式\n- 超参数$\\alpha$根据任务设置为10，0.1等等\n- 训练的epoch、步长、系数$\\alpha$，采样动作的数量$K 和 M$根据任务（多目标，单目标，微调）的不同而不同，具体请看原论文附录D部分\n\n## 实验结果\n\n未完待续\n\n# 个人感想\n\n虽然文中用大量公式、篇幅结合最大熵进行介绍、推理，但是在伪代码以及目标函数中似乎并没有看到关于熵的影子，包含熵项的Q值也是通过Q网络的输出将熵的值包含在内，并没有显式地计算它。\n\n虽然算法的名字为soft Q-Learning，但其实它跟传统的Q-Learning算法思想并不相同，如果说有一点相同，那也是都是想使Q值收敛以推导出最优策略，但是这个优化过程也跟SARSA算法比较像，并没有使用传统Q-Learning中贪婪的选择最有价值下一个动作以自举的方法。","slug":"rl-with-deep-energy-based-policies","published":1,"updated":"2019-07-07T10:19:13.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzutl7006020cdel76sbz1","content":"<p>本文提出了一个算法，用于学习连续空间下基于能量的策略：SQL，不是数据库的SQL，而是soft Q-Learning。该算法应用了最大熵理论，并且使用能量模型（EBM，Energy-Based Model）作为决策模型。</p>\n<p>推荐阅读该论文：</p>\n<ul>\n<li>公式复杂，但详尽吃透可以学习到SVGD、EBM等概念与算法</li>\n<li>文章充实，可以继续阅读后续算法SAC</li>\n<li>拓展在强化学习与熵进行结合方面的知识</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/abs/1702.08165\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/abs/1702.08165</a></p>\n<p>源代码：<a href=\"https://github.com/rail-berkeley/softlearning\" rel=\"external nofollow\" target=\"_blank\">https://github.com/rail-berkeley/softlearning</a></p>\n<p>该论文与2017年发于第34次ICML会议上，本文对v2版本进行分析。该论文作者为Tuomas Haarnoja，是伯克利大学BAIR实验室的博士生，SAC算法也是他的杰作。</p>\n<p>传统的RL方法主要是用分布拟合单峰分布，即</p>\n<p><img src=\"./rl-with-deep-energy-based-policies/unimodal-policy.png\" alt=\"\"></p>\n<p>也有许多算法想要根据Q函数的值拟合出多峰分布，即</p>\n<p><img src=\"./rl-with-deep-energy-based-policies/multimodal-policy.png\" alt=\"\"></p>\n<p>本文中就是针对拟合多峰分布提出了算法SQL。</p>\n<p>为什么要拟合多峰分布呢？当我们考虑最优控制和概率推理之间的联系时，随机策略才是最优解。</p>\n<blockquote>\n<p>As discussed in prior work, a stochastic policy emerges as the optimal answer when we consider the connection between optimal control and probabilistic inference.</p>\n</blockquote>\n<p>随机策略有一些优点：</p>\n<ul>\n<li>如果可以全面地学习给定任务中的目标策略，那么结果策略可以作为很好的初始化策略，微调后以学习更高级的策略</li>\n<li>这种随机的探索机制，可以更好地寻求多峰任务中的最佳决策模型</li>\n<li>更好的鲁棒性，环境有干扰或者噪音时，有多种完成目标的行动可以选择，可以从干扰中“脱身”</li>\n</ul>\n<h2 id=\"算法效果\"><a href=\"#算法效果\" class=\"headerlink\" title=\"算法效果\"></a>算法效果</h2><blockquote>\n<p>The applications of training such stochastic policies include improved exploration in the case of multimodal objectives and compositionality via pretraining general-purpose stochastic policies that can then be efficiently finetuned into task-specific behaviors. </p>\n</blockquote>\n<p>在多峰目标任务中训练随机策略可以提升探索，也可以预训练出通用目的的随机策略以微调后运用至指定任务中进行训练（迁移学习、元学习）。</p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><h2 id=\"标准强化学习的最优策略\"><a href=\"#标准强化学习的最优策略\" class=\"headerlink\" title=\"标准强化学习的最优策略\"></a>标准强化学习的最优策略</h2><script type=\"math/tex; mode=display\">\n\\pi_{\\mathrm{std}}^{*}=\\arg \\max _{\\pi} \\sum_{t} \\mathbb{E}_{\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\sim \\rho_{\\pi}}\\left[r\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right] \\tag{1}</script><ul>\n<li><p><code>std</code>下标代表标准的意思：standard，星号$\\ast$代表最优</p>\n</li>\n<li><p>$\\rho_{\\pi}$代表策略$\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right)$下的迹分布，$\\rho_{\\pi}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)$代表状态-行动对的边缘分布。</p>\n</li>\n</ul>\n<blockquote>\n<p>We will also use $\\rho_{\\pi}\\left(\\mathbf{s}_{t}\\right)$ and $\\rho_{\\pi}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)$ to denote the state and state-action marginals of the trajectory distribution induced by a policy $\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right)$. </p>\n</blockquote>\n<h2 id=\"最大熵强化学习的最优策略\"><a href=\"#最大熵强化学习的最优策略\" class=\"headerlink\" title=\"最大熵强化学习的最优策略\"></a>最大熵强化学习的最优策略</h2><p>最大熵强化学习在标准RL的目标函数上加入了一个关于状态下可选动作分布熵的项，这种目标希望智能体不仅能以获得最大奖励的方式完成目标，而且能够决策地尽可能随机。因为通过这种目标函数学到的策略<strong>更具鲁棒性</strong>，可以更好适用于环境的突然变化，或者从前没有遇到过得场景。</p>\n<script type=\"math/tex; mode=display\">\n\\pi_{\\mathrm{MaxEnt}}^{*}=\\arg \\max _{\\pi} \\sum_{t} \\mathbb{E}_{\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\sim \\rho_{\\pi}}\\left[r\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)+\\color{red}{\\alpha \\mathcal{H}\\left(\\pi\\left(\\cdot | \\mathbf{s}_{t}\\right)\\right)}\\right]\n\\tag{2}</script><ul>\n<li><code>MaxEnt</code>下标代表最大熵的意思：Maximum entropy</li>\n<li>式中的系数$\\alpha$可以用来调节奖励项与熵值项的重要性比率。<strong>一般将$\\alpha$表示为奖励范围（reward scale）的倒数，但在实际中通常将其作为超参数手动调节。</strong>SAC算法中有介绍在训练过程中自动调节该系数的方法。</li>\n<li>本文中的SQL算法也是为了优化该目标函数</li>\n</ul>\n<h2 id=\"最大熵目标的优点\"><a href=\"#最大熵目标的优点\" class=\"headerlink\" title=\"最大熵目标的优点\"></a>最大熵目标的优点</h2><ul>\n<li>在多峰（即一个状态下有多个最优动作选择）问题中提升探索能力</li>\n<li>可以用于迁移学习，因为其“预训练”模型更好地适应之后的任务</li>\n</ul>\n<h2 id=\"soft-值函数\"><a href=\"#soft-值函数\" class=\"headerlink\" title=\"soft 值函数\"></a>soft 值函数</h2><p>文中，<strong><em>定义</em></strong>了最大熵RL下的Q函数与V函数，注意，是定义，不是推导出来的。</p>\n<p>soft Q函数定义如下：</p>\n<script type=\"math/tex; mode=display\">\n{Q_{\\text { soft }}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+}  {\\mathbb{E}_{\\left(\\mathbf{s}_{t+1}, \\ldots\\right) \\sim \\rho_{\\pi}}\\left[\\sum_{l=1}^{\\infty} \\gamma^{l}\\left(r_{t+l}+\\alpha \\mathcal{H}\\left(\\pi_{\\text { MaxEnt }}^{*}\\left(\\cdot | \\mathbf{s}_{t+l}\\right)\\right)\\right)\\right]}\n\\tag{3}</script><p>soft V函数定义如下：</p>\n<script type=\"math/tex; mode=display\">\nV_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)=\\alpha \\log \\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}\n\\tag{4}</script><p>乍一看这个值函数$V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)$的形式定义的很奇怪，的确很奇怪，严格来说，它的真实意义并不是为了构造状态值函数，而是构造一个配分函数使得后面推导最优策略时可以化简过程。当然，算法中也不需要用它的值去衡量状态的价值，只是作为计算的中间过程。</p>\n<p>作者说，值函数满足soft 贝尔曼方程，即</p>\n<script type=\"math/tex; mode=display\">\nQ_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t+1}\\right)\\right]\n\\tag{5}</script><h2 id=\"能量模型与策略\"><a href=\"#能量模型与策略\" class=\"headerlink\" title=\"能量模型与策略\"></a>能量模型与策略</h2><p>文中提出能量模型（Energy-Based Models）的初衷是之前很多人在研究中使用了多项式分布（discrete multinomial distributions）、高斯分布（Gaussian distributions）来表示策略，这样的分布通常用来表示动作价值分布是单峰（unimodal）的情况，而且最终收敛结果往往是接近确定性（near-deterministic）的。即使拓展出多峰的形式，也各自有或多或少的不足。基于此，作者想使用更广泛、通用的分布用来表示复杂、多峰的动作选择。</p>\n<p>所以，作者选择使用基于能量的通用策略：</p>\n<script type=\"math/tex; mode=display\">\n\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right) \\propto \\exp \\left(-\\mathcal{E}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right)\n\\tag{6}</script><ul>\n<li><p>$\\mathcal{E}$是字母E的花体形式，代表能量函数，其可以被深度神经网络表示，如果使用通用值函数近似来表示能量函数，那么可以表示任意策略$\\pi\\left(\\boldsymbol{a}_{t} | \\mathbf{s}_{t}\\right)$</p>\n</li>\n<li><blockquote>\n<p>where $\\mathcal{E}$ is an energy function that could be represented, for example, by a deep neural network. If we use a universal function approximator for $\\mathcal{E}$, we can represent any distribution $\\pi\\left(\\boldsymbol{a}_{t} | \\mathbf{s}_{t}\\right)$. </p>\n</blockquote>\n</li>\n<li><p>文中将该能量函数设置为</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{E}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=-\\frac{1}{\\alpha} Q_{\\operatorname{soft}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\n\\tag{7}</script><p>其实也很容易就能理解，将负号抵消掉之后，Q值大的动作能量高嘛，指数分布又能更好的放大较大的值，使Q值大的动作更为突出，这样完全可以作为选择动作的策略</p>\n</li>\n</ul>\n<p>但是有一个问题是，不能使能量无限大呀，假如超过了计算能力那就不好了，当然这种情况几乎不会发生。于是，可以将能量给归一化，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \n\\pi_{\\text { MaxEnt }}^{*}\\left(a_{t} | s_{t}\\right) \n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right) \\mathrm{d} a^{\\prime}} \\\\ \n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\exp \\left(\\frac{1}{\\alpha} V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)} \\\\\n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\color{blue}{\\exp \\log} \\exp \\left(\\frac{1}{\\alpha} V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)} \\\\\n&=\\color{red}{\\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)-V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)\\right)}\n\\end{aligned}\n\\tag{8}</script><p></p><p align=\"center\" style=\"color:blue\"><a href=\"https://bluefisher.github.io/2018/11/13/Reinforcement-Learning-with-Deep-Energy-Based-Policies/\" rel=\"external nofollow\" target=\"_blank\">BlueFisher's Blog</a></p><br>论文中只给出了红色字体的部分，其实这才是作者想要表达的意思，文中就是基于此定义了状态值函数$V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)$的形式。<p></p>\n<p>在这个公式中就可以看出，策略是对动作值函数Q进行了一个softmax操作，这也是文中soft的含义。</p>\n<h2 id=\"使用SQL优化目标函数\"><a href=\"#使用SQL优化目标函数\" class=\"headerlink\" title=\"使用SQL优化目标函数\"></a>使用SQL优化目标函数</h2><p>像使用Q-Learning对网格世界问题进行优化求解一样，我们也可以使用迭代的方式进行优化，交互计算两个值函数，使其各自收敛，就可以导出最优策略。</p>\n<p>于是，作者定义了soft Q-Iteration。</p>\n<h3 id=\"Soft-Q-Iteration\"><a href=\"#Soft-Q-Iteration\" class=\"headerlink\" title=\"Soft Q-Iteration\"></a>Soft Q-Iteration</h3><p>先要假设值函数$Q_{\\mathrm{soft}}(\\cdot, \\cdot)$、$V_{\\text { soft }}(\\cdot)$有界，</p>\n<script type=\"math/tex; mode=display\">\n\\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}\\left(\\cdot, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}<\\infty \\ ，\\ Q_{\\mathrm{soft}}^{*}<\\infty\n\\tag{9}</script><p>文中定义的交互迭代至收敛的方式其实跟SARSA算法比较像：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{c}\n{Q_{\\text { soft }}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\leftarrow r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\text { soft }}\\left(\\mathbf{s}_{t+1}\\right)\\right], \\forall \\mathbf{s}_{t}, \\mathbf{a}_{t}} \\\\ \n{V_{\\text { soft }}\\left(\\mathbf{s}_{t}\\right) \\leftarrow \\alpha \\log \\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}, \\forall \\mathbf{s}_{t}}\n\\end{array}\n\\tag{10}</script><p>这种优化方式在理论上是可行的，但是在实际应用中存在两个问题：</p>\n<ol>\n<li>连续空间无法求期望，或者计算不准确。<strong>解决方案是重要性采样，使用采样多次后计算来代替积分，在初期进行随机均匀采样，后期根据policy来采样。</strong></li>\n<li>迭代过程需要不断选择动作，问题是式（8）的分布形式无法进行采样。<strong>解决方案是使用SVGD算法拟合后验分布，并输出采样的动作。</strong></li>\n</ol>\n<h3 id=\"Soft-Q-Learning\"><a href=\"#Soft-Q-Learning\" class=\"headerlink\" title=\"Soft Q-Learning\"></a>Soft Q-Learning</h3><p>文中在这一部分引用了重要性采样，解决了上面提到的第一个问题，即，使用分布$q_{\\mathrm{a}^{\\prime}}$来代替真实策略分布</p>\n<script type=\"math/tex; mode=display\">\n\\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)-V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)\\right\n)</script><p>进行采样。</p>\n<script type=\"math/tex; mode=display\">\nV_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}\\right)=\\alpha \\log \\mathbb{E}_{\\color{red}{q_{\\mathrm{a}^{\\prime}}}}\\left[\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right)}{q_{\\mathrm{a}^{\\prime}}\\left(\\mathbf{a}^{\\prime}\\right)}\\right]\n\\tag{11}</script><p>采样分布$q_{\\mathrm{a}^{\\prime}}$可以使用任意的分布，但是由于重要性采样的性质，采样分布与原分布越接近，效果越好。式子中的$\\theta$为Q神经网络的参数。</p>\n<p>因为在训练初期，我们估计的真实分布是偏差很大的，几乎可以说是错误的，因此在训练初期将采样分布设置为均匀分布比较合理，在训练一段时间之后，可以将采样分布设置为接近原分布，甚至是原分布（如果原分布可以采样，如，使用神经网络等“黑匣子”进行表示）</p>\n<p>由此，可以定义Q神经网络的损失函数为：</p>\n<script type=\"math/tex; mode=display\">\nJ_{Q}(\\theta)=\\mathbb{E}_{\\mathbf{s}_{t} \\sim q_{\\mathbf{s}_{t}}, \\mathbf{a}_{t} \\sim q_{\\mathbf{a}_{t}}}\\left[\\frac{1}{2}\\left(\\hat{Q}_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)-Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right)^{2}\\right]\n\\tag{12}</script><p>上式中期望的下标为环境和真实策略分布，$\\overline{\\theta}$代表target网络的参数，目标是最小化这个损失函数，其中，</p>\n<script type=\"math/tex; mode=display\">\n\\hat{Q}_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t+1}\\right)\\right]\n\\tag{13}</script><h3 id=\"近似采样与SVGD\"><a href=\"#近似采样与SVGD\" class=\"headerlink\" title=\"近似采样与SVGD\"></a>近似采样与SVGD</h3><p>SVGD：Stein Vairational Gradient Descent，SVGD是一种确定性的、基于梯度的近似推理采样算法。</p>\n<p>文中在这一部分引用了SVGD的优化算法，并且使用SVGD近似策略的后验分布以进行采样，解决了上文提到的第二个问题。在百度上完全搜不到关于SVGD算法的信息，但是了解了这个算法之后，感觉它的能力还是很强的，最终，搜集了Google、Bing的检索结果，发现了原作者在SVGD方法上的一些资源分享，<a href=\"https://www.cs.utexas.edu/~lqiang/stein.html\" rel=\"external nofollow\" target=\"_blank\">Stein’s Method for Practical Machine Learning</a></p>\n<p>对于基于能量的模型、分布，有两类采样方式：</p>\n<ol>\n<li>MCMC采样，即马尔科夫链蒙特卡洛采样</li>\n<li>学习一个采样网络去近似采样出符合目标分布的样本</li>\n</ol>\n<p>在需要不断更新策略的在线学习任务中，使用MCMC采样是不可行的，于是作者使用了基于SVGD和Amortized SVGD的采样网络。</p>\n<p>SVGD论文：<a href=\"https://arxiv.org/abs/1608.04471\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/abs/1608.04471</a></p>\n<p>Amortized SVGD论文：<a href=\"https://arxiv.org/abs/1707.06626\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/abs/1707.06626</a></p>\n<p><img src=\"./rl-with-deep-energy-based-policies/1dgmm.gif\" alt=\"\"><br><img src=\"./rl-with-deep-energy-based-policies/vp.gif\" alt=\"\"></p>\n<p>Amortized SVGD有一些有趣的性质：</p>\n<ul>\n<li>可以训练随机采样网络非常快地采样</li>\n<li>可以准确收敛至EBM能量模型的后验估计分布</li>\n<li>文中结合了Amortized SVGD后，算法形式很像A-C模式</li>\n</ul>\n<p>SVGD算法的更新形式是这样的，</p>\n<script type=\"math/tex; mode=display\">\nx_{i} \\leftarrow x_{i}+\\frac{\\epsilon}{n} \\sum_{j=1}^{n}\\left[k\\left(x_{j}, x_{i}\\right) \\nabla_{x_{j}} \\log p\\left(x_{j}\\right)+\\nabla_{x_{j}} k\\left(x_{j}, x_{i}\\right)\\right], \\qquad \\forall i=1, \\ldots, n\n\\tag{14}</script><ul>\n<li>$\\epsilon$代表学习率</li>\n<li>$k\\left(x_{j}, x_{i}\\right)$代表正定核，如径向基（RBF，Radial Basis Function）函数$k\\left(x, x^{\\prime}\\right)=\\exp \\left(-\\frac{1}{h}\\left|x-x^{\\prime}\\right|_{2}^{2}\\right)$，它可以被认为是变量之间的相似性度量</li>\n<li>包含对数项$\\log p\\left(x_{j}\\right)$的梯度驱使采样器朝着$p(x)$分布中高概率区域进行采样</li>\n<li>第二项核函数梯度驱使样本点之间产生间隙，相当于用一个排斥力使样本点尽可能分散开</li>\n<li>对数项梯度不依赖分布$p(x)$的归一化常数，使SVGD易于应用于图模型、贝叶斯推理和深层生成模型中出现的难以处理的分布。</li>\n</ul>\n<p>先定义我们采样网络（其实就是Actor）的目标函数：</p>\n<script type=\"math/tex; mode=display\">\nJ_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)=D_{\\mathrm{KL}}\\left(\\pi^{\\phi}\\left(\\cdot | \\mathbf{s}_{t}\\right) \\| \\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\cdot\\right)-V_{\\mathrm{soft}}^{\\theta}\\right)\\right)\\right)\n\\tag{15}</script><ul>\n<li>$\\phi$表示采样网络中的参数</li>\n<li>将产生动作的函数简写成$\\mathbf{a}_{t}^{(i)}=f^{\\phi}\\left(\\xi^{(i)} ; \\mathbf{s}_{t}\\right)$，也就是说神经网络的输入分为两部分，一部分是状态$s$，一部分是噪声扰乱“perturb”$\\xi$，一般从标准正态分布中采样，而且最好使噪声的维度与动作的维度一致</li>\n</ul>\n<p>计算梯度方向：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\Delta f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)=& \\mathbb{E}_{\\mathbf{a}_{t} \\sim \\pi^{\\phi}}\\left[\\kappa\\left(\\mathbf{a}_{t}, f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)\\right) \\nabla_{\\mathbf{a}^{\\prime}} Q_{\\mathrm{soft}}^{\\theta}\\left.\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{t}}\\right.\\\\ &+\\alpha \\nabla_{\\mathbf{a}^{\\prime}} \\kappa\\left.\\left(\\mathbf{a}^{\\prime}, f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{t}} ] \\end{aligned}\n\\tag{16}</script><ul>\n<li><p>严格来说，$\\Delta f^{\\phi}$是希尔伯特空间的最优梯度方向，并不是Actor目标函数$J_{\\pi}$的梯度</p>\n</li>\n<li><blockquote>\n<p>To be precise, $\\Delta f^{\\phi}$ is the optimal direction in the reproducing kernel Hilbert space of $\\kappa$, and is thus not strictly speaking the gradient of $J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)$ </p>\n</blockquote>\n</li>\n</ul>\n<p>根据链式法则，Stein变分梯度SVG为</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)}{\\partial \\phi} \\propto \\mathbb{E}_{\\xi}\\left[\\Delta f^{\\phi}\\left(\\xi ; \\mathbf{s}_{t}\\right) \\frac{\\partial f^{\\phi}\\left(\\xi ; \\mathbf{s}_{t}\\right)}{\\partial \\phi}\\right]\n\\tag{17}</script><h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./rl-with-deep-energy-based-policies/pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<p>算法中更新Actor网络时，其实是使用了如下梯度公式：</p>\n<script type=\"math/tex; mode=display\">\n\\hat{\\nabla}_{\\phi} J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)=\\frac{1}{K M} \\sum_{j=1}^{K} \\sum_{i=1}^{M}\\left(\\kappa\\left(\\mathbf{a}_{t}^{(i)}, \\tilde{\\mathbf{a}}_{t}^{(j)}\\right) \\nabla_{\\mathbf{a}^{\\prime}} Q_{\\mathrm{soft}}\\left.\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{i}^{(i)}}+\\nabla_{\\mathbf{a}^{\\prime}} \\kappa\\left.\\left(\\mathbf{a}^{\\prime}, \\tilde{\\mathbf{a}}_{t}^{(j)}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{i}^{(i)}}\\right) \\nabla_{\\phi} f^{\\phi}\\left(\\tilde{\\xi}^{(j)} ; \\mathbf{s}_{t}\\right)\n\\tag{18}</script><p>更新方向为mini-batch经验的梯度平均值，而不是累加和</p>\n<ul>\n<li>伪代码中定义了Actor的target网络，参数为$\\overline{\\theta}$。但是伪代码中并没有显示出其在何处使用，我<strong>猜测</strong>该网络代表采样分布$q_{\\mathbf{a}^{\\prime}}$<ul>\n<li>$q_{\\mathbf{a}^{\\prime}}$在训练初期使用均匀分布</li>\n<li>$q_{\\mathbf{a}^{\\prime}}$在一段时间之后使用Actor真实分布，我猜测这里使用的就是Actor目标网络</li>\n</ul>\n</li>\n<li>噪音$\\xi$从多维标准正态分布中采样，维度最好与动作空间维度一致</li>\n<li>$\\left\\{\\mathbf{a}^{(i, j)}\\right\\}_{j=0}^{M} \\sim q_{\\mathbf{a}^{\\prime}}$其中的M用于设置采样多少个样本，以使用公式（11）计算V值，使用的网络为Q目标网络</li>\n<li>在更新Q网络时，使用了从经验池采样到的真实执行过的动作</li>\n<li>$\\left\\{\\xi^{(i, j)}\\right\\}_{j=0}^{M} \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{I})$中其实少写了一个参数$K$，但实际上$K=M$，在这一步中需要采样两组噪音，当然也可以采样一组，使用两次。</li>\n<li>在更新Actor网络时，没有使用经验池中采样到的动作，而模拟采样了两组动作，即根据两组噪音生成的动作，用它们来计算梯度并更新。</li>\n<li>Q网络的输入为状态与动作的连接，$(s||a)$，输出为Q值</li>\n<li>Actor网络的输入为状态与噪音的连接，$(s||\\xi)$，输出为动作$a$</li>\n<li>伪代码中的式(10)、(11)、(13)、(14)分别代表本文中的式(11)、(12)、(16)、(17)</li>\n</ul>\n<h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><h2 id=\"实验设置\"><a href=\"#实验设置\" class=\"headerlink\" title=\"实验设置\"></a>实验设置</h2><ul>\n<li>比较算法：DDPG vs SQL</li>\n<li>Actor和Q网络使用Adam优化器</li>\n<li>Actor学习率为0.0001，Q网络学习率为0.001</li>\n<li>经验池大小为100W</li>\n<li>经验池填充1W条经验后开始训练</li>\n<li>batch_size=64</li>\n<li>Actor和Q网络都是2层隐藏层，每层200个隐藏节点，激活函数为ReLU</li>\n<li><p>DDPG和SQL都使用了Ornstein-Uhlenbeck随机过程产生噪音来增加探索，它是一种序贯相关的随机过程，$\\theta=0.15 \\ , \\ \\sigma=0.3$</p>\n<ul>\n<li><p>OU随机过程可以在序贯模型中添加与时间相关的随机噪音，而且噪音也满足强马尔可夫性</p>\n</li>\n<li><p>形式为$d x_{t}=\\theta\\left(\\mu-x_{t}\\right) d t+\\sigma d W_{t}$，是一个具有均值恢复属性的随机过程</p>\n</li>\n<li><p>$\\theta$表示变量$x$以多大幅度、多块恢复到平均值，$\\mu$代表平均值，$\\sigma$代表波动程度，$d W_{t}$代表维纳过程，一般通过高斯分布实现</p>\n</li>\n<li><p>OU随机过程产生的噪音只与上一次产生的噪音相关，它可以用于增加探索，也能够柔顺控制。比如在相邻的两个决策动作，一个为10，一个为-10，反复如此，智能体会产生震荡。在此使用OU过程可以使智能体在一个方向保持一定时间，不会瞬间过大地改变智能体的状态，相当于增加了时滞性。</p>\n</li>\n<li><p>代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = 10</span><br><span class=\"line\">dx = theta * (mu - x) + sigma * numpy.random.randn(len(x))</span><br><span class=\"line\">x = x + dx</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>参考：</p>\n<ul>\n<li><a href=\"https://www.quora.com/Why-do-we-use-the-Ornstein-Uhlenbeck-Process-in-the-exploration-of-DDPG\" rel=\"external nofollow\" target=\"_blank\">https://www.quora.com/Why-do-we-use-the-Ornstein-Uhlenbeck-Process-in-the-exploration-of-DDPG</a></li>\n<li><a href=\"https://github.com/floodsung/DDPG-tensorflow/blob/master/ou_noise.py\" rel=\"external nofollow\" target=\"_blank\">https://github.com/floodsung/DDPG-tensorflow/blob/master/ou_noise.py</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/51333694\" rel=\"external nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/51333694</a></li>\n<li>核函数使用了径向基函数RBF，$\\kappa\\left(\\mathbf{a}, \\mathbf{a}^{\\prime}\\right)=\\exp \\left(-\\frac{1}{h}\\left|\\mathbf{a}-\\mathbf{a}^{\\prime}\\right|_{2}^{2}\\right)$，其中，$h=\\frac{d}{2 \\log (M+1)}$，$d$为各变量对之间距离的中位数</li>\n<li>目标网络的更新采样硬覆盖的模式</li>\n<li>超参数$\\alpha$根据任务设置为10，0.1等等</li>\n<li>训练的epoch、步长、系数$\\alpha$，采样动作的数量$K 和 M$根据任务（多目标，单目标，微调）的不同而不同，具体请看原论文附录D部分</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p>未完待续</p>\n<h1 id=\"个人感想\"><a href=\"#个人感想\" class=\"headerlink\" title=\"个人感想\"></a>个人感想</h1><p>虽然文中用大量公式、篇幅结合最大熵进行介绍、推理，但是在伪代码以及目标函数中似乎并没有看到关于熵的影子，包含熵项的Q值也是通过Q网络的输出将熵的值包含在内，并没有显式地计算它。</p>\n<p>虽然算法的名字为soft Q-Learning，但其实它跟传统的Q-Learning算法思想并不相同，如果说有一点相同，那也是都是想使Q值收敛以推导出最优策略，但是这个优化过程也跟SARSA算法比较像，并没有使用传统Q-Learning中贪婪的选择最有价值下一个动作以自举的方法。</p>\n","site":{"data":{}},"excerpt":"<p>本文提出了一个算法，用于学习连续空间下基于能量的策略：SQL，不是数据库的SQL，而是soft Q-Learning。该算法应用了最大熵理论，并且使用能量模型（EBM，Energy-Based Model）作为决策模型。</p>\n<p>推荐阅读该论文：</p>\n<ul>\n<li>公式复杂，但详尽吃透可以学习到SVGD、EBM等概念与算法</li>\n<li>文章充实，可以继续阅读后续算法SAC</li>\n<li>拓展在强化学习与熵进行结合方面的知识</li>\n</ul>","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>论文地址：<a href=\"https://arxiv.org/abs/1702.08165\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/abs/1702.08165</a></p>\n<p>源代码：<a href=\"https://github.com/rail-berkeley/softlearning\" rel=\"external nofollow\" target=\"_blank\">https://github.com/rail-berkeley/softlearning</a></p>\n<p>该论文与2017年发于第34次ICML会议上，本文对v2版本进行分析。该论文作者为Tuomas Haarnoja，是伯克利大学BAIR实验室的博士生，SAC算法也是他的杰作。</p>\n<p>传统的RL方法主要是用分布拟合单峰分布，即</p>\n<p><img src=\"./rl-with-deep-energy-based-policies/unimodal-policy.png\" alt=\"\"></p>\n<p>也有许多算法想要根据Q函数的值拟合出多峰分布，即</p>\n<p><img src=\"./rl-with-deep-energy-based-policies/multimodal-policy.png\" alt=\"\"></p>\n<p>本文中就是针对拟合多峰分布提出了算法SQL。</p>\n<p>为什么要拟合多峰分布呢？当我们考虑最优控制和概率推理之间的联系时，随机策略才是最优解。</p>\n<blockquote>\n<p>As discussed in prior work, a stochastic policy emerges as the optimal answer when we consider the connection between optimal control and probabilistic inference.</p>\n</blockquote>\n<p>随机策略有一些优点：</p>\n<ul>\n<li>如果可以全面地学习给定任务中的目标策略，那么结果策略可以作为很好的初始化策略，微调后以学习更高级的策略</li>\n<li>这种随机的探索机制，可以更好地寻求多峰任务中的最佳决策模型</li>\n<li>更好的鲁棒性，环境有干扰或者噪音时，有多种完成目标的行动可以选择，可以从干扰中“脱身”</li>\n</ul>\n<h2 id=\"算法效果\"><a href=\"#算法效果\" class=\"headerlink\" title=\"算法效果\"></a>算法效果</h2><blockquote>\n<p>The applications of training such stochastic policies include improved exploration in the case of multimodal objectives and compositionality via pretraining general-purpose stochastic policies that can then be efficiently finetuned into task-specific behaviors. </p>\n</blockquote>\n<p>在多峰目标任务中训练随机策略可以提升探索，也可以预训练出通用目的的随机策略以微调后运用至指定任务中进行训练（迁移学习、元学习）。</p>\n<h1 id=\"文中精要\"><a href=\"#文中精要\" class=\"headerlink\" title=\"文中精要\"></a>文中精要</h1><h2 id=\"标准强化学习的最优策略\"><a href=\"#标准强化学习的最优策略\" class=\"headerlink\" title=\"标准强化学习的最优策略\"></a>标准强化学习的最优策略</h2><script type=\"math/tex; mode=display\">\n\\pi_{\\mathrm{std}}^{*}=\\arg \\max _{\\pi} \\sum_{t} \\mathbb{E}_{\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\sim \\rho_{\\pi}}\\left[r\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right] \\tag{1}</script><ul>\n<li><p><code>std</code>下标代表标准的意思：standard，星号$\\ast$代表最优</p>\n</li>\n<li><p>$\\rho_{\\pi}$代表策略$\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right)$下的迹分布，$\\rho_{\\pi}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)$代表状态-行动对的边缘分布。</p>\n</li>\n</ul>\n<blockquote>\n<p>We will also use $\\rho_{\\pi}\\left(\\mathbf{s}_{t}\\right)$ and $\\rho_{\\pi}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)$ to denote the state and state-action marginals of the trajectory distribution induced by a policy $\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right)$. </p>\n</blockquote>\n<h2 id=\"最大熵强化学习的最优策略\"><a href=\"#最大熵强化学习的最优策略\" class=\"headerlink\" title=\"最大熵强化学习的最优策略\"></a>最大熵强化学习的最优策略</h2><p>最大熵强化学习在标准RL的目标函数上加入了一个关于状态下可选动作分布熵的项，这种目标希望智能体不仅能以获得最大奖励的方式完成目标，而且能够决策地尽可能随机。因为通过这种目标函数学到的策略<strong>更具鲁棒性</strong>，可以更好适用于环境的突然变化，或者从前没有遇到过得场景。</p>\n<script type=\"math/tex; mode=display\">\n\\pi_{\\mathrm{MaxEnt}}^{*}=\\arg \\max _{\\pi} \\sum_{t} \\mathbb{E}_{\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\sim \\rho_{\\pi}}\\left[r\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)+\\color{red}{\\alpha \\mathcal{H}\\left(\\pi\\left(\\cdot | \\mathbf{s}_{t}\\right)\\right)}\\right]\n\\tag{2}</script><ul>\n<li><code>MaxEnt</code>下标代表最大熵的意思：Maximum entropy</li>\n<li>式中的系数$\\alpha$可以用来调节奖励项与熵值项的重要性比率。<strong>一般将$\\alpha$表示为奖励范围（reward scale）的倒数，但在实际中通常将其作为超参数手动调节。</strong>SAC算法中有介绍在训练过程中自动调节该系数的方法。</li>\n<li>本文中的SQL算法也是为了优化该目标函数</li>\n</ul>\n<h2 id=\"最大熵目标的优点\"><a href=\"#最大熵目标的优点\" class=\"headerlink\" title=\"最大熵目标的优点\"></a>最大熵目标的优点</h2><ul>\n<li>在多峰（即一个状态下有多个最优动作选择）问题中提升探索能力</li>\n<li>可以用于迁移学习，因为其“预训练”模型更好地适应之后的任务</li>\n</ul>\n<h2 id=\"soft-值函数\"><a href=\"#soft-值函数\" class=\"headerlink\" title=\"soft 值函数\"></a>soft 值函数</h2><p>文中，<strong><em>定义</em></strong>了最大熵RL下的Q函数与V函数，注意，是定义，不是推导出来的。</p>\n<p>soft Q函数定义如下：</p>\n<script type=\"math/tex; mode=display\">\n{Q_{\\text { soft }}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+}  {\\mathbb{E}_{\\left(\\mathbf{s}_{t+1}, \\ldots\\right) \\sim \\rho_{\\pi}}\\left[\\sum_{l=1}^{\\infty} \\gamma^{l}\\left(r_{t+l}+\\alpha \\mathcal{H}\\left(\\pi_{\\text { MaxEnt }}^{*}\\left(\\cdot | \\mathbf{s}_{t+l}\\right)\\right)\\right)\\right]}\n\\tag{3}</script><p>soft V函数定义如下：</p>\n<script type=\"math/tex; mode=display\">\nV_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)=\\alpha \\log \\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}\n\\tag{4}</script><p>乍一看这个值函数$V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)$的形式定义的很奇怪，的确很奇怪，严格来说，它的真实意义并不是为了构造状态值函数，而是构造一个配分函数使得后面推导最优策略时可以化简过程。当然，算法中也不需要用它的值去衡量状态的价值，只是作为计算的中间过程。</p>\n<p>作者说，值函数满足soft 贝尔曼方程，即</p>\n<script type=\"math/tex; mode=display\">\nQ_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t+1}\\right)\\right]\n\\tag{5}</script><h2 id=\"能量模型与策略\"><a href=\"#能量模型与策略\" class=\"headerlink\" title=\"能量模型与策略\"></a>能量模型与策略</h2><p>文中提出能量模型（Energy-Based Models）的初衷是之前很多人在研究中使用了多项式分布（discrete multinomial distributions）、高斯分布（Gaussian distributions）来表示策略，这样的分布通常用来表示动作价值分布是单峰（unimodal）的情况，而且最终收敛结果往往是接近确定性（near-deterministic）的。即使拓展出多峰的形式，也各自有或多或少的不足。基于此，作者想使用更广泛、通用的分布用来表示复杂、多峰的动作选择。</p>\n<p>所以，作者选择使用基于能量的通用策略：</p>\n<script type=\"math/tex; mode=display\">\n\\pi\\left(\\mathbf{a}_{t} | \\mathbf{s}_{t}\\right) \\propto \\exp \\left(-\\mathcal{E}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right)\n\\tag{6}</script><ul>\n<li><p>$\\mathcal{E}$是字母E的花体形式，代表能量函数，其可以被深度神经网络表示，如果使用通用值函数近似来表示能量函数，那么可以表示任意策略$\\pi\\left(\\boldsymbol{a}_{t} | \\mathbf{s}_{t}\\right)$</p>\n</li>\n<li><blockquote>\n<p>where $\\mathcal{E}$ is an energy function that could be represented, for example, by a deep neural network. If we use a universal function approximator for $\\mathcal{E}$, we can represent any distribution $\\pi\\left(\\boldsymbol{a}_{t} | \\mathbf{s}_{t}\\right)$. </p>\n</blockquote>\n</li>\n<li><p>文中将该能量函数设置为</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{E}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=-\\frac{1}{\\alpha} Q_{\\operatorname{soft}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\n\\tag{7}</script><p>其实也很容易就能理解，将负号抵消掉之后，Q值大的动作能量高嘛，指数分布又能更好的放大较大的值，使Q值大的动作更为突出，这样完全可以作为选择动作的策略</p>\n</li>\n</ul>\n<p>但是有一个问题是，不能使能量无限大呀，假如超过了计算能力那就不好了，当然这种情况几乎不会发生。于是，可以将能量给归一化，即</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned} \n\\pi_{\\text { MaxEnt }}^{*}\\left(a_{t} | s_{t}\\right) \n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right) \\mathrm{d} a^{\\prime}} \\\\ \n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\exp \\left(\\frac{1}{\\alpha} V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)} \\\\\n&=\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)\\right)}{\\color{blue}{\\exp \\log} \\exp \\left(\\frac{1}{\\alpha} V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)} \\\\\n&=\\color{red}{\\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)-V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)\\right)}\n\\end{aligned}\n\\tag{8}</script><p></p><p align=\"center\" style=\"color:blue\"><a href=\"https://bluefisher.github.io/2018/11/13/Reinforcement-Learning-with-Deep-Energy-Based-Policies/\" rel=\"external nofollow\" target=\"_blank\">BlueFisher's Blog</a></p><br>论文中只给出了红色字体的部分，其实这才是作者想要表达的意思，文中就是基于此定义了状态值函数$V_{\\mathrm{soft}}^{*}\\left(\\mathbf{s}_{t}\\right)$的形式。<p></p>\n<p>在这个公式中就可以看出，策略是对动作值函数Q进行了一个softmax操作，这也是文中soft的含义。</p>\n<h2 id=\"使用SQL优化目标函数\"><a href=\"#使用SQL优化目标函数\" class=\"headerlink\" title=\"使用SQL优化目标函数\"></a>使用SQL优化目标函数</h2><p>像使用Q-Learning对网格世界问题进行优化求解一样，我们也可以使用迭代的方式进行优化，交互计算两个值函数，使其各自收敛，就可以导出最优策略。</p>\n<p>于是，作者定义了soft Q-Iteration。</p>\n<h3 id=\"Soft-Q-Iteration\"><a href=\"#Soft-Q-Iteration\" class=\"headerlink\" title=\"Soft Q-Iteration\"></a>Soft Q-Iteration</h3><p>先要假设值函数$Q_{\\mathrm{soft}}(\\cdot, \\cdot)$、$V_{\\text { soft }}(\\cdot)$有界，</p>\n<script type=\"math/tex; mode=display\">\n\\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}\\left(\\cdot, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}<\\infty \\ ，\\ Q_{\\mathrm{soft}}^{*}<\\infty\n\\tag{9}</script><p>文中定义的交互迭代至收敛的方式其实跟SARSA算法比较像：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{c}\n{Q_{\\text { soft }}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right) \\leftarrow r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\text { soft }}\\left(\\mathbf{s}_{t+1}\\right)\\right], \\forall \\mathbf{s}_{t}, \\mathbf{a}_{t}} \\\\ \n{V_{\\text { soft }}\\left(\\mathbf{s}_{t}\\right) \\leftarrow \\alpha \\log \\int_{\\mathcal{A}} \\exp \\left(\\frac{1}{\\alpha} Q_{\\text { soft }}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right) d \\mathbf{a}^{\\prime}, \\forall \\mathbf{s}_{t}}\n\\end{array}\n\\tag{10}</script><p>这种优化方式在理论上是可行的，但是在实际应用中存在两个问题：</p>\n<ol>\n<li>连续空间无法求期望，或者计算不准确。<strong>解决方案是重要性采样，使用采样多次后计算来代替积分，在初期进行随机均匀采样，后期根据policy来采样。</strong></li>\n<li>迭代过程需要不断选择动作，问题是式（8）的分布形式无法进行采样。<strong>解决方案是使用SVGD算法拟合后验分布，并输出采样的动作。</strong></li>\n</ol>\n<h3 id=\"Soft-Q-Learning\"><a href=\"#Soft-Q-Learning\" class=\"headerlink\" title=\"Soft Q-Learning\"></a>Soft Q-Learning</h3><p>文中在这一部分引用了重要性采样，解决了上面提到的第一个问题，即，使用分布$q_{\\mathrm{a}^{\\prime}}$来代替真实策略分布</p>\n<script type=\"math/tex; mode=display\">\n\\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\text { soft }}^{*}\\left(s_{t}, a_{t}\\right)-V_{\\text { soft }}^{*}\\left(s_{t}\\right)\\right)\\right\n)</script><p>进行采样。</p>\n<script type=\"math/tex; mode=display\">\nV_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}\\right)=\\alpha \\log \\mathbb{E}_{\\color{red}{q_{\\mathrm{a}^{\\prime}}}}\\left[\\frac{\\exp \\left(\\frac{1}{\\alpha} Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right)}{q_{\\mathrm{a}^{\\prime}}\\left(\\mathbf{a}^{\\prime}\\right)}\\right]\n\\tag{11}</script><p>采样分布$q_{\\mathrm{a}^{\\prime}}$可以使用任意的分布，但是由于重要性采样的性质，采样分布与原分布越接近，效果越好。式子中的$\\theta$为Q神经网络的参数。</p>\n<p>因为在训练初期，我们估计的真实分布是偏差很大的，几乎可以说是错误的，因此在训练初期将采样分布设置为均匀分布比较合理，在训练一段时间之后，可以将采样分布设置为接近原分布，甚至是原分布（如果原分布可以采样，如，使用神经网络等“黑匣子”进行表示）</p>\n<p>由此，可以定义Q神经网络的损失函数为：</p>\n<script type=\"math/tex; mode=display\">\nJ_{Q}(\\theta)=\\mathbb{E}_{\\mathbf{s}_{t} \\sim q_{\\mathbf{s}_{t}}, \\mathbf{a}_{t} \\sim q_{\\mathbf{a}_{t}}}\\left[\\frac{1}{2}\\left(\\hat{Q}_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)-Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)\\right)^{2}\\right]\n\\tag{12}</script><p>上式中期望的下标为环境和真实策略分布，$\\overline{\\theta}$代表target网络的参数，目标是最小化这个损失函数，其中，</p>\n<script type=\"math/tex; mode=display\">\n\\hat{Q}_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t}, \\mathbf{a}_{t}\\right)=r_{t}+\\gamma \\mathbb{E}_{\\mathbf{s}_{t+1} \\sim p_{\\mathbf{s}}}\\left[V_{\\mathrm{soft}}^{\\overline{\\theta}}\\left(\\mathbf{s}_{t+1}\\right)\\right]\n\\tag{13}</script><h3 id=\"近似采样与SVGD\"><a href=\"#近似采样与SVGD\" class=\"headerlink\" title=\"近似采样与SVGD\"></a>近似采样与SVGD</h3><p>SVGD：Stein Vairational Gradient Descent，SVGD是一种确定性的、基于梯度的近似推理采样算法。</p>\n<p>文中在这一部分引用了SVGD的优化算法，并且使用SVGD近似策略的后验分布以进行采样，解决了上文提到的第二个问题。在百度上完全搜不到关于SVGD算法的信息，但是了解了这个算法之后，感觉它的能力还是很强的，最终，搜集了Google、Bing的检索结果，发现了原作者在SVGD方法上的一些资源分享，<a href=\"https://www.cs.utexas.edu/~lqiang/stein.html\" rel=\"external nofollow\" target=\"_blank\">Stein’s Method for Practical Machine Learning</a></p>\n<p>对于基于能量的模型、分布，有两类采样方式：</p>\n<ol>\n<li>MCMC采样，即马尔科夫链蒙特卡洛采样</li>\n<li>学习一个采样网络去近似采样出符合目标分布的样本</li>\n</ol>\n<p>在需要不断更新策略的在线学习任务中，使用MCMC采样是不可行的，于是作者使用了基于SVGD和Amortized SVGD的采样网络。</p>\n<p>SVGD论文：<a href=\"https://arxiv.org/abs/1608.04471\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/abs/1608.04471</a></p>\n<p>Amortized SVGD论文：<a href=\"https://arxiv.org/abs/1707.06626\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/abs/1707.06626</a></p>\n<p><img src=\"./rl-with-deep-energy-based-policies/1dgmm.gif\" alt=\"\"><br><img src=\"./rl-with-deep-energy-based-policies/vp.gif\" alt=\"\"></p>\n<p>Amortized SVGD有一些有趣的性质：</p>\n<ul>\n<li>可以训练随机采样网络非常快地采样</li>\n<li>可以准确收敛至EBM能量模型的后验估计分布</li>\n<li>文中结合了Amortized SVGD后，算法形式很像A-C模式</li>\n</ul>\n<p>SVGD算法的更新形式是这样的，</p>\n<script type=\"math/tex; mode=display\">\nx_{i} \\leftarrow x_{i}+\\frac{\\epsilon}{n} \\sum_{j=1}^{n}\\left[k\\left(x_{j}, x_{i}\\right) \\nabla_{x_{j}} \\log p\\left(x_{j}\\right)+\\nabla_{x_{j}} k\\left(x_{j}, x_{i}\\right)\\right], \\qquad \\forall i=1, \\ldots, n\n\\tag{14}</script><ul>\n<li>$\\epsilon$代表学习率</li>\n<li>$k\\left(x_{j}, x_{i}\\right)$代表正定核，如径向基（RBF，Radial Basis Function）函数$k\\left(x, x^{\\prime}\\right)=\\exp \\left(-\\frac{1}{h}\\left|x-x^{\\prime}\\right|_{2}^{2}\\right)$，它可以被认为是变量之间的相似性度量</li>\n<li>包含对数项$\\log p\\left(x_{j}\\right)$的梯度驱使采样器朝着$p(x)$分布中高概率区域进行采样</li>\n<li>第二项核函数梯度驱使样本点之间产生间隙，相当于用一个排斥力使样本点尽可能分散开</li>\n<li>对数项梯度不依赖分布$p(x)$的归一化常数，使SVGD易于应用于图模型、贝叶斯推理和深层生成模型中出现的难以处理的分布。</li>\n</ul>\n<p>先定义我们采样网络（其实就是Actor）的目标函数：</p>\n<script type=\"math/tex; mode=display\">\nJ_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)=D_{\\mathrm{KL}}\\left(\\pi^{\\phi}\\left(\\cdot | \\mathbf{s}_{t}\\right) \\| \\exp \\left(\\frac{1}{\\alpha}\\left(Q_{\\mathrm{soft}}^{\\theta}\\left(\\mathbf{s}_{t}, \\cdot\\right)-V_{\\mathrm{soft}}^{\\theta}\\right)\\right)\\right)\n\\tag{15}</script><ul>\n<li>$\\phi$表示采样网络中的参数</li>\n<li>将产生动作的函数简写成$\\mathbf{a}_{t}^{(i)}=f^{\\phi}\\left(\\xi^{(i)} ; \\mathbf{s}_{t}\\right)$，也就是说神经网络的输入分为两部分，一部分是状态$s$，一部分是噪声扰乱“perturb”$\\xi$，一般从标准正态分布中采样，而且最好使噪声的维度与动作的维度一致</li>\n</ul>\n<p>计算梯度方向：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\Delta f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)=& \\mathbb{E}_{\\mathbf{a}_{t} \\sim \\pi^{\\phi}}\\left[\\kappa\\left(\\mathbf{a}_{t}, f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)\\right) \\nabla_{\\mathbf{a}^{\\prime}} Q_{\\mathrm{soft}}^{\\theta}\\left.\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{t}}\\right.\\\\ &+\\alpha \\nabla_{\\mathbf{a}^{\\prime}} \\kappa\\left.\\left(\\mathbf{a}^{\\prime}, f^{\\phi}\\left(\\cdot ; \\mathbf{s}_{t}\\right)\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{t}} ] \\end{aligned}\n\\tag{16}</script><ul>\n<li><p>严格来说，$\\Delta f^{\\phi}$是希尔伯特空间的最优梯度方向，并不是Actor目标函数$J_{\\pi}$的梯度</p>\n</li>\n<li><blockquote>\n<p>To be precise, $\\Delta f^{\\phi}$ is the optimal direction in the reproducing kernel Hilbert space of $\\kappa$, and is thus not strictly speaking the gradient of $J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)$ </p>\n</blockquote>\n</li>\n</ul>\n<p>根据链式法则，Stein变分梯度SVG为</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\partial J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)}{\\partial \\phi} \\propto \\mathbb{E}_{\\xi}\\left[\\Delta f^{\\phi}\\left(\\xi ; \\mathbf{s}_{t}\\right) \\frac{\\partial f^{\\phi}\\left(\\xi ; \\mathbf{s}_{t}\\right)}{\\partial \\phi}\\right]\n\\tag{17}</script><h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./rl-with-deep-energy-based-policies/pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<p>算法中更新Actor网络时，其实是使用了如下梯度公式：</p>\n<script type=\"math/tex; mode=display\">\n\\hat{\\nabla}_{\\phi} J_{\\pi}\\left(\\phi ; \\mathbf{s}_{t}\\right)=\\frac{1}{K M} \\sum_{j=1}^{K} \\sum_{i=1}^{M}\\left(\\kappa\\left(\\mathbf{a}_{t}^{(i)}, \\tilde{\\mathbf{a}}_{t}^{(j)}\\right) \\nabla_{\\mathbf{a}^{\\prime}} Q_{\\mathrm{soft}}\\left.\\left(\\mathbf{s}_{t}, \\mathbf{a}^{\\prime}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{i}^{(i)}}+\\nabla_{\\mathbf{a}^{\\prime}} \\kappa\\left.\\left(\\mathbf{a}^{\\prime}, \\tilde{\\mathbf{a}}_{t}^{(j)}\\right)\\right|_{\\mathbf{a}^{\\prime}=\\mathbf{a}_{i}^{(i)}}\\right) \\nabla_{\\phi} f^{\\phi}\\left(\\tilde{\\xi}^{(j)} ; \\mathbf{s}_{t}\\right)\n\\tag{18}</script><p>更新方向为mini-batch经验的梯度平均值，而不是累加和</p>\n<ul>\n<li>伪代码中定义了Actor的target网络，参数为$\\overline{\\theta}$。但是伪代码中并没有显示出其在何处使用，我<strong>猜测</strong>该网络代表采样分布$q_{\\mathbf{a}^{\\prime}}$<ul>\n<li>$q_{\\mathbf{a}^{\\prime}}$在训练初期使用均匀分布</li>\n<li>$q_{\\mathbf{a}^{\\prime}}$在一段时间之后使用Actor真实分布，我猜测这里使用的就是Actor目标网络</li>\n</ul>\n</li>\n<li>噪音$\\xi$从多维标准正态分布中采样，维度最好与动作空间维度一致</li>\n<li>$\\left\\{\\mathbf{a}^{(i, j)}\\right\\}_{j=0}^{M} \\sim q_{\\mathbf{a}^{\\prime}}$其中的M用于设置采样多少个样本，以使用公式（11）计算V值，使用的网络为Q目标网络</li>\n<li>在更新Q网络时，使用了从经验池采样到的真实执行过的动作</li>\n<li>$\\left\\{\\xi^{(i, j)}\\right\\}_{j=0}^{M} \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{I})$中其实少写了一个参数$K$，但实际上$K=M$，在这一步中需要采样两组噪音，当然也可以采样一组，使用两次。</li>\n<li>在更新Actor网络时，没有使用经验池中采样到的动作，而模拟采样了两组动作，即根据两组噪音生成的动作，用它们来计算梯度并更新。</li>\n<li>Q网络的输入为状态与动作的连接，$(s||a)$，输出为Q值</li>\n<li>Actor网络的输入为状态与噪音的连接，$(s||\\xi)$，输出为动作$a$</li>\n<li>伪代码中的式(10)、(11)、(13)、(14)分别代表本文中的式(11)、(12)、(16)、(17)</li>\n</ul>\n<h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><h2 id=\"实验设置\"><a href=\"#实验设置\" class=\"headerlink\" title=\"实验设置\"></a>实验设置</h2><ul>\n<li>比较算法：DDPG vs SQL</li>\n<li>Actor和Q网络使用Adam优化器</li>\n<li>Actor学习率为0.0001，Q网络学习率为0.001</li>\n<li>经验池大小为100W</li>\n<li>经验池填充1W条经验后开始训练</li>\n<li>batch_size=64</li>\n<li>Actor和Q网络都是2层隐藏层，每层200个隐藏节点，激活函数为ReLU</li>\n<li><p>DDPG和SQL都使用了Ornstein-Uhlenbeck随机过程产生噪音来增加探索，它是一种序贯相关的随机过程，$\\theta=0.15 \\ , \\ \\sigma=0.3$</p>\n<ul>\n<li><p>OU随机过程可以在序贯模型中添加与时间相关的随机噪音，而且噪音也满足强马尔可夫性</p>\n</li>\n<li><p>形式为$d x_{t}=\\theta\\left(\\mu-x_{t}\\right) d t+\\sigma d W_{t}$，是一个具有均值恢复属性的随机过程</p>\n</li>\n<li><p>$\\theta$表示变量$x$以多大幅度、多块恢复到平均值，$\\mu$代表平均值，$\\sigma$代表波动程度，$d W_{t}$代表维纳过程，一般通过高斯分布实现</p>\n</li>\n<li><p>OU随机过程产生的噪音只与上一次产生的噪音相关，它可以用于增加探索，也能够柔顺控制。比如在相邻的两个决策动作，一个为10，一个为-10，反复如此，智能体会产生震荡。在此使用OU过程可以使智能体在一个方向保持一定时间，不会瞬间过大地改变智能体的状态，相当于增加了时滞性。</p>\n</li>\n<li><p>代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = 10</span><br><span class=\"line\">dx = theta * (mu - x) + sigma * numpy.random.randn(len(x))</span><br><span class=\"line\">x = x + dx</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>参考：</p>\n<ul>\n<li><a href=\"https://www.quora.com/Why-do-we-use-the-Ornstein-Uhlenbeck-Process-in-the-exploration-of-DDPG\" rel=\"external nofollow\" target=\"_blank\">https://www.quora.com/Why-do-we-use-the-Ornstein-Uhlenbeck-Process-in-the-exploration-of-DDPG</a></li>\n<li><a href=\"https://github.com/floodsung/DDPG-tensorflow/blob/master/ou_noise.py\" rel=\"external nofollow\" target=\"_blank\">https://github.com/floodsung/DDPG-tensorflow/blob/master/ou_noise.py</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/51333694\" rel=\"external nofollow\" target=\"_blank\">https://zhuanlan.zhihu.com/p/51333694</a></li>\n<li>核函数使用了径向基函数RBF，$\\kappa\\left(\\mathbf{a}, \\mathbf{a}^{\\prime}\\right)=\\exp \\left(-\\frac{1}{h}\\left|\\mathbf{a}-\\mathbf{a}^{\\prime}\\right|_{2}^{2}\\right)$，其中，$h=\\frac{d}{2 \\log (M+1)}$，$d$为各变量对之间距离的中位数</li>\n<li>目标网络的更新采样硬覆盖的模式</li>\n<li>超参数$\\alpha$根据任务设置为10，0.1等等</li>\n<li>训练的epoch、步长、系数$\\alpha$，采样动作的数量$K 和 M$根据任务（多目标，单目标，微调）的不同而不同，具体请看原论文附录D部分</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h2><p>未完待续</p>\n<h1 id=\"个人感想\"><a href=\"#个人感想\" class=\"headerlink\" title=\"个人感想\"></a>个人感想</h1><p>虽然文中用大量公式、篇幅结合最大熵进行介绍、推理，但是在伪代码以及目标函数中似乎并没有看到关于熵的影子，包含熵项的Q值也是通过Q网络的输出将熵的值包含在内，并没有显式地计算它。</p>\n<p>虽然算法的名字为soft Q-Learning，但其实它跟传统的Q-Learning算法思想并不相同，如果说有一点相同，那也是都是想使Q值收敛以推导出最优策略，但是这个优化过程也跟SARSA算法比较像，并没有使用传统Q-Learning中贪婪的选择最有价值下一个动作以自举的方法。</p>"},{"title":"强化学习之MDP马尔科夫决策过程","copyright":true,"top":1,"date":"2019-05-08T03:04:20.000Z","mathjax":true,"_content":"\n# 强化学习之MDP马尔科夫决策过程\n\n每每提到强化学习，最先接触的理论肯定是马尔科夫决策过程（MDP，Markov Decision Process），为什么总提到MDP呢？并不是只有我一个人有这个疑问。\n\n<!--more-->\n\n百度上没有人提出这样的问题，可能是大家理解得都比较透彻吧，于是在Google查到相关提问和解释。\n\n> [What is the relationship between Markov Decision Processes and Reinforcement Learning?](https://datascience.stackexchange.com/a/38851)\n\n>>In Reinforcement Learning (RL), the problem to resolve is described as a Markov Decision Process (MDP). Theoretical results in RL rely on the MDP description being a correct match to the problem. If your problem is well described as a MDP, then RL may be a good framework to use to find solutions. That does not mean you need to fully describe the MDP (all the transition probabilities), just that you expect an MDP model could be made or discovered.\n\n>>Conversely, if you cannot map your problem onto a MDP, then the theory behind RL makes no guarantees of any useful result.\n\n>>One key factor that affects how well RL will work is that the states should have the Markov property - that the value of the current state is enough knowledge to fix immediate transition probabilities and immediate rewards following an action choice. Again you don't need to know in advance what those are, just that this relationship is expected to be reliable and stable. If it is not reliable, you may have a POMDP. If it is not stable, you may have a non-stationary problem. In either case, if the difference from a more strictly defined MDP is small enough, you may still get away with using RL techniques or need to adapt them slightly.\n>>\n>>**The general relationship between RL and MDP is that RL is a framework for solving problems that can be expressed as MDPs.**\n\nMDP是当前强化学习理论推导的基石，对强化学习来说，一般以马尔科夫决策过程作为形式化问题的手段。也就是说，对于目前的绝大部分强化学习算法，只有可以将问题抽象为MDP的才可以确保算法的性能（收敛性，效果等），对于违背MDP的问题并不一定确保算法有效，因为其数学公式都是基于MDP来进行推导的。\n\n## 马尔科夫性\n\n> 马尔科夫性质（英语：Markov property）是概率论中的一个概念，因为俄国数学家安德雷·马尔科夫得名。当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态；换句话说，在给定现在状态时，它与过去状态（即该过程的历史路径）是条件独立的，那么此随机过程即具有马尔科夫性质。[马尔科夫性-百度百科](https://baike.baidu.com/item/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%80%A7%E8%B4%A8/23149887?fr=aladdin)\n\n马尔科夫性，也就是无后效性：**某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响**。也就是说，**未来与过去无关**。\n\n具体地说，如果一个问题被划分各个阶段之后，阶段$k$中的状态只能通过阶段$k+1$中的状态通过状态转移方程得来，与其他状态没有关系，特别是与未发生的状态没有关系，这就是无后效性。\n\n公式描述：\n\n$$\nP[S_{t+1}|S_{t}]=P[S_{t+1}|S_{1},...,S_{t}]\n$$\n\n强化学习问题中的状态也符合马尔科夫性，即在当前状态$s_{t}$下执行动作$a_{t}$并转移至下一个状态$s_{t+1}$，而不需要考虑之前的状态$s_{t-1},...,s_{1}$。\n\n举一个不恰当的例子：\n\n![](./强化学习之MDP马尔科夫决策过程/M.jpg)\n\n假设天气预测符合马尔科夫性，如果以每天表示为一种状态，即周一、周二到周日。今天（5月8日，周三）天气为晴，明天（周四）会不会下雨只与今天的天气有关，而与之前周一、周二的天气状况无关。如果以时间节点表示为一种状态，即2点、5点、8点等，如图2点的温度为15.8°C,那么下个时间点5点的气温如何只与2点的温度有关系。\n\n强化学习中默认状态的转移是符合马尔科夫性质的，状态具体是什么，需要根据不同的问题进行不同的设定。\n\n## 马尔科夫过程\n\n马尔科夫过程是随机过程的一种，什么是随机过程呢？简单来说，一个商店从早上营业到晚上打烊这段时间，根据每个时间点店内顾客的人数所组成的序列就是随机过程。随机过程根据时间节点$T_{t}$取到的值是一个变量。\n\n马尔科夫过程是满足马尔科夫性的随机过程，它由二元组$M=(S,P)$组成，且满足：\n\n1. S是有限状态集合\n2. P是状态转移概率矩阵\n\n状态与状态之间的转换过程即为马尔科夫过程。***虽然我们可能不知道P的具体值到底是什么，但是通常我们假设P是存在的（转移概率存在，如果是确定的，无非就是概率为1），而且是稳定的（意思是从状态A到其他状态的转移虽然符合某个分布，但是其转移到某个状态的概率是确定的，不随时间变化的）。***\n\n这里说的**有限**二字我有自己的理解，在最开始的强化学习研究中，解决的都是表格式的问题，也就是状态的数量是有限可取的，但是后续强化学习研究的也有连续状态空间的问题，算法如DQN,PG,PPO等。状态的数量并不是有限的，但是其向量维度则是固定的、有限的，而且也同样符合马尔科夫性质，因此**我认为这里定义的有限并不是说状态数量有限，而是状态维度有限**。因为好像没有无限马尔科夫的叫法，所以姑且这么解释一下。\n\n马尔科夫过程有如下分类：\n\n![](./强化学习之MDP马尔科夫决策过程/MPs.jpg)\n\n### 状态转移矩阵\n\n状态转移矩阵由许多状态转移概率组成，状态转移概率是指从一个马尔科夫状态$s$转移到下一个状态$s'$的概率。\n\n公示表示：\n\n$$\n\\mathcal{P}_{ss'}=\\mathbb{P}[S_{t+1}=s'|S_{t}=s]\n$$\n\n等同于：\n\n$$\n\\mathcal{P}(s'|s)=\\mathbb{P}[S_{t+1}=s'|S_{t}=s]\n$$\n\n假设有1到n个状态，将所有的状态从上到下、从左到右排列，组成一个$n \\times n$的矩阵，那么其状态转移矩阵如下所示：\n\n$$\n\\mathcal{P}=\n\\begin{bmatrix}\n\\mathcal{P}_{11} & \\cdots & \\mathcal{P}_{1n} \\\\ \n\\vdots & \\ddots & \\vdots \\\\ \n\\mathcal{P}_{n1} & \\cdots & \\mathcal{P}_{nn} \\\\\n\\end{bmatrix}\n$$\n\n其中，每行元素相加等于1，矩阵的总和为状态的数量n。\n\n对于可数状态，$\\sum_{s'=1}^{n}\\mathcal{P}(s'|s)=1$\n\n$$\nsum(\\mathcal{P}) = \\sum_{s'=1}^{n}\\sum_{s=1}^{n}\\mathcal{P}_{ss'} = n\n$$\n\n对于不可数状态（连续状态),$\\int_{s'}\\mathcal{P}(s'|s)=1$\n\n$$\nsum(\\mathcal{P}) = \\int_{s'}\\int_{s}\\mathcal{P}_{ss'} = n\n$$\n\n举一个马尔科夫过程的例子:\n\n假设一个学生，他目前在学习语文科目，那么他接下来进行的活动过程如下图所示，游戏的吸引力很大，所以他有50%的概率在学完语文去玩游戏，并且很容易沉迷其中，图示玩游戏这个循环有90%的可能性，他还可以选择学习其他科目或者去睡觉，最终学习结束之后是否能通过考试也是有一定的概率的，这些状态之间转移的概率即为状态转移概率。\n\n![](./强化学习之MDP马尔科夫决策过程/MP.jpg)\n\n如果把例子中的各项状态用字母表示，将其表示为：\n$$\n\\begin{bmatrix}\n玩游戏 & A\\\\ \n语文 & B\\\\ \n数学 & C\\\\ \n英语 & D\\\\ \n挂科 & E\\\\ \n\\mathcal{Pass} & F\\\\ \n睡觉 & G\n\\end{bmatrix}\n$$\n那么其状态转移矩阵$\\mathcal{P}$可以表示成：\n$$\n\\begin{array}{lc}\n\\mbox{}&\n\\begin{array}{cc}A & B & C & D & E & F & G \\end{array}\\\\\n\\begin{array}{c}A\\\\B\\\\C\\\\D\\\\E\\\\F\\\\G\\end{array}&\n\\left[\\begin{array}{cc}\n0.9&0.1\\\\\n0.5& &0.5\\\\\n& & &0.8& & &0.2\\\\\n&&&&0.4&0.6&\\\\\n&0.2&0.4&0.4&&&\\\\\n&&&&&&1\\\\\n&&&&&&&\n\\end{array}\\right]\n\\end{array}\n$$\n\n### 马尔科夫链与Episode\n\nEpisode可以翻译为片段、情节、回合等，在强化学习问题中，一个Episode就是一个马尔科夫链，根据状态转移矩阵可以得到许多不同的episode，也就是多个马尔科夫链。\n\n强化学习问题分两种：\n\n1. 如果一个任务总能达到终态，结束任务或者开启下一轮任务，那么这个任务就被称为回合任务，也就是episode任务。例如，让一个智能体学习如何下围棋，围棋棋盘只有那么大，游戏定会终局，所以是一个回合式任务。\n2. 如果一个任务可以无限持续下去，永远不会结束，即永远在训练当中，那么这个任务就被称为连续性任务。例如，教会一辆车能够进行自动驾驶就是一个连续性任务，*不要钻牛角尖说能源会耗尽，车子会磨损，我们只聚焦问题与环境本身，不涉及其他非稳定因素。*\n\n在上边举的例子中就是一个回合式任务，因为无论这个序列有多长，最终都会达到终态-“睡觉”。\n\n根据上述例子我们可能采样出如下episode：\n\n1. $B-C-D-E-C-G$，即“学语文→数学→英语→考试没通过,挂科→继续学数学→睡觉”\n2. $B-A-A-...-A-B-C-G$，即“学语文→玩王者荣耀→玩刺激战场→玩OverCooker→玩守望先锋→玩英雄联盟→玩CS:GO→...→看一会儿数学→睡觉”。（仿佛就是我自己嘛！）\n\n## 马尔科夫奖励过程\n\n马尔科夫过程（Markov Process）主要描述的是状态之间的转移关系，在各个状态的转移过程中赋予不同的奖励值就得到了马尔科夫奖励过程。\n\n定义：马尔科夫奖励过程（Markov Reward Process, MRP）由一个四元组组成$(S,P,R,\\gamma)$\n\n1. $S$代表了状态的集合(也是维度有限的)\n2. $P$描述了状态转移矩阵$\\mathcal{P}_{ss'}=\\mathbb{P}[S_{t+1}=s'|S_{t}=s]$\n3. $R$表示奖励函数，$R(s)$描述了在状态$s$下的期望(立即)奖励，$\\mathcal{R}(s)=\\mathbb{E}[R_{t+1}|S_{t}=s]$\n4. $\\gamma$表示衰减因子,即discounted factor,$\\gamma\\in[0,1]$\n\n$\\gamma$是用来计算累计奖励回报的,表示我们有多看中现在或者未来,为什么这么说呢?假设我们现在要计算一个episode始态$S_{0}$的奖励值$V(S_{0})$,不涉及具体公式推导的说,我们应该把$S_{0}$状态后续的奖励全部加和,这样就得到了对始态$S_{0}$的值估计,这些后续奖励的值的权重都是1,或者说此时$\\gamma=1$,但是当前状态对很多步之后的状态未必影响很大,我们这样计算过来并不能完全表示一个状态的值,那么我们应当顺势减少距离远的状态的权重,此时$\\gamma\\lt1$\n\n- 当$\\gamma=0$时,状态$S$的值完全由其转移的期望立即奖励表示,即**一点都不关心未来**\n- 当$\\gamma=1$时,状态$S$的值由以当前状态为始态,运行至终态所得到的所有立即奖励加和的值表示,即**未来与现在同等重要**\n- 当$0 \\lt\\gamma \\lt1$时,状态$S$的值是前两个模式的*trade-off*,即**对未来看重的程度由$\\gamma$决定**\n\n这只是我们的直观感受,其实是为了数学便利（虽然我也不知道具体哪里提高了数学便利，但是在有些情况下会使值函数更快迭代收敛这是真的）。\n\n*注：也有很多地方将MRP表示为三元组，即去掉$\\gamma$，但这不影响我们对这个过程的理解，下边的MDP也是一样，无论是三元组、四元组、还是五元组，只要能描述过程的性质就可以。*\n\n将上述马尔科夫过程的例子升级为马尔科夫奖励过程如下图所示:\n\n![](./强化学习之MDP马尔科夫决策过程/MRP.png)\n\n奖励值定义为:\n$$\n\\begin{bmatrix}\n玩游戏 & A & -1\\\\ \n语文 & B & -2\\\\ \n数学 & C & -2\\\\ \n英语 & D & -2\\\\ \n挂科 & E & -5\\\\ \n\\mathcal{Pass} & F & 10\\\\ \n睡觉 & G & 0\n\\end{bmatrix}\n$$\n这么定义奖励并没有什么复杂的含义,在这个例子中就拿身心愉悦程度来定义吧,学习固然是枯燥无味的,所以给予负奖励-2,玩游戏虽然会心情放松,但是始终面临着考试的压力,其实并不轻松,所以给予负奖励-1,挂科最痛苦为-5,考试全pass最开心为+10。\n\n在马尔科夫过程中的状态转移加入相应的奖励值即为马尔科夫奖励过程。\n\n\n\n## 马尔科夫决策过程\n\n马尔科夫决策过程(Markov Decision Process, MDP)相比马尔科夫奖励过程多了一个动作$A$,它可以用一个五元组$(S,A,P,R,\\gamma)$表示:\n\n1. $S$代表了状态的集合(也是维度有限的)\n2. $A$代表了决策过程中动作的集合(维度有限的)\n3. $P$描述了状态转移矩阵$\\mathcal{P}_{ss'}^{a}=\\mathbb{P}[S_{t+1}=s'|S_{t}=s,A_{t}=a]$\n4. $R$表示奖励函数，$R(s)$描述了在状态$s$下**执行某动作**的期望(立即)奖励，$\\mathcal{R}(s,a)=\\mathbb{E}[R_{t+1}|S_{t}=s,A_{t}=a]$\n5. $\\gamma$表示衰减因子,即discounted factor,$\\gamma\\in[0,1]$\n\nMDPs是一个从交互中达成目标的强化学习问题的一个直接的框架。学习者和决策者叫做Agent。Agent进行交互的其它一切Agent之外的东西都叫做环境。Agent不断的选择动作，而环境也给出相应的反应，并且向Agent表现出新的状态。环境同时也给出一个数值作为反馈。Agent的目标就是通过选择不同的Action来最大化这个反馈值。\n\n![](./强化学习之MDP马尔科夫决策过程/agent-env.png)\n\n强化学习所研究的内容就是得到一个状态$S$到动作$A$的映射关系,因此策略Policy可以表示成\n$$\n\\pi(a|s)=p(A_{t}=a|S_{t}=s)\n$$\n---\n\n注意:\n你可能会认为,在马尔科夫奖励过程(MRP)中没有定义动作,但是其实是包含动作的,因为每个状态有多个转移的下一状态,其实就是多个动作嘛！\n\n很多文章会将有限MDP分开来讲，有限MDP即状态、动作和奖励值都只有有限个元素，对于有限MDP最优策略有唯一解，但是现实世界中任务复杂，因此大多数深度强化学习算法并不局限于解决有限MDP问题，因此本文不将MDP分情况来讲，即默认基于MDP的最优策略**至少有一个解**。\n\n---\n\n没错,的确是这样的,MRP中也包含动作,但是我们并不关心,为什么这么说呢?**因为就算每个状态可以执行多个动作,但是其每个动作所能转移到的状态是确定的,不确定的只是动作的选择,而不是动作的转移,而MDP中不确定的却是动作的转移,即执行动作所转移的下一状态是有一定概率的.**什么意思呢?拿之前MRP的例子来说,语文状态有两个状态可以转移,数学和玩游戏,概率分别是0.5,但是当确定一个转移方向的时候(图中的箭头),其转移结果是确定的,获得的奖励也是确定的,但是在MDP中,执行动作导致转移的结果都未必是确定的.***需要注意的是,MRP是属于MDP的,MDP执行动作并不一定必须是随机的.***\n\n接下来,我们将MRP的例子转换至MDP, 为了方便理解而又不增加示例的复杂性,不妨将\"挂科\"这个状态看作是一个动作,因为这个节点正巧入度为1,姑且就认为从英语到挂科的这个箭头是英语状态所能执行的动作.如图所示:\n\n![](./强化学习之MDP马尔科夫决策过程/MDP.jpg)\n\n比较两个图可以发现区别,我把这个不确定的动作标为实心黑圆圈,这位刻苦的同学在学习完英语之后还想继续学习,但是他感觉三门科目都差不多了,于是他也很迷茫,他执行\"学习\"这个动作时的转移状态有三种:学语文、学数学、学英语.概率分别是:0.2、0.4,、0.4.这下就明白为什么我们要在MDP中加入动作$A$了吧,如果还不明白,请接着看下边的内容.\n\n顺便说一下,这个时候的转移矩阵已经不是简单的二维了,当然也可以用二维来表示,假设总共有$n$个状态,每个状态有$m$个动作,那么其行数为$n\\times m$,即遍历所有的状态和动作,得到$n \\times m$个状态-动作对$(s,a)$,其列数还是$n$.当然,也可以用一个三维tensor来表示,行和列都是$n$,第三维深度为动作的数量m$,很好理解.\n\n---\n\n**网上有写MDP在给定策略下会退化为MRP,我对此不置可否,认为此种说法不够严谨,因为即使说在某状态s下选择的动作a是确定的,并不意味着其转移结果是确定的.**\n\n---\n\n### 回报 Return\n\n在强化学习问题中，总是提到回报二字，论文中出现Return或者Discounted Return，我们已经知道奖励是什么，奖励就是转移到某个状态或者执行了某个动作之后转移至某个状态所获得的值$r$.\n\n回报就是由某时刻$t$之后决策序列所获得的奖励值经过一定规则计算出来的数值.\n\n公式描述:\n$$\nG_{t}\\doteq R_{t+1}+R_{t+2}+R_{t+3}+...+R_{t}\n$$\n.其中,$T$表示一个episode达到终态的时间点.\n\n像之前介绍的一样,我们可能对未来有不同的看重程度,于是引入折扣因子$\\gamma$的回报表示为:\n$$\nG_{t}\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+...=\\begin{cases}\n\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\\\\n\\sum_{k=t+1}^{T}\\gamma^{k-t-1}R_{k}\n\\end{cases}\n$$\n其中,$ 0\\leq\\gamma \\leq1$\n\n可以推出回报有如下形式:\n$$\n\\begin{align*}\nG_{t} &\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+\\gamma^{3}R_{t+4}+...\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma R_{t+3}+\\gamma^{2}R_{t+4}+...)\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma (R_{t+3}+\\gamma R_{t+4}+...))\\\\\n&=R_{t+1}+\\gamma G_{t+1}\n\\end{align*}\n$$\n\n### 策略 Policy\n\n我们一般使用$\\pi$来表示一个策略,使用$\\pi(a|s)$来表示某状态$s$采取动作$a$的概率,公示表示为:\n$$\n\\pi(a|s)=P(A_{t}=a|S_{t}=s)\n$$\n策略完整定义了智能体在所有状态下的所有行为和其概率.\n\n给定一个MDP和一个策略$\\pi$,采样的状态序列\n$$\nS_{0},S_{1},S_{2},...,S_{n},...\n$$\n是一个马尔科夫过程$\\lt S,P \\gt ^{\\pi}$,\n\n采样的状态、奖励序列\n$$\n(S_{0},R_{0}),(S_{1},R_{1}),(S_{2},R_{2}),...,(S_{n},R_{n}),...\n$$\n是一个马尔科夫奖励过程$ \\lt S,P,R,\\gamma  \\gt^{\\pi}$,\n\n采样的状态、动作、奖励序列\n$$\n(S_{0},A_{0},R_{0}),(S_{1},A_{1},R_{1}),(S_{2},A_{2},R_{2}),...,(S_{n},A_{n},R_{n}),...\n$$\n是一个马尔科夫决策过程$ \\lt S,A^{\\pi},P,R,\\gamma  \\gt^{\\pi}$.\n\n*注意:在编程时一般以四元组$(s,a,r,s')$为单位存储\"经验\"*\n\n$\\pi$策略下$s\\rightarrow s'$转移概率由期望计算得$P_{ss'}^{\\pi}=\\sum_{a\\in A}\\pi(a|s)P_{ss'}^{a}$,$s$状态下的期望立即奖励为$R_{s}^{\\pi}=\\sum_{a\\in A}\\pi(a|s)R_{s}^{a}$.\n\n上述例子中\n$$\n\\begin{align*}\nR_{英语}&=\\sum_{a\\in A}\\pi(a|英语)R_{英语}^{a}\\\\\n&=0.2\\times-2+0.4\\times-2+0.4\\times-2\\\\\n&=-2\n\\end{align*}\n$$\n状态转移概率可以描述为：在执行策略$\\pi$时，状态从$s$转移至$s'$的概率等于执行该状态下所有行为的概率与对应行为能使状态从$s$转移至$s’$的概率的乘积的和。\n\n奖励函数可以描述为：在执行策略$\\pi$时获得的奖励等于执行该状态下所有行为的概率与对应行为产生的即时奖励的乘积的和。\n\n**强化学习的目标就是最大化期望回报,相应的结果就是找到从状态空间$S$映射到动作空间$A$的最优策略**,重点是,如何建立回报与策略之间的联系呢?","source":"_posts/强化学习之MDP马尔科夫决策过程.md","raw":"---\ntitle: 强化学习之MDP马尔科夫决策过程\ncopyright: true\ntop: 1\ndate: 2019-05-08 11:04:20\nmathjax: true\ncategories: ReinforcementLearning\ntags:\n- rl\n---\n\n# 强化学习之MDP马尔科夫决策过程\n\n每每提到强化学习，最先接触的理论肯定是马尔科夫决策过程（MDP，Markov Decision Process），为什么总提到MDP呢？并不是只有我一个人有这个疑问。\n\n<!--more-->\n\n百度上没有人提出这样的问题，可能是大家理解得都比较透彻吧，于是在Google查到相关提问和解释。\n\n> [What is the relationship between Markov Decision Processes and Reinforcement Learning?](https://datascience.stackexchange.com/a/38851)\n\n>>In Reinforcement Learning (RL), the problem to resolve is described as a Markov Decision Process (MDP). Theoretical results in RL rely on the MDP description being a correct match to the problem. If your problem is well described as a MDP, then RL may be a good framework to use to find solutions. That does not mean you need to fully describe the MDP (all the transition probabilities), just that you expect an MDP model could be made or discovered.\n\n>>Conversely, if you cannot map your problem onto a MDP, then the theory behind RL makes no guarantees of any useful result.\n\n>>One key factor that affects how well RL will work is that the states should have the Markov property - that the value of the current state is enough knowledge to fix immediate transition probabilities and immediate rewards following an action choice. Again you don't need to know in advance what those are, just that this relationship is expected to be reliable and stable. If it is not reliable, you may have a POMDP. If it is not stable, you may have a non-stationary problem. In either case, if the difference from a more strictly defined MDP is small enough, you may still get away with using RL techniques or need to adapt them slightly.\n>>\n>>**The general relationship between RL and MDP is that RL is a framework for solving problems that can be expressed as MDPs.**\n\nMDP是当前强化学习理论推导的基石，对强化学习来说，一般以马尔科夫决策过程作为形式化问题的手段。也就是说，对于目前的绝大部分强化学习算法，只有可以将问题抽象为MDP的才可以确保算法的性能（收敛性，效果等），对于违背MDP的问题并不一定确保算法有效，因为其数学公式都是基于MDP来进行推导的。\n\n## 马尔科夫性\n\n> 马尔科夫性质（英语：Markov property）是概率论中的一个概念，因为俄国数学家安德雷·马尔科夫得名。当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态；换句话说，在给定现在状态时，它与过去状态（即该过程的历史路径）是条件独立的，那么此随机过程即具有马尔科夫性质。[马尔科夫性-百度百科](https://baike.baidu.com/item/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%80%A7%E8%B4%A8/23149887?fr=aladdin)\n\n马尔科夫性，也就是无后效性：**某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响**。也就是说，**未来与过去无关**。\n\n具体地说，如果一个问题被划分各个阶段之后，阶段$k$中的状态只能通过阶段$k+1$中的状态通过状态转移方程得来，与其他状态没有关系，特别是与未发生的状态没有关系，这就是无后效性。\n\n公式描述：\n\n$$\nP[S_{t+1}|S_{t}]=P[S_{t+1}|S_{1},...,S_{t}]\n$$\n\n强化学习问题中的状态也符合马尔科夫性，即在当前状态$s_{t}$下执行动作$a_{t}$并转移至下一个状态$s_{t+1}$，而不需要考虑之前的状态$s_{t-1},...,s_{1}$。\n\n举一个不恰当的例子：\n\n![](./强化学习之MDP马尔科夫决策过程/M.jpg)\n\n假设天气预测符合马尔科夫性，如果以每天表示为一种状态，即周一、周二到周日。今天（5月8日，周三）天气为晴，明天（周四）会不会下雨只与今天的天气有关，而与之前周一、周二的天气状况无关。如果以时间节点表示为一种状态，即2点、5点、8点等，如图2点的温度为15.8°C,那么下个时间点5点的气温如何只与2点的温度有关系。\n\n强化学习中默认状态的转移是符合马尔科夫性质的，状态具体是什么，需要根据不同的问题进行不同的设定。\n\n## 马尔科夫过程\n\n马尔科夫过程是随机过程的一种，什么是随机过程呢？简单来说，一个商店从早上营业到晚上打烊这段时间，根据每个时间点店内顾客的人数所组成的序列就是随机过程。随机过程根据时间节点$T_{t}$取到的值是一个变量。\n\n马尔科夫过程是满足马尔科夫性的随机过程，它由二元组$M=(S,P)$组成，且满足：\n\n1. S是有限状态集合\n2. P是状态转移概率矩阵\n\n状态与状态之间的转换过程即为马尔科夫过程。***虽然我们可能不知道P的具体值到底是什么，但是通常我们假设P是存在的（转移概率存在，如果是确定的，无非就是概率为1），而且是稳定的（意思是从状态A到其他状态的转移虽然符合某个分布，但是其转移到某个状态的概率是确定的，不随时间变化的）。***\n\n这里说的**有限**二字我有自己的理解，在最开始的强化学习研究中，解决的都是表格式的问题，也就是状态的数量是有限可取的，但是后续强化学习研究的也有连续状态空间的问题，算法如DQN,PG,PPO等。状态的数量并不是有限的，但是其向量维度则是固定的、有限的，而且也同样符合马尔科夫性质，因此**我认为这里定义的有限并不是说状态数量有限，而是状态维度有限**。因为好像没有无限马尔科夫的叫法，所以姑且这么解释一下。\n\n马尔科夫过程有如下分类：\n\n![](./强化学习之MDP马尔科夫决策过程/MPs.jpg)\n\n### 状态转移矩阵\n\n状态转移矩阵由许多状态转移概率组成，状态转移概率是指从一个马尔科夫状态$s$转移到下一个状态$s'$的概率。\n\n公示表示：\n\n$$\n\\mathcal{P}_{ss'}=\\mathbb{P}[S_{t+1}=s'|S_{t}=s]\n$$\n\n等同于：\n\n$$\n\\mathcal{P}(s'|s)=\\mathbb{P}[S_{t+1}=s'|S_{t}=s]\n$$\n\n假设有1到n个状态，将所有的状态从上到下、从左到右排列，组成一个$n \\times n$的矩阵，那么其状态转移矩阵如下所示：\n\n$$\n\\mathcal{P}=\n\\begin{bmatrix}\n\\mathcal{P}_{11} & \\cdots & \\mathcal{P}_{1n} \\\\ \n\\vdots & \\ddots & \\vdots \\\\ \n\\mathcal{P}_{n1} & \\cdots & \\mathcal{P}_{nn} \\\\\n\\end{bmatrix}\n$$\n\n其中，每行元素相加等于1，矩阵的总和为状态的数量n。\n\n对于可数状态，$\\sum_{s'=1}^{n}\\mathcal{P}(s'|s)=1$\n\n$$\nsum(\\mathcal{P}) = \\sum_{s'=1}^{n}\\sum_{s=1}^{n}\\mathcal{P}_{ss'} = n\n$$\n\n对于不可数状态（连续状态),$\\int_{s'}\\mathcal{P}(s'|s)=1$\n\n$$\nsum(\\mathcal{P}) = \\int_{s'}\\int_{s}\\mathcal{P}_{ss'} = n\n$$\n\n举一个马尔科夫过程的例子:\n\n假设一个学生，他目前在学习语文科目，那么他接下来进行的活动过程如下图所示，游戏的吸引力很大，所以他有50%的概率在学完语文去玩游戏，并且很容易沉迷其中，图示玩游戏这个循环有90%的可能性，他还可以选择学习其他科目或者去睡觉，最终学习结束之后是否能通过考试也是有一定的概率的，这些状态之间转移的概率即为状态转移概率。\n\n![](./强化学习之MDP马尔科夫决策过程/MP.jpg)\n\n如果把例子中的各项状态用字母表示，将其表示为：\n$$\n\\begin{bmatrix}\n玩游戏 & A\\\\ \n语文 & B\\\\ \n数学 & C\\\\ \n英语 & D\\\\ \n挂科 & E\\\\ \n\\mathcal{Pass} & F\\\\ \n睡觉 & G\n\\end{bmatrix}\n$$\n那么其状态转移矩阵$\\mathcal{P}$可以表示成：\n$$\n\\begin{array}{lc}\n\\mbox{}&\n\\begin{array}{cc}A & B & C & D & E & F & G \\end{array}\\\\\n\\begin{array}{c}A\\\\B\\\\C\\\\D\\\\E\\\\F\\\\G\\end{array}&\n\\left[\\begin{array}{cc}\n0.9&0.1\\\\\n0.5& &0.5\\\\\n& & &0.8& & &0.2\\\\\n&&&&0.4&0.6&\\\\\n&0.2&0.4&0.4&&&\\\\\n&&&&&&1\\\\\n&&&&&&&\n\\end{array}\\right]\n\\end{array}\n$$\n\n### 马尔科夫链与Episode\n\nEpisode可以翻译为片段、情节、回合等，在强化学习问题中，一个Episode就是一个马尔科夫链，根据状态转移矩阵可以得到许多不同的episode，也就是多个马尔科夫链。\n\n强化学习问题分两种：\n\n1. 如果一个任务总能达到终态，结束任务或者开启下一轮任务，那么这个任务就被称为回合任务，也就是episode任务。例如，让一个智能体学习如何下围棋，围棋棋盘只有那么大，游戏定会终局，所以是一个回合式任务。\n2. 如果一个任务可以无限持续下去，永远不会结束，即永远在训练当中，那么这个任务就被称为连续性任务。例如，教会一辆车能够进行自动驾驶就是一个连续性任务，*不要钻牛角尖说能源会耗尽，车子会磨损，我们只聚焦问题与环境本身，不涉及其他非稳定因素。*\n\n在上边举的例子中就是一个回合式任务，因为无论这个序列有多长，最终都会达到终态-“睡觉”。\n\n根据上述例子我们可能采样出如下episode：\n\n1. $B-C-D-E-C-G$，即“学语文→数学→英语→考试没通过,挂科→继续学数学→睡觉”\n2. $B-A-A-...-A-B-C-G$，即“学语文→玩王者荣耀→玩刺激战场→玩OverCooker→玩守望先锋→玩英雄联盟→玩CS:GO→...→看一会儿数学→睡觉”。（仿佛就是我自己嘛！）\n\n## 马尔科夫奖励过程\n\n马尔科夫过程（Markov Process）主要描述的是状态之间的转移关系，在各个状态的转移过程中赋予不同的奖励值就得到了马尔科夫奖励过程。\n\n定义：马尔科夫奖励过程（Markov Reward Process, MRP）由一个四元组组成$(S,P,R,\\gamma)$\n\n1. $S$代表了状态的集合(也是维度有限的)\n2. $P$描述了状态转移矩阵$\\mathcal{P}_{ss'}=\\mathbb{P}[S_{t+1}=s'|S_{t}=s]$\n3. $R$表示奖励函数，$R(s)$描述了在状态$s$下的期望(立即)奖励，$\\mathcal{R}(s)=\\mathbb{E}[R_{t+1}|S_{t}=s]$\n4. $\\gamma$表示衰减因子,即discounted factor,$\\gamma\\in[0,1]$\n\n$\\gamma$是用来计算累计奖励回报的,表示我们有多看中现在或者未来,为什么这么说呢?假设我们现在要计算一个episode始态$S_{0}$的奖励值$V(S_{0})$,不涉及具体公式推导的说,我们应该把$S_{0}$状态后续的奖励全部加和,这样就得到了对始态$S_{0}$的值估计,这些后续奖励的值的权重都是1,或者说此时$\\gamma=1$,但是当前状态对很多步之后的状态未必影响很大,我们这样计算过来并不能完全表示一个状态的值,那么我们应当顺势减少距离远的状态的权重,此时$\\gamma\\lt1$\n\n- 当$\\gamma=0$时,状态$S$的值完全由其转移的期望立即奖励表示,即**一点都不关心未来**\n- 当$\\gamma=1$时,状态$S$的值由以当前状态为始态,运行至终态所得到的所有立即奖励加和的值表示,即**未来与现在同等重要**\n- 当$0 \\lt\\gamma \\lt1$时,状态$S$的值是前两个模式的*trade-off*,即**对未来看重的程度由$\\gamma$决定**\n\n这只是我们的直观感受,其实是为了数学便利（虽然我也不知道具体哪里提高了数学便利，但是在有些情况下会使值函数更快迭代收敛这是真的）。\n\n*注：也有很多地方将MRP表示为三元组，即去掉$\\gamma$，但这不影响我们对这个过程的理解，下边的MDP也是一样，无论是三元组、四元组、还是五元组，只要能描述过程的性质就可以。*\n\n将上述马尔科夫过程的例子升级为马尔科夫奖励过程如下图所示:\n\n![](./强化学习之MDP马尔科夫决策过程/MRP.png)\n\n奖励值定义为:\n$$\n\\begin{bmatrix}\n玩游戏 & A & -1\\\\ \n语文 & B & -2\\\\ \n数学 & C & -2\\\\ \n英语 & D & -2\\\\ \n挂科 & E & -5\\\\ \n\\mathcal{Pass} & F & 10\\\\ \n睡觉 & G & 0\n\\end{bmatrix}\n$$\n这么定义奖励并没有什么复杂的含义,在这个例子中就拿身心愉悦程度来定义吧,学习固然是枯燥无味的,所以给予负奖励-2,玩游戏虽然会心情放松,但是始终面临着考试的压力,其实并不轻松,所以给予负奖励-1,挂科最痛苦为-5,考试全pass最开心为+10。\n\n在马尔科夫过程中的状态转移加入相应的奖励值即为马尔科夫奖励过程。\n\n\n\n## 马尔科夫决策过程\n\n马尔科夫决策过程(Markov Decision Process, MDP)相比马尔科夫奖励过程多了一个动作$A$,它可以用一个五元组$(S,A,P,R,\\gamma)$表示:\n\n1. $S$代表了状态的集合(也是维度有限的)\n2. $A$代表了决策过程中动作的集合(维度有限的)\n3. $P$描述了状态转移矩阵$\\mathcal{P}_{ss'}^{a}=\\mathbb{P}[S_{t+1}=s'|S_{t}=s,A_{t}=a]$\n4. $R$表示奖励函数，$R(s)$描述了在状态$s$下**执行某动作**的期望(立即)奖励，$\\mathcal{R}(s,a)=\\mathbb{E}[R_{t+1}|S_{t}=s,A_{t}=a]$\n5. $\\gamma$表示衰减因子,即discounted factor,$\\gamma\\in[0,1]$\n\nMDPs是一个从交互中达成目标的强化学习问题的一个直接的框架。学习者和决策者叫做Agent。Agent进行交互的其它一切Agent之外的东西都叫做环境。Agent不断的选择动作，而环境也给出相应的反应，并且向Agent表现出新的状态。环境同时也给出一个数值作为反馈。Agent的目标就是通过选择不同的Action来最大化这个反馈值。\n\n![](./强化学习之MDP马尔科夫决策过程/agent-env.png)\n\n强化学习所研究的内容就是得到一个状态$S$到动作$A$的映射关系,因此策略Policy可以表示成\n$$\n\\pi(a|s)=p(A_{t}=a|S_{t}=s)\n$$\n---\n\n注意:\n你可能会认为,在马尔科夫奖励过程(MRP)中没有定义动作,但是其实是包含动作的,因为每个状态有多个转移的下一状态,其实就是多个动作嘛！\n\n很多文章会将有限MDP分开来讲，有限MDP即状态、动作和奖励值都只有有限个元素，对于有限MDP最优策略有唯一解，但是现实世界中任务复杂，因此大多数深度强化学习算法并不局限于解决有限MDP问题，因此本文不将MDP分情况来讲，即默认基于MDP的最优策略**至少有一个解**。\n\n---\n\n没错,的确是这样的,MRP中也包含动作,但是我们并不关心,为什么这么说呢?**因为就算每个状态可以执行多个动作,但是其每个动作所能转移到的状态是确定的,不确定的只是动作的选择,而不是动作的转移,而MDP中不确定的却是动作的转移,即执行动作所转移的下一状态是有一定概率的.**什么意思呢?拿之前MRP的例子来说,语文状态有两个状态可以转移,数学和玩游戏,概率分别是0.5,但是当确定一个转移方向的时候(图中的箭头),其转移结果是确定的,获得的奖励也是确定的,但是在MDP中,执行动作导致转移的结果都未必是确定的.***需要注意的是,MRP是属于MDP的,MDP执行动作并不一定必须是随机的.***\n\n接下来,我们将MRP的例子转换至MDP, 为了方便理解而又不增加示例的复杂性,不妨将\"挂科\"这个状态看作是一个动作,因为这个节点正巧入度为1,姑且就认为从英语到挂科的这个箭头是英语状态所能执行的动作.如图所示:\n\n![](./强化学习之MDP马尔科夫决策过程/MDP.jpg)\n\n比较两个图可以发现区别,我把这个不确定的动作标为实心黑圆圈,这位刻苦的同学在学习完英语之后还想继续学习,但是他感觉三门科目都差不多了,于是他也很迷茫,他执行\"学习\"这个动作时的转移状态有三种:学语文、学数学、学英语.概率分别是:0.2、0.4,、0.4.这下就明白为什么我们要在MDP中加入动作$A$了吧,如果还不明白,请接着看下边的内容.\n\n顺便说一下,这个时候的转移矩阵已经不是简单的二维了,当然也可以用二维来表示,假设总共有$n$个状态,每个状态有$m$个动作,那么其行数为$n\\times m$,即遍历所有的状态和动作,得到$n \\times m$个状态-动作对$(s,a)$,其列数还是$n$.当然,也可以用一个三维tensor来表示,行和列都是$n$,第三维深度为动作的数量m$,很好理解.\n\n---\n\n**网上有写MDP在给定策略下会退化为MRP,我对此不置可否,认为此种说法不够严谨,因为即使说在某状态s下选择的动作a是确定的,并不意味着其转移结果是确定的.**\n\n---\n\n### 回报 Return\n\n在强化学习问题中，总是提到回报二字，论文中出现Return或者Discounted Return，我们已经知道奖励是什么，奖励就是转移到某个状态或者执行了某个动作之后转移至某个状态所获得的值$r$.\n\n回报就是由某时刻$t$之后决策序列所获得的奖励值经过一定规则计算出来的数值.\n\n公式描述:\n$$\nG_{t}\\doteq R_{t+1}+R_{t+2}+R_{t+3}+...+R_{t}\n$$\n.其中,$T$表示一个episode达到终态的时间点.\n\n像之前介绍的一样,我们可能对未来有不同的看重程度,于是引入折扣因子$\\gamma$的回报表示为:\n$$\nG_{t}\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+...=\\begin{cases}\n\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\\\\n\\sum_{k=t+1}^{T}\\gamma^{k-t-1}R_{k}\n\\end{cases}\n$$\n其中,$ 0\\leq\\gamma \\leq1$\n\n可以推出回报有如下形式:\n$$\n\\begin{align*}\nG_{t} &\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+\\gamma^{3}R_{t+4}+...\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma R_{t+3}+\\gamma^{2}R_{t+4}+...)\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma (R_{t+3}+\\gamma R_{t+4}+...))\\\\\n&=R_{t+1}+\\gamma G_{t+1}\n\\end{align*}\n$$\n\n### 策略 Policy\n\n我们一般使用$\\pi$来表示一个策略,使用$\\pi(a|s)$来表示某状态$s$采取动作$a$的概率,公示表示为:\n$$\n\\pi(a|s)=P(A_{t}=a|S_{t}=s)\n$$\n策略完整定义了智能体在所有状态下的所有行为和其概率.\n\n给定一个MDP和一个策略$\\pi$,采样的状态序列\n$$\nS_{0},S_{1},S_{2},...,S_{n},...\n$$\n是一个马尔科夫过程$\\lt S,P \\gt ^{\\pi}$,\n\n采样的状态、奖励序列\n$$\n(S_{0},R_{0}),(S_{1},R_{1}),(S_{2},R_{2}),...,(S_{n},R_{n}),...\n$$\n是一个马尔科夫奖励过程$ \\lt S,P,R,\\gamma  \\gt^{\\pi}$,\n\n采样的状态、动作、奖励序列\n$$\n(S_{0},A_{0},R_{0}),(S_{1},A_{1},R_{1}),(S_{2},A_{2},R_{2}),...,(S_{n},A_{n},R_{n}),...\n$$\n是一个马尔科夫决策过程$ \\lt S,A^{\\pi},P,R,\\gamma  \\gt^{\\pi}$.\n\n*注意:在编程时一般以四元组$(s,a,r,s')$为单位存储\"经验\"*\n\n$\\pi$策略下$s\\rightarrow s'$转移概率由期望计算得$P_{ss'}^{\\pi}=\\sum_{a\\in A}\\pi(a|s)P_{ss'}^{a}$,$s$状态下的期望立即奖励为$R_{s}^{\\pi}=\\sum_{a\\in A}\\pi(a|s)R_{s}^{a}$.\n\n上述例子中\n$$\n\\begin{align*}\nR_{英语}&=\\sum_{a\\in A}\\pi(a|英语)R_{英语}^{a}\\\\\n&=0.2\\times-2+0.4\\times-2+0.4\\times-2\\\\\n&=-2\n\\end{align*}\n$$\n状态转移概率可以描述为：在执行策略$\\pi$时，状态从$s$转移至$s'$的概率等于执行该状态下所有行为的概率与对应行为能使状态从$s$转移至$s’$的概率的乘积的和。\n\n奖励函数可以描述为：在执行策略$\\pi$时获得的奖励等于执行该状态下所有行为的概率与对应行为产生的即时奖励的乘积的和。\n\n**强化学习的目标就是最大化期望回报,相应的结果就是找到从状态空间$S$映射到动作空间$A$的最优策略**,重点是,如何建立回报与策略之间的联系呢?","slug":"强化学习之MDP马尔科夫决策过程","published":1,"updated":"2020-05-21T09:43:45.886Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzutl8006220cdgzgwut2g","content":"<h1 id=\"强化学习之MDP马尔科夫决策过程\"><a href=\"#强化学习之MDP马尔科夫决策过程\" class=\"headerlink\" title=\"强化学习之MDP马尔科夫决策过程\"></a>强化学习之MDP马尔科夫决策过程</h1><p>每每提到强化学习，最先接触的理论肯定是马尔科夫决策过程（MDP，Markov Decision Process），为什么总提到MDP呢？并不是只有我一个人有这个疑问。</p>\n<a id=\"more\"></a>\n<p>百度上没有人提出这样的问题，可能是大家理解得都比较透彻吧，于是在Google查到相关提问和解释。</p>\n<blockquote>\n<p><a href=\"https://datascience.stackexchange.com/a/38851\" rel=\"external nofollow\" target=\"_blank\">What is the relationship between Markov Decision Processes and Reinforcement Learning?</a></p>\n<blockquote>\n<p>In Reinforcement Learning (RL), the problem to resolve is described as a Markov Decision Process (MDP). Theoretical results in RL rely on the MDP description being a correct match to the problem. If your problem is well described as a MDP, then RL may be a good framework to use to find solutions. That does not mean you need to fully describe the MDP (all the transition probabilities), just that you expect an MDP model could be made or discovered.</p>\n<p>Conversely, if you cannot map your problem onto a MDP, then the theory behind RL makes no guarantees of any useful result.</p>\n<p>One key factor that affects how well RL will work is that the states should have the Markov property - that the value of the current state is enough knowledge to fix immediate transition probabilities and immediate rewards following an action choice. Again you don’t need to know in advance what those are, just that this relationship is expected to be reliable and stable. If it is not reliable, you may have a POMDP. If it is not stable, you may have a non-stationary problem. In either case, if the difference from a more strictly defined MDP is small enough, you may still get away with using RL techniques or need to adapt them slightly.</p>\n<p><strong>The general relationship between RL and MDP is that RL is a framework for solving problems that can be expressed as MDPs.</strong></p>\n</blockquote>\n</blockquote>\n<p>MDP是当前强化学习理论推导的基石，对强化学习来说，一般以马尔科夫决策过程作为形式化问题的手段。也就是说，对于目前的绝大部分强化学习算法，只有可以将问题抽象为MDP的才可以确保算法的性能（收敛性，效果等），对于违背MDP的问题并不一定确保算法有效，因为其数学公式都是基于MDP来进行推导的。</p>\n<h2 id=\"马尔科夫性\"><a href=\"#马尔科夫性\" class=\"headerlink\" title=\"马尔科夫性\"></a>马尔科夫性</h2><blockquote>\n<p>马尔科夫性质（英语：Markov property）是概率论中的一个概念，因为俄国数学家安德雷·马尔科夫得名。当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态；换句话说，在给定现在状态时，它与过去状态（即该过程的历史路径）是条件独立的，那么此随机过程即具有马尔科夫性质。<a href=\"https://baike.baidu.com/item/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%80%A7%E8%B4%A8/23149887?fr=aladdin\" rel=\"external nofollow\" target=\"_blank\">马尔科夫性-百度百科</a></p>\n</blockquote>\n<p>马尔科夫性，也就是无后效性：<strong>某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响</strong>。也就是说，<strong>未来与过去无关</strong>。</p>\n<p>具体地说，如果一个问题被划分各个阶段之后，阶段$k$中的状态只能通过阶段$k+1$中的状态通过状态转移方程得来，与其他状态没有关系，特别是与未发生的状态没有关系，这就是无后效性。</p>\n<p>公式描述：</p>\n<script type=\"math/tex; mode=display\">\nP[S_{t+1}|S_{t}]=P[S_{t+1}|S_{1},...,S_{t}]</script><p>强化学习问题中的状态也符合马尔科夫性，即在当前状态$s_{t}$下执行动作$a_{t}$并转移至下一个状态$s_{t+1}$，而不需要考虑之前的状态$s_{t-1},…,s_{1}$。</p>\n<p>举一个不恰当的例子：</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/M.jpg\" alt=\"\"></p>\n<p>假设天气预测符合马尔科夫性，如果以每天表示为一种状态，即周一、周二到周日。今天（5月8日，周三）天气为晴，明天（周四）会不会下雨只与今天的天气有关，而与之前周一、周二的天气状况无关。如果以时间节点表示为一种状态，即2点、5点、8点等，如图2点的温度为15.8°C,那么下个时间点5点的气温如何只与2点的温度有关系。</p>\n<p>强化学习中默认状态的转移是符合马尔科夫性质的，状态具体是什么，需要根据不同的问题进行不同的设定。</p>\n<h2 id=\"马尔科夫过程\"><a href=\"#马尔科夫过程\" class=\"headerlink\" title=\"马尔科夫过程\"></a>马尔科夫过程</h2><p>马尔科夫过程是随机过程的一种，什么是随机过程呢？简单来说，一个商店从早上营业到晚上打烊这段时间，根据每个时间点店内顾客的人数所组成的序列就是随机过程。随机过程根据时间节点$T_{t}$取到的值是一个变量。</p>\n<p>马尔科夫过程是满足马尔科夫性的随机过程，它由二元组$M=(S,P)$组成，且满足：</p>\n<ol>\n<li>S是有限状态集合</li>\n<li>P是状态转移概率矩阵</li>\n</ol>\n<p>状态与状态之间的转换过程即为马尔科夫过程。<strong><em>虽然我们可能不知道P的具体值到底是什么，但是通常我们假设P是存在的（转移概率存在，如果是确定的，无非就是概率为1），而且是稳定的（意思是从状态A到其他状态的转移虽然符合某个分布，但是其转移到某个状态的概率是确定的，不随时间变化的）。</em></strong></p>\n<p>这里说的<strong>有限</strong>二字我有自己的理解，在最开始的强化学习研究中，解决的都是表格式的问题，也就是状态的数量是有限可取的，但是后续强化学习研究的也有连续状态空间的问题，算法如DQN,PG,PPO等。状态的数量并不是有限的，但是其向量维度则是固定的、有限的，而且也同样符合马尔科夫性质，因此<strong>我认为这里定义的有限并不是说状态数量有限，而是状态维度有限</strong>。因为好像没有无限马尔科夫的叫法，所以姑且这么解释一下。</p>\n<p>马尔科夫过程有如下分类：</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/MPs.jpg\" alt=\"\"></p>\n<h3 id=\"状态转移矩阵\"><a href=\"#状态转移矩阵\" class=\"headerlink\" title=\"状态转移矩阵\"></a>状态转移矩阵</h3><p>状态转移矩阵由许多状态转移概率组成，状态转移概率是指从一个马尔科夫状态$s$转移到下一个状态$s’$的概率。</p>\n<p>公示表示：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{P}_{ss'}=\\mathbb{P}[S_{t+1}=s'|S_{t}=s]</script><p>等同于：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{P}(s'|s)=\\mathbb{P}[S_{t+1}=s'|S_{t}=s]</script><p>假设有1到n个状态，将所有的状态从上到下、从左到右排列，组成一个$n \\times n$的矩阵，那么其状态转移矩阵如下所示：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{P}=\n\\begin{bmatrix}\n\\mathcal{P}_{11} & \\cdots & \\mathcal{P}_{1n} \\\\ \n\\vdots & \\ddots & \\vdots \\\\ \n\\mathcal{P}_{n1} & \\cdots & \\mathcal{P}_{nn} \\\\\n\\end{bmatrix}</script><p>其中，每行元素相加等于1，矩阵的总和为状态的数量n。</p>\n<p>对于可数状态，$\\sum_{s’=1}^{n}\\mathcal{P}(s’|s)=1$</p>\n<script type=\"math/tex; mode=display\">\nsum(\\mathcal{P}) = \\sum_{s'=1}^{n}\\sum_{s=1}^{n}\\mathcal{P}_{ss'} = n</script><p>对于不可数状态（连续状态),$\\int_{s’}\\mathcal{P}(s’|s)=1$</p>\n<script type=\"math/tex; mode=display\">\nsum(\\mathcal{P}) = \\int_{s'}\\int_{s}\\mathcal{P}_{ss'} = n</script><p>举一个马尔科夫过程的例子:</p>\n<p>假设一个学生，他目前在学习语文科目，那么他接下来进行的活动过程如下图所示，游戏的吸引力很大，所以他有50%的概率在学完语文去玩游戏，并且很容易沉迷其中，图示玩游戏这个循环有90%的可能性，他还可以选择学习其他科目或者去睡觉，最终学习结束之后是否能通过考试也是有一定的概率的，这些状态之间转移的概率即为状态转移概率。</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/MP.jpg\" alt=\"\"></p>\n<p>如果把例子中的各项状态用字母表示，将其表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n玩游戏 & A\\\\ \n语文 & B\\\\ \n数学 & C\\\\ \n英语 & D\\\\ \n挂科 & E\\\\ \n\\mathcal{Pass} & F\\\\ \n睡觉 & G\n\\end{bmatrix}</script><p>那么其状态转移矩阵$\\mathcal{P}$可以表示成：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{lc}\n\\mbox{}&\n\\begin{array}{cc}A & B & C & D & E & F & G \\end{array}\\\\\n\\begin{array}{c}A\\\\B\\\\C\\\\D\\\\E\\\\F\\\\G\\end{array}&\n\\left[\\begin{array}{cc}\n0.9&0.1\\\\\n0.5& &0.5\\\\\n& & &0.8& & &0.2\\\\\n&&&&0.4&0.6&\\\\\n&0.2&0.4&0.4&&&\\\\\n&&&&&&1\\\\\n&&&&&&&\n\\end{array}\\right]\n\\end{array}</script><h3 id=\"马尔科夫链与Episode\"><a href=\"#马尔科夫链与Episode\" class=\"headerlink\" title=\"马尔科夫链与Episode\"></a>马尔科夫链与Episode</h3><p>Episode可以翻译为片段、情节、回合等，在强化学习问题中，一个Episode就是一个马尔科夫链，根据状态转移矩阵可以得到许多不同的episode，也就是多个马尔科夫链。</p>\n<p>强化学习问题分两种：</p>\n<ol>\n<li>如果一个任务总能达到终态，结束任务或者开启下一轮任务，那么这个任务就被称为回合任务，也就是episode任务。例如，让一个智能体学习如何下围棋，围棋棋盘只有那么大，游戏定会终局，所以是一个回合式任务。</li>\n<li>如果一个任务可以无限持续下去，永远不会结束，即永远在训练当中，那么这个任务就被称为连续性任务。例如，教会一辆车能够进行自动驾驶就是一个连续性任务，<em>不要钻牛角尖说能源会耗尽，车子会磨损，我们只聚焦问题与环境本身，不涉及其他非稳定因素。</em></li>\n</ol>\n<p>在上边举的例子中就是一个回合式任务，因为无论这个序列有多长，最终都会达到终态-“睡觉”。</p>\n<p>根据上述例子我们可能采样出如下episode：</p>\n<ol>\n<li>$B-C-D-E-C-G$，即“学语文→数学→英语→考试没通过,挂科→继续学数学→睡觉”</li>\n<li>$B-A-A-…-A-B-C-G$，即“学语文→玩王者荣耀→玩刺激战场→玩OverCooker→玩守望先锋→玩英雄联盟→玩CS:GO→…→看一会儿数学→睡觉”。（仿佛就是我自己嘛！）</li>\n</ol>\n<h2 id=\"马尔科夫奖励过程\"><a href=\"#马尔科夫奖励过程\" class=\"headerlink\" title=\"马尔科夫奖励过程\"></a>马尔科夫奖励过程</h2><p>马尔科夫过程（Markov Process）主要描述的是状态之间的转移关系，在各个状态的转移过程中赋予不同的奖励值就得到了马尔科夫奖励过程。</p>\n<p>定义：马尔科夫奖励过程（Markov Reward Process, MRP）由一个四元组组成$(S,P,R,\\gamma)$</p>\n<ol>\n<li>$S$代表了状态的集合(也是维度有限的)</li>\n<li>$P$描述了状态转移矩阵$\\mathcal{P}_{ss’}=\\mathbb{P}[S_{t+1}=s’|S_{t}=s]$</li>\n<li>$R$表示奖励函数，$R(s)$描述了在状态$s$下的期望(立即)奖励，$\\mathcal{R}(s)=\\mathbb{E}[R_{t+1}|S_{t}=s]$</li>\n<li>$\\gamma$表示衰减因子,即discounted factor,$\\gamma\\in[0,1]$</li>\n</ol>\n<p>$\\gamma$是用来计算累计奖励回报的,表示我们有多看中现在或者未来,为什么这么说呢?假设我们现在要计算一个episode始态$S_{0}$的奖励值$V(S_{0})$,不涉及具体公式推导的说,我们应该把$S_{0}$状态后续的奖励全部加和,这样就得到了对始态$S_{0}$的值估计,这些后续奖励的值的权重都是1,或者说此时$\\gamma=1$,但是当前状态对很多步之后的状态未必影响很大,我们这样计算过来并不能完全表示一个状态的值,那么我们应当顺势减少距离远的状态的权重,此时$\\gamma\\lt1$</p>\n<ul>\n<li>当$\\gamma=0$时,状态$S$的值完全由其转移的期望立即奖励表示,即<strong>一点都不关心未来</strong></li>\n<li>当$\\gamma=1$时,状态$S$的值由以当前状态为始态,运行至终态所得到的所有立即奖励加和的值表示,即<strong>未来与现在同等重要</strong></li>\n<li>当$0 \\lt\\gamma \\lt1$时,状态$S$的值是前两个模式的<em>trade-off</em>,即<strong>对未来看重的程度由$\\gamma$决定</strong></li>\n</ul>\n<p>这只是我们的直观感受,其实是为了数学便利（虽然我也不知道具体哪里提高了数学便利，但是在有些情况下会使值函数更快迭代收敛这是真的）。</p>\n<p><em>注：也有很多地方将MRP表示为三元组，即去掉$\\gamma$，但这不影响我们对这个过程的理解，下边的MDP也是一样，无论是三元组、四元组、还是五元组，只要能描述过程的性质就可以。</em></p>\n<p>将上述马尔科夫过程的例子升级为马尔科夫奖励过程如下图所示:</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/MRP.png\" alt=\"\"></p>\n<p>奖励值定义为:</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n玩游戏 & A & -1\\\\ \n语文 & B & -2\\\\ \n数学 & C & -2\\\\ \n英语 & D & -2\\\\ \n挂科 & E & -5\\\\ \n\\mathcal{Pass} & F & 10\\\\ \n睡觉 & G & 0\n\\end{bmatrix}</script><p>这么定义奖励并没有什么复杂的含义,在这个例子中就拿身心愉悦程度来定义吧,学习固然是枯燥无味的,所以给予负奖励-2,玩游戏虽然会心情放松,但是始终面临着考试的压力,其实并不轻松,所以给予负奖励-1,挂科最痛苦为-5,考试全pass最开心为+10。</p>\n<p>在马尔科夫过程中的状态转移加入相应的奖励值即为马尔科夫奖励过程。</p>\n<h2 id=\"马尔科夫决策过程\"><a href=\"#马尔科夫决策过程\" class=\"headerlink\" title=\"马尔科夫决策过程\"></a>马尔科夫决策过程</h2><p>马尔科夫决策过程(Markov Decision Process, MDP)相比马尔科夫奖励过程多了一个动作$A$,它可以用一个五元组$(S,A,P,R,\\gamma)$表示:</p>\n<ol>\n<li>$S$代表了状态的集合(也是维度有限的)</li>\n<li>$A$代表了决策过程中动作的集合(维度有限的)</li>\n<li>$P$描述了状态转移矩阵$\\mathcal{P}_{ss’}^{a}=\\mathbb{P}[S_{t+1}=s’|S_{t}=s,A_{t}=a]$</li>\n<li>$R$表示奖励函数，$R(s)$描述了在状态$s$下<strong>执行某动作</strong>的期望(立即)奖励，$\\mathcal{R}(s,a)=\\mathbb{E}[R_{t+1}|S_{t}=s,A_{t}=a]$</li>\n<li>$\\gamma$表示衰减因子,即discounted factor,$\\gamma\\in[0,1]$</li>\n</ol>\n<p>MDPs是一个从交互中达成目标的强化学习问题的一个直接的框架。学习者和决策者叫做Agent。Agent进行交互的其它一切Agent之外的东西都叫做环境。Agent不断的选择动作，而环境也给出相应的反应，并且向Agent表现出新的状态。环境同时也给出一个数值作为反馈。Agent的目标就是通过选择不同的Action来最大化这个反馈值。</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/agent-env.png\" alt=\"\"></p>\n<p>强化学习所研究的内容就是得到一个状态$S$到动作$A$的映射关系,因此策略Policy可以表示成</p>\n<script type=\"math/tex; mode=display\">\n\\pi(a|s)=p(A_{t}=a|S_{t}=s)</script><hr>\n<p>注意:<br>你可能会认为,在马尔科夫奖励过程(MRP)中没有定义动作,但是其实是包含动作的,因为每个状态有多个转移的下一状态,其实就是多个动作嘛！</p>\n<p>很多文章会将有限MDP分开来讲，有限MDP即状态、动作和奖励值都只有有限个元素，对于有限MDP最优策略有唯一解，但是现实世界中任务复杂，因此大多数深度强化学习算法并不局限于解决有限MDP问题，因此本文不将MDP分情况来讲，即默认基于MDP的最优策略<strong>至少有一个解</strong>。</p>\n<hr>\n<p>没错,的确是这样的,MRP中也包含动作,但是我们并不关心,为什么这么说呢?<strong>因为就算每个状态可以执行多个动作,但是其每个动作所能转移到的状态是确定的,不确定的只是动作的选择,而不是动作的转移,而MDP中不确定的却是动作的转移,即执行动作所转移的下一状态是有一定概率的.</strong>什么意思呢?拿之前MRP的例子来说,语文状态有两个状态可以转移,数学和玩游戏,概率分别是0.5,但是当确定一个转移方向的时候(图中的箭头),其转移结果是确定的,获得的奖励也是确定的,但是在MDP中,执行动作导致转移的结果都未必是确定的.<strong><em>需要注意的是,MRP是属于MDP的,MDP执行动作并不一定必须是随机的.</em></strong></p>\n<p>接下来,我们将MRP的例子转换至MDP, 为了方便理解而又不增加示例的复杂性,不妨将”挂科”这个状态看作是一个动作,因为这个节点正巧入度为1,姑且就认为从英语到挂科的这个箭头是英语状态所能执行的动作.如图所示:</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/MDP.jpg\" alt=\"\"></p>\n<p>比较两个图可以发现区别,我把这个不确定的动作标为实心黑圆圈,这位刻苦的同学在学习完英语之后还想继续学习,但是他感觉三门科目都差不多了,于是他也很迷茫,他执行”学习”这个动作时的转移状态有三种:学语文、学数学、学英语.概率分别是:0.2、0.4,、0.4.这下就明白为什么我们要在MDP中加入动作$A$了吧,如果还不明白,请接着看下边的内容.</p>\n<p>顺便说一下,这个时候的转移矩阵已经不是简单的二维了,当然也可以用二维来表示,假设总共有$n$个状态,每个状态有$m$个动作,那么其行数为$n\\times m$,即遍历所有的状态和动作,得到$n \\times m$个状态-动作对$(s,a)$,其列数还是$n$.当然,也可以用一个三维tensor来表示,行和列都是$n$,第三维深度为动作的数量m$,很好理解.</p>\n<hr>\n<p><strong>网上有写MDP在给定策略下会退化为MRP,我对此不置可否,认为此种说法不够严谨,因为即使说在某状态s下选择的动作a是确定的,并不意味着其转移结果是确定的.</strong></p>\n<hr>\n<h3 id=\"回报-Return\"><a href=\"#回报-Return\" class=\"headerlink\" title=\"回报 Return\"></a>回报 Return</h3><p>在强化学习问题中，总是提到回报二字，论文中出现Return或者Discounted Return，我们已经知道奖励是什么，奖励就是转移到某个状态或者执行了某个动作之后转移至某个状态所获得的值$r$.</p>\n<p>回报就是由某时刻$t$之后决策序列所获得的奖励值经过一定规则计算出来的数值.</p>\n<p>公式描述:</p>\n<script type=\"math/tex; mode=display\">\nG_{t}\\doteq R_{t+1}+R_{t+2}+R_{t+3}+...+R_{t}</script><p>.其中,$T$表示一个episode达到终态的时间点.</p>\n<p>像之前介绍的一样,我们可能对未来有不同的看重程度,于是引入折扣因子$\\gamma$的回报表示为:</p>\n<script type=\"math/tex; mode=display\">\nG_{t}\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+...=\\begin{cases}\n\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\\\\n\\sum_{k=t+1}^{T}\\gamma^{k-t-1}R_{k}\n\\end{cases}</script><p>其中,$ 0\\leq\\gamma \\leq1$</p>\n<p>可以推出回报有如下形式:</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\nG_{t} &\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+\\gamma^{3}R_{t+4}+...\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma R_{t+3}+\\gamma^{2}R_{t+4}+...)\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma (R_{t+3}+\\gamma R_{t+4}+...))\\\\\n&=R_{t+1}+\\gamma G_{t+1}\n\\end{align*}</script><h3 id=\"策略-Policy\"><a href=\"#策略-Policy\" class=\"headerlink\" title=\"策略 Policy\"></a>策略 Policy</h3><p>我们一般使用$\\pi$来表示一个策略,使用$\\pi(a|s)$来表示某状态$s$采取动作$a$的概率,公示表示为:</p>\n<script type=\"math/tex; mode=display\">\n\\pi(a|s)=P(A_{t}=a|S_{t}=s)</script><p>策略完整定义了智能体在所有状态下的所有行为和其概率.</p>\n<p>给定一个MDP和一个策略$\\pi$,采样的状态序列</p>\n<script type=\"math/tex; mode=display\">\nS_{0},S_{1},S_{2},...,S_{n},...</script><p>是一个马尔科夫过程$\\lt S,P \\gt ^{\\pi}$,</p>\n<p>采样的状态、奖励序列</p>\n<script type=\"math/tex; mode=display\">\n(S_{0},R_{0}),(S_{1},R_{1}),(S_{2},R_{2}),...,(S_{n},R_{n}),...</script><p>是一个马尔科夫奖励过程$ \\lt S,P,R,\\gamma  \\gt^{\\pi}$,</p>\n<p>采样的状态、动作、奖励序列</p>\n<script type=\"math/tex; mode=display\">\n(S_{0},A_{0},R_{0}),(S_{1},A_{1},R_{1}),(S_{2},A_{2},R_{2}),...,(S_{n},A_{n},R_{n}),...</script><p>是一个马尔科夫决策过程$ \\lt S,A^{\\pi},P,R,\\gamma  \\gt^{\\pi}$.</p>\n<p><em>注意:在编程时一般以四元组$(s,a,r,s’)$为单位存储”经验”</em></p>\n<p>$\\pi$策略下$s\\rightarrow s’$转移概率由期望计算得$P_{ss’}^{\\pi}=\\sum_{a\\in A}\\pi(a|s)P_{ss’}^{a}$,$s$状态下的期望立即奖励为$R_{s}^{\\pi}=\\sum_{a\\in A}\\pi(a|s)R_{s}^{a}$.</p>\n<p>上述例子中</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\nR_{英语}&=\\sum_{a\\in A}\\pi(a|英语)R_{英语}^{a}\\\\\n&=0.2\\times-2+0.4\\times-2+0.4\\times-2\\\\\n&=-2\n\\end{align*}</script><p>状态转移概率可以描述为：在执行策略$\\pi$时，状态从$s$转移至$s’$的概率等于执行该状态下所有行为的概率与对应行为能使状态从$s$转移至$s’$的概率的乘积的和。</p>\n<p>奖励函数可以描述为：在执行策略$\\pi$时获得的奖励等于执行该状态下所有行为的概率与对应行为产生的即时奖励的乘积的和。</p>\n<p><strong>强化学习的目标就是最大化期望回报,相应的结果就是找到从状态空间$S$映射到动作空间$A$的最优策略</strong>,重点是,如何建立回报与策略之间的联系呢?</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"强化学习之MDP马尔科夫决策过程\"><a href=\"#强化学习之MDP马尔科夫决策过程\" class=\"headerlink\" title=\"强化学习之MDP马尔科夫决策过程\"></a>强化学习之MDP马尔科夫决策过程</h1><p>每每提到强化学习，最先接触的理论肯定是马尔科夫决策过程（MDP，Markov Decision Process），为什么总提到MDP呢？并不是只有我一个人有这个疑问。</p>","more":"<p>百度上没有人提出这样的问题，可能是大家理解得都比较透彻吧，于是在Google查到相关提问和解释。</p>\n<blockquote>\n<p><a href=\"https://datascience.stackexchange.com/a/38851\" rel=\"external nofollow\" target=\"_blank\">What is the relationship between Markov Decision Processes and Reinforcement Learning?</a></p>\n<blockquote>\n<p>In Reinforcement Learning (RL), the problem to resolve is described as a Markov Decision Process (MDP). Theoretical results in RL rely on the MDP description being a correct match to the problem. If your problem is well described as a MDP, then RL may be a good framework to use to find solutions. That does not mean you need to fully describe the MDP (all the transition probabilities), just that you expect an MDP model could be made or discovered.</p>\n<p>Conversely, if you cannot map your problem onto a MDP, then the theory behind RL makes no guarantees of any useful result.</p>\n<p>One key factor that affects how well RL will work is that the states should have the Markov property - that the value of the current state is enough knowledge to fix immediate transition probabilities and immediate rewards following an action choice. Again you don’t need to know in advance what those are, just that this relationship is expected to be reliable and stable. If it is not reliable, you may have a POMDP. If it is not stable, you may have a non-stationary problem. In either case, if the difference from a more strictly defined MDP is small enough, you may still get away with using RL techniques or need to adapt them slightly.</p>\n<p><strong>The general relationship between RL and MDP is that RL is a framework for solving problems that can be expressed as MDPs.</strong></p>\n</blockquote>\n</blockquote>\n<p>MDP是当前强化学习理论推导的基石，对强化学习来说，一般以马尔科夫决策过程作为形式化问题的手段。也就是说，对于目前的绝大部分强化学习算法，只有可以将问题抽象为MDP的才可以确保算法的性能（收敛性，效果等），对于违背MDP的问题并不一定确保算法有效，因为其数学公式都是基于MDP来进行推导的。</p>\n<h2 id=\"马尔科夫性\"><a href=\"#马尔科夫性\" class=\"headerlink\" title=\"马尔科夫性\"></a>马尔科夫性</h2><blockquote>\n<p>马尔科夫性质（英语：Markov property）是概率论中的一个概念，因为俄国数学家安德雷·马尔科夫得名。当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态；换句话说，在给定现在状态时，它与过去状态（即该过程的历史路径）是条件独立的，那么此随机过程即具有马尔科夫性质。<a href=\"https://baike.baidu.com/item/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%80%A7%E8%B4%A8/23149887?fr=aladdin\" rel=\"external nofollow\" target=\"_blank\">马尔科夫性-百度百科</a></p>\n</blockquote>\n<p>马尔科夫性，也就是无后效性：<strong>某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响</strong>。也就是说，<strong>未来与过去无关</strong>。</p>\n<p>具体地说，如果一个问题被划分各个阶段之后，阶段$k$中的状态只能通过阶段$k+1$中的状态通过状态转移方程得来，与其他状态没有关系，特别是与未发生的状态没有关系，这就是无后效性。</p>\n<p>公式描述：</p>\n<script type=\"math/tex; mode=display\">\nP[S_{t+1}|S_{t}]=P[S_{t+1}|S_{1},...,S_{t}]</script><p>强化学习问题中的状态也符合马尔科夫性，即在当前状态$s_{t}$下执行动作$a_{t}$并转移至下一个状态$s_{t+1}$，而不需要考虑之前的状态$s_{t-1},…,s_{1}$。</p>\n<p>举一个不恰当的例子：</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/M.jpg\" alt=\"\"></p>\n<p>假设天气预测符合马尔科夫性，如果以每天表示为一种状态，即周一、周二到周日。今天（5月8日，周三）天气为晴，明天（周四）会不会下雨只与今天的天气有关，而与之前周一、周二的天气状况无关。如果以时间节点表示为一种状态，即2点、5点、8点等，如图2点的温度为15.8°C,那么下个时间点5点的气温如何只与2点的温度有关系。</p>\n<p>强化学习中默认状态的转移是符合马尔科夫性质的，状态具体是什么，需要根据不同的问题进行不同的设定。</p>\n<h2 id=\"马尔科夫过程\"><a href=\"#马尔科夫过程\" class=\"headerlink\" title=\"马尔科夫过程\"></a>马尔科夫过程</h2><p>马尔科夫过程是随机过程的一种，什么是随机过程呢？简单来说，一个商店从早上营业到晚上打烊这段时间，根据每个时间点店内顾客的人数所组成的序列就是随机过程。随机过程根据时间节点$T_{t}$取到的值是一个变量。</p>\n<p>马尔科夫过程是满足马尔科夫性的随机过程，它由二元组$M=(S,P)$组成，且满足：</p>\n<ol>\n<li>S是有限状态集合</li>\n<li>P是状态转移概率矩阵</li>\n</ol>\n<p>状态与状态之间的转换过程即为马尔科夫过程。<strong><em>虽然我们可能不知道P的具体值到底是什么，但是通常我们假设P是存在的（转移概率存在，如果是确定的，无非就是概率为1），而且是稳定的（意思是从状态A到其他状态的转移虽然符合某个分布，但是其转移到某个状态的概率是确定的，不随时间变化的）。</em></strong></p>\n<p>这里说的<strong>有限</strong>二字我有自己的理解，在最开始的强化学习研究中，解决的都是表格式的问题，也就是状态的数量是有限可取的，但是后续强化学习研究的也有连续状态空间的问题，算法如DQN,PG,PPO等。状态的数量并不是有限的，但是其向量维度则是固定的、有限的，而且也同样符合马尔科夫性质，因此<strong>我认为这里定义的有限并不是说状态数量有限，而是状态维度有限</strong>。因为好像没有无限马尔科夫的叫法，所以姑且这么解释一下。</p>\n<p>马尔科夫过程有如下分类：</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/MPs.jpg\" alt=\"\"></p>\n<h3 id=\"状态转移矩阵\"><a href=\"#状态转移矩阵\" class=\"headerlink\" title=\"状态转移矩阵\"></a>状态转移矩阵</h3><p>状态转移矩阵由许多状态转移概率组成，状态转移概率是指从一个马尔科夫状态$s$转移到下一个状态$s’$的概率。</p>\n<p>公示表示：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{P}_{ss'}=\\mathbb{P}[S_{t+1}=s'|S_{t}=s]</script><p>等同于：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{P}(s'|s)=\\mathbb{P}[S_{t+1}=s'|S_{t}=s]</script><p>假设有1到n个状态，将所有的状态从上到下、从左到右排列，组成一个$n \\times n$的矩阵，那么其状态转移矩阵如下所示：</p>\n<script type=\"math/tex; mode=display\">\n\\mathcal{P}=\n\\begin{bmatrix}\n\\mathcal{P}_{11} & \\cdots & \\mathcal{P}_{1n} \\\\ \n\\vdots & \\ddots & \\vdots \\\\ \n\\mathcal{P}_{n1} & \\cdots & \\mathcal{P}_{nn} \\\\\n\\end{bmatrix}</script><p>其中，每行元素相加等于1，矩阵的总和为状态的数量n。</p>\n<p>对于可数状态，$\\sum_{s’=1}^{n}\\mathcal{P}(s’|s)=1$</p>\n<script type=\"math/tex; mode=display\">\nsum(\\mathcal{P}) = \\sum_{s'=1}^{n}\\sum_{s=1}^{n}\\mathcal{P}_{ss'} = n</script><p>对于不可数状态（连续状态),$\\int_{s’}\\mathcal{P}(s’|s)=1$</p>\n<script type=\"math/tex; mode=display\">\nsum(\\mathcal{P}) = \\int_{s'}\\int_{s}\\mathcal{P}_{ss'} = n</script><p>举一个马尔科夫过程的例子:</p>\n<p>假设一个学生，他目前在学习语文科目，那么他接下来进行的活动过程如下图所示，游戏的吸引力很大，所以他有50%的概率在学完语文去玩游戏，并且很容易沉迷其中，图示玩游戏这个循环有90%的可能性，他还可以选择学习其他科目或者去睡觉，最终学习结束之后是否能通过考试也是有一定的概率的，这些状态之间转移的概率即为状态转移概率。</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/MP.jpg\" alt=\"\"></p>\n<p>如果把例子中的各项状态用字母表示，将其表示为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n玩游戏 & A\\\\ \n语文 & B\\\\ \n数学 & C\\\\ \n英语 & D\\\\ \n挂科 & E\\\\ \n\\mathcal{Pass} & F\\\\ \n睡觉 & G\n\\end{bmatrix}</script><p>那么其状态转移矩阵$\\mathcal{P}$可以表示成：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{lc}\n\\mbox{}&\n\\begin{array}{cc}A & B & C & D & E & F & G \\end{array}\\\\\n\\begin{array}{c}A\\\\B\\\\C\\\\D\\\\E\\\\F\\\\G\\end{array}&\n\\left[\\begin{array}{cc}\n0.9&0.1\\\\\n0.5& &0.5\\\\\n& & &0.8& & &0.2\\\\\n&&&&0.4&0.6&\\\\\n&0.2&0.4&0.4&&&\\\\\n&&&&&&1\\\\\n&&&&&&&\n\\end{array}\\right]\n\\end{array}</script><h3 id=\"马尔科夫链与Episode\"><a href=\"#马尔科夫链与Episode\" class=\"headerlink\" title=\"马尔科夫链与Episode\"></a>马尔科夫链与Episode</h3><p>Episode可以翻译为片段、情节、回合等，在强化学习问题中，一个Episode就是一个马尔科夫链，根据状态转移矩阵可以得到许多不同的episode，也就是多个马尔科夫链。</p>\n<p>强化学习问题分两种：</p>\n<ol>\n<li>如果一个任务总能达到终态，结束任务或者开启下一轮任务，那么这个任务就被称为回合任务，也就是episode任务。例如，让一个智能体学习如何下围棋，围棋棋盘只有那么大，游戏定会终局，所以是一个回合式任务。</li>\n<li>如果一个任务可以无限持续下去，永远不会结束，即永远在训练当中，那么这个任务就被称为连续性任务。例如，教会一辆车能够进行自动驾驶就是一个连续性任务，<em>不要钻牛角尖说能源会耗尽，车子会磨损，我们只聚焦问题与环境本身，不涉及其他非稳定因素。</em></li>\n</ol>\n<p>在上边举的例子中就是一个回合式任务，因为无论这个序列有多长，最终都会达到终态-“睡觉”。</p>\n<p>根据上述例子我们可能采样出如下episode：</p>\n<ol>\n<li>$B-C-D-E-C-G$，即“学语文→数学→英语→考试没通过,挂科→继续学数学→睡觉”</li>\n<li>$B-A-A-…-A-B-C-G$，即“学语文→玩王者荣耀→玩刺激战场→玩OverCooker→玩守望先锋→玩英雄联盟→玩CS:GO→…→看一会儿数学→睡觉”。（仿佛就是我自己嘛！）</li>\n</ol>\n<h2 id=\"马尔科夫奖励过程\"><a href=\"#马尔科夫奖励过程\" class=\"headerlink\" title=\"马尔科夫奖励过程\"></a>马尔科夫奖励过程</h2><p>马尔科夫过程（Markov Process）主要描述的是状态之间的转移关系，在各个状态的转移过程中赋予不同的奖励值就得到了马尔科夫奖励过程。</p>\n<p>定义：马尔科夫奖励过程（Markov Reward Process, MRP）由一个四元组组成$(S,P,R,\\gamma)$</p>\n<ol>\n<li>$S$代表了状态的集合(也是维度有限的)</li>\n<li>$P$描述了状态转移矩阵$\\mathcal{P}_{ss’}=\\mathbb{P}[S_{t+1}=s’|S_{t}=s]$</li>\n<li>$R$表示奖励函数，$R(s)$描述了在状态$s$下的期望(立即)奖励，$\\mathcal{R}(s)=\\mathbb{E}[R_{t+1}|S_{t}=s]$</li>\n<li>$\\gamma$表示衰减因子,即discounted factor,$\\gamma\\in[0,1]$</li>\n</ol>\n<p>$\\gamma$是用来计算累计奖励回报的,表示我们有多看中现在或者未来,为什么这么说呢?假设我们现在要计算一个episode始态$S_{0}$的奖励值$V(S_{0})$,不涉及具体公式推导的说,我们应该把$S_{0}$状态后续的奖励全部加和,这样就得到了对始态$S_{0}$的值估计,这些后续奖励的值的权重都是1,或者说此时$\\gamma=1$,但是当前状态对很多步之后的状态未必影响很大,我们这样计算过来并不能完全表示一个状态的值,那么我们应当顺势减少距离远的状态的权重,此时$\\gamma\\lt1$</p>\n<ul>\n<li>当$\\gamma=0$时,状态$S$的值完全由其转移的期望立即奖励表示,即<strong>一点都不关心未来</strong></li>\n<li>当$\\gamma=1$时,状态$S$的值由以当前状态为始态,运行至终态所得到的所有立即奖励加和的值表示,即<strong>未来与现在同等重要</strong></li>\n<li>当$0 \\lt\\gamma \\lt1$时,状态$S$的值是前两个模式的<em>trade-off</em>,即<strong>对未来看重的程度由$\\gamma$决定</strong></li>\n</ul>\n<p>这只是我们的直观感受,其实是为了数学便利（虽然我也不知道具体哪里提高了数学便利，但是在有些情况下会使值函数更快迭代收敛这是真的）。</p>\n<p><em>注：也有很多地方将MRP表示为三元组，即去掉$\\gamma$，但这不影响我们对这个过程的理解，下边的MDP也是一样，无论是三元组、四元组、还是五元组，只要能描述过程的性质就可以。</em></p>\n<p>将上述马尔科夫过程的例子升级为马尔科夫奖励过程如下图所示:</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/MRP.png\" alt=\"\"></p>\n<p>奖励值定义为:</p>\n<script type=\"math/tex; mode=display\">\n\\begin{bmatrix}\n玩游戏 & A & -1\\\\ \n语文 & B & -2\\\\ \n数学 & C & -2\\\\ \n英语 & D & -2\\\\ \n挂科 & E & -5\\\\ \n\\mathcal{Pass} & F & 10\\\\ \n睡觉 & G & 0\n\\end{bmatrix}</script><p>这么定义奖励并没有什么复杂的含义,在这个例子中就拿身心愉悦程度来定义吧,学习固然是枯燥无味的,所以给予负奖励-2,玩游戏虽然会心情放松,但是始终面临着考试的压力,其实并不轻松,所以给予负奖励-1,挂科最痛苦为-5,考试全pass最开心为+10。</p>\n<p>在马尔科夫过程中的状态转移加入相应的奖励值即为马尔科夫奖励过程。</p>\n<h2 id=\"马尔科夫决策过程\"><a href=\"#马尔科夫决策过程\" class=\"headerlink\" title=\"马尔科夫决策过程\"></a>马尔科夫决策过程</h2><p>马尔科夫决策过程(Markov Decision Process, MDP)相比马尔科夫奖励过程多了一个动作$A$,它可以用一个五元组$(S,A,P,R,\\gamma)$表示:</p>\n<ol>\n<li>$S$代表了状态的集合(也是维度有限的)</li>\n<li>$A$代表了决策过程中动作的集合(维度有限的)</li>\n<li>$P$描述了状态转移矩阵$\\mathcal{P}_{ss’}^{a}=\\mathbb{P}[S_{t+1}=s’|S_{t}=s,A_{t}=a]$</li>\n<li>$R$表示奖励函数，$R(s)$描述了在状态$s$下<strong>执行某动作</strong>的期望(立即)奖励，$\\mathcal{R}(s,a)=\\mathbb{E}[R_{t+1}|S_{t}=s,A_{t}=a]$</li>\n<li>$\\gamma$表示衰减因子,即discounted factor,$\\gamma\\in[0,1]$</li>\n</ol>\n<p>MDPs是一个从交互中达成目标的强化学习问题的一个直接的框架。学习者和决策者叫做Agent。Agent进行交互的其它一切Agent之外的东西都叫做环境。Agent不断的选择动作，而环境也给出相应的反应，并且向Agent表现出新的状态。环境同时也给出一个数值作为反馈。Agent的目标就是通过选择不同的Action来最大化这个反馈值。</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/agent-env.png\" alt=\"\"></p>\n<p>强化学习所研究的内容就是得到一个状态$S$到动作$A$的映射关系,因此策略Policy可以表示成</p>\n<script type=\"math/tex; mode=display\">\n\\pi(a|s)=p(A_{t}=a|S_{t}=s)</script><hr>\n<p>注意:<br>你可能会认为,在马尔科夫奖励过程(MRP)中没有定义动作,但是其实是包含动作的,因为每个状态有多个转移的下一状态,其实就是多个动作嘛！</p>\n<p>很多文章会将有限MDP分开来讲，有限MDP即状态、动作和奖励值都只有有限个元素，对于有限MDP最优策略有唯一解，但是现实世界中任务复杂，因此大多数深度强化学习算法并不局限于解决有限MDP问题，因此本文不将MDP分情况来讲，即默认基于MDP的最优策略<strong>至少有一个解</strong>。</p>\n<hr>\n<p>没错,的确是这样的,MRP中也包含动作,但是我们并不关心,为什么这么说呢?<strong>因为就算每个状态可以执行多个动作,但是其每个动作所能转移到的状态是确定的,不确定的只是动作的选择,而不是动作的转移,而MDP中不确定的却是动作的转移,即执行动作所转移的下一状态是有一定概率的.</strong>什么意思呢?拿之前MRP的例子来说,语文状态有两个状态可以转移,数学和玩游戏,概率分别是0.5,但是当确定一个转移方向的时候(图中的箭头),其转移结果是确定的,获得的奖励也是确定的,但是在MDP中,执行动作导致转移的结果都未必是确定的.<strong><em>需要注意的是,MRP是属于MDP的,MDP执行动作并不一定必须是随机的.</em></strong></p>\n<p>接下来,我们将MRP的例子转换至MDP, 为了方便理解而又不增加示例的复杂性,不妨将”挂科”这个状态看作是一个动作,因为这个节点正巧入度为1,姑且就认为从英语到挂科的这个箭头是英语状态所能执行的动作.如图所示:</p>\n<p><img src=\"./强化学习之MDP马尔科夫决策过程/MDP.jpg\" alt=\"\"></p>\n<p>比较两个图可以发现区别,我把这个不确定的动作标为实心黑圆圈,这位刻苦的同学在学习完英语之后还想继续学习,但是他感觉三门科目都差不多了,于是他也很迷茫,他执行”学习”这个动作时的转移状态有三种:学语文、学数学、学英语.概率分别是:0.2、0.4,、0.4.这下就明白为什么我们要在MDP中加入动作$A$了吧,如果还不明白,请接着看下边的内容.</p>\n<p>顺便说一下,这个时候的转移矩阵已经不是简单的二维了,当然也可以用二维来表示,假设总共有$n$个状态,每个状态有$m$个动作,那么其行数为$n\\times m$,即遍历所有的状态和动作,得到$n \\times m$个状态-动作对$(s,a)$,其列数还是$n$.当然,也可以用一个三维tensor来表示,行和列都是$n$,第三维深度为动作的数量m$,很好理解.</p>\n<hr>\n<p><strong>网上有写MDP在给定策略下会退化为MRP,我对此不置可否,认为此种说法不够严谨,因为即使说在某状态s下选择的动作a是确定的,并不意味着其转移结果是确定的.</strong></p>\n<hr>\n<h3 id=\"回报-Return\"><a href=\"#回报-Return\" class=\"headerlink\" title=\"回报 Return\"></a>回报 Return</h3><p>在强化学习问题中，总是提到回报二字，论文中出现Return或者Discounted Return，我们已经知道奖励是什么，奖励就是转移到某个状态或者执行了某个动作之后转移至某个状态所获得的值$r$.</p>\n<p>回报就是由某时刻$t$之后决策序列所获得的奖励值经过一定规则计算出来的数值.</p>\n<p>公式描述:</p>\n<script type=\"math/tex; mode=display\">\nG_{t}\\doteq R_{t+1}+R_{t+2}+R_{t+3}+...+R_{t}</script><p>.其中,$T$表示一个episode达到终态的时间点.</p>\n<p>像之前介绍的一样,我们可能对未来有不同的看重程度,于是引入折扣因子$\\gamma$的回报表示为:</p>\n<script type=\"math/tex; mode=display\">\nG_{t}\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+...=\\begin{cases}\n\\sum_{k=0}^{\\infty}\\gamma^{k}R_{t+k+1}\\\\\n\\sum_{k=t+1}^{T}\\gamma^{k-t-1}R_{k}\n\\end{cases}</script><p>其中,$ 0\\leq\\gamma \\leq1$</p>\n<p>可以推出回报有如下形式:</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\nG_{t} &\\doteq R_{t+1}+\\gamma R_{t+2}+\\gamma^{2}R_{t+3}+\\gamma^{3}R_{t+4}+...\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma R_{t+3}+\\gamma^{2}R_{t+4}+...)\\\\\n&=R_{t+1}+\\gamma (R_{t+2}+\\gamma (R_{t+3}+\\gamma R_{t+4}+...))\\\\\n&=R_{t+1}+\\gamma G_{t+1}\n\\end{align*}</script><h3 id=\"策略-Policy\"><a href=\"#策略-Policy\" class=\"headerlink\" title=\"策略 Policy\"></a>策略 Policy</h3><p>我们一般使用$\\pi$来表示一个策略,使用$\\pi(a|s)$来表示某状态$s$采取动作$a$的概率,公示表示为:</p>\n<script type=\"math/tex; mode=display\">\n\\pi(a|s)=P(A_{t}=a|S_{t}=s)</script><p>策略完整定义了智能体在所有状态下的所有行为和其概率.</p>\n<p>给定一个MDP和一个策略$\\pi$,采样的状态序列</p>\n<script type=\"math/tex; mode=display\">\nS_{0},S_{1},S_{2},...,S_{n},...</script><p>是一个马尔科夫过程$\\lt S,P \\gt ^{\\pi}$,</p>\n<p>采样的状态、奖励序列</p>\n<script type=\"math/tex; mode=display\">\n(S_{0},R_{0}),(S_{1},R_{1}),(S_{2},R_{2}),...,(S_{n},R_{n}),...</script><p>是一个马尔科夫奖励过程$ \\lt S,P,R,\\gamma  \\gt^{\\pi}$,</p>\n<p>采样的状态、动作、奖励序列</p>\n<script type=\"math/tex; mode=display\">\n(S_{0},A_{0},R_{0}),(S_{1},A_{1},R_{1}),(S_{2},A_{2},R_{2}),...,(S_{n},A_{n},R_{n}),...</script><p>是一个马尔科夫决策过程$ \\lt S,A^{\\pi},P,R,\\gamma  \\gt^{\\pi}$.</p>\n<p><em>注意:在编程时一般以四元组$(s,a,r,s’)$为单位存储”经验”</em></p>\n<p>$\\pi$策略下$s\\rightarrow s’$转移概率由期望计算得$P_{ss’}^{\\pi}=\\sum_{a\\in A}\\pi(a|s)P_{ss’}^{a}$,$s$状态下的期望立即奖励为$R_{s}^{\\pi}=\\sum_{a\\in A}\\pi(a|s)R_{s}^{a}$.</p>\n<p>上述例子中</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align*}\nR_{英语}&=\\sum_{a\\in A}\\pi(a|英语)R_{英语}^{a}\\\\\n&=0.2\\times-2+0.4\\times-2+0.4\\times-2\\\\\n&=-2\n\\end{align*}</script><p>状态转移概率可以描述为：在执行策略$\\pi$时，状态从$s$转移至$s’$的概率等于执行该状态下所有行为的概率与对应行为能使状态从$s$转移至$s’$的概率的乘积的和。</p>\n<p>奖励函数可以描述为：在执行策略$\\pi$时获得的奖励等于执行该状态下所有行为的概率与对应行为产生的即时奖励的乘积的和。</p>\n<p><strong>强化学习的目标就是最大化期望回报,相应的结果就是找到从状态空间$S$映射到动作空间$A$的最优策略</strong>,重点是,如何建立回报与策略之间的联系呢?</p>"},{"title":"强化学习论文浅读集合","copyright":true,"mathjax":true,"top":1,"date":"2019-06-10T07:55:29.000Z","keywords":null,"description":null,"_content":"\n本文记录了一些粗读的强化学习相关的论文。\n\n<!--more-->\n\n<h1 align=\"center\" style=\"color:blue\" id=\"Gorila\">[DeepMind]Massively Parallel Methods for Deep Reinforcement Learning[Gorila]</h1>\n\n本文提出了一个分布式强化学习训练的架构：Gorila(General Reinforcement Learning Architecture)。2015年发于ICML，本文使用DQN算法进行分布式实现。\n\n论文地址：[https://arxiv.org/pdf/1507.04296.pdf](https://arxiv.org/pdf/1507.04296.pdf)\n\n## 模型示意图\n\n![](./rl-rough-reading/gorila.png)\n\n解析：\n\n- shard代表参数分片的意思，即模型过大、参数过多，需要将参数分片放置多台机器上\n- Bundled Mode模式指的是Actor中的Q网络与Learner中的Q网络一样，但是Learner比Actor多了一个目标Q网络，用于计算梯度\n\n## 特点\n\n- 并行Actor采数据\n- 并行Learner计算梯度，**不更新Learner中的模型**\n- 中心参数服务器，用于维持最新的网络模型。如果模型太大、参数过多，可以分片将网络模型放置多个参数服务器，每个参数服务器中的参数独立不关联，根据learner传的梯度更新相应的变量\n- 经验池机制，分为local与global两种\n  - local，即每个actor节点一个经验池\n  - global，将所有actor节点的经验存至一个分布式数据库中，这个**需要网络通信开销**\n\n## 伪代码\n\n![](./rl-rough-reading/gorila-pseudo.png)\n\n解析：\n\n- 伪代码中为一个actor节点的流程\n\n- 注意伪代码中出现两次`Update θ from parameters θ+ of the parameter server `，这句话的意思为从中心参数服务器拉取模型到actor和learner，拉取的时间点为：\n\n  - 每个episode开始前\n  - 每次执行动作$a_{t}$后，但是在计算梯度并将梯度传递至参数服务器之前\n\n- 伪代码中`equation 2`，代表$g_{i}=\\left(r+\\gamma \\max _{a^{\\prime}} Q\\left(s^{\\prime}, a^{\\prime} ; \\theta_{i}^{-}\\right)-Q\\left(s, a ; \\theta_{i}\\right)\\right) \\nabla_{\\theta_{i}} Q(s, a ; \\theta)$，这是DQN中的损失函数\n\n- 注意，与传统DQN不同的是，**该分布式DQN中给Learner中的目标Q网络赋值时，是直接将更新N次的中心参数服务器中的模型进行拉取覆盖，而不是使用Learner中的Q网络**\n\n- 中心参数服务器中的参数梯度更新需要累计多个learner传来的梯度后进行更新，使用异步SGD即ASGD方法进行梯度下降。\n\n  - > The parameter server then applies the updates that are accumulated from many learners. \n\n- 因为每个actor都是阶段更新自己的模型，即从参数服务器中拉取。所以每个actor中的行为策略（采样策略）都不完全相同，事实上，每个actor节点可以采取不同的探索机制，这样可以更有效地探索环境\n\n## 稳定性\n\n为了应对节点退出、网速慢、节点机器运行慢等问题，该文章中指出使用了一个超参数用来控制actor和server之间最大延时。\n\n- 过时的梯度（低于时间阈值）将会被丢弃\n\n  - > All gradients older than the threshold are discarded by the parameter server. \n\n- 过高或过低的梯度也将被丢弃\n\n  - > each actor/learner keeps a running average and standard deviation of the absolute DQN loss for the data it sees and discards gradients with absolute loss higher than the mean plus several standard deviations. \n\n- 使用AdaGrad更新规则\n\n## 效果\n\n采用于提出DQN的论文中一样的网络结构，具体请见论文中第5部分。\n\n在Atari 2600 49个游戏中，41个明显优于单GPU DQN。\n\nGorila进一步实现了DRL的希望：一个可伸缩的架构，随着计算和内存的增加，它的性能会越来越好\n\n\n\n<h1 align=\"center\" style=\"color:blue\" id=\"MB-MPO\">[UCB/OpenAI]Model-Based Reinforcement Learning via Meta-Policy Optimization[MB-MPO]</h1>\n\n论文地址：[https://arxiv.org/pdf/1809.05214.pdf](https://arxiv.org/pdf/1809.05214.pdf)\n\n本文2018年发布于CoRL，提出了一个基于模型的元强化学习算法MB-MPO。相比于一般的元强化学习是从多个MDPs任务中学习一个通用模型加速以后特定任务的模型训练，该文中的方法是将一个model-free的任务学习多个不确定、不完全、不完美的动态模型，即一个模型集合，然后使用这个模型集合学习出该任务的通用模型。因为它有一个从model-free学习动态模型的过程，所以为model-based方法。\n\n## 元强化学习\n\n$$\n\\max _{\\theta} \\mathbb{E}_{\\mathcal{M}_{k} \\sim \\rho(\\mathcal{M}),\\boldsymbol{s}_{t+1} \\sim p_{k},\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}^{\\prime}}\\left(\\boldsymbol{a}_{t} | \\boldsymbol{s}_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r_{k}\\left(s_{t}, a_{t}\\right)\\right] \\\\ s.t.:\\boldsymbol{\\theta}^{\\prime}=\\boldsymbol{\\theta}+\\alpha\\nabla_{\\boldsymbol{\\theta}} \\mathbb{E}_{\\boldsymbol{s}_{t+1} \\sim p_{k},\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}}\\left(\\boldsymbol{a}_{t} | \\boldsymbol{s}_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r_{k}\\left(s_{t}, a_{t}\\right)\\right]\n$$\n\n$\\mathcal{M}$为一系列MDP，共享相同的状态空间$\\mathcal{S}$与动作空间$\\mathcal{A}$，但是奖励函数可以不同\n\n## 学习环境动态模型\n\n$$\n\\min _{\\boldsymbol{\\phi}_{k}} \\frac{1}{\\left|\\mathcal{D}_{k}\\right|} \\sum_{\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}, \\boldsymbol{s}_{t+1}\\right) \\in \\mathcal{D}_{k}}\\left\\|\\boldsymbol{s}_{t+1}-\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)\\right\\|_{2}^{2}\n$$\n\n解析：\n\n- $\\mathcal{D}_{k}$为第k个学习模型采样的“经验”\n\n- $\\phi$为用神经网络表示的环境模型的参数\n\n- $\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)$为第k个学习模型针对状态$s_{t}$执行动作$a_{t}$后转移状态的预测，其中，神经网络的输出不直接是预测的状态$\\color{red}{s_{t+1}}$，而是$\\color{red}{\\Delta s=s_{t+1}-s_{t}}$，所以$\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)=s_{t}+\\Delta s$\n\n  - > We follow the standard practice in model-based RL of training the neural network to predict the change in state $\\Delta s=s_{t+1}-s_{t}$ (rather than the next state $s_{t+1}$) \n\n为了防止过拟合，文中使用了3个trick：\n\n1. 早停\n2. 归一化神经网络输入与输出\n3. 权重归一化\n\n## 基于环境动态模型的元强化学习\n\n假设学到了K个近似模型$\\left\\{\\hat{f}_{\\phi_{1}}, \\hat{f}_{\\phi_{2}}, \\ldots, \\hat{f}_{\\phi_{K}}\\right\\}$，把每个模型转换成一个MDP过程，即$\\mathcal{M}_{k}=\\left(S, A, \\hat{f}_{\\phi_{k}}, r, \\gamma, p_{0}\\right)$，其中，**奖励函数相同**\n\n由此给每个学习到的动态模型分配的行为策略目标函数为：\n$$\nJ_{k}(\\boldsymbol{\\theta})=\\mathbb{E}_{\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}}\\left(\\boldsymbol{a}_{t} | s_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right) | \\boldsymbol{s}_{t+1}=\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)\\right]\n$$\n定义MB=MPO的最终目标函数为：\n$$\n\\max _{\\boldsymbol{\\theta}} \\frac{1}{K} \\sum_{k=0}^{K} J_{k}\\left(\\boldsymbol{\\theta}_{k}^{\\prime}\\right) \\quad \\text { s.t.: } \\quad \\boldsymbol{\\theta}_{k}^{\\prime}=\\boldsymbol{\\theta}+\\alpha \\nabla_{\\boldsymbol{\\theta}} J_{k}(\\boldsymbol{\\theta})\n$$\n小写k代表第k个学到的模型，大写K代表模型的总数。\n\n注意看，这里公式后边使用的是$\\color{red}{\\theta'_{k}}$，而不是$\\theta$。这里并没有写错，我起初以为写错了，具体请看后边的伪代码解释。\n\n## 伪代码\n\n![](./rl-rough-reading/mb-mpo-pseudo.png)\n\n解析：\n\n- MB-MPO分为两部分更新，第一部分更新每个模型分配的行为策略，第二部分更新元策略。**注意：行为策略的更新是不连贯的，即不是自身迭代，而是不断使用元策略进行稍加修改然后替换，所以叫做adapted policy**\n- 上一项提到的两次更新都是对元策略的参数$\\theta$进行更新，区别是，第一次更新将更新后的参数赋值给了行为策略，未更改元策略本身，第二次更新直接更新元策略本身\n- $\\alpha, \\beta$为两部分更新的学习率\n- 行为策略使用VPG，即传统策略梯度算法进行优化，元策略使用TRPO算法进行优化\n- 伪代码中的大致流程如下：\n  1. 初始化策略$\\pi_{\\theta}$并将其复制K份$\\pi_{\\theta_{1}^{\\prime}}, \\dots, \\pi_{\\boldsymbol{\\theta}_{K}^{\\prime}}$\n  2. 使用$\\pi_{\\theta_{1}^{\\prime}}, \\dots, \\pi_{\\boldsymbol{\\theta}_{K}^{\\prime}}$对**真实的环境模型进行采样（这一步是实际交互，即真实数据）**，将数据存入经验池\n  3. 根据经验池训练K个环境模型，即使用`学习环境动态模型`部分的公式\n  4. 对于每个更新后的环境模型，用元策略$\\color{red}{\\pi_{\\theta}}$进行**虚拟采样（这一步是预测采样，即不实际进行交互）**，采样到$\\mathcal{T}_{k}$以适应性修改行为策略$\\boldsymbol{\\theta}_{k}^{\\prime}$。这里也是前边提到的行为策略更新是不连贯的原因。\n  5. 再用适应性策略$\\boldsymbol{\\theta}_{k}^{\\prime}$进行**虚拟采样**，采样到$\\mathcal{T}_{k}^{\\prime}$以更新元策略$\\pi_{\\theta}$\n  6. 跳向第2步\n- 伪代码中虽然没有明确指出，但是其实使用了baseline的trick用来减少方差\n\n## 流程示意图\n\n![](./rl-rough-reading/mb-mpo-visio.png)\n\n## 效果\n\n1. 比之前的model-based方法效果好、收敛快\n2. 可以达到model-free算法的渐进性能\n3. 需要更少的经验，低采样复杂性。其实是使用了虚拟采样，提高了数据效率，减少了交互采样的代价。\n4. 对于模型偏差（model-bias，即环境模型没学到位）的情况，之前的算法不能有效处理，该算法对不完美、不完全、不完整的模型具有很好地鲁棒性\n\n<h1 align=\"center\" style=\"color:blue\" id=\"DIAYN\">[UCB/Google AI]Diversity is All Your Need: Learning Skills Without a Reward Function[DIAYN]</h1>\n\n论文地址：[https://arxiv.org/pdf/1802.06070.pdf](https://arxiv.org/pdf/1802.06070.pdf)\n\nGoogle网页：[https://sites.google.com/view/diayn/home](https://sites.google.com/view/diayn/home)\n\nGithub项目：[https://github.com/ben-eysenbach/sac/blob/master/DIAYN.md](https://github.com/ben-eysenbach/sac/blob/master/DIAYN.md)\n\n这篇文章使用信息论中最大熵的方法来构造强化学习的学习目标，**期望学习到具有多样性的技能（skills）**。\n\n个人认为，此文章中所提的方法虽然很新颖，但是不能作为优化一项任务的可用算法，因为虽然其可以学到以各种花样完成目标，但是没有奖励函数的控制使得无法规范、指引智能体“解题”过程的效果，如柔顺性、实用性、实际可行性等。从另一方面来讲，将这样虽然不规划、不严谨决策行为的策略用于元策略的预训练模式还是可用的。\n\n## 技能\n\n技能的定义在文中有如下表述：\n\n> A skill is a latent-conditioned policy that alters that state of the environment in a consistent\n> way. \n> we refer to a/the policy conditioned on a fixed Z as a “skill” .\n\n意思是，设定一个隐变量，以（状态$S$，隐变量$Z$）为条件进行动作选择，即为技能——skill。\n\nDIAYN就好像是要给每个状态赋予各个不同技能的概率，并且使其中一个技能的概率最大，这样就使得在整个状态空间中，不同的技能“占领”着状态空间的不同部分，每个技能在各自偏好的局部状态空间中作用，但是作者同样希望每个技能在各自的状态空间中尽可能随机决策。\n\n![](./rl-rough-reading/skill.png)\n\n假设以不同的颜色代表不同的技能skill，每个方格代表一个状态，那么每个状态对于每个技能到达此状态的“偏好”概率是不同的。总的来说，作者希望技能之间的重合度尽可能小，但每个技能在各自的领域内尽可能随机地完成目标。\n\n## 亮点与作用\n\n1. 去掉了奖励函数\n2. 修改了目标函数，$\\mathcal{F}(\\theta)\\triangleq \\mathcal{G}(\\color{red}{\\theta, \\phi})$\n   - $\\color{red}{\\theta}$代表Actor网络中的参数\n   - $\\color{red}{\\phi}$代表Critic网络中的参数\n3. 学习到的技能可以用于*分层强化学习、迁移学习、模仿学习*\n\n## 目标函数\n\n$$\n\\begin{aligned} \n\\mathcal{F}(\\theta) & \\triangleq \\color{red}{I(S ; Z)+\\mathcal{H}[A | S]-I(A ; Z | S)} \\\\ \n&=(\\mathcal{H}[Z]-\\mathcal{H}[Z | S])+\\mathcal{H}[A | S]-(\\mathcal{H}[A | S]-\\mathcal{H}[A | S, Z]) \\\\ \n&=\\color{blue}{\\mathcal{H}[Z]-\\mathcal{H}[Z | S]+\\mathcal{H}[A | S, Z]} \\\\\n&=\\mathcal{H}[A | S, Z]+\\mathbb{E}_{z \\sim p(z), s \\sim \\pi(z)}[\\log p(z | s)]-\\mathbb{E}_{z \\sim p(z)}[\\log p(z)] \\\\\n&{ \\color{orange}{\\geq} \\mathcal{H}[A | S, Z]+\\mathbb{E}_{z \\sim p(z), s \\sim \\pi(z)}\\left[\\log q_{\\phi}(z | s)-\\log p(z)\\right] \\\\ \n\\triangleq \\mathcal{G}(\\theta, \\phi)}\n\\end{aligned}\n$$\n\n解析：\n\n- 互信息，离散下为$I(X ; Y)=\\sum_{y \\in Y} \\sum_{x \\in X} p(x, y) \\log \\left(\\frac{p(x, y)}{p(x) p(y)}\\right)$，连续下为$I(X ; Y)=\\int_{Y} \\int_{X} p(x, y) \\log \\left(\\frac{p(x, y)}{p(x) p(y)}\\right) d x d y$\n\n- 信息熵表示为$H(X, Y)=-\\sum_{x, y} p(x, y) \\log p(x, y)=-\\sum_{i=1}^{n} \\sum_{j=1}^{m} p\\left(x_{i}, y_{i}\\right) \\log p\\left(x_{i}, y_{i}\\right)$\n\n- 推到中频繁使用了性质$I(X,Y)=H(X)-H(X | Y)$\n\n- 式中对数的底为自然指数$e$\n\n- 看红色部分，化简之前：\n\n  - **增大**：$I(S ; Z)$代表状态$S$与策略隐变量$Z$之间的互信息。因为作者希望可以通过策略所能到达的状态来判别其属于哪个技能，即将技能与状态挂钩。作者给出一个直观的解释：因为在有些状态下可以执行很多动作，但是却不改变环境（至少不明显改变），就像用机械手臂夹紧一个物体时，可使用力的大小、方向等都是很多的，不同技能选择不同动作导致的效果可能相同，所以作者不希望从动作的选择来区分学到的技能，而是通过可以明显观察到、数值化的状态$S$来作为区别不同技能的标准。**互信息$I(X,Y)$有一个直观的性质就是，它可以衡量两个随机变量的“相关性”，也就是说，互信息越大，代表知道$X$后对$Y$的不确定性减少，即知道其一可以加深对另一个的了解。**所以，目标函数希望最大化互信息$I(S ; Z)$，以将状态和技能相关联，使技能尽可能根据状态可以区分。\n  - **增大**：$\\mathcal{H}[A | S]$代表策略（不以隐变量$Z$区分技能，混合所有技能即为策略）的熵值。与SAC算法中想要使用熵增来使得动作的选择更加随机一样，作者希望随机性的动作同样可以完成目标，所以希望尽可能增大这一项。\n  - **减小**：$I(A ; Z | S)$代表动作$A$与策略隐变量$Z$在给定状态$S$时之间的互信息。为了避免歧义，应该写作为$I[(A ; Z) | S]$。作者希望技能根据状态可区分，而不是根据动作，所以需要最小化这一项。\n\n- 看蓝色部分，化简之后：\n\n  - **固定最大，为$\\ln n$**：$\\mathcal{H}[Z]$代表技能分布的不确定性，既然要最大化这个项，不如就固定它，使得技能从其中均匀采样，使熵为最大值。\n  - **减小**：$\\mathcal{H}[Z | S]$代表状态$S$条件下技能的不确定性，我们知道，熵越大，不确定性越大；熵越小，不确定性越小。作者希望技能根据状态可区分，可以需要使这一项最小，以减小给定状态下所属技能的不确定性，使其尽可能接近概率1。\n  - **增大**：$\\mathcal{H [ A | S}, Z ]$代表给定技能$(S,Z)$下动作的不确定性。因为作者希望动作的选择尽可能随机但又可以完成目标，所以需要最大化这一项。\n\n- 看橘色部分，使用Jensen不等式：\n\n  - 这一步推导使用了论文[《The IM Algorithm : A variational approach to Information Maximization》](https://pdfs.semanticscholar.org/f586/4b47b1d848e4426319a8bb28efeeaf55a52a.pdf)中的推导公式\n    $$\n    I(\\mathbf{x}, \\mathbf{y}) \\geq \\underbrace{H(\\mathbf{x})}_{\\text { ‘‘entrop’’ }}+\\underbrace{\\langle\\log q(\\mathbf{x} | \\mathbf{y})\\rangle_{p(\\mathbf{x}, \\mathbf{y})}}_{\\text { ‘‘energy’’ }} \\stackrel{\\mathrm{def}}{=} \\tilde{I}(\\mathbf{x}, \\mathbf{y})\n    $$\n\n  - ![](./rl-rough-reading/Agakov.png)\n\n  - 蓝色公式中，有$I(Z;S) = \\mathcal{H}[Z]-\\mathcal{H}[Z | S]$，可以应用上述性质进行推导，将真实分布$p(z | s)$替换为任意变分分布(variational distribution)$q(z | s)$\n\n  - 最后使用变分下界$\\mathcal{G}(\\theta, \\phi)$代替目标函数$\\mathcal{F}(\\theta)$\n\n- 至此，思路已经十分清晰。Actor网络以变量$\\theta$参数化，并使用SAC算法($\\alpha=0.1$)最大化$\\mathcal{G}(\\theta, \\phi)$中$\\mathcal{H}[A | S, Z]$部分；Critic网络以变量$\\phi$参数化，并最大化后半个期望部分。文中将期望内的元素定义为“伪奖励”：\n  $$\n  r_{z}(s, a) \\triangleq \\log q_{\\phi}(z | s)-\\log p(z)\n  $$\n  由于$p(z)$为均匀分布，是固定的；对数函数不改变原函数单调性，所以只需最大化$q_{\\phi}(z | s)$即可。\n\n## 伪代码\n\n![](./rl-rough-reading/diayn-pseudo.png)\n\n解析：\n\n- 每个episode都重新采样隐变量$z$\n- Actor网络的输入为$(S||Z)$，即状态与隐变量的连结(我猜的= =)\n- Critic网络的输入为状态$S$\n\n## 模型示意图\n\n![](./rl-rough-reading/diayn.png)\n\n解析：\n\n- 隐变量分布$p(z)$是固定的\n\n\n\n<h1 align=\"center\" style=\"color:blue\" id=\"CDP\">Curiosity-Driven Experience Prioritization via Density Estimation[CDP]</h1>\n论文地址：[https://arxiv.org/pdf/1902.08039.pdf](https://arxiv.org/pdf/1902.08039.pdf)\n\n这篇文章发于2018年的NIPS，作者为赵瑞，之前读过他的两篇论文，并写了博客，可以在论文精读里找，此处不贴链接了，分别是基于能量的HER和最大熵正则化多目标RL。\n\n这篇文章总的来说提出了**基于迹密度的优先经验回放**，人类的好奇心机制驱动他有了这样的想法，文中说受有监督学习使用过采样和降采样解决训练集样本不平衡问题的启发，想在强化学习中解决经验池中迹“不足（under-represented）”的问题。\n\n说起来也挺佩服这个作者的，目前（2019年6月21日14:59:05）总共发了三篇关于强化学习的论文，但都有很好地结果：\n\n1. 基于迹能量的优先级，发了CoRL\n2. 基于迹密度的优先级，也就是这篇，发了NIPS\n3. 基于迹最大熵的优先级，发了ICML\n\n我个人道行尚浅，对于几篇论文中的深奥精髓有些不能尽数参透，由于先验知识不足，对于文中内容也不敢完全苟同，但是从这几篇阅读总结下来，发得了这种高级别论文有以下几个“加分性”要求：\n\n1. 数学要好，这是必然的，数学公式写的越华丽，数学模型越复杂，当然越具有吸引力\n2. 工作要专一且连续，看这三篇论文虽然不是递进关系，但都是在解决经验池优先相关的工作，所以找准一个领域内的小角度也是很重要的\n3. 实验部分要做好，三篇都没用完整地、细节地比较各个算法，但是却新奇地比较了采样复杂性、数据利用率等等，总之，一定要用实验表明自己的方法在某方面有用\n4. 其他秘密因素\n\n## 流程\n\n这篇论文的方法流程如下：\n\n1. 计算**迹密度**$\\rho$\n2. 计算迹密度的补$\\overline{\\rho} \\propto 1-\\rho$\n3. 根据补排序，并设置优先级，补越大优先级越大\n4. 使用HER补充经验，设置相同的优先级和迹密度\n5. 优化算法\n\n## 迹密度的计算\n\n这一部分没有看太懂，主要是本人数学功底比较薄弱，感兴趣的可以亲自查看论文中2.4与3.2.1、3.2.2部分。\n\n根据文中的意思，思想大致如下：\n\n1. 用GMM（高斯混合模型）来估计迹密度\n   $$\n   \\rho(\\mathbf{x})=\\sum_{k=1}^{K} c_{k} \\mathcal{N}\\left(\\mathbf{x} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)\n   $$\n\n2. 在每个epoch，使用V-GMM（GMM的一个变体）+EM算法推断GMM参数($\\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}$)的后验分布\n\n3. 在每个episode，使用如下公式计算迹密度\n   $$\n   \\rho=\\mathrm{V}-\\operatorname{GMM}(\\mathcal{T})=\\sum_{k=1}^{K} c_{k} \\mathcal{N}\\left(\\mathcal{T} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)\n   $$\n   其中，$\\mathcal{T}=\\left(s_{0}\\left\\|s_{1}\\right\\| \\ldots \\| s_{T}\\right)$，**每个迹的长度相同**，中间的符号代表连结操作的意思，然后进行归一化\n   $$\n   \\rho_{i}=\\frac{\\rho_{i}}{\\sum_{n=1}^{N} \\rho_{n}}\n   $$\n\n*注：我猜想上边符号表示的$s$其实包含了智能体的所在状态和要达到的真实目标，也就是$(s,g)$，文中有一段可能解释了这一部分，但是我没有太理解。*\n\n![](./rl-rough-reading/cdp-sg.png)\n\n## 优先级的设定\n\n作者说使用rank-based方法来设置优先级，因为其受异常点影响小而具有良好的鲁棒性。\n\n先计算迹密度的补\n$$\n\\overline{\\rho} \\propto 1-\\rho\n$$\n将补从小到大排序，并根据排名计算优先级，排名从0开始，即\n$$\n\\operatorname{rank}(\\cdot) \\in\\{0,1, \\ldots, N-1\\}\n$$\n\n$$\np\\left(\\mathcal{T}_{i}\\right)=\\frac{\\operatorname{rank}\\left(\\overline{\\rho}\\left(\\mathcal{T}_{i}\\right)\\right)}{\\sum_{n=1}^{N} \\operatorname{rank}\\left(\\left(\\overline{\\rho}\\left(\\mathcal{T}_{n}\\right)\\right)\\right.}\n$$\n\n## 伪代码\n\n![](./rl-rough-reading/cdp-pseudo.png)\n\n解析：\n\n- 每个epoch根据经验池中的样本数据重新拟合一次密度模型，也就是GMM中的参数\n- 每个episode都计算其迹密度\n- 红色框中的公式数字编号分别代表之间部分中关于计算迹密度和迹优先级的公式\n- 采样迹、采样经验转换之后，需要采样目标并存入经验池，重构后的经验其优先级及迹密度与真正目标下迹的相同\n\n## 优点\n\n实验部分的比较详见论文。\n\n1. 可以适用于任何Off-Policy算法\n2. 不使用TD-error计算优先级，而使用迹密度，减少了计算时间\n3. 提升了采样效率两倍左右\n4. 算法性能超过最新算法9%（这个结果看看即可，不必放在心上）\n\n<h1 align=\"center\" style=\"color:blue\" id=\"NAF\">[Google]Continuous Deep Q-Learning with Model-based Acceleration[NAF]</h1>\n论文地址：[https://arxiv.org/abs/1603.00748](https://arxiv.org/abs/1603.00748)\n\n本文介绍了标准化优势函数Normalized Advantage Function——NAF算法，该算法简化了A-C架构，将Q-Learning的思想应用于高维连续空间。\n\n本文的主要贡献是：\n\n1. 提出NAF，简化了Actor-Critic架构\n2. 将Q-Learning推广至高维连续空间\n3. 提出新的与已学模型结合的方法，提升了采样复杂性（也就是降低）和学习效率，不牺牲策略的最优性。原文中翻译意思是，评估了几种将已学习模型与Q-Learning结合的方案，提出将局部线性模型与局部On-Policy想定推演结合以加速Q-Learning算法在model-free、连续问题下的学习\n\n## 伪代码\n\n![](./rl-rough-reading/naf-pseudo.png)\n\n解析：\n\n- 待写\n\n\n\n<h1 align=\"center\" style=\"color:blue\" id=\"ERE\">[NYU]Boosting Soft Actor-Critic: Emphasizing Recent Experience without Forgetting the Past[ERE]</h1>\n\n论文地址：[http://arxiv.org/abs/1906.04009](http://arxiv.org/abs/1906.04009)\n\n代码仓库：[https://github.com/BY571/Soft-Actor-Critic-and-Extensions](https://github.com/BY571/Soft-Actor-Critic-and-Extensions)(不确定是否为论文原作者的仓库，该仓库PER的实现没有用sum-tree，2020年04月02日13:42:44)\n\n这篇论文主要是对经验池机制的扩展，SAC是被应用的算法。\n\nERE是Emphasizing Recent Experience的缩写，从名字即可以看出，该经验池机制的侧重点是近期经验。简单说一下ERE的思想及流程：\n\n1. 强调近期观测到的数据，同时不遗忘过去学到的知识；\n2. 在更新神经网络参数时，比如要连续更新$K$次，即要从经验池中循环取$K$个mini-batch的数据，那么，在第一次更新时，从整个经验池进行采样，后续更新时，逐渐缩小经验池的可采样范围，也就是收缩，使得在间隔内更新的次数也多，近期经验被采样出的概率越大\n\n论文中的原句：\n\n> We propose Emphasizing Recent Experience (ERE), a simple but powerful off-policy sampling technique, which emphasizes recently observed data while not forgetting the past. The ERE algorithm samples more aggressively from recent experience, and also orders the updates to ensure that updates from old data do not overwrite updates from new data.\n\n## 经验池逐渐缩放的原理\n\n核心思想是，在训练阶段（也就是先收集好一批轨迹，然后再更新$K$次的阶段），第一个mini-batch数据从整个经验池范围采样，在后续次序的更新中，我们逐渐减小经验池的可采样范围，使得mini-batch数据中包含越来越多的近期经验。\n\n举个例子：假如经验池共十个位置，即0到9，0放置最新的经验，9放置最旧的经验，batch-size为2，那么在第一次更新时，从0-9中采样两条经验。在第二次更新时，从0-8中采样两条经验。……以此类推。\n\n论文中提出了下边这个公式：\n$$\nc_{k}=\\max \\left\\{N \\cdot \\eta^{k \\frac{1000}{K}}, c_{\\min }\\right\\}\n$$\n在这个公式中，$N$代表经验池的总容量；$\\eta \\in(0,1]$是引入的一个超参数，用来决定**对近期数据的重视程度**，当$\\eta=1$时等同于均匀采样，当$\\eta<1$时，$c_k$随着更新次数逐渐减小。作者通过实验发现$\\eta \\in(0.994,0.999)$时效果不错；$c_{min}$是为$c_k$设置的一个下界，防止从一个很小的范围内采样数据，可能会导致过拟合现象。大写的$K$表示更新的册数，小写的$k$，$1\\leq k \\leq K$，表示当前是第几次更新。\n\n虽然作者说只引入了$\\eta$这一个超参数，但其实我觉得，更新次数$K$与基数$1000$也属于可调的超参数，虽然在实验中往往将$K$设置为一条轨迹的步长，即有多少步就更新多少次，这样在更新次数上与一步一更新是一致的，但是说到底它也是个可变的参数。\n\n文中还提到ERE可以与PER相结合，先决定采样区间，再按照区间内经验的权重选择批数据进行更新。通过代码没有看到在ERE与PER结合时使用sum-tree结构，可能在sum-tree结构上ERE不能很好适用，因为区间的选择也会改变树根节点的位置，为各种功能的计算都引入不便。\n$$\nP(i)=\\frac{p_{i}^{\\alpha}}{\\sum_{j} p_{j}^{\\alpha}}, i, j \\in D_{c_{k}}\n$$\n$D_{c_k}$即为经验池中前$c_k$个近期的经验数据。\n\n## 伪代码\n\n![](./rl-rough-reading/ere-pseudo.png)\n\n\n\n## 优缺点\n\n优点：\n\n1. 简单有效\n2. 可用于任何使用经验池机制的off-policy算法中，通用性强\n3. 引入的额外计算损耗可以忽略不计\n4. 只引入一个超参数$\\eta$，用来控制经验池可采样范围缩减的速率，容易调节（我觉得公式中的1000以及$c_{min}$应该也算是需要手动设置的超参数）\n5. 可以结合PER使用\n\n缺点：\n\n1. 传统off-policy算法的更新方式是走一步更新一次参数，像baseline等许多仓库都是这么做的，但是OpenAI的Spinning Up仓库却采用先采样一条轨迹，然后按照轨迹的步长为更新次数，循环更新网络。该论文提出的ERE也是使用先采样轨迹再更新的方式，目前看来不能应用在一步一更新的优化方式中，因为各个时间步的经验池是略有不同的\n2. 创新很小，实验上也没有看出明显的提升。而且，增加重放近期经验的次数的本质原因也不清楚，似乎只是实验效果不错，所以就这样错了，没有看到比较透彻的数学分析\n\n## 总结\n\n该论文的实验图见原文。虽然在许多环境中都产生了1.收敛速度更快一点，2.最终性能得分更高一些，但是总感觉不那么make sense。我个人觉得这个ERE可用可不用，它更像是一种实验得出来有效的trick，而不像是为了解决某一问题而特定研究出来的方法。该方法可以当做是扩展眼界的trick。\n\n<h1 align=\"center\" style=\"color:blue\" id=\"6SAN\">Reinforcement Learning with Attention that Works: A Self-Supervised Approach</h1>\n\n论文地址：[http://arxiv.org/abs/1904.03367](http://arxiv.org/abs/1904.03367)\n\n这篇文章是将self-attention结合进强化学习，并在PPO算法上进行了验证，使用了Arcade Learning Environment的10个环境，分3个随机种子进行实验。\n\n由于论文中没有明确的self-attention在RL中的运算过程，所以目前不太清楚中间的计算细节。\n\n## 提出的方法\n\n![](./rl-rough-reading/6san.png)\n\n上图为论文提出的Self-Attention在RL中应用的总体架构，其中$H_1,H_2,H_3$均为卷积层。文中将自注意力层加在了卷积层中间，而不是像DARQN一样将注意力层放置在卷积层之后。文中并未对Self-Attention模块中$F_1,F_2,G_1,Y$的运算进行解释。\n\n作者对self-attention的可能实现做了深入的探索，提出并实验了六种结构：\n\n1. SAN: Self-Attending Network 在$H_1,H_2$最底层网络间加入自注意力机制\n\n2. SSAN: Strong Self-Attending Network 意思似乎是将自注意力机制的输出$Y$乘以因子2，以增强注意力在网络中的影响\n\n   > Multiplying the output of the last convolutional layer in the self-attention component (’Y’) by a factor of two (thereby increasing the inﬂuence of attention on the network).\n\n3. SADN: Self-Attending Double Network 加入两个自注意力层，分别在$H_1, H_2$与$H_2, H_3$之间\n\n4. SSADN: Strong Self-Attending Double Network 两注意力层的输出均乘2\n\n5. PSAN: Pure Self-Attending Network 只使用注意力层的输出作为特征表示\n\n   > Passing only the output of the selfattention forward, removing the addition of the previous convolutional layer output.\n\n6. PSADN: Pure Self-Attending Double Network 与上相同\n\n## 总结\n\n实验结果与分析见论文原文。\n\n此篇文章略读思想即可，文章中没有自注意力机制的完整计算流程，也没有开源源代码，因此无法了解到具体细节。而且，文章中提出了六种自注意力机制结构并进行了实验，个人感觉这六种结构不全是必要的，比如SSAN与PSAN这两类的完全没有get到这么设置的意义，给人一种为了做对比试验而设置的感觉。本篇文章创新性也不高。\n\n<h1 align=\"center\" style=\"color:blue\" id=\"MANet\">[SNU]Multi-focus Attention Network for Efficient Deep Reinforcement Learning[MANet]</h1>\n\n论文地址：[http://arxiv.org/abs/1712.04603](http://arxiv.org/abs/1712.04603)\n\n这篇文章17年发表在AAAI上，提出了MANet算法(多焦点注意力+DQN)，它的创新点主要是将图像分割成若干区域，在这些区域中并行计算注意力权重，最终加权得到新的状态特征。作者展示了MANet算法可以应用在**单智能体图像输**入的环境中，也可以扩展模型应用**在多智能体合作任务**中。\n\n作者提出MANet针对的问题是：当前深度强化学习模型无法利用感知数据中实体与实体之间的关系，因此需要大量的采样经验去学习。作者希望通过多焦点注意力模型将感知数据中局部范围内实体之间的关系给embed到状态特征之中，加速策略模型学习并且提升模型性能。\n\n> current DRL models connect the entire low-level sensory input to the state-action values rather than exploiting the relationship between and among entities that constitute the sensory input.\n\n最终实验结果简报是：\n\n1. 与DQN做比较时，单智能体场景中使用更少经验取得最高得分\n2. 在多智能体合作任务中，相较于SOTA算法(18年以前)，MANet加速学习20%\n\n> MANet attains highest scores with significantly less experience samples. Additionally, the model shows higher performance compared to the Deep Q-network and the single attention model as benchmarks. Furthermore, we extend our model to attentive communication model for performing multi-agent cooperative tasks. In multi-agent cooperative task experiments, our model shows 20% faster learning than existing state-of-the-art model.\n\n## 模型讲解\n\n![](./rl-rough-reading/MANet-structure.png)\n\n上图为论文中提出的MANet的结构示意图。MANet主要由四个模块组成：\n\n- 输入分割模块(Input Segmentation)\n- 特征提取模块(Feature Extraction)\n- 并行注意力模块(Parallel Attentions)\n- 状态-动作值估计模块(State-action Value Estimation)\n\n**在单智能体任务中**：\n\n1. 输入分割模块\n\n   在这个阶段主要将底层传感器输入分割成多个块/区域，将每一个块的状态称为局部状态。作者使用了最简单的均匀格子切分方法，就是每个局部状态格子大小相同。作者也提到可以使用其他分割方式，可能由于实现困难或者切分后图像大小不一致使处理困难等因素而没有采用。\n\n   > We believe that we can apply more sophisticated methods like super-pixel segmentation (Achanta et al. 2010) or spatial transformer networks (Jaderberg, Simonyan, and Zisserman 2015).\n\n2. 特征提取模块\n\n   这个模块主要从每个局部状态提取键(Key)特征和值(Value)特征。\n\n   其中，键特征主要用于决定模型应该注意到的位置\n\n   > The key features are used to determine where the model should attend.\n\n   值特征主要用于编码用于评估Q值的信息\n\n   > The value features are used to encode information for state-action value estimation.\n\n   这一模块的计算过程是这样的，首先提取局部状态的通用特征：\n   $$\n   c_{i}=f_{f}\\left(s_{i}\\right) \\text { for all } i \\in(0,1, \\ldots, K)\n   $$\n   其中，$K$为第一阶段切分的局部状态的个数，$s_i$表示第$i$个局部状态，$c_i$表示其通用特征，$f_f$是特征提取函数（作者使用深度卷积网络）。\n\n   然后，将通用特征$c_i$与局部状态的索引$i$拼接后，再计算键特征与值特征：\n   $$\n   \\begin{aligned}\n   &K e y_{i}=W_{k e y} * c_{i}\\\\\n   &V a l_{i}=f_{v}\\left(W_{v a l} * c_{i}\\right)\n   \\end{aligned}\n   $$\n   其中，$Key_i$与$Val_i$分别表示第$i$个局部状态的键、值特征。$f_v$表示非线性激活函数（作者使用的是leaky ReLU），$W_{key},W_{val}$是权重矩阵。\n\n3. 并行注意力模块\n\n   这一模块主要是区分各个局部状态的重要性，按重要性的不同加权表示特征。\n   $$\n   A_{i}^{n}=\\frac{\\exp \\left(a_{n} * Key_{i}^{T}\\right)}{\\sum_{i^{\\prime}} \\exp \\left(a_{n^{*} Key_{i^{\\prime}}^{T}}\\right)} \\text { for all } n \\in(0,1, \\ldots, N)\n   $$\n   其中，$N$是上面结构图中注意力层的数量，$A_i^n$表示第$n$层注意力的向量的第$i$个元素，$i^{\\prime} \\in\\{0,1, \\ldots, \\mathrm{K}\\}$，$a_n$是第$n$个选择向量（图中的selector，像神经网络参数一样可以被训练）。上述公式其实是softmax的形式。\n\n   由于$a$的随机初始化基本上相似，所以计算得来的注意力权重也必将相近，作者不希望所有的注意力层都注意某一局部区域（或者相似区域），比如说第5个局部区域，这样的话就很低效。作者希望多个注意力层可以皆可能地注意到不同的局部状态，以达到多焦点（multi-focus）的效果，作者探索了两种正则化方式来鼓励这种行为。\n\n   第一种正则化方法是熵正则化：\n   $$\n   R_{e}=\\lambda_{e} * \\sum_{n}\\left\\|A^{n} * \\log A^{n}\\right\\|\n   $$\n   这个式子的熵的负数形式，值越小，越随机（越雨露均沾），趋向于均匀分布，也就是越不集中注意力。\n\n   第二种正则化方法是距离正则化：\n   $$\n   R_{d}=\\lambda_{d} * \\exp \\left(-\\sum_{n, m}\\left(A^{n}-A^{m}\\right)^{2}\\right)\n   $$\n   这个式子为$e$的指数性质，值越小，说明两个注意力层注意关注的区域越不相同，也就是越集中注意力且注意不同的局部状态。\n\n   *由于论文没有开源源代码，所以目前不确定熵正则化项的具体应用方式，不知道是最大化熵正则化项以鼓励不同注意力层注意不同区域，还是最小化熵正则化项以trade-off距离正则化项，放置距离正则化项过多的注意不同区域。*\n\n4. 状态-动作值估计模块\n\n   这一模块综合每个注意力层的输出特征，并且输入到剩余网络以估计状态-动作值。作者将基于注意力的加权值特征定义为：\n   $$\n   h_{n}=\\sum_{i} V a l_{i} * A_{i}^{n}\n   $$\n   其中，$h_n$是由第$n$个注意力层的注意力权重$A^n$加权的值特征。最终联合特征和Q值表示为：\n   $$\n   g=\\left\\{h_{0}, h_{1}, \\ldots, h_{N}\\right\\}\n   $$\n\n   $$\n   Q=f_{q}(g)\n   $$\n\n**在多智能体合作任务中**：\n\n​\t在这种任务中，MANet主要将其它智能体的相关信息加权到某个智能体的状态特征中，相当于特征融合。\n\n1. 输入分割模块\n\n   每一个智能体即是局部状态，因此不用分割，故不需要该模块。\n\n2. 特征提取模块\n   $$\n   \\begin{aligned}\n   &c_{i}=f_{f}\\left(s_{i}\\right) \\text { for all } i \\in(0,1, \\ldots, K)\\\\\n   &K e y_{i}=W_{k e y} * c_{i}\\\\\n   &\\color{red}{a_{i}=W_{a} * c_{i}}\\\\\n   &V a l_{i}=f_{v}\\left(W_{v a l} * c_{i}\\right)\n   \\end{aligned}\n   $$\n   $K$表示任务中智能体的个数。与单智能体不同的是，这里的selector是由通用特征$c_i$与权重矩阵$W_a$计算得来的，如上述公式红色字体所示。\n\n3. 注意力交流模块（Attentive Communication）\n   $$\n   A_{j}^{i}=\\frac{\\exp \\left(a^{i} * \\operatorname{Key}_{j}^{T}\\right)}{\\sum_{j^{\\prime}} \\exp \\left(a^{i} * \\operatorname{Ke} y_{j^{\\prime}}^{T}\\right)} \\quad i, j \\in(0,1, \\ldots, K)\n   $$\n   $A_j^i$表示智能体$j$对智能体$i$的注意力权重，值越大则$j$的信息对$i$越重要。\n\n4. 状态-动作值估计模块\n   $$\n   \\begin{array}{c}\n   h_{i}=\\sum_{j} V a l_{j} * A_{j}^{i} \\quad j \\in(0,1, \\ldots, K) \\\\\n   g_{i}=\\left\\{V a l_{i}, h_{i}\\right\\} \\\\\n   Q_{i}=f\\left(g_{i}\\right)\n   \\end{array}\n   $$\n   $h_i$为第$i$个智能体的交流特征——从其他智能体的特征中基于注意力加权得来的。\n\n   在多智能体任务中，由于selector $a$与智能体的通用特征相关，因此之间不太相似，所以不需要熵和距离正则化项（作者认为的）。\n\n   作者添加了另一个正则化项$R=\\lambda \\cdot \\left(a \\cdot Key^{T} \\right)$以解决值容易发散的问题。***我目前还没有理解到这个正则化项的作用及意义。***\n\n   \n\n","source":"_posts/rl-rough-reading.md","raw":"---\ntitle: 强化学习论文浅读集合\ncopyright: true\nmathjax: true\ntop: 1\ndate: 2019-06-10 15:55:29\ncategories: ReinforcementLearning\ntags:\n- rl\nkeywords:\ndescription:\n---\n\n本文记录了一些粗读的强化学习相关的论文。\n\n<!--more-->\n\n<h1 align=\"center\" style=\"color:blue\" id=\"Gorila\">[DeepMind]Massively Parallel Methods for Deep Reinforcement Learning[Gorila]</h1>\n\n本文提出了一个分布式强化学习训练的架构：Gorila(General Reinforcement Learning Architecture)。2015年发于ICML，本文使用DQN算法进行分布式实现。\n\n论文地址：[https://arxiv.org/pdf/1507.04296.pdf](https://arxiv.org/pdf/1507.04296.pdf)\n\n## 模型示意图\n\n![](./rl-rough-reading/gorila.png)\n\n解析：\n\n- shard代表参数分片的意思，即模型过大、参数过多，需要将参数分片放置多台机器上\n- Bundled Mode模式指的是Actor中的Q网络与Learner中的Q网络一样，但是Learner比Actor多了一个目标Q网络，用于计算梯度\n\n## 特点\n\n- 并行Actor采数据\n- 并行Learner计算梯度，**不更新Learner中的模型**\n- 中心参数服务器，用于维持最新的网络模型。如果模型太大、参数过多，可以分片将网络模型放置多个参数服务器，每个参数服务器中的参数独立不关联，根据learner传的梯度更新相应的变量\n- 经验池机制，分为local与global两种\n  - local，即每个actor节点一个经验池\n  - global，将所有actor节点的经验存至一个分布式数据库中，这个**需要网络通信开销**\n\n## 伪代码\n\n![](./rl-rough-reading/gorila-pseudo.png)\n\n解析：\n\n- 伪代码中为一个actor节点的流程\n\n- 注意伪代码中出现两次`Update θ from parameters θ+ of the parameter server `，这句话的意思为从中心参数服务器拉取模型到actor和learner，拉取的时间点为：\n\n  - 每个episode开始前\n  - 每次执行动作$a_{t}$后，但是在计算梯度并将梯度传递至参数服务器之前\n\n- 伪代码中`equation 2`，代表$g_{i}=\\left(r+\\gamma \\max _{a^{\\prime}} Q\\left(s^{\\prime}, a^{\\prime} ; \\theta_{i}^{-}\\right)-Q\\left(s, a ; \\theta_{i}\\right)\\right) \\nabla_{\\theta_{i}} Q(s, a ; \\theta)$，这是DQN中的损失函数\n\n- 注意，与传统DQN不同的是，**该分布式DQN中给Learner中的目标Q网络赋值时，是直接将更新N次的中心参数服务器中的模型进行拉取覆盖，而不是使用Learner中的Q网络**\n\n- 中心参数服务器中的参数梯度更新需要累计多个learner传来的梯度后进行更新，使用异步SGD即ASGD方法进行梯度下降。\n\n  - > The parameter server then applies the updates that are accumulated from many learners. \n\n- 因为每个actor都是阶段更新自己的模型，即从参数服务器中拉取。所以每个actor中的行为策略（采样策略）都不完全相同，事实上，每个actor节点可以采取不同的探索机制，这样可以更有效地探索环境\n\n## 稳定性\n\n为了应对节点退出、网速慢、节点机器运行慢等问题，该文章中指出使用了一个超参数用来控制actor和server之间最大延时。\n\n- 过时的梯度（低于时间阈值）将会被丢弃\n\n  - > All gradients older than the threshold are discarded by the parameter server. \n\n- 过高或过低的梯度也将被丢弃\n\n  - > each actor/learner keeps a running average and standard deviation of the absolute DQN loss for the data it sees and discards gradients with absolute loss higher than the mean plus several standard deviations. \n\n- 使用AdaGrad更新规则\n\n## 效果\n\n采用于提出DQN的论文中一样的网络结构，具体请见论文中第5部分。\n\n在Atari 2600 49个游戏中，41个明显优于单GPU DQN。\n\nGorila进一步实现了DRL的希望：一个可伸缩的架构，随着计算和内存的增加，它的性能会越来越好\n\n\n\n<h1 align=\"center\" style=\"color:blue\" id=\"MB-MPO\">[UCB/OpenAI]Model-Based Reinforcement Learning via Meta-Policy Optimization[MB-MPO]</h1>\n\n论文地址：[https://arxiv.org/pdf/1809.05214.pdf](https://arxiv.org/pdf/1809.05214.pdf)\n\n本文2018年发布于CoRL，提出了一个基于模型的元强化学习算法MB-MPO。相比于一般的元强化学习是从多个MDPs任务中学习一个通用模型加速以后特定任务的模型训练，该文中的方法是将一个model-free的任务学习多个不确定、不完全、不完美的动态模型，即一个模型集合，然后使用这个模型集合学习出该任务的通用模型。因为它有一个从model-free学习动态模型的过程，所以为model-based方法。\n\n## 元强化学习\n\n$$\n\\max _{\\theta} \\mathbb{E}_{\\mathcal{M}_{k} \\sim \\rho(\\mathcal{M}),\\boldsymbol{s}_{t+1} \\sim p_{k},\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}^{\\prime}}\\left(\\boldsymbol{a}_{t} | \\boldsymbol{s}_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r_{k}\\left(s_{t}, a_{t}\\right)\\right] \\\\ s.t.:\\boldsymbol{\\theta}^{\\prime}=\\boldsymbol{\\theta}+\\alpha\\nabla_{\\boldsymbol{\\theta}} \\mathbb{E}_{\\boldsymbol{s}_{t+1} \\sim p_{k},\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}}\\left(\\boldsymbol{a}_{t} | \\boldsymbol{s}_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r_{k}\\left(s_{t}, a_{t}\\right)\\right]\n$$\n\n$\\mathcal{M}$为一系列MDP，共享相同的状态空间$\\mathcal{S}$与动作空间$\\mathcal{A}$，但是奖励函数可以不同\n\n## 学习环境动态模型\n\n$$\n\\min _{\\boldsymbol{\\phi}_{k}} \\frac{1}{\\left|\\mathcal{D}_{k}\\right|} \\sum_{\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}, \\boldsymbol{s}_{t+1}\\right) \\in \\mathcal{D}_{k}}\\left\\|\\boldsymbol{s}_{t+1}-\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)\\right\\|_{2}^{2}\n$$\n\n解析：\n\n- $\\mathcal{D}_{k}$为第k个学习模型采样的“经验”\n\n- $\\phi$为用神经网络表示的环境模型的参数\n\n- $\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)$为第k个学习模型针对状态$s_{t}$执行动作$a_{t}$后转移状态的预测，其中，神经网络的输出不直接是预测的状态$\\color{red}{s_{t+1}}$，而是$\\color{red}{\\Delta s=s_{t+1}-s_{t}}$，所以$\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)=s_{t}+\\Delta s$\n\n  - > We follow the standard practice in model-based RL of training the neural network to predict the change in state $\\Delta s=s_{t+1}-s_{t}$ (rather than the next state $s_{t+1}$) \n\n为了防止过拟合，文中使用了3个trick：\n\n1. 早停\n2. 归一化神经网络输入与输出\n3. 权重归一化\n\n## 基于环境动态模型的元强化学习\n\n假设学到了K个近似模型$\\left\\{\\hat{f}_{\\phi_{1}}, \\hat{f}_{\\phi_{2}}, \\ldots, \\hat{f}_{\\phi_{K}}\\right\\}$，把每个模型转换成一个MDP过程，即$\\mathcal{M}_{k}=\\left(S, A, \\hat{f}_{\\phi_{k}}, r, \\gamma, p_{0}\\right)$，其中，**奖励函数相同**\n\n由此给每个学习到的动态模型分配的行为策略目标函数为：\n$$\nJ_{k}(\\boldsymbol{\\theta})=\\mathbb{E}_{\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}}\\left(\\boldsymbol{a}_{t} | s_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right) | \\boldsymbol{s}_{t+1}=\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)\\right]\n$$\n定义MB=MPO的最终目标函数为：\n$$\n\\max _{\\boldsymbol{\\theta}} \\frac{1}{K} \\sum_{k=0}^{K} J_{k}\\left(\\boldsymbol{\\theta}_{k}^{\\prime}\\right) \\quad \\text { s.t.: } \\quad \\boldsymbol{\\theta}_{k}^{\\prime}=\\boldsymbol{\\theta}+\\alpha \\nabla_{\\boldsymbol{\\theta}} J_{k}(\\boldsymbol{\\theta})\n$$\n小写k代表第k个学到的模型，大写K代表模型的总数。\n\n注意看，这里公式后边使用的是$\\color{red}{\\theta'_{k}}$，而不是$\\theta$。这里并没有写错，我起初以为写错了，具体请看后边的伪代码解释。\n\n## 伪代码\n\n![](./rl-rough-reading/mb-mpo-pseudo.png)\n\n解析：\n\n- MB-MPO分为两部分更新，第一部分更新每个模型分配的行为策略，第二部分更新元策略。**注意：行为策略的更新是不连贯的，即不是自身迭代，而是不断使用元策略进行稍加修改然后替换，所以叫做adapted policy**\n- 上一项提到的两次更新都是对元策略的参数$\\theta$进行更新，区别是，第一次更新将更新后的参数赋值给了行为策略，未更改元策略本身，第二次更新直接更新元策略本身\n- $\\alpha, \\beta$为两部分更新的学习率\n- 行为策略使用VPG，即传统策略梯度算法进行优化，元策略使用TRPO算法进行优化\n- 伪代码中的大致流程如下：\n  1. 初始化策略$\\pi_{\\theta}$并将其复制K份$\\pi_{\\theta_{1}^{\\prime}}, \\dots, \\pi_{\\boldsymbol{\\theta}_{K}^{\\prime}}$\n  2. 使用$\\pi_{\\theta_{1}^{\\prime}}, \\dots, \\pi_{\\boldsymbol{\\theta}_{K}^{\\prime}}$对**真实的环境模型进行采样（这一步是实际交互，即真实数据）**，将数据存入经验池\n  3. 根据经验池训练K个环境模型，即使用`学习环境动态模型`部分的公式\n  4. 对于每个更新后的环境模型，用元策略$\\color{red}{\\pi_{\\theta}}$进行**虚拟采样（这一步是预测采样，即不实际进行交互）**，采样到$\\mathcal{T}_{k}$以适应性修改行为策略$\\boldsymbol{\\theta}_{k}^{\\prime}$。这里也是前边提到的行为策略更新是不连贯的原因。\n  5. 再用适应性策略$\\boldsymbol{\\theta}_{k}^{\\prime}$进行**虚拟采样**，采样到$\\mathcal{T}_{k}^{\\prime}$以更新元策略$\\pi_{\\theta}$\n  6. 跳向第2步\n- 伪代码中虽然没有明确指出，但是其实使用了baseline的trick用来减少方差\n\n## 流程示意图\n\n![](./rl-rough-reading/mb-mpo-visio.png)\n\n## 效果\n\n1. 比之前的model-based方法效果好、收敛快\n2. 可以达到model-free算法的渐进性能\n3. 需要更少的经验，低采样复杂性。其实是使用了虚拟采样，提高了数据效率，减少了交互采样的代价。\n4. 对于模型偏差（model-bias，即环境模型没学到位）的情况，之前的算法不能有效处理，该算法对不完美、不完全、不完整的模型具有很好地鲁棒性\n\n<h1 align=\"center\" style=\"color:blue\" id=\"DIAYN\">[UCB/Google AI]Diversity is All Your Need: Learning Skills Without a Reward Function[DIAYN]</h1>\n\n论文地址：[https://arxiv.org/pdf/1802.06070.pdf](https://arxiv.org/pdf/1802.06070.pdf)\n\nGoogle网页：[https://sites.google.com/view/diayn/home](https://sites.google.com/view/diayn/home)\n\nGithub项目：[https://github.com/ben-eysenbach/sac/blob/master/DIAYN.md](https://github.com/ben-eysenbach/sac/blob/master/DIAYN.md)\n\n这篇文章使用信息论中最大熵的方法来构造强化学习的学习目标，**期望学习到具有多样性的技能（skills）**。\n\n个人认为，此文章中所提的方法虽然很新颖，但是不能作为优化一项任务的可用算法，因为虽然其可以学到以各种花样完成目标，但是没有奖励函数的控制使得无法规范、指引智能体“解题”过程的效果，如柔顺性、实用性、实际可行性等。从另一方面来讲，将这样虽然不规划、不严谨决策行为的策略用于元策略的预训练模式还是可用的。\n\n## 技能\n\n技能的定义在文中有如下表述：\n\n> A skill is a latent-conditioned policy that alters that state of the environment in a consistent\n> way. \n> we refer to a/the policy conditioned on a fixed Z as a “skill” .\n\n意思是，设定一个隐变量，以（状态$S$，隐变量$Z$）为条件进行动作选择，即为技能——skill。\n\nDIAYN就好像是要给每个状态赋予各个不同技能的概率，并且使其中一个技能的概率最大，这样就使得在整个状态空间中，不同的技能“占领”着状态空间的不同部分，每个技能在各自偏好的局部状态空间中作用，但是作者同样希望每个技能在各自的状态空间中尽可能随机决策。\n\n![](./rl-rough-reading/skill.png)\n\n假设以不同的颜色代表不同的技能skill，每个方格代表一个状态，那么每个状态对于每个技能到达此状态的“偏好”概率是不同的。总的来说，作者希望技能之间的重合度尽可能小，但每个技能在各自的领域内尽可能随机地完成目标。\n\n## 亮点与作用\n\n1. 去掉了奖励函数\n2. 修改了目标函数，$\\mathcal{F}(\\theta)\\triangleq \\mathcal{G}(\\color{red}{\\theta, \\phi})$\n   - $\\color{red}{\\theta}$代表Actor网络中的参数\n   - $\\color{red}{\\phi}$代表Critic网络中的参数\n3. 学习到的技能可以用于*分层强化学习、迁移学习、模仿学习*\n\n## 目标函数\n\n$$\n\\begin{aligned} \n\\mathcal{F}(\\theta) & \\triangleq \\color{red}{I(S ; Z)+\\mathcal{H}[A | S]-I(A ; Z | S)} \\\\ \n&=(\\mathcal{H}[Z]-\\mathcal{H}[Z | S])+\\mathcal{H}[A | S]-(\\mathcal{H}[A | S]-\\mathcal{H}[A | S, Z]) \\\\ \n&=\\color{blue}{\\mathcal{H}[Z]-\\mathcal{H}[Z | S]+\\mathcal{H}[A | S, Z]} \\\\\n&=\\mathcal{H}[A | S, Z]+\\mathbb{E}_{z \\sim p(z), s \\sim \\pi(z)}[\\log p(z | s)]-\\mathbb{E}_{z \\sim p(z)}[\\log p(z)] \\\\\n&{ \\color{orange}{\\geq} \\mathcal{H}[A | S, Z]+\\mathbb{E}_{z \\sim p(z), s \\sim \\pi(z)}\\left[\\log q_{\\phi}(z | s)-\\log p(z)\\right] \\\\ \n\\triangleq \\mathcal{G}(\\theta, \\phi)}\n\\end{aligned}\n$$\n\n解析：\n\n- 互信息，离散下为$I(X ; Y)=\\sum_{y \\in Y} \\sum_{x \\in X} p(x, y) \\log \\left(\\frac{p(x, y)}{p(x) p(y)}\\right)$，连续下为$I(X ; Y)=\\int_{Y} \\int_{X} p(x, y) \\log \\left(\\frac{p(x, y)}{p(x) p(y)}\\right) d x d y$\n\n- 信息熵表示为$H(X, Y)=-\\sum_{x, y} p(x, y) \\log p(x, y)=-\\sum_{i=1}^{n} \\sum_{j=1}^{m} p\\left(x_{i}, y_{i}\\right) \\log p\\left(x_{i}, y_{i}\\right)$\n\n- 推到中频繁使用了性质$I(X,Y)=H(X)-H(X | Y)$\n\n- 式中对数的底为自然指数$e$\n\n- 看红色部分，化简之前：\n\n  - **增大**：$I(S ; Z)$代表状态$S$与策略隐变量$Z$之间的互信息。因为作者希望可以通过策略所能到达的状态来判别其属于哪个技能，即将技能与状态挂钩。作者给出一个直观的解释：因为在有些状态下可以执行很多动作，但是却不改变环境（至少不明显改变），就像用机械手臂夹紧一个物体时，可使用力的大小、方向等都是很多的，不同技能选择不同动作导致的效果可能相同，所以作者不希望从动作的选择来区分学到的技能，而是通过可以明显观察到、数值化的状态$S$来作为区别不同技能的标准。**互信息$I(X,Y)$有一个直观的性质就是，它可以衡量两个随机变量的“相关性”，也就是说，互信息越大，代表知道$X$后对$Y$的不确定性减少，即知道其一可以加深对另一个的了解。**所以，目标函数希望最大化互信息$I(S ; Z)$，以将状态和技能相关联，使技能尽可能根据状态可以区分。\n  - **增大**：$\\mathcal{H}[A | S]$代表策略（不以隐变量$Z$区分技能，混合所有技能即为策略）的熵值。与SAC算法中想要使用熵增来使得动作的选择更加随机一样，作者希望随机性的动作同样可以完成目标，所以希望尽可能增大这一项。\n  - **减小**：$I(A ; Z | S)$代表动作$A$与策略隐变量$Z$在给定状态$S$时之间的互信息。为了避免歧义，应该写作为$I[(A ; Z) | S]$。作者希望技能根据状态可区分，而不是根据动作，所以需要最小化这一项。\n\n- 看蓝色部分，化简之后：\n\n  - **固定最大，为$\\ln n$**：$\\mathcal{H}[Z]$代表技能分布的不确定性，既然要最大化这个项，不如就固定它，使得技能从其中均匀采样，使熵为最大值。\n  - **减小**：$\\mathcal{H}[Z | S]$代表状态$S$条件下技能的不确定性，我们知道，熵越大，不确定性越大；熵越小，不确定性越小。作者希望技能根据状态可区分，可以需要使这一项最小，以减小给定状态下所属技能的不确定性，使其尽可能接近概率1。\n  - **增大**：$\\mathcal{H [ A | S}, Z ]$代表给定技能$(S,Z)$下动作的不确定性。因为作者希望动作的选择尽可能随机但又可以完成目标，所以需要最大化这一项。\n\n- 看橘色部分，使用Jensen不等式：\n\n  - 这一步推导使用了论文[《The IM Algorithm : A variational approach to Information Maximization》](https://pdfs.semanticscholar.org/f586/4b47b1d848e4426319a8bb28efeeaf55a52a.pdf)中的推导公式\n    $$\n    I(\\mathbf{x}, \\mathbf{y}) \\geq \\underbrace{H(\\mathbf{x})}_{\\text { ‘‘entrop’’ }}+\\underbrace{\\langle\\log q(\\mathbf{x} | \\mathbf{y})\\rangle_{p(\\mathbf{x}, \\mathbf{y})}}_{\\text { ‘‘energy’’ }} \\stackrel{\\mathrm{def}}{=} \\tilde{I}(\\mathbf{x}, \\mathbf{y})\n    $$\n\n  - ![](./rl-rough-reading/Agakov.png)\n\n  - 蓝色公式中，有$I(Z;S) = \\mathcal{H}[Z]-\\mathcal{H}[Z | S]$，可以应用上述性质进行推导，将真实分布$p(z | s)$替换为任意变分分布(variational distribution)$q(z | s)$\n\n  - 最后使用变分下界$\\mathcal{G}(\\theta, \\phi)$代替目标函数$\\mathcal{F}(\\theta)$\n\n- 至此，思路已经十分清晰。Actor网络以变量$\\theta$参数化，并使用SAC算法($\\alpha=0.1$)最大化$\\mathcal{G}(\\theta, \\phi)$中$\\mathcal{H}[A | S, Z]$部分；Critic网络以变量$\\phi$参数化，并最大化后半个期望部分。文中将期望内的元素定义为“伪奖励”：\n  $$\n  r_{z}(s, a) \\triangleq \\log q_{\\phi}(z | s)-\\log p(z)\n  $$\n  由于$p(z)$为均匀分布，是固定的；对数函数不改变原函数单调性，所以只需最大化$q_{\\phi}(z | s)$即可。\n\n## 伪代码\n\n![](./rl-rough-reading/diayn-pseudo.png)\n\n解析：\n\n- 每个episode都重新采样隐变量$z$\n- Actor网络的输入为$(S||Z)$，即状态与隐变量的连结(我猜的= =)\n- Critic网络的输入为状态$S$\n\n## 模型示意图\n\n![](./rl-rough-reading/diayn.png)\n\n解析：\n\n- 隐变量分布$p(z)$是固定的\n\n\n\n<h1 align=\"center\" style=\"color:blue\" id=\"CDP\">Curiosity-Driven Experience Prioritization via Density Estimation[CDP]</h1>\n论文地址：[https://arxiv.org/pdf/1902.08039.pdf](https://arxiv.org/pdf/1902.08039.pdf)\n\n这篇文章发于2018年的NIPS，作者为赵瑞，之前读过他的两篇论文，并写了博客，可以在论文精读里找，此处不贴链接了，分别是基于能量的HER和最大熵正则化多目标RL。\n\n这篇文章总的来说提出了**基于迹密度的优先经验回放**，人类的好奇心机制驱动他有了这样的想法，文中说受有监督学习使用过采样和降采样解决训练集样本不平衡问题的启发，想在强化学习中解决经验池中迹“不足（under-represented）”的问题。\n\n说起来也挺佩服这个作者的，目前（2019年6月21日14:59:05）总共发了三篇关于强化学习的论文，但都有很好地结果：\n\n1. 基于迹能量的优先级，发了CoRL\n2. 基于迹密度的优先级，也就是这篇，发了NIPS\n3. 基于迹最大熵的优先级，发了ICML\n\n我个人道行尚浅，对于几篇论文中的深奥精髓有些不能尽数参透，由于先验知识不足，对于文中内容也不敢完全苟同，但是从这几篇阅读总结下来，发得了这种高级别论文有以下几个“加分性”要求：\n\n1. 数学要好，这是必然的，数学公式写的越华丽，数学模型越复杂，当然越具有吸引力\n2. 工作要专一且连续，看这三篇论文虽然不是递进关系，但都是在解决经验池优先相关的工作，所以找准一个领域内的小角度也是很重要的\n3. 实验部分要做好，三篇都没用完整地、细节地比较各个算法，但是却新奇地比较了采样复杂性、数据利用率等等，总之，一定要用实验表明自己的方法在某方面有用\n4. 其他秘密因素\n\n## 流程\n\n这篇论文的方法流程如下：\n\n1. 计算**迹密度**$\\rho$\n2. 计算迹密度的补$\\overline{\\rho} \\propto 1-\\rho$\n3. 根据补排序，并设置优先级，补越大优先级越大\n4. 使用HER补充经验，设置相同的优先级和迹密度\n5. 优化算法\n\n## 迹密度的计算\n\n这一部分没有看太懂，主要是本人数学功底比较薄弱，感兴趣的可以亲自查看论文中2.4与3.2.1、3.2.2部分。\n\n根据文中的意思，思想大致如下：\n\n1. 用GMM（高斯混合模型）来估计迹密度\n   $$\n   \\rho(\\mathbf{x})=\\sum_{k=1}^{K} c_{k} \\mathcal{N}\\left(\\mathbf{x} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)\n   $$\n\n2. 在每个epoch，使用V-GMM（GMM的一个变体）+EM算法推断GMM参数($\\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}$)的后验分布\n\n3. 在每个episode，使用如下公式计算迹密度\n   $$\n   \\rho=\\mathrm{V}-\\operatorname{GMM}(\\mathcal{T})=\\sum_{k=1}^{K} c_{k} \\mathcal{N}\\left(\\mathcal{T} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)\n   $$\n   其中，$\\mathcal{T}=\\left(s_{0}\\left\\|s_{1}\\right\\| \\ldots \\| s_{T}\\right)$，**每个迹的长度相同**，中间的符号代表连结操作的意思，然后进行归一化\n   $$\n   \\rho_{i}=\\frac{\\rho_{i}}{\\sum_{n=1}^{N} \\rho_{n}}\n   $$\n\n*注：我猜想上边符号表示的$s$其实包含了智能体的所在状态和要达到的真实目标，也就是$(s,g)$，文中有一段可能解释了这一部分，但是我没有太理解。*\n\n![](./rl-rough-reading/cdp-sg.png)\n\n## 优先级的设定\n\n作者说使用rank-based方法来设置优先级，因为其受异常点影响小而具有良好的鲁棒性。\n\n先计算迹密度的补\n$$\n\\overline{\\rho} \\propto 1-\\rho\n$$\n将补从小到大排序，并根据排名计算优先级，排名从0开始，即\n$$\n\\operatorname{rank}(\\cdot) \\in\\{0,1, \\ldots, N-1\\}\n$$\n\n$$\np\\left(\\mathcal{T}_{i}\\right)=\\frac{\\operatorname{rank}\\left(\\overline{\\rho}\\left(\\mathcal{T}_{i}\\right)\\right)}{\\sum_{n=1}^{N} \\operatorname{rank}\\left(\\left(\\overline{\\rho}\\left(\\mathcal{T}_{n}\\right)\\right)\\right.}\n$$\n\n## 伪代码\n\n![](./rl-rough-reading/cdp-pseudo.png)\n\n解析：\n\n- 每个epoch根据经验池中的样本数据重新拟合一次密度模型，也就是GMM中的参数\n- 每个episode都计算其迹密度\n- 红色框中的公式数字编号分别代表之间部分中关于计算迹密度和迹优先级的公式\n- 采样迹、采样经验转换之后，需要采样目标并存入经验池，重构后的经验其优先级及迹密度与真正目标下迹的相同\n\n## 优点\n\n实验部分的比较详见论文。\n\n1. 可以适用于任何Off-Policy算法\n2. 不使用TD-error计算优先级，而使用迹密度，减少了计算时间\n3. 提升了采样效率两倍左右\n4. 算法性能超过最新算法9%（这个结果看看即可，不必放在心上）\n\n<h1 align=\"center\" style=\"color:blue\" id=\"NAF\">[Google]Continuous Deep Q-Learning with Model-based Acceleration[NAF]</h1>\n论文地址：[https://arxiv.org/abs/1603.00748](https://arxiv.org/abs/1603.00748)\n\n本文介绍了标准化优势函数Normalized Advantage Function——NAF算法，该算法简化了A-C架构，将Q-Learning的思想应用于高维连续空间。\n\n本文的主要贡献是：\n\n1. 提出NAF，简化了Actor-Critic架构\n2. 将Q-Learning推广至高维连续空间\n3. 提出新的与已学模型结合的方法，提升了采样复杂性（也就是降低）和学习效率，不牺牲策略的最优性。原文中翻译意思是，评估了几种将已学习模型与Q-Learning结合的方案，提出将局部线性模型与局部On-Policy想定推演结合以加速Q-Learning算法在model-free、连续问题下的学习\n\n## 伪代码\n\n![](./rl-rough-reading/naf-pseudo.png)\n\n解析：\n\n- 待写\n\n\n\n<h1 align=\"center\" style=\"color:blue\" id=\"ERE\">[NYU]Boosting Soft Actor-Critic: Emphasizing Recent Experience without Forgetting the Past[ERE]</h1>\n\n论文地址：[http://arxiv.org/abs/1906.04009](http://arxiv.org/abs/1906.04009)\n\n代码仓库：[https://github.com/BY571/Soft-Actor-Critic-and-Extensions](https://github.com/BY571/Soft-Actor-Critic-and-Extensions)(不确定是否为论文原作者的仓库，该仓库PER的实现没有用sum-tree，2020年04月02日13:42:44)\n\n这篇论文主要是对经验池机制的扩展，SAC是被应用的算法。\n\nERE是Emphasizing Recent Experience的缩写，从名字即可以看出，该经验池机制的侧重点是近期经验。简单说一下ERE的思想及流程：\n\n1. 强调近期观测到的数据，同时不遗忘过去学到的知识；\n2. 在更新神经网络参数时，比如要连续更新$K$次，即要从经验池中循环取$K$个mini-batch的数据，那么，在第一次更新时，从整个经验池进行采样，后续更新时，逐渐缩小经验池的可采样范围，也就是收缩，使得在间隔内更新的次数也多，近期经验被采样出的概率越大\n\n论文中的原句：\n\n> We propose Emphasizing Recent Experience (ERE), a simple but powerful off-policy sampling technique, which emphasizes recently observed data while not forgetting the past. The ERE algorithm samples more aggressively from recent experience, and also orders the updates to ensure that updates from old data do not overwrite updates from new data.\n\n## 经验池逐渐缩放的原理\n\n核心思想是，在训练阶段（也就是先收集好一批轨迹，然后再更新$K$次的阶段），第一个mini-batch数据从整个经验池范围采样，在后续次序的更新中，我们逐渐减小经验池的可采样范围，使得mini-batch数据中包含越来越多的近期经验。\n\n举个例子：假如经验池共十个位置，即0到9，0放置最新的经验，9放置最旧的经验，batch-size为2，那么在第一次更新时，从0-9中采样两条经验。在第二次更新时，从0-8中采样两条经验。……以此类推。\n\n论文中提出了下边这个公式：\n$$\nc_{k}=\\max \\left\\{N \\cdot \\eta^{k \\frac{1000}{K}}, c_{\\min }\\right\\}\n$$\n在这个公式中，$N$代表经验池的总容量；$\\eta \\in(0,1]$是引入的一个超参数，用来决定**对近期数据的重视程度**，当$\\eta=1$时等同于均匀采样，当$\\eta<1$时，$c_k$随着更新次数逐渐减小。作者通过实验发现$\\eta \\in(0.994,0.999)$时效果不错；$c_{min}$是为$c_k$设置的一个下界，防止从一个很小的范围内采样数据，可能会导致过拟合现象。大写的$K$表示更新的册数，小写的$k$，$1\\leq k \\leq K$，表示当前是第几次更新。\n\n虽然作者说只引入了$\\eta$这一个超参数，但其实我觉得，更新次数$K$与基数$1000$也属于可调的超参数，虽然在实验中往往将$K$设置为一条轨迹的步长，即有多少步就更新多少次，这样在更新次数上与一步一更新是一致的，但是说到底它也是个可变的参数。\n\n文中还提到ERE可以与PER相结合，先决定采样区间，再按照区间内经验的权重选择批数据进行更新。通过代码没有看到在ERE与PER结合时使用sum-tree结构，可能在sum-tree结构上ERE不能很好适用，因为区间的选择也会改变树根节点的位置，为各种功能的计算都引入不便。\n$$\nP(i)=\\frac{p_{i}^{\\alpha}}{\\sum_{j} p_{j}^{\\alpha}}, i, j \\in D_{c_{k}}\n$$\n$D_{c_k}$即为经验池中前$c_k$个近期的经验数据。\n\n## 伪代码\n\n![](./rl-rough-reading/ere-pseudo.png)\n\n\n\n## 优缺点\n\n优点：\n\n1. 简单有效\n2. 可用于任何使用经验池机制的off-policy算法中，通用性强\n3. 引入的额外计算损耗可以忽略不计\n4. 只引入一个超参数$\\eta$，用来控制经验池可采样范围缩减的速率，容易调节（我觉得公式中的1000以及$c_{min}$应该也算是需要手动设置的超参数）\n5. 可以结合PER使用\n\n缺点：\n\n1. 传统off-policy算法的更新方式是走一步更新一次参数，像baseline等许多仓库都是这么做的，但是OpenAI的Spinning Up仓库却采用先采样一条轨迹，然后按照轨迹的步长为更新次数，循环更新网络。该论文提出的ERE也是使用先采样轨迹再更新的方式，目前看来不能应用在一步一更新的优化方式中，因为各个时间步的经验池是略有不同的\n2. 创新很小，实验上也没有看出明显的提升。而且，增加重放近期经验的次数的本质原因也不清楚，似乎只是实验效果不错，所以就这样错了，没有看到比较透彻的数学分析\n\n## 总结\n\n该论文的实验图见原文。虽然在许多环境中都产生了1.收敛速度更快一点，2.最终性能得分更高一些，但是总感觉不那么make sense。我个人觉得这个ERE可用可不用，它更像是一种实验得出来有效的trick，而不像是为了解决某一问题而特定研究出来的方法。该方法可以当做是扩展眼界的trick。\n\n<h1 align=\"center\" style=\"color:blue\" id=\"6SAN\">Reinforcement Learning with Attention that Works: A Self-Supervised Approach</h1>\n\n论文地址：[http://arxiv.org/abs/1904.03367](http://arxiv.org/abs/1904.03367)\n\n这篇文章是将self-attention结合进强化学习，并在PPO算法上进行了验证，使用了Arcade Learning Environment的10个环境，分3个随机种子进行实验。\n\n由于论文中没有明确的self-attention在RL中的运算过程，所以目前不太清楚中间的计算细节。\n\n## 提出的方法\n\n![](./rl-rough-reading/6san.png)\n\n上图为论文提出的Self-Attention在RL中应用的总体架构，其中$H_1,H_2,H_3$均为卷积层。文中将自注意力层加在了卷积层中间，而不是像DARQN一样将注意力层放置在卷积层之后。文中并未对Self-Attention模块中$F_1,F_2,G_1,Y$的运算进行解释。\n\n作者对self-attention的可能实现做了深入的探索，提出并实验了六种结构：\n\n1. SAN: Self-Attending Network 在$H_1,H_2$最底层网络间加入自注意力机制\n\n2. SSAN: Strong Self-Attending Network 意思似乎是将自注意力机制的输出$Y$乘以因子2，以增强注意力在网络中的影响\n\n   > Multiplying the output of the last convolutional layer in the self-attention component (’Y’) by a factor of two (thereby increasing the inﬂuence of attention on the network).\n\n3. SADN: Self-Attending Double Network 加入两个自注意力层，分别在$H_1, H_2$与$H_2, H_3$之间\n\n4. SSADN: Strong Self-Attending Double Network 两注意力层的输出均乘2\n\n5. PSAN: Pure Self-Attending Network 只使用注意力层的输出作为特征表示\n\n   > Passing only the output of the selfattention forward, removing the addition of the previous convolutional layer output.\n\n6. PSADN: Pure Self-Attending Double Network 与上相同\n\n## 总结\n\n实验结果与分析见论文原文。\n\n此篇文章略读思想即可，文章中没有自注意力机制的完整计算流程，也没有开源源代码，因此无法了解到具体细节。而且，文章中提出了六种自注意力机制结构并进行了实验，个人感觉这六种结构不全是必要的，比如SSAN与PSAN这两类的完全没有get到这么设置的意义，给人一种为了做对比试验而设置的感觉。本篇文章创新性也不高。\n\n<h1 align=\"center\" style=\"color:blue\" id=\"MANet\">[SNU]Multi-focus Attention Network for Efficient Deep Reinforcement Learning[MANet]</h1>\n\n论文地址：[http://arxiv.org/abs/1712.04603](http://arxiv.org/abs/1712.04603)\n\n这篇文章17年发表在AAAI上，提出了MANet算法(多焦点注意力+DQN)，它的创新点主要是将图像分割成若干区域，在这些区域中并行计算注意力权重，最终加权得到新的状态特征。作者展示了MANet算法可以应用在**单智能体图像输**入的环境中，也可以扩展模型应用**在多智能体合作任务**中。\n\n作者提出MANet针对的问题是：当前深度强化学习模型无法利用感知数据中实体与实体之间的关系，因此需要大量的采样经验去学习。作者希望通过多焦点注意力模型将感知数据中局部范围内实体之间的关系给embed到状态特征之中，加速策略模型学习并且提升模型性能。\n\n> current DRL models connect the entire low-level sensory input to the state-action values rather than exploiting the relationship between and among entities that constitute the sensory input.\n\n最终实验结果简报是：\n\n1. 与DQN做比较时，单智能体场景中使用更少经验取得最高得分\n2. 在多智能体合作任务中，相较于SOTA算法(18年以前)，MANet加速学习20%\n\n> MANet attains highest scores with significantly less experience samples. Additionally, the model shows higher performance compared to the Deep Q-network and the single attention model as benchmarks. Furthermore, we extend our model to attentive communication model for performing multi-agent cooperative tasks. In multi-agent cooperative task experiments, our model shows 20% faster learning than existing state-of-the-art model.\n\n## 模型讲解\n\n![](./rl-rough-reading/MANet-structure.png)\n\n上图为论文中提出的MANet的结构示意图。MANet主要由四个模块组成：\n\n- 输入分割模块(Input Segmentation)\n- 特征提取模块(Feature Extraction)\n- 并行注意力模块(Parallel Attentions)\n- 状态-动作值估计模块(State-action Value Estimation)\n\n**在单智能体任务中**：\n\n1. 输入分割模块\n\n   在这个阶段主要将底层传感器输入分割成多个块/区域，将每一个块的状态称为局部状态。作者使用了最简单的均匀格子切分方法，就是每个局部状态格子大小相同。作者也提到可以使用其他分割方式，可能由于实现困难或者切分后图像大小不一致使处理困难等因素而没有采用。\n\n   > We believe that we can apply more sophisticated methods like super-pixel segmentation (Achanta et al. 2010) or spatial transformer networks (Jaderberg, Simonyan, and Zisserman 2015).\n\n2. 特征提取模块\n\n   这个模块主要从每个局部状态提取键(Key)特征和值(Value)特征。\n\n   其中，键特征主要用于决定模型应该注意到的位置\n\n   > The key features are used to determine where the model should attend.\n\n   值特征主要用于编码用于评估Q值的信息\n\n   > The value features are used to encode information for state-action value estimation.\n\n   这一模块的计算过程是这样的，首先提取局部状态的通用特征：\n   $$\n   c_{i}=f_{f}\\left(s_{i}\\right) \\text { for all } i \\in(0,1, \\ldots, K)\n   $$\n   其中，$K$为第一阶段切分的局部状态的个数，$s_i$表示第$i$个局部状态，$c_i$表示其通用特征，$f_f$是特征提取函数（作者使用深度卷积网络）。\n\n   然后，将通用特征$c_i$与局部状态的索引$i$拼接后，再计算键特征与值特征：\n   $$\n   \\begin{aligned}\n   &K e y_{i}=W_{k e y} * c_{i}\\\\\n   &V a l_{i}=f_{v}\\left(W_{v a l} * c_{i}\\right)\n   \\end{aligned}\n   $$\n   其中，$Key_i$与$Val_i$分别表示第$i$个局部状态的键、值特征。$f_v$表示非线性激活函数（作者使用的是leaky ReLU），$W_{key},W_{val}$是权重矩阵。\n\n3. 并行注意力模块\n\n   这一模块主要是区分各个局部状态的重要性，按重要性的不同加权表示特征。\n   $$\n   A_{i}^{n}=\\frac{\\exp \\left(a_{n} * Key_{i}^{T}\\right)}{\\sum_{i^{\\prime}} \\exp \\left(a_{n^{*} Key_{i^{\\prime}}^{T}}\\right)} \\text { for all } n \\in(0,1, \\ldots, N)\n   $$\n   其中，$N$是上面结构图中注意力层的数量，$A_i^n$表示第$n$层注意力的向量的第$i$个元素，$i^{\\prime} \\in\\{0,1, \\ldots, \\mathrm{K}\\}$，$a_n$是第$n$个选择向量（图中的selector，像神经网络参数一样可以被训练）。上述公式其实是softmax的形式。\n\n   由于$a$的随机初始化基本上相似，所以计算得来的注意力权重也必将相近，作者不希望所有的注意力层都注意某一局部区域（或者相似区域），比如说第5个局部区域，这样的话就很低效。作者希望多个注意力层可以皆可能地注意到不同的局部状态，以达到多焦点（multi-focus）的效果，作者探索了两种正则化方式来鼓励这种行为。\n\n   第一种正则化方法是熵正则化：\n   $$\n   R_{e}=\\lambda_{e} * \\sum_{n}\\left\\|A^{n} * \\log A^{n}\\right\\|\n   $$\n   这个式子的熵的负数形式，值越小，越随机（越雨露均沾），趋向于均匀分布，也就是越不集中注意力。\n\n   第二种正则化方法是距离正则化：\n   $$\n   R_{d}=\\lambda_{d} * \\exp \\left(-\\sum_{n, m}\\left(A^{n}-A^{m}\\right)^{2}\\right)\n   $$\n   这个式子为$e$的指数性质，值越小，说明两个注意力层注意关注的区域越不相同，也就是越集中注意力且注意不同的局部状态。\n\n   *由于论文没有开源源代码，所以目前不确定熵正则化项的具体应用方式，不知道是最大化熵正则化项以鼓励不同注意力层注意不同区域，还是最小化熵正则化项以trade-off距离正则化项，放置距离正则化项过多的注意不同区域。*\n\n4. 状态-动作值估计模块\n\n   这一模块综合每个注意力层的输出特征，并且输入到剩余网络以估计状态-动作值。作者将基于注意力的加权值特征定义为：\n   $$\n   h_{n}=\\sum_{i} V a l_{i} * A_{i}^{n}\n   $$\n   其中，$h_n$是由第$n$个注意力层的注意力权重$A^n$加权的值特征。最终联合特征和Q值表示为：\n   $$\n   g=\\left\\{h_{0}, h_{1}, \\ldots, h_{N}\\right\\}\n   $$\n\n   $$\n   Q=f_{q}(g)\n   $$\n\n**在多智能体合作任务中**：\n\n​\t在这种任务中，MANet主要将其它智能体的相关信息加权到某个智能体的状态特征中，相当于特征融合。\n\n1. 输入分割模块\n\n   每一个智能体即是局部状态，因此不用分割，故不需要该模块。\n\n2. 特征提取模块\n   $$\n   \\begin{aligned}\n   &c_{i}=f_{f}\\left(s_{i}\\right) \\text { for all } i \\in(0,1, \\ldots, K)\\\\\n   &K e y_{i}=W_{k e y} * c_{i}\\\\\n   &\\color{red}{a_{i}=W_{a} * c_{i}}\\\\\n   &V a l_{i}=f_{v}\\left(W_{v a l} * c_{i}\\right)\n   \\end{aligned}\n   $$\n   $K$表示任务中智能体的个数。与单智能体不同的是，这里的selector是由通用特征$c_i$与权重矩阵$W_a$计算得来的，如上述公式红色字体所示。\n\n3. 注意力交流模块（Attentive Communication）\n   $$\n   A_{j}^{i}=\\frac{\\exp \\left(a^{i} * \\operatorname{Key}_{j}^{T}\\right)}{\\sum_{j^{\\prime}} \\exp \\left(a^{i} * \\operatorname{Ke} y_{j^{\\prime}}^{T}\\right)} \\quad i, j \\in(0,1, \\ldots, K)\n   $$\n   $A_j^i$表示智能体$j$对智能体$i$的注意力权重，值越大则$j$的信息对$i$越重要。\n\n4. 状态-动作值估计模块\n   $$\n   \\begin{array}{c}\n   h_{i}=\\sum_{j} V a l_{j} * A_{j}^{i} \\quad j \\in(0,1, \\ldots, K) \\\\\n   g_{i}=\\left\\{V a l_{i}, h_{i}\\right\\} \\\\\n   Q_{i}=f\\left(g_{i}\\right)\n   \\end{array}\n   $$\n   $h_i$为第$i$个智能体的交流特征——从其他智能体的特征中基于注意力加权得来的。\n\n   在多智能体任务中，由于selector $a$与智能体的通用特征相关，因此之间不太相似，所以不需要熵和距离正则化项（作者认为的）。\n\n   作者添加了另一个正则化项$R=\\lambda \\cdot \\left(a \\cdot Key^{T} \\right)$以解决值容易发散的问题。***我目前还没有理解到这个正则化项的作用及意义。***\n\n   \n\n","slug":"rl-rough-reading","published":1,"updated":"2020-04-11T04:00:03.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbrzutyu006a20cd3dfdzqj7","content":"<p>本文记录了一些粗读的强化学习相关的论文。</p>\n<a id=\"more\"></a>\n<h1 align=\"center\" style=\"color:blue\" id=\"Gorila\">[DeepMind]Massively Parallel Methods for Deep Reinforcement Learning[Gorila]</h1>\n\n<p>本文提出了一个分布式强化学习训练的架构：Gorila(General Reinforcement Learning Architecture)。2015年发于ICML，本文使用DQN算法进行分布式实现。</p>\n<p>论文地址：<a href=\"https://arxiv.org/pdf/1507.04296.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1507.04296.pdf</a></p>\n<h2 id=\"模型示意图\"><a href=\"#模型示意图\" class=\"headerlink\" title=\"模型示意图\"></a>模型示意图</h2><p><img src=\"./rl-rough-reading/gorila.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>shard代表参数分片的意思，即模型过大、参数过多，需要将参数分片放置多台机器上</li>\n<li>Bundled Mode模式指的是Actor中的Q网络与Learner中的Q网络一样，但是Learner比Actor多了一个目标Q网络，用于计算梯度</li>\n</ul>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>并行Actor采数据</li>\n<li>并行Learner计算梯度，<strong>不更新Learner中的模型</strong></li>\n<li>中心参数服务器，用于维持最新的网络模型。如果模型太大、参数过多，可以分片将网络模型放置多个参数服务器，每个参数服务器中的参数独立不关联，根据learner传的梯度更新相应的变量</li>\n<li>经验池机制，分为local与global两种<ul>\n<li>local，即每个actor节点一个经验池</li>\n<li>global，将所有actor节点的经验存至一个分布式数据库中，这个<strong>需要网络通信开销</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./rl-rough-reading/gorila-pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li><p>伪代码中为一个actor节点的流程</p>\n</li>\n<li><p>注意伪代码中出现两次<code>Update θ from parameters θ+ of the parameter server</code>，这句话的意思为从中心参数服务器拉取模型到actor和learner，拉取的时间点为：</p>\n<ul>\n<li>每个episode开始前</li>\n<li>每次执行动作$a_{t}$后，但是在计算梯度并将梯度传递至参数服务器之前</li>\n</ul>\n</li>\n<li><p>伪代码中<code>equation 2</code>，代表$g_{i}=\\left(r+\\gamma \\max _{a^{\\prime}} Q\\left(s^{\\prime}, a^{\\prime} ; \\theta_{i}^{-}\\right)-Q\\left(s, a ; \\theta_{i}\\right)\\right) \\nabla_{\\theta_{i}} Q(s, a ; \\theta)$，这是DQN中的损失函数</p>\n</li>\n<li><p>注意，与传统DQN不同的是，<strong>该分布式DQN中给Learner中的目标Q网络赋值时，是直接将更新N次的中心参数服务器中的模型进行拉取覆盖，而不是使用Learner中的Q网络</strong></p>\n</li>\n<li><p>中心参数服务器中的参数梯度更新需要累计多个learner传来的梯度后进行更新，使用异步SGD即ASGD方法进行梯度下降。</p>\n<ul>\n<li><blockquote>\n<p>The parameter server then applies the updates that are accumulated from many learners. </p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>因为每个actor都是阶段更新自己的模型，即从参数服务器中拉取。所以每个actor中的行为策略（采样策略）都不完全相同，事实上，每个actor节点可以采取不同的探索机制，这样可以更有效地探索环境</p>\n</li>\n</ul>\n<h2 id=\"稳定性\"><a href=\"#稳定性\" class=\"headerlink\" title=\"稳定性\"></a>稳定性</h2><p>为了应对节点退出、网速慢、节点机器运行慢等问题，该文章中指出使用了一个超参数用来控制actor和server之间最大延时。</p>\n<ul>\n<li><p>过时的梯度（低于时间阈值）将会被丢弃</p>\n<ul>\n<li><blockquote>\n<p>All gradients older than the threshold are discarded by the parameter server. </p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>过高或过低的梯度也将被丢弃</p>\n<ul>\n<li><blockquote>\n<p>each actor/learner keeps a running average and standard deviation of the absolute DQN loss for the data it sees and discards gradients with absolute loss higher than the mean plus several standard deviations. </p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>使用AdaGrad更新规则</p>\n</li>\n</ul>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p>采用于提出DQN的论文中一样的网络结构，具体请见论文中第5部分。</p>\n<p>在Atari 2600 49个游戏中，41个明显优于单GPU DQN。</p>\n<p>Gorila进一步实现了DRL的希望：一个可伸缩的架构，随着计算和内存的增加，它的性能会越来越好</p>\n<h1 align=\"center\" style=\"color:blue\" id=\"MB-MPO\">[UCB/OpenAI]Model-Based Reinforcement Learning via Meta-Policy Optimization[MB-MPO]</h1>\n\n<p>论文地址：<a href=\"https://arxiv.org/pdf/1809.05214.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1809.05214.pdf</a></p>\n<p>本文2018年发布于CoRL，提出了一个基于模型的元强化学习算法MB-MPO。相比于一般的元强化学习是从多个MDPs任务中学习一个通用模型加速以后特定任务的模型训练，该文中的方法是将一个model-free的任务学习多个不确定、不完全、不完美的动态模型，即一个模型集合，然后使用这个模型集合学习出该任务的通用模型。因为它有一个从model-free学习动态模型的过程，所以为model-based方法。</p>\n<h2 id=\"元强化学习\"><a href=\"#元强化学习\" class=\"headerlink\" title=\"元强化学习\"></a>元强化学习</h2><script type=\"math/tex; mode=display\">\n\\max _{\\theta} \\mathbb{E}_{\\mathcal{M}_{k} \\sim \\rho(\\mathcal{M}),\\boldsymbol{s}_{t+1} \\sim p_{k},\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}^{\\prime}}\\left(\\boldsymbol{a}_{t} | \\boldsymbol{s}_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r_{k}\\left(s_{t}, a_{t}\\right)\\right] \\\\ s.t.:\\boldsymbol{\\theta}^{\\prime}=\\boldsymbol{\\theta}+\\alpha\\nabla_{\\boldsymbol{\\theta}} \\mathbb{E}_{\\boldsymbol{s}_{t+1} \\sim p_{k},\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}}\\left(\\boldsymbol{a}_{t} | \\boldsymbol{s}_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r_{k}\\left(s_{t}, a_{t}\\right)\\right]</script><p>$\\mathcal{M}$为一系列MDP，共享相同的状态空间$\\mathcal{S}$与动作空间$\\mathcal{A}$，但是奖励函数可以不同</p>\n<h2 id=\"学习环境动态模型\"><a href=\"#学习环境动态模型\" class=\"headerlink\" title=\"学习环境动态模型\"></a>学习环境动态模型</h2><script type=\"math/tex; mode=display\">\n\\min _{\\boldsymbol{\\phi}_{k}} \\frac{1}{\\left|\\mathcal{D}_{k}\\right|} \\sum_{\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}, \\boldsymbol{s}_{t+1}\\right) \\in \\mathcal{D}_{k}}\\left\\|\\boldsymbol{s}_{t+1}-\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)\\right\\|_{2}^{2}</script><p>解析：</p>\n<ul>\n<li><p>$\\mathcal{D}_{k}$为第k个学习模型采样的“经验”</p>\n</li>\n<li><p>$\\phi$为用神经网络表示的环境模型的参数</p>\n</li>\n<li><p>$\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)$为第k个学习模型针对状态$s_{t}$执行动作$a_{t}$后转移状态的预测，其中，神经网络的输出不直接是预测的状态$\\color{red}{s_{t+1}}$，而是$\\color{red}{\\Delta s=s_{t+1}-s_{t}}$，所以$\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)=s_{t}+\\Delta s$</p>\n<ul>\n<li><blockquote>\n<p>We follow the standard practice in model-based RL of training the neural network to predict the change in state $\\Delta s=s_{t+1}-s_{t}$ (rather than the next state $s_{t+1}$) </p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>为了防止过拟合，文中使用了3个trick：</p>\n<ol>\n<li>早停</li>\n<li>归一化神经网络输入与输出</li>\n<li>权重归一化</li>\n</ol>\n<h2 id=\"基于环境动态模型的元强化学习\"><a href=\"#基于环境动态模型的元强化学习\" class=\"headerlink\" title=\"基于环境动态模型的元强化学习\"></a>基于环境动态模型的元强化学习</h2><p>假设学到了K个近似模型$\\left\\{\\hat{f}_{\\phi_{1}}, \\hat{f}_{\\phi_{2}}, \\ldots, \\hat{f}_{\\phi_{K}}\\right\\}$，把每个模型转换成一个MDP过程，即$\\mathcal{M}_{k}=\\left(S, A, \\hat{f}_{\\phi_{k}}, r, \\gamma, p_{0}\\right)$，其中，<strong>奖励函数相同</strong></p>\n<p>由此给每个学习到的动态模型分配的行为策略目标函数为：</p>\n<script type=\"math/tex; mode=display\">\nJ_{k}(\\boldsymbol{\\theta})=\\mathbb{E}_{\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}}\\left(\\boldsymbol{a}_{t} | s_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right) | \\boldsymbol{s}_{t+1}=\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)\\right]</script><p>定义MB=MPO的最终目标函数为：</p>\n<script type=\"math/tex; mode=display\">\n\\max _{\\boldsymbol{\\theta}} \\frac{1}{K} \\sum_{k=0}^{K} J_{k}\\left(\\boldsymbol{\\theta}_{k}^{\\prime}\\right) \\quad \\text { s.t.: } \\quad \\boldsymbol{\\theta}_{k}^{\\prime}=\\boldsymbol{\\theta}+\\alpha \\nabla_{\\boldsymbol{\\theta}} J_{k}(\\boldsymbol{\\theta})</script><p>小写k代表第k个学到的模型，大写K代表模型的总数。</p>\n<p>注意看，这里公式后边使用的是$\\color{red}{\\theta’_{k}}$，而不是$\\theta$。这里并没有写错，我起初以为写错了，具体请看后边的伪代码解释。</p>\n<h2 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./rl-rough-reading/mb-mpo-pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>MB-MPO分为两部分更新，第一部分更新每个模型分配的行为策略，第二部分更新元策略。<strong>注意：行为策略的更新是不连贯的，即不是自身迭代，而是不断使用元策略进行稍加修改然后替换，所以叫做adapted policy</strong></li>\n<li>上一项提到的两次更新都是对元策略的参数$\\theta$进行更新，区别是，第一次更新将更新后的参数赋值给了行为策略，未更改元策略本身，第二次更新直接更新元策略本身</li>\n<li>$\\alpha, \\beta$为两部分更新的学习率</li>\n<li>行为策略使用VPG，即传统策略梯度算法进行优化，元策略使用TRPO算法进行优化</li>\n<li>伪代码中的大致流程如下：<ol>\n<li>初始化策略$\\pi_{\\theta}$并将其复制K份$\\pi_{\\theta_{1}^{\\prime}}, \\dots, \\pi_{\\boldsymbol{\\theta}_{K}^{\\prime}}$</li>\n<li>使用$\\pi_{\\theta_{1}^{\\prime}}, \\dots, \\pi_{\\boldsymbol{\\theta}_{K}^{\\prime}}$对<strong>真实的环境模型进行采样（这一步是实际交互，即真实数据）</strong>，将数据存入经验池</li>\n<li>根据经验池训练K个环境模型，即使用<code>学习环境动态模型</code>部分的公式</li>\n<li>对于每个更新后的环境模型，用元策略$\\color{red}{\\pi_{\\theta}}$进行<strong>虚拟采样（这一步是预测采样，即不实际进行交互）</strong>，采样到$\\mathcal{T}_{k}$以适应性修改行为策略$\\boldsymbol{\\theta}_{k}^{\\prime}$。这里也是前边提到的行为策略更新是不连贯的原因。</li>\n<li>再用适应性策略$\\boldsymbol{\\theta}_{k}^{\\prime}$进行<strong>虚拟采样</strong>，采样到$\\mathcal{T}_{k}^{\\prime}$以更新元策略$\\pi_{\\theta}$</li>\n<li>跳向第2步</li>\n</ol>\n</li>\n<li>伪代码中虽然没有明确指出，但是其实使用了baseline的trick用来减少方差</li>\n</ul>\n<h2 id=\"流程示意图\"><a href=\"#流程示意图\" class=\"headerlink\" title=\"流程示意图\"></a>流程示意图</h2><p><img src=\"./rl-rough-reading/mb-mpo-visio.png\" alt=\"\"></p>\n<h2 id=\"效果-1\"><a href=\"#效果-1\" class=\"headerlink\" title=\"效果\"></a>效果</h2><ol>\n<li>比之前的model-based方法效果好、收敛快</li>\n<li>可以达到model-free算法的渐进性能</li>\n<li>需要更少的经验，低采样复杂性。其实是使用了虚拟采样，提高了数据效率，减少了交互采样的代价。</li>\n<li>对于模型偏差（model-bias，即环境模型没学到位）的情况，之前的算法不能有效处理，该算法对不完美、不完全、不完整的模型具有很好地鲁棒性</li>\n</ol>\n<h1 align=\"center\" style=\"color:blue\" id=\"DIAYN\">[UCB/Google AI]Diversity is All Your Need: Learning Skills Without a Reward Function[DIAYN]</h1>\n\n<p>论文地址：<a href=\"https://arxiv.org/pdf/1802.06070.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1802.06070.pdf</a></p>\n<p>Google网页：<a href=\"https://sites.google.com/view/diayn/home\" rel=\"external nofollow\" target=\"_blank\">https://sites.google.com/view/diayn/home</a></p>\n<p>Github项目：<a href=\"https://github.com/ben-eysenbach/sac/blob/master/DIAYN.md\" rel=\"external nofollow\" target=\"_blank\">https://github.com/ben-eysenbach/sac/blob/master/DIAYN.md</a></p>\n<p>这篇文章使用信息论中最大熵的方法来构造强化学习的学习目标，<strong>期望学习到具有多样性的技能（skills）</strong>。</p>\n<p>个人认为，此文章中所提的方法虽然很新颖，但是不能作为优化一项任务的可用算法，因为虽然其可以学到以各种花样完成目标，但是没有奖励函数的控制使得无法规范、指引智能体“解题”过程的效果，如柔顺性、实用性、实际可行性等。从另一方面来讲，将这样虽然不规划、不严谨决策行为的策略用于元策略的预训练模式还是可用的。</p>\n<h2 id=\"技能\"><a href=\"#技能\" class=\"headerlink\" title=\"技能\"></a>技能</h2><p>技能的定义在文中有如下表述：</p>\n<blockquote>\n<p>A skill is a latent-conditioned policy that alters that state of the environment in a consistent<br>way.<br>we refer to a/the policy conditioned on a fixed Z as a “skill” .</p>\n</blockquote>\n<p>意思是，设定一个隐变量，以（状态$S$，隐变量$Z$）为条件进行动作选择，即为技能——skill。</p>\n<p>DIAYN就好像是要给每个状态赋予各个不同技能的概率，并且使其中一个技能的概率最大，这样就使得在整个状态空间中，不同的技能“占领”着状态空间的不同部分，每个技能在各自偏好的局部状态空间中作用，但是作者同样希望每个技能在各自的状态空间中尽可能随机决策。</p>\n<p><img src=\"./rl-rough-reading/skill.png\" alt=\"\"></p>\n<p>假设以不同的颜色代表不同的技能skill，每个方格代表一个状态，那么每个状态对于每个技能到达此状态的“偏好”概率是不同的。总的来说，作者希望技能之间的重合度尽可能小，但每个技能在各自的领域内尽可能随机地完成目标。</p>\n<h2 id=\"亮点与作用\"><a href=\"#亮点与作用\" class=\"headerlink\" title=\"亮点与作用\"></a>亮点与作用</h2><ol>\n<li>去掉了奖励函数</li>\n<li>修改了目标函数，$\\mathcal{F}(\\theta)\\triangleq \\mathcal{G}(\\color{red}{\\theta, \\phi})$<ul>\n<li>$\\color{red}{\\theta}$代表Actor网络中的参数</li>\n<li>$\\color{red}{\\phi}$代表Critic网络中的参数</li>\n</ul>\n</li>\n<li>学习到的技能可以用于<em>分层强化学习、迁移学习、模仿学习</em></li>\n</ol>\n<h2 id=\"目标函数\"><a href=\"#目标函数\" class=\"headerlink\" title=\"目标函数\"></a>目标函数</h2><script type=\"math/tex; mode=display\">\n\\begin{aligned} \n\\mathcal{F}(\\theta) & \\triangleq \\color{red}{I(S ; Z)+\\mathcal{H}[A | S]-I(A ; Z | S)} \\\\ \n&=(\\mathcal{H}[Z]-\\mathcal{H}[Z | S])+\\mathcal{H}[A | S]-(\\mathcal{H}[A | S]-\\mathcal{H}[A | S, Z]) \\\\ \n&=\\color{blue}{\\mathcal{H}[Z]-\\mathcal{H}[Z | S]+\\mathcal{H}[A | S, Z]} \\\\\n&=\\mathcal{H}[A | S, Z]+\\mathbb{E}_{z \\sim p(z), s \\sim \\pi(z)}[\\log p(z | s)]-\\mathbb{E}_{z \\sim p(z)}[\\log p(z)] \\\\\n&{ \\color{orange}{\\geq} \\mathcal{H}[A | S, Z]+\\mathbb{E}_{z \\sim p(z), s \\sim \\pi(z)}\\left[\\log q_{\\phi}(z | s)-\\log p(z)\\right] \\\\ \n\\triangleq \\mathcal{G}(\\theta, \\phi)}\n\\end{aligned}</script><p>解析：</p>\n<ul>\n<li><p>互信息，离散下为$I(X ; Y)=\\sum_{y \\in Y} \\sum_{x \\in X} p(x, y) \\log \\left(\\frac{p(x, y)}{p(x) p(y)}\\right)$，连续下为$I(X ; Y)=\\int_{Y} \\int_{X} p(x, y) \\log \\left(\\frac{p(x, y)}{p(x) p(y)}\\right) d x d y$</p>\n</li>\n<li><p>信息熵表示为$H(X, Y)=-\\sum_{x, y} p(x, y) \\log p(x, y)=-\\sum_{i=1}^{n} \\sum_{j=1}^{m} p\\left(x_{i}, y_{i}\\right) \\log p\\left(x_{i}, y_{i}\\right)$</p>\n</li>\n<li><p>推到中频繁使用了性质$I(X,Y)=H(X)-H(X | Y)$</p>\n</li>\n<li><p>式中对数的底为自然指数$e$</p>\n</li>\n<li><p>看红色部分，化简之前：</p>\n<ul>\n<li><strong>增大</strong>：$I(S ; Z)$代表状态$S$与策略隐变量$Z$之间的互信息。因为作者希望可以通过策略所能到达的状态来判别其属于哪个技能，即将技能与状态挂钩。作者给出一个直观的解释：因为在有些状态下可以执行很多动作，但是却不改变环境（至少不明显改变），就像用机械手臂夹紧一个物体时，可使用力的大小、方向等都是很多的，不同技能选择不同动作导致的效果可能相同，所以作者不希望从动作的选择来区分学到的技能，而是通过可以明显观察到、数值化的状态$S$来作为区别不同技能的标准。<strong>互信息$I(X,Y)$有一个直观的性质就是，它可以衡量两个随机变量的“相关性”，也就是说，互信息越大，代表知道$X$后对$Y$的不确定性减少，即知道其一可以加深对另一个的了解。</strong>所以，目标函数希望最大化互信息$I(S ; Z)$，以将状态和技能相关联，使技能尽可能根据状态可以区分。</li>\n<li><strong>增大</strong>：$\\mathcal{H}[A | S]$代表策略（不以隐变量$Z$区分技能，混合所有技能即为策略）的熵值。与SAC算法中想要使用熵增来使得动作的选择更加随机一样，作者希望随机性的动作同样可以完成目标，所以希望尽可能增大这一项。</li>\n<li><strong>减小</strong>：$I(A ; Z | S)$代表动作$A$与策略隐变量$Z$在给定状态$S$时之间的互信息。为了避免歧义，应该写作为$I[(A ; Z) | S]$。作者希望技能根据状态可区分，而不是根据动作，所以需要最小化这一项。</li>\n</ul>\n</li>\n<li><p>看蓝色部分，化简之后：</p>\n<ul>\n<li><strong>固定最大，为$\\ln n$</strong>：$\\mathcal{H}[Z]$代表技能分布的不确定性，既然要最大化这个项，不如就固定它，使得技能从其中均匀采样，使熵为最大值。</li>\n<li><strong>减小</strong>：$\\mathcal{H}[Z | S]$代表状态$S$条件下技能的不确定性，我们知道，熵越大，不确定性越大；熵越小，不确定性越小。作者希望技能根据状态可区分，可以需要使这一项最小，以减小给定状态下所属技能的不确定性，使其尽可能接近概率1。</li>\n<li><strong>增大</strong>：$\\mathcal{H [ A | S}, Z ]$代表给定技能$(S,Z)$下动作的不确定性。因为作者希望动作的选择尽可能随机但又可以完成目标，所以需要最大化这一项。</li>\n</ul>\n</li>\n<li><p>看橘色部分，使用Jensen不等式：</p>\n<ul>\n<li><p>这一步推导使用了论文<a href=\"https://pdfs.semanticscholar.org/f586/4b47b1d848e4426319a8bb28efeeaf55a52a.pdf\" rel=\"external nofollow\" target=\"_blank\">《The IM Algorithm : A variational approach to Information Maximization》</a>中的推导公式</p>\n<script type=\"math/tex; mode=display\">\nI(\\mathbf{x}, \\mathbf{y}) \\geq \\underbrace{H(\\mathbf{x})}_{\\text { ‘‘entrop’’ }}+\\underbrace{\\langle\\log q(\\mathbf{x} | \\mathbf{y})\\rangle_{p(\\mathbf{x}, \\mathbf{y})}}_{\\text { ‘‘energy’’ }} \\stackrel{\\mathrm{def}}{=} \\tilde{I}(\\mathbf{x}, \\mathbf{y})</script></li>\n<li><p><img src=\"./rl-rough-reading/Agakov.png\" alt=\"\"></p>\n</li>\n<li><p>蓝色公式中，有$I(Z;S) = \\mathcal{H}[Z]-\\mathcal{H}[Z | S]$，可以应用上述性质进行推导，将真实分布$p(z | s)$替换为任意变分分布(variational distribution)$q(z | s)$</p>\n</li>\n<li><p>最后使用变分下界$\\mathcal{G}(\\theta, \\phi)$代替目标函数$\\mathcal{F}(\\theta)$</p>\n</li>\n</ul>\n</li>\n<li><p>至此，思路已经十分清晰。Actor网络以变量$\\theta$参数化，并使用SAC算法($\\alpha=0.1$)最大化$\\mathcal{G}(\\theta, \\phi)$中$\\mathcal{H}[A | S, Z]$部分；Critic网络以变量$\\phi$参数化，并最大化后半个期望部分。文中将期望内的元素定义为“伪奖励”：</p>\n<script type=\"math/tex; mode=display\">\nr_{z}(s, a) \\triangleq \\log q_{\\phi}(z | s)-\\log p(z)</script><p>由于$p(z)$为均匀分布，是固定的；对数函数不改变原函数单调性，所以只需最大化$q_{\\phi}(z | s)$即可。</p>\n</li>\n</ul>\n<h2 id=\"伪代码-2\"><a href=\"#伪代码-2\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./rl-rough-reading/diayn-pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>每个episode都重新采样隐变量$z$</li>\n<li>Actor网络的输入为$(S||Z)$，即状态与隐变量的连结(我猜的= =)</li>\n<li>Critic网络的输入为状态$S$</li>\n</ul>\n<h2 id=\"模型示意图-1\"><a href=\"#模型示意图-1\" class=\"headerlink\" title=\"模型示意图\"></a>模型示意图</h2><p><img src=\"./rl-rough-reading/diayn.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>隐变量分布$p(z)$是固定的</li>\n</ul>\n<h1 align=\"center\" style=\"color:blue\" id=\"CDP\">Curiosity-Driven Experience Prioritization via Density Estimation[CDP]</h1>\n论文地址：[https://arxiv.org/pdf/1902.08039.pdf](https://arxiv.org/pdf/1902.08039.pdf)\n\n这篇文章发于2018年的NIPS，作者为赵瑞，之前读过他的两篇论文，并写了博客，可以在论文精读里找，此处不贴链接了，分别是基于能量的HER和最大熵正则化多目标RL。\n\n这篇文章总的来说提出了**基于迹密度的优先经验回放**，人类的好奇心机制驱动他有了这样的想法，文中说受有监督学习使用过采样和降采样解决训练集样本不平衡问题的启发，想在强化学习中解决经验池中迹“不足（under-represented）”的问题。\n\n说起来也挺佩服这个作者的，目前（2019年6月21日14:59:05）总共发了三篇关于强化学习的论文，但都有很好地结果：\n\n1. 基于迹能量的优先级，发了CoRL\n2. 基于迹密度的优先级，也就是这篇，发了NIPS\n3. 基于迹最大熵的优先级，发了ICML\n\n我个人道行尚浅，对于几篇论文中的深奥精髓有些不能尽数参透，由于先验知识不足，对于文中内容也不敢完全苟同，但是从这几篇阅读总结下来，发得了这种高级别论文有以下几个“加分性”要求：\n\n1. 数学要好，这是必然的，数学公式写的越华丽，数学模型越复杂，当然越具有吸引力\n2. 工作要专一且连续，看这三篇论文虽然不是递进关系，但都是在解决经验池优先相关的工作，所以找准一个领域内的小角度也是很重要的\n3. 实验部分要做好，三篇都没用完整地、细节地比较各个算法，但是却新奇地比较了采样复杂性、数据利用率等等，总之，一定要用实验表明自己的方法在某方面有用\n4. 其他秘密因素\n\n## 流程\n\n这篇论文的方法流程如下：\n\n1. 计算**迹密度**$\\rho$\n2. 计算迹密度的补$\\overline{\\rho} \\propto 1-\\rho$\n3. 根据补排序，并设置优先级，补越大优先级越大\n4. 使用HER补充经验，设置相同的优先级和迹密度\n5. 优化算法\n\n## 迹密度的计算\n\n这一部分没有看太懂，主要是本人数学功底比较薄弱，感兴趣的可以亲自查看论文中2.4与3.2.1、3.2.2部分。\n\n根据文中的意思，思想大致如下：\n\n1. 用GMM（高斯混合模型）来估计迹密度\n   $$\n   \\rho(\\mathbf{x})=\\sum_{k=1}^{K} c_{k} \\mathcal{N}\\left(\\mathbf{x} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)\n   $$\n\n2. 在每个epoch，使用V-GMM（GMM的一个变体）+EM算法推断GMM参数($\\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}$)的后验分布\n\n3. 在每个episode，使用如下公式计算迹密度\n   $$\n   \\rho=\\mathrm{V}-\\operatorname{GMM}(\\mathcal{T})=\\sum_{k=1}^{K} c_{k} \\mathcal{N}\\left(\\mathcal{T} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)\n   $$\n   其中，$\\mathcal{T}=\\left(s_{0}\\left\\|s_{1}\\right\\| \\ldots \\| s_{T}\\right)$，**每个迹的长度相同**，中间的符号代表连结操作的意思，然后进行归一化\n   $$\n   \\rho_{i}=\\frac{\\rho_{i}}{\\sum_{n=1}^{N} \\rho_{n}}\n   $$\n\n*注：我猜想上边符号表示的$s$其实包含了智能体的所在状态和要达到的真实目标，也就是$(s,g)$，文中有一段可能解释了这一部分，但是我没有太理解。*\n\n![](./rl-rough-reading/cdp-sg.png)\n\n## 优先级的设定\n\n作者说使用rank-based方法来设置优先级，因为其受异常点影响小而具有良好的鲁棒性。\n\n先计算迹密度的补\n$$\n\\overline{\\rho} \\propto 1-\\rho\n$$\n将补从小到大排序，并根据排名计算优先级，排名从0开始，即\n$$\n\\operatorname{rank}(\\cdot) \\in\\{0,1, \\ldots, N-1\\}\n$$\n\n$$\np\\left(\\mathcal{T}_{i}\\right)=\\frac{\\operatorname{rank}\\left(\\overline{\\rho}\\left(\\mathcal{T}_{i}\\right)\\right)}{\\sum_{n=1}^{N} \\operatorname{rank}\\left(\\left(\\overline{\\rho}\\left(\\mathcal{T}_{n}\\right)\\right)\\right.}\n$$\n\n## 伪代码\n\n![](./rl-rough-reading/cdp-pseudo.png)\n\n解析：\n\n- 每个epoch根据经验池中的样本数据重新拟合一次密度模型，也就是GMM中的参数\n- 每个episode都计算其迹密度\n- 红色框中的公式数字编号分别代表之间部分中关于计算迹密度和迹优先级的公式\n- 采样迹、采样经验转换之后，需要采样目标并存入经验池，重构后的经验其优先级及迹密度与真正目标下迹的相同\n\n## 优点\n\n实验部分的比较详见论文。\n\n1. 可以适用于任何Off-Policy算法\n2. 不使用TD-error计算优先级，而使用迹密度，减少了计算时间\n3. 提升了采样效率两倍左右\n4. 算法性能超过最新算法9%（这个结果看看即可，不必放在心上）\n\n<h1 align=\"center\" style=\"color:blue\" id=\"NAF\">[Google]Continuous Deep Q-Learning with Model-based Acceleration[NAF]</h1>\n论文地址：[https://arxiv.org/abs/1603.00748](https://arxiv.org/abs/1603.00748)\n\n本文介绍了标准化优势函数Normalized Advantage Function——NAF算法，该算法简化了A-C架构，将Q-Learning的思想应用于高维连续空间。\n\n本文的主要贡献是：\n\n1. 提出NAF，简化了Actor-Critic架构\n2. 将Q-Learning推广至高维连续空间\n3. 提出新的与已学模型结合的方法，提升了采样复杂性（也就是降低）和学习效率，不牺牲策略的最优性。原文中翻译意思是，评估了几种将已学习模型与Q-Learning结合的方案，提出将局部线性模型与局部On-Policy想定推演结合以加速Q-Learning算法在model-free、连续问题下的学习\n\n## 伪代码\n\n![](./rl-rough-reading/naf-pseudo.png)\n\n解析：\n\n- 待写\n\n\n\n<h1 align=\"center\" style=\"color:blue\" id=\"ERE\">[NYU]Boosting Soft Actor-Critic: Emphasizing Recent Experience without Forgetting the Past[ERE]</h1>\n\n<p>论文地址：<a href=\"http://arxiv.org/abs/1906.04009\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1906.04009</a></p>\n<p>代码仓库：<a href=\"https://github.com/BY571/Soft-Actor-Critic-and-Extensions\" rel=\"external nofollow\" target=\"_blank\">https://github.com/BY571/Soft-Actor-Critic-and-Extensions</a>(不确定是否为论文原作者的仓库，该仓库PER的实现没有用sum-tree，2020年04月02日13:42:44)</p>\n<p>这篇论文主要是对经验池机制的扩展，SAC是被应用的算法。</p>\n<p>ERE是Emphasizing Recent Experience的缩写，从名字即可以看出，该经验池机制的侧重点是近期经验。简单说一下ERE的思想及流程：</p>\n<ol>\n<li>强调近期观测到的数据，同时不遗忘过去学到的知识；</li>\n<li>在更新神经网络参数时，比如要连续更新$K$次，即要从经验池中循环取$K$个mini-batch的数据，那么，在第一次更新时，从整个经验池进行采样，后续更新时，逐渐缩小经验池的可采样范围，也就是收缩，使得在间隔内更新的次数也多，近期经验被采样出的概率越大</li>\n</ol>\n<p>论文中的原句：</p>\n<blockquote>\n<p>We propose Emphasizing Recent Experience (ERE), a simple but powerful off-policy sampling technique, which emphasizes recently observed data while not forgetting the past. The ERE algorithm samples more aggressively from recent experience, and also orders the updates to ensure that updates from old data do not overwrite updates from new data.</p>\n</blockquote>\n<h2 id=\"经验池逐渐缩放的原理\"><a href=\"#经验池逐渐缩放的原理\" class=\"headerlink\" title=\"经验池逐渐缩放的原理\"></a>经验池逐渐缩放的原理</h2><p>核心思想是，在训练阶段（也就是先收集好一批轨迹，然后再更新$K$次的阶段），第一个mini-batch数据从整个经验池范围采样，在后续次序的更新中，我们逐渐减小经验池的可采样范围，使得mini-batch数据中包含越来越多的近期经验。</p>\n<p>举个例子：假如经验池共十个位置，即0到9，0放置最新的经验，9放置最旧的经验，batch-size为2，那么在第一次更新时，从0-9中采样两条经验。在第二次更新时，从0-8中采样两条经验。……以此类推。</p>\n<p>论文中提出了下边这个公式：</p>\n<script type=\"math/tex; mode=display\">\nc_{k}=\\max \\left\\{N \\cdot \\eta^{k \\frac{1000}{K}}, c_{\\min }\\right\\}</script><p>在这个公式中，$N$代表经验池的总容量；$\\eta \\in(0,1]$是引入的一个超参数，用来决定<strong>对近期数据的重视程度</strong>，当$\\eta=1$时等同于均匀采样，当$\\eta&lt;1$时，$c_k$随着更新次数逐渐减小。作者通过实验发现$\\eta \\in(0.994,0.999)$时效果不错；$c_{min}$是为$c_k$设置的一个下界，防止从一个很小的范围内采样数据，可能会导致过拟合现象。大写的$K$表示更新的册数，小写的$k$，$1\\leq k \\leq K$，表示当前是第几次更新。</p>\n<p>虽然作者说只引入了$\\eta$这一个超参数，但其实我觉得，更新次数$K$与基数$1000$也属于可调的超参数，虽然在实验中往往将$K$设置为一条轨迹的步长，即有多少步就更新多少次，这样在更新次数上与一步一更新是一致的，但是说到底它也是个可变的参数。</p>\n<p>文中还提到ERE可以与PER相结合，先决定采样区间，再按照区间内经验的权重选择批数据进行更新。通过代码没有看到在ERE与PER结合时使用sum-tree结构，可能在sum-tree结构上ERE不能很好适用，因为区间的选择也会改变树根节点的位置，为各种功能的计算都引入不便。</p>\n<script type=\"math/tex; mode=display\">\nP(i)=\\frac{p_{i}^{\\alpha}}{\\sum_{j} p_{j}^{\\alpha}}, i, j \\in D_{c_{k}}</script><p>$D_{c_k}$即为经验池中前$c_k$个近期的经验数据。</p>\n<h2 id=\"伪代码-3\"><a href=\"#伪代码-3\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./rl-rough-reading/ere-pseudo.png\" alt=\"\"></p>\n<h2 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h2><p>优点：</p>\n<ol>\n<li>简单有效</li>\n<li>可用于任何使用经验池机制的off-policy算法中，通用性强</li>\n<li>引入的额外计算损耗可以忽略不计</li>\n<li>只引入一个超参数$\\eta$，用来控制经验池可采样范围缩减的速率，容易调节（我觉得公式中的1000以及$c_{min}$应该也算是需要手动设置的超参数）</li>\n<li>可以结合PER使用</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>传统off-policy算法的更新方式是走一步更新一次参数，像baseline等许多仓库都是这么做的，但是OpenAI的Spinning Up仓库却采用先采样一条轨迹，然后按照轨迹的步长为更新次数，循环更新网络。该论文提出的ERE也是使用先采样轨迹再更新的方式，目前看来不能应用在一步一更新的优化方式中，因为各个时间步的经验池是略有不同的</li>\n<li>创新很小，实验上也没有看出明显的提升。而且，增加重放近期经验的次数的本质原因也不清楚，似乎只是实验效果不错，所以就这样错了，没有看到比较透彻的数学分析</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>该论文的实验图见原文。虽然在许多环境中都产生了1.收敛速度更快一点，2.最终性能得分更高一些，但是总感觉不那么make sense。我个人觉得这个ERE可用可不用，它更像是一种实验得出来有效的trick，而不像是为了解决某一问题而特定研究出来的方法。该方法可以当做是扩展眼界的trick。</p>\n<h1 align=\"center\" style=\"color:blue\" id=\"6SAN\">Reinforcement Learning with Attention that Works: A Self-Supervised Approach</h1>\n\n<p>论文地址：<a href=\"http://arxiv.org/abs/1904.03367\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1904.03367</a></p>\n<p>这篇文章是将self-attention结合进强化学习，并在PPO算法上进行了验证，使用了Arcade Learning Environment的10个环境，分3个随机种子进行实验。</p>\n<p>由于论文中没有明确的self-attention在RL中的运算过程，所以目前不太清楚中间的计算细节。</p>\n<h2 id=\"提出的方法\"><a href=\"#提出的方法\" class=\"headerlink\" title=\"提出的方法\"></a>提出的方法</h2><p><img src=\"./rl-rough-reading/6san.png\" alt=\"\"></p>\n<p>上图为论文提出的Self-Attention在RL中应用的总体架构，其中$H_1,H_2,H_3$均为卷积层。文中将自注意力层加在了卷积层中间，而不是像DARQN一样将注意力层放置在卷积层之后。文中并未对Self-Attention模块中$F_1,F_2,G_1,Y$的运算进行解释。</p>\n<p>作者对self-attention的可能实现做了深入的探索，提出并实验了六种结构：</p>\n<ol>\n<li><p>SAN: Self-Attending Network 在$H_1,H_2$最底层网络间加入自注意力机制</p>\n</li>\n<li><p>SSAN: Strong Self-Attending Network 意思似乎是将自注意力机制的输出$Y$乘以因子2，以增强注意力在网络中的影响</p>\n<blockquote>\n<p>Multiplying the output of the last convolutional layer in the self-attention component (’Y’) by a factor of two (thereby increasing the inﬂuence of attention on the network).</p>\n</blockquote>\n</li>\n<li><p>SADN: Self-Attending Double Network 加入两个自注意力层，分别在$H_1, H_2$与$H_2, H_3$之间</p>\n</li>\n<li><p>SSADN: Strong Self-Attending Double Network 两注意力层的输出均乘2</p>\n</li>\n<li><p>PSAN: Pure Self-Attending Network 只使用注意力层的输出作为特征表示</p>\n<blockquote>\n<p>Passing only the output of the selfattention forward, removing the addition of the previous convolutional layer output.</p>\n</blockquote>\n</li>\n<li><p>PSADN: Pure Self-Attending Double Network 与上相同</p>\n</li>\n</ol>\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实验结果与分析见论文原文。</p>\n<p>此篇文章略读思想即可，文章中没有自注意力机制的完整计算流程，也没有开源源代码，因此无法了解到具体细节。而且，文章中提出了六种自注意力机制结构并进行了实验，个人感觉这六种结构不全是必要的，比如SSAN与PSAN这两类的完全没有get到这么设置的意义，给人一种为了做对比试验而设置的感觉。本篇文章创新性也不高。</p>\n<h1 align=\"center\" style=\"color:blue\" id=\"MANet\">[SNU]Multi-focus Attention Network for Efficient Deep Reinforcement Learning[MANet]</h1>\n\n<p>论文地址：<a href=\"http://arxiv.org/abs/1712.04603\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1712.04603</a></p>\n<p>这篇文章17年发表在AAAI上，提出了MANet算法(多焦点注意力+DQN)，它的创新点主要是将图像分割成若干区域，在这些区域中并行计算注意力权重，最终加权得到新的状态特征。作者展示了MANet算法可以应用在<strong>单智能体图像输</strong>入的环境中，也可以扩展模型应用<strong>在多智能体合作任务</strong>中。</p>\n<p>作者提出MANet针对的问题是：当前深度强化学习模型无法利用感知数据中实体与实体之间的关系，因此需要大量的采样经验去学习。作者希望通过多焦点注意力模型将感知数据中局部范围内实体之间的关系给embed到状态特征之中，加速策略模型学习并且提升模型性能。</p>\n<blockquote>\n<p>current DRL models connect the entire low-level sensory input to the state-action values rather than exploiting the relationship between and among entities that constitute the sensory input.</p>\n</blockquote>\n<p>最终实验结果简报是：</p>\n<ol>\n<li>与DQN做比较时，单智能体场景中使用更少经验取得最高得分</li>\n<li>在多智能体合作任务中，相较于SOTA算法(18年以前)，MANet加速学习20%</li>\n</ol>\n<blockquote>\n<p>MANet attains highest scores with significantly less experience samples. Additionally, the model shows higher performance compared to the Deep Q-network and the single attention model as benchmarks. Furthermore, we extend our model to attentive communication model for performing multi-agent cooperative tasks. In multi-agent cooperative task experiments, our model shows 20% faster learning than existing state-of-the-art model.</p>\n</blockquote>\n<h2 id=\"模型讲解\"><a href=\"#模型讲解\" class=\"headerlink\" title=\"模型讲解\"></a>模型讲解</h2><p><img src=\"./rl-rough-reading/MANet-structure.png\" alt=\"\"></p>\n<p>上图为论文中提出的MANet的结构示意图。MANet主要由四个模块组成：</p>\n<ul>\n<li>输入分割模块(Input Segmentation)</li>\n<li>特征提取模块(Feature Extraction)</li>\n<li>并行注意力模块(Parallel Attentions)</li>\n<li>状态-动作值估计模块(State-action Value Estimation)</li>\n</ul>\n<p><strong>在单智能体任务中</strong>：</p>\n<ol>\n<li><p>输入分割模块</p>\n<p>在这个阶段主要将底层传感器输入分割成多个块/区域，将每一个块的状态称为局部状态。作者使用了最简单的均匀格子切分方法，就是每个局部状态格子大小相同。作者也提到可以使用其他分割方式，可能由于实现困难或者切分后图像大小不一致使处理困难等因素而没有采用。</p>\n<blockquote>\n<p>We believe that we can apply more sophisticated methods like super-pixel segmentation (Achanta et al. 2010) or spatial transformer networks (Jaderberg, Simonyan, and Zisserman 2015).</p>\n</blockquote>\n</li>\n<li><p>特征提取模块</p>\n<p>这个模块主要从每个局部状态提取键(Key)特征和值(Value)特征。</p>\n<p>其中，键特征主要用于决定模型应该注意到的位置</p>\n<blockquote>\n<p>The key features are used to determine where the model should attend.</p>\n</blockquote>\n<p>值特征主要用于编码用于评估Q值的信息</p>\n<blockquote>\n<p>The value features are used to encode information for state-action value estimation.</p>\n</blockquote>\n<p>这一模块的计算过程是这样的，首先提取局部状态的通用特征：</p>\n<script type=\"math/tex; mode=display\">\nc_{i}=f_{f}\\left(s_{i}\\right) \\text { for all } i \\in(0,1, \\ldots, K)</script><p>其中，$K$为第一阶段切分的局部状态的个数，$s_i$表示第$i$个局部状态，$c_i$表示其通用特征，$f_f$是特征提取函数（作者使用深度卷积网络）。</p>\n<p>然后，将通用特征$c_i$与局部状态的索引$i$拼接后，再计算键特征与值特征：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&K e y_{i}=W_{k e y} * c_{i}\\\\\n&V a l_{i}=f_{v}\\left(W_{v a l} * c_{i}\\right)\n\\end{aligned}</script><p>其中，$Key_i$与$Val_i$分别表示第$i$个局部状态的键、值特征。$f_v$表示非线性激活函数（作者使用的是leaky ReLU），$W_{key},W_{val}$是权重矩阵。</p>\n</li>\n<li><p>并行注意力模块</p>\n<p>这一模块主要是区分各个局部状态的重要性，按重要性的不同加权表示特征。</p>\n<script type=\"math/tex; mode=display\">\nA_{i}^{n}=\\frac{\\exp \\left(a_{n} * Key_{i}^{T}\\right)}{\\sum_{i^{\\prime}} \\exp \\left(a_{n^{*} Key_{i^{\\prime}}^{T}}\\right)} \\text { for all } n \\in(0,1, \\ldots, N)</script><p>其中，$N$是上面结构图中注意力层的数量，$A_i^n$表示第$n$层注意力的向量的第$i$个元素，$i^{\\prime} \\in\\{0,1, \\ldots, \\mathrm{K}\\}$，$a_n$是第$n$个选择向量（图中的selector，像神经网络参数一样可以被训练）。上述公式其实是softmax的形式。</p>\n<p>由于$a$的随机初始化基本上相似，所以计算得来的注意力权重也必将相近，作者不希望所有的注意力层都注意某一局部区域（或者相似区域），比如说第5个局部区域，这样的话就很低效。作者希望多个注意力层可以皆可能地注意到不同的局部状态，以达到多焦点（multi-focus）的效果，作者探索了两种正则化方式来鼓励这种行为。</p>\n<p>第一种正则化方法是熵正则化：</p>\n<script type=\"math/tex; mode=display\">\nR_{e}=\\lambda_{e} * \\sum_{n}\\left\\|A^{n} * \\log A^{n}\\right\\|</script><p>这个式子的熵的负数形式，值越小，越随机（越雨露均沾），趋向于均匀分布，也就是越不集中注意力。</p>\n<p>第二种正则化方法是距离正则化：</p>\n<script type=\"math/tex; mode=display\">\nR_{d}=\\lambda_{d} * \\exp \\left(-\\sum_{n, m}\\left(A^{n}-A^{m}\\right)^{2}\\right)</script><p>这个式子为$e$的指数性质，值越小，说明两个注意力层注意关注的区域越不相同，也就是越集中注意力且注意不同的局部状态。</p>\n<p><em>由于论文没有开源源代码，所以目前不确定熵正则化项的具体应用方式，不知道是最大化熵正则化项以鼓励不同注意力层注意不同区域，还是最小化熵正则化项以trade-off距离正则化项，放置距离正则化项过多的注意不同区域。</em></p>\n</li>\n<li><p>状态-动作值估计模块</p>\n<p>这一模块综合每个注意力层的输出特征，并且输入到剩余网络以估计状态-动作值。作者将基于注意力的加权值特征定义为：</p>\n<script type=\"math/tex; mode=display\">\nh_{n}=\\sum_{i} V a l_{i} * A_{i}^{n}</script><p>其中，$h_n$是由第$n$个注意力层的注意力权重$A^n$加权的值特征。最终联合特征和Q值表示为：</p>\n<script type=\"math/tex; mode=display\">\ng=\\left\\{h_{0}, h_{1}, \\ldots, h_{N}\\right\\}</script><script type=\"math/tex; mode=display\">\nQ=f_{q}(g)</script></li>\n</ol>\n<p><strong>在多智能体合作任务中</strong>：</p>\n<p>​    在这种任务中，MANet主要将其它智能体的相关信息加权到某个智能体的状态特征中，相当于特征融合。</p>\n<ol>\n<li><p>输入分割模块</p>\n<p>每一个智能体即是局部状态，因此不用分割，故不需要该模块。</p>\n</li>\n<li><p>特征提取模块</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&c_{i}=f_{f}\\left(s_{i}\\right) \\text { for all } i \\in(0,1, \\ldots, K)\\\\\n&K e y_{i}=W_{k e y} * c_{i}\\\\\n&\\color{red}{a_{i}=W_{a} * c_{i}}\\\\\n&V a l_{i}=f_{v}\\left(W_{v a l} * c_{i}\\right)\n\\end{aligned}</script><p>$K$表示任务中智能体的个数。与单智能体不同的是，这里的selector是由通用特征$c_i$与权重矩阵$W_a$计算得来的，如上述公式红色字体所示。</p>\n</li>\n<li><p>注意力交流模块（Attentive Communication）</p>\n<script type=\"math/tex; mode=display\">\nA_{j}^{i}=\\frac{\\exp \\left(a^{i} * \\operatorname{Key}_{j}^{T}\\right)}{\\sum_{j^{\\prime}} \\exp \\left(a^{i} * \\operatorname{Ke} y_{j^{\\prime}}^{T}\\right)} \\quad i, j \\in(0,1, \\ldots, K)</script><p>$A_j^i$表示智能体$j$对智能体$i$的注意力权重，值越大则$j$的信息对$i$越重要。</p>\n</li>\n<li><p>状态-动作值估计模块</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{c}\nh_{i}=\\sum_{j} V a l_{j} * A_{j}^{i} \\quad j \\in(0,1, \\ldots, K) \\\\\ng_{i}=\\left\\{V a l_{i}, h_{i}\\right\\} \\\\\nQ_{i}=f\\left(g_{i}\\right)\n\\end{array}</script><p>$h_i$为第$i$个智能体的交流特征——从其他智能体的特征中基于注意力加权得来的。</p>\n<p>在多智能体任务中，由于selector $a$与智能体的通用特征相关，因此之间不太相似，所以不需要熵和距离正则化项（作者认为的）。</p>\n<p>作者添加了另一个正则化项$R=\\lambda \\cdot \\left(a \\cdot Key^{T} \\right)$以解决值容易发散的问题。<strong><em>我目前还没有理解到这个正则化项的作用及意义。</em></strong></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文记录了一些粗读的强化学习相关的论文。</p>","more":"<h1 align=\"center\" style=\"color:blue\" id=\"Gorila\">[DeepMind]Massively Parallel Methods for Deep Reinforcement Learning[Gorila]</h1>\n\n<p>本文提出了一个分布式强化学习训练的架构：Gorila(General Reinforcement Learning Architecture)。2015年发于ICML，本文使用DQN算法进行分布式实现。</p>\n<p>论文地址：<a href=\"https://arxiv.org/pdf/1507.04296.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1507.04296.pdf</a></p>\n<h2 id=\"模型示意图\"><a href=\"#模型示意图\" class=\"headerlink\" title=\"模型示意图\"></a>模型示意图</h2><p><img src=\"./rl-rough-reading/gorila.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>shard代表参数分片的意思，即模型过大、参数过多，需要将参数分片放置多台机器上</li>\n<li>Bundled Mode模式指的是Actor中的Q网络与Learner中的Q网络一样，但是Learner比Actor多了一个目标Q网络，用于计算梯度</li>\n</ul>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>并行Actor采数据</li>\n<li>并行Learner计算梯度，<strong>不更新Learner中的模型</strong></li>\n<li>中心参数服务器，用于维持最新的网络模型。如果模型太大、参数过多，可以分片将网络模型放置多个参数服务器，每个参数服务器中的参数独立不关联，根据learner传的梯度更新相应的变量</li>\n<li>经验池机制，分为local与global两种<ul>\n<li>local，即每个actor节点一个经验池</li>\n<li>global，将所有actor节点的经验存至一个分布式数据库中，这个<strong>需要网络通信开销</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./rl-rough-reading/gorila-pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li><p>伪代码中为一个actor节点的流程</p>\n</li>\n<li><p>注意伪代码中出现两次<code>Update θ from parameters θ+ of the parameter server</code>，这句话的意思为从中心参数服务器拉取模型到actor和learner，拉取的时间点为：</p>\n<ul>\n<li>每个episode开始前</li>\n<li>每次执行动作$a_{t}$后，但是在计算梯度并将梯度传递至参数服务器之前</li>\n</ul>\n</li>\n<li><p>伪代码中<code>equation 2</code>，代表$g_{i}=\\left(r+\\gamma \\max _{a^{\\prime}} Q\\left(s^{\\prime}, a^{\\prime} ; \\theta_{i}^{-}\\right)-Q\\left(s, a ; \\theta_{i}\\right)\\right) \\nabla_{\\theta_{i}} Q(s, a ; \\theta)$，这是DQN中的损失函数</p>\n</li>\n<li><p>注意，与传统DQN不同的是，<strong>该分布式DQN中给Learner中的目标Q网络赋值时，是直接将更新N次的中心参数服务器中的模型进行拉取覆盖，而不是使用Learner中的Q网络</strong></p>\n</li>\n<li><p>中心参数服务器中的参数梯度更新需要累计多个learner传来的梯度后进行更新，使用异步SGD即ASGD方法进行梯度下降。</p>\n<ul>\n<li><blockquote>\n<p>The parameter server then applies the updates that are accumulated from many learners. </p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>因为每个actor都是阶段更新自己的模型，即从参数服务器中拉取。所以每个actor中的行为策略（采样策略）都不完全相同，事实上，每个actor节点可以采取不同的探索机制，这样可以更有效地探索环境</p>\n</li>\n</ul>\n<h2 id=\"稳定性\"><a href=\"#稳定性\" class=\"headerlink\" title=\"稳定性\"></a>稳定性</h2><p>为了应对节点退出、网速慢、节点机器运行慢等问题，该文章中指出使用了一个超参数用来控制actor和server之间最大延时。</p>\n<ul>\n<li><p>过时的梯度（低于时间阈值）将会被丢弃</p>\n<ul>\n<li><blockquote>\n<p>All gradients older than the threshold are discarded by the parameter server. </p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>过高或过低的梯度也将被丢弃</p>\n<ul>\n<li><blockquote>\n<p>each actor/learner keeps a running average and standard deviation of the absolute DQN loss for the data it sees and discards gradients with absolute loss higher than the mean plus several standard deviations. </p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>使用AdaGrad更新规则</p>\n</li>\n</ul>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p>采用于提出DQN的论文中一样的网络结构，具体请见论文中第5部分。</p>\n<p>在Atari 2600 49个游戏中，41个明显优于单GPU DQN。</p>\n<p>Gorila进一步实现了DRL的希望：一个可伸缩的架构，随着计算和内存的增加，它的性能会越来越好</p>\n<h1 align=\"center\" style=\"color:blue\" id=\"MB-MPO\">[UCB/OpenAI]Model-Based Reinforcement Learning via Meta-Policy Optimization[MB-MPO]</h1>\n\n<p>论文地址：<a href=\"https://arxiv.org/pdf/1809.05214.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1809.05214.pdf</a></p>\n<p>本文2018年发布于CoRL，提出了一个基于模型的元强化学习算法MB-MPO。相比于一般的元强化学习是从多个MDPs任务中学习一个通用模型加速以后特定任务的模型训练，该文中的方法是将一个model-free的任务学习多个不确定、不完全、不完美的动态模型，即一个模型集合，然后使用这个模型集合学习出该任务的通用模型。因为它有一个从model-free学习动态模型的过程，所以为model-based方法。</p>\n<h2 id=\"元强化学习\"><a href=\"#元强化学习\" class=\"headerlink\" title=\"元强化学习\"></a>元强化学习</h2><script type=\"math/tex; mode=display\">\n\\max _{\\theta} \\mathbb{E}_{\\mathcal{M}_{k} \\sim \\rho(\\mathcal{M}),\\boldsymbol{s}_{t+1} \\sim p_{k},\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}^{\\prime}}\\left(\\boldsymbol{a}_{t} | \\boldsymbol{s}_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r_{k}\\left(s_{t}, a_{t}\\right)\\right] \\\\ s.t.:\\boldsymbol{\\theta}^{\\prime}=\\boldsymbol{\\theta}+\\alpha\\nabla_{\\boldsymbol{\\theta}} \\mathbb{E}_{\\boldsymbol{s}_{t+1} \\sim p_{k},\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}}\\left(\\boldsymbol{a}_{t} | \\boldsymbol{s}_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r_{k}\\left(s_{t}, a_{t}\\right)\\right]</script><p>$\\mathcal{M}$为一系列MDP，共享相同的状态空间$\\mathcal{S}$与动作空间$\\mathcal{A}$，但是奖励函数可以不同</p>\n<h2 id=\"学习环境动态模型\"><a href=\"#学习环境动态模型\" class=\"headerlink\" title=\"学习环境动态模型\"></a>学习环境动态模型</h2><script type=\"math/tex; mode=display\">\n\\min _{\\boldsymbol{\\phi}_{k}} \\frac{1}{\\left|\\mathcal{D}_{k}\\right|} \\sum_{\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}, \\boldsymbol{s}_{t+1}\\right) \\in \\mathcal{D}_{k}}\\left\\|\\boldsymbol{s}_{t+1}-\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)\\right\\|_{2}^{2}</script><p>解析：</p>\n<ul>\n<li><p>$\\mathcal{D}_{k}$为第k个学习模型采样的“经验”</p>\n</li>\n<li><p>$\\phi$为用神经网络表示的环境模型的参数</p>\n</li>\n<li><p>$\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)$为第k个学习模型针对状态$s_{t}$执行动作$a_{t}$后转移状态的预测，其中，神经网络的输出不直接是预测的状态$\\color{red}{s_{t+1}}$，而是$\\color{red}{\\Delta s=s_{t+1}-s_{t}}$，所以$\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)=s_{t}+\\Delta s$</p>\n<ul>\n<li><blockquote>\n<p>We follow the standard practice in model-based RL of training the neural network to predict the change in state $\\Delta s=s_{t+1}-s_{t}$ (rather than the next state $s_{t+1}$) </p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<p>为了防止过拟合，文中使用了3个trick：</p>\n<ol>\n<li>早停</li>\n<li>归一化神经网络输入与输出</li>\n<li>权重归一化</li>\n</ol>\n<h2 id=\"基于环境动态模型的元强化学习\"><a href=\"#基于环境动态模型的元强化学习\" class=\"headerlink\" title=\"基于环境动态模型的元强化学习\"></a>基于环境动态模型的元强化学习</h2><p>假设学到了K个近似模型$\\left\\{\\hat{f}_{\\phi_{1}}, \\hat{f}_{\\phi_{2}}, \\ldots, \\hat{f}_{\\phi_{K}}\\right\\}$，把每个模型转换成一个MDP过程，即$\\mathcal{M}_{k}=\\left(S, A, \\hat{f}_{\\phi_{k}}, r, \\gamma, p_{0}\\right)$，其中，<strong>奖励函数相同</strong></p>\n<p>由此给每个学习到的动态模型分配的行为策略目标函数为：</p>\n<script type=\"math/tex; mode=display\">\nJ_{k}(\\boldsymbol{\\theta})=\\mathbb{E}_{\\boldsymbol{a}_{t} \\sim \\pi_{\\boldsymbol{\\theta}}\\left(\\boldsymbol{a}_{t} | s_{t}\\right)}\\left[\\sum_{t=0}^{H-1} r\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right) | \\boldsymbol{s}_{t+1}=\\hat{f}_{\\boldsymbol{\\phi}_{k}}\\left(\\boldsymbol{s}_{t}, \\boldsymbol{a}_{t}\\right)\\right]</script><p>定义MB=MPO的最终目标函数为：</p>\n<script type=\"math/tex; mode=display\">\n\\max _{\\boldsymbol{\\theta}} \\frac{1}{K} \\sum_{k=0}^{K} J_{k}\\left(\\boldsymbol{\\theta}_{k}^{\\prime}\\right) \\quad \\text { s.t.: } \\quad \\boldsymbol{\\theta}_{k}^{\\prime}=\\boldsymbol{\\theta}+\\alpha \\nabla_{\\boldsymbol{\\theta}} J_{k}(\\boldsymbol{\\theta})</script><p>小写k代表第k个学到的模型，大写K代表模型的总数。</p>\n<p>注意看，这里公式后边使用的是$\\color{red}{\\theta’_{k}}$，而不是$\\theta$。这里并没有写错，我起初以为写错了，具体请看后边的伪代码解释。</p>\n<h2 id=\"伪代码-1\"><a href=\"#伪代码-1\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./rl-rough-reading/mb-mpo-pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>MB-MPO分为两部分更新，第一部分更新每个模型分配的行为策略，第二部分更新元策略。<strong>注意：行为策略的更新是不连贯的，即不是自身迭代，而是不断使用元策略进行稍加修改然后替换，所以叫做adapted policy</strong></li>\n<li>上一项提到的两次更新都是对元策略的参数$\\theta$进行更新，区别是，第一次更新将更新后的参数赋值给了行为策略，未更改元策略本身，第二次更新直接更新元策略本身</li>\n<li>$\\alpha, \\beta$为两部分更新的学习率</li>\n<li>行为策略使用VPG，即传统策略梯度算法进行优化，元策略使用TRPO算法进行优化</li>\n<li>伪代码中的大致流程如下：<ol>\n<li>初始化策略$\\pi_{\\theta}$并将其复制K份$\\pi_{\\theta_{1}^{\\prime}}, \\dots, \\pi_{\\boldsymbol{\\theta}_{K}^{\\prime}}$</li>\n<li>使用$\\pi_{\\theta_{1}^{\\prime}}, \\dots, \\pi_{\\boldsymbol{\\theta}_{K}^{\\prime}}$对<strong>真实的环境模型进行采样（这一步是实际交互，即真实数据）</strong>，将数据存入经验池</li>\n<li>根据经验池训练K个环境模型，即使用<code>学习环境动态模型</code>部分的公式</li>\n<li>对于每个更新后的环境模型，用元策略$\\color{red}{\\pi_{\\theta}}$进行<strong>虚拟采样（这一步是预测采样，即不实际进行交互）</strong>，采样到$\\mathcal{T}_{k}$以适应性修改行为策略$\\boldsymbol{\\theta}_{k}^{\\prime}$。这里也是前边提到的行为策略更新是不连贯的原因。</li>\n<li>再用适应性策略$\\boldsymbol{\\theta}_{k}^{\\prime}$进行<strong>虚拟采样</strong>，采样到$\\mathcal{T}_{k}^{\\prime}$以更新元策略$\\pi_{\\theta}$</li>\n<li>跳向第2步</li>\n</ol>\n</li>\n<li>伪代码中虽然没有明确指出，但是其实使用了baseline的trick用来减少方差</li>\n</ul>\n<h2 id=\"流程示意图\"><a href=\"#流程示意图\" class=\"headerlink\" title=\"流程示意图\"></a>流程示意图</h2><p><img src=\"./rl-rough-reading/mb-mpo-visio.png\" alt=\"\"></p>\n<h2 id=\"效果-1\"><a href=\"#效果-1\" class=\"headerlink\" title=\"效果\"></a>效果</h2><ol>\n<li>比之前的model-based方法效果好、收敛快</li>\n<li>可以达到model-free算法的渐进性能</li>\n<li>需要更少的经验，低采样复杂性。其实是使用了虚拟采样，提高了数据效率，减少了交互采样的代价。</li>\n<li>对于模型偏差（model-bias，即环境模型没学到位）的情况，之前的算法不能有效处理，该算法对不完美、不完全、不完整的模型具有很好地鲁棒性</li>\n</ol>\n<h1 align=\"center\" style=\"color:blue\" id=\"DIAYN\">[UCB/Google AI]Diversity is All Your Need: Learning Skills Without a Reward Function[DIAYN]</h1>\n\n<p>论文地址：<a href=\"https://arxiv.org/pdf/1802.06070.pdf\" rel=\"external nofollow\" target=\"_blank\">https://arxiv.org/pdf/1802.06070.pdf</a></p>\n<p>Google网页：<a href=\"https://sites.google.com/view/diayn/home\" rel=\"external nofollow\" target=\"_blank\">https://sites.google.com/view/diayn/home</a></p>\n<p>Github项目：<a href=\"https://github.com/ben-eysenbach/sac/blob/master/DIAYN.md\" rel=\"external nofollow\" target=\"_blank\">https://github.com/ben-eysenbach/sac/blob/master/DIAYN.md</a></p>\n<p>这篇文章使用信息论中最大熵的方法来构造强化学习的学习目标，<strong>期望学习到具有多样性的技能（skills）</strong>。</p>\n<p>个人认为，此文章中所提的方法虽然很新颖，但是不能作为优化一项任务的可用算法，因为虽然其可以学到以各种花样完成目标，但是没有奖励函数的控制使得无法规范、指引智能体“解题”过程的效果，如柔顺性、实用性、实际可行性等。从另一方面来讲，将这样虽然不规划、不严谨决策行为的策略用于元策略的预训练模式还是可用的。</p>\n<h2 id=\"技能\"><a href=\"#技能\" class=\"headerlink\" title=\"技能\"></a>技能</h2><p>技能的定义在文中有如下表述：</p>\n<blockquote>\n<p>A skill is a latent-conditioned policy that alters that state of the environment in a consistent<br>way.<br>we refer to a/the policy conditioned on a fixed Z as a “skill” .</p>\n</blockquote>\n<p>意思是，设定一个隐变量，以（状态$S$，隐变量$Z$）为条件进行动作选择，即为技能——skill。</p>\n<p>DIAYN就好像是要给每个状态赋予各个不同技能的概率，并且使其中一个技能的概率最大，这样就使得在整个状态空间中，不同的技能“占领”着状态空间的不同部分，每个技能在各自偏好的局部状态空间中作用，但是作者同样希望每个技能在各自的状态空间中尽可能随机决策。</p>\n<p><img src=\"./rl-rough-reading/skill.png\" alt=\"\"></p>\n<p>假设以不同的颜色代表不同的技能skill，每个方格代表一个状态，那么每个状态对于每个技能到达此状态的“偏好”概率是不同的。总的来说，作者希望技能之间的重合度尽可能小，但每个技能在各自的领域内尽可能随机地完成目标。</p>\n<h2 id=\"亮点与作用\"><a href=\"#亮点与作用\" class=\"headerlink\" title=\"亮点与作用\"></a>亮点与作用</h2><ol>\n<li>去掉了奖励函数</li>\n<li>修改了目标函数，$\\mathcal{F}(\\theta)\\triangleq \\mathcal{G}(\\color{red}{\\theta, \\phi})$<ul>\n<li>$\\color{red}{\\theta}$代表Actor网络中的参数</li>\n<li>$\\color{red}{\\phi}$代表Critic网络中的参数</li>\n</ul>\n</li>\n<li>学习到的技能可以用于<em>分层强化学习、迁移学习、模仿学习</em></li>\n</ol>\n<h2 id=\"目标函数\"><a href=\"#目标函数\" class=\"headerlink\" title=\"目标函数\"></a>目标函数</h2><script type=\"math/tex; mode=display\">\n\\begin{aligned} \n\\mathcal{F}(\\theta) & \\triangleq \\color{red}{I(S ; Z)+\\mathcal{H}[A | S]-I(A ; Z | S)} \\\\ \n&=(\\mathcal{H}[Z]-\\mathcal{H}[Z | S])+\\mathcal{H}[A | S]-(\\mathcal{H}[A | S]-\\mathcal{H}[A | S, Z]) \\\\ \n&=\\color{blue}{\\mathcal{H}[Z]-\\mathcal{H}[Z | S]+\\mathcal{H}[A | S, Z]} \\\\\n&=\\mathcal{H}[A | S, Z]+\\mathbb{E}_{z \\sim p(z), s \\sim \\pi(z)}[\\log p(z | s)]-\\mathbb{E}_{z \\sim p(z)}[\\log p(z)] \\\\\n&{ \\color{orange}{\\geq} \\mathcal{H}[A | S, Z]+\\mathbb{E}_{z \\sim p(z), s \\sim \\pi(z)}\\left[\\log q_{\\phi}(z | s)-\\log p(z)\\right] \\\\ \n\\triangleq \\mathcal{G}(\\theta, \\phi)}\n\\end{aligned}</script><p>解析：</p>\n<ul>\n<li><p>互信息，离散下为$I(X ; Y)=\\sum_{y \\in Y} \\sum_{x \\in X} p(x, y) \\log \\left(\\frac{p(x, y)}{p(x) p(y)}\\right)$，连续下为$I(X ; Y)=\\int_{Y} \\int_{X} p(x, y) \\log \\left(\\frac{p(x, y)}{p(x) p(y)}\\right) d x d y$</p>\n</li>\n<li><p>信息熵表示为$H(X, Y)=-\\sum_{x, y} p(x, y) \\log p(x, y)=-\\sum_{i=1}^{n} \\sum_{j=1}^{m} p\\left(x_{i}, y_{i}\\right) \\log p\\left(x_{i}, y_{i}\\right)$</p>\n</li>\n<li><p>推到中频繁使用了性质$I(X,Y)=H(X)-H(X | Y)$</p>\n</li>\n<li><p>式中对数的底为自然指数$e$</p>\n</li>\n<li><p>看红色部分，化简之前：</p>\n<ul>\n<li><strong>增大</strong>：$I(S ; Z)$代表状态$S$与策略隐变量$Z$之间的互信息。因为作者希望可以通过策略所能到达的状态来判别其属于哪个技能，即将技能与状态挂钩。作者给出一个直观的解释：因为在有些状态下可以执行很多动作，但是却不改变环境（至少不明显改变），就像用机械手臂夹紧一个物体时，可使用力的大小、方向等都是很多的，不同技能选择不同动作导致的效果可能相同，所以作者不希望从动作的选择来区分学到的技能，而是通过可以明显观察到、数值化的状态$S$来作为区别不同技能的标准。<strong>互信息$I(X,Y)$有一个直观的性质就是，它可以衡量两个随机变量的“相关性”，也就是说，互信息越大，代表知道$X$后对$Y$的不确定性减少，即知道其一可以加深对另一个的了解。</strong>所以，目标函数希望最大化互信息$I(S ; Z)$，以将状态和技能相关联，使技能尽可能根据状态可以区分。</li>\n<li><strong>增大</strong>：$\\mathcal{H}[A | S]$代表策略（不以隐变量$Z$区分技能，混合所有技能即为策略）的熵值。与SAC算法中想要使用熵增来使得动作的选择更加随机一样，作者希望随机性的动作同样可以完成目标，所以希望尽可能增大这一项。</li>\n<li><strong>减小</strong>：$I(A ; Z | S)$代表动作$A$与策略隐变量$Z$在给定状态$S$时之间的互信息。为了避免歧义，应该写作为$I[(A ; Z) | S]$。作者希望技能根据状态可区分，而不是根据动作，所以需要最小化这一项。</li>\n</ul>\n</li>\n<li><p>看蓝色部分，化简之后：</p>\n<ul>\n<li><strong>固定最大，为$\\ln n$</strong>：$\\mathcal{H}[Z]$代表技能分布的不确定性，既然要最大化这个项，不如就固定它，使得技能从其中均匀采样，使熵为最大值。</li>\n<li><strong>减小</strong>：$\\mathcal{H}[Z | S]$代表状态$S$条件下技能的不确定性，我们知道，熵越大，不确定性越大；熵越小，不确定性越小。作者希望技能根据状态可区分，可以需要使这一项最小，以减小给定状态下所属技能的不确定性，使其尽可能接近概率1。</li>\n<li><strong>增大</strong>：$\\mathcal{H [ A | S}, Z ]$代表给定技能$(S,Z)$下动作的不确定性。因为作者希望动作的选择尽可能随机但又可以完成目标，所以需要最大化这一项。</li>\n</ul>\n</li>\n<li><p>看橘色部分，使用Jensen不等式：</p>\n<ul>\n<li><p>这一步推导使用了论文<a href=\"https://pdfs.semanticscholar.org/f586/4b47b1d848e4426319a8bb28efeeaf55a52a.pdf\" rel=\"external nofollow\" target=\"_blank\">《The IM Algorithm : A variational approach to Information Maximization》</a>中的推导公式</p>\n<script type=\"math/tex; mode=display\">\nI(\\mathbf{x}, \\mathbf{y}) \\geq \\underbrace{H(\\mathbf{x})}_{\\text { ‘‘entrop’’ }}+\\underbrace{\\langle\\log q(\\mathbf{x} | \\mathbf{y})\\rangle_{p(\\mathbf{x}, \\mathbf{y})}}_{\\text { ‘‘energy’’ }} \\stackrel{\\mathrm{def}}{=} \\tilde{I}(\\mathbf{x}, \\mathbf{y})</script></li>\n<li><p><img src=\"./rl-rough-reading/Agakov.png\" alt=\"\"></p>\n</li>\n<li><p>蓝色公式中，有$I(Z;S) = \\mathcal{H}[Z]-\\mathcal{H}[Z | S]$，可以应用上述性质进行推导，将真实分布$p(z | s)$替换为任意变分分布(variational distribution)$q(z | s)$</p>\n</li>\n<li><p>最后使用变分下界$\\mathcal{G}(\\theta, \\phi)$代替目标函数$\\mathcal{F}(\\theta)$</p>\n</li>\n</ul>\n</li>\n<li><p>至此，思路已经十分清晰。Actor网络以变量$\\theta$参数化，并使用SAC算法($\\alpha=0.1$)最大化$\\mathcal{G}(\\theta, \\phi)$中$\\mathcal{H}[A | S, Z]$部分；Critic网络以变量$\\phi$参数化，并最大化后半个期望部分。文中将期望内的元素定义为“伪奖励”：</p>\n<script type=\"math/tex; mode=display\">\nr_{z}(s, a) \\triangleq \\log q_{\\phi}(z | s)-\\log p(z)</script><p>由于$p(z)$为均匀分布，是固定的；对数函数不改变原函数单调性，所以只需最大化$q_{\\phi}(z | s)$即可。</p>\n</li>\n</ul>\n<h2 id=\"伪代码-2\"><a href=\"#伪代码-2\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./rl-rough-reading/diayn-pseudo.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>每个episode都重新采样隐变量$z$</li>\n<li>Actor网络的输入为$(S||Z)$，即状态与隐变量的连结(我猜的= =)</li>\n<li>Critic网络的输入为状态$S$</li>\n</ul>\n<h2 id=\"模型示意图-1\"><a href=\"#模型示意图-1\" class=\"headerlink\" title=\"模型示意图\"></a>模型示意图</h2><p><img src=\"./rl-rough-reading/diayn.png\" alt=\"\"></p>\n<p>解析：</p>\n<ul>\n<li>隐变量分布$p(z)$是固定的</li>\n</ul>\n<h1 align=\"center\" style=\"color:blue\" id=\"CDP\">Curiosity-Driven Experience Prioritization via Density Estimation[CDP]</h1>\n论文地址：[https://arxiv.org/pdf/1902.08039.pdf](https://arxiv.org/pdf/1902.08039.pdf)\n\n这篇文章发于2018年的NIPS，作者为赵瑞，之前读过他的两篇论文，并写了博客，可以在论文精读里找，此处不贴链接了，分别是基于能量的HER和最大熵正则化多目标RL。\n\n这篇文章总的来说提出了**基于迹密度的优先经验回放**，人类的好奇心机制驱动他有了这样的想法，文中说受有监督学习使用过采样和降采样解决训练集样本不平衡问题的启发，想在强化学习中解决经验池中迹“不足（under-represented）”的问题。\n\n说起来也挺佩服这个作者的，目前（2019年6月21日14:59:05）总共发了三篇关于强化学习的论文，但都有很好地结果：\n\n1. 基于迹能量的优先级，发了CoRL\n2. 基于迹密度的优先级，也就是这篇，发了NIPS\n3. 基于迹最大熵的优先级，发了ICML\n\n我个人道行尚浅，对于几篇论文中的深奥精髓有些不能尽数参透，由于先验知识不足，对于文中内容也不敢完全苟同，但是从这几篇阅读总结下来，发得了这种高级别论文有以下几个“加分性”要求：\n\n1. 数学要好，这是必然的，数学公式写的越华丽，数学模型越复杂，当然越具有吸引力\n2. 工作要专一且连续，看这三篇论文虽然不是递进关系，但都是在解决经验池优先相关的工作，所以找准一个领域内的小角度也是很重要的\n3. 实验部分要做好，三篇都没用完整地、细节地比较各个算法，但是却新奇地比较了采样复杂性、数据利用率等等，总之，一定要用实验表明自己的方法在某方面有用\n4. 其他秘密因素\n\n## 流程\n\n这篇论文的方法流程如下：\n\n1. 计算**迹密度**$\\rho$\n2. 计算迹密度的补$\\overline{\\rho} \\propto 1-\\rho$\n3. 根据补排序，并设置优先级，补越大优先级越大\n4. 使用HER补充经验，设置相同的优先级和迹密度\n5. 优化算法\n\n## 迹密度的计算\n\n这一部分没有看太懂，主要是本人数学功底比较薄弱，感兴趣的可以亲自查看论文中2.4与3.2.1、3.2.2部分。\n\n根据文中的意思，思想大致如下：\n\n1. 用GMM（高斯混合模型）来估计迹密度\n   $$\n   \\rho(\\mathbf{x})=\\sum_{k=1}^{K} c_{k} \\mathcal{N}\\left(\\mathbf{x} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)\n   $$\n\n2. 在每个epoch，使用V-GMM（GMM的一个变体）+EM算法推断GMM参数($\\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}$)的后验分布\n\n3. 在每个episode，使用如下公式计算迹密度\n   $$\n   \\rho=\\mathrm{V}-\\operatorname{GMM}(\\mathcal{T})=\\sum_{k=1}^{K} c_{k} \\mathcal{N}\\left(\\mathcal{T} | \\boldsymbol{\\mu}_{k}, \\boldsymbol{\\Sigma}_{k}\\right)\n   $$\n   其中，$\\mathcal{T}=\\left(s_{0}\\left\\|s_{1}\\right\\| \\ldots \\| s_{T}\\right)$，**每个迹的长度相同**，中间的符号代表连结操作的意思，然后进行归一化\n   $$\n   \\rho_{i}=\\frac{\\rho_{i}}{\\sum_{n=1}^{N} \\rho_{n}}\n   $$\n\n*注：我猜想上边符号表示的$s$其实包含了智能体的所在状态和要达到的真实目标，也就是$(s,g)$，文中有一段可能解释了这一部分，但是我没有太理解。*\n\n![](./rl-rough-reading/cdp-sg.png)\n\n## 优先级的设定\n\n作者说使用rank-based方法来设置优先级，因为其受异常点影响小而具有良好的鲁棒性。\n\n先计算迹密度的补\n$$\n\\overline{\\rho} \\propto 1-\\rho\n$$\n将补从小到大排序，并根据排名计算优先级，排名从0开始，即\n$$\n\\operatorname{rank}(\\cdot) \\in\\{0,1, \\ldots, N-1\\}\n$$\n\n$$\np\\left(\\mathcal{T}_{i}\\right)=\\frac{\\operatorname{rank}\\left(\\overline{\\rho}\\left(\\mathcal{T}_{i}\\right)\\right)}{\\sum_{n=1}^{N} \\operatorname{rank}\\left(\\left(\\overline{\\rho}\\left(\\mathcal{T}_{n}\\right)\\right)\\right.}\n$$\n\n## 伪代码\n\n![](./rl-rough-reading/cdp-pseudo.png)\n\n解析：\n\n- 每个epoch根据经验池中的样本数据重新拟合一次密度模型，也就是GMM中的参数\n- 每个episode都计算其迹密度\n- 红色框中的公式数字编号分别代表之间部分中关于计算迹密度和迹优先级的公式\n- 采样迹、采样经验转换之后，需要采样目标并存入经验池，重构后的经验其优先级及迹密度与真正目标下迹的相同\n\n## 优点\n\n实验部分的比较详见论文。\n\n1. 可以适用于任何Off-Policy算法\n2. 不使用TD-error计算优先级，而使用迹密度，减少了计算时间\n3. 提升了采样效率两倍左右\n4. 算法性能超过最新算法9%（这个结果看看即可，不必放在心上）\n\n<h1 align=\"center\" style=\"color:blue\" id=\"NAF\">[Google]Continuous Deep Q-Learning with Model-based Acceleration[NAF]</h1>\n论文地址：[https://arxiv.org/abs/1603.00748](https://arxiv.org/abs/1603.00748)\n\n本文介绍了标准化优势函数Normalized Advantage Function——NAF算法，该算法简化了A-C架构，将Q-Learning的思想应用于高维连续空间。\n\n本文的主要贡献是：\n\n1. 提出NAF，简化了Actor-Critic架构\n2. 将Q-Learning推广至高维连续空间\n3. 提出新的与已学模型结合的方法，提升了采样复杂性（也就是降低）和学习效率，不牺牲策略的最优性。原文中翻译意思是，评估了几种将已学习模型与Q-Learning结合的方案，提出将局部线性模型与局部On-Policy想定推演结合以加速Q-Learning算法在model-free、连续问题下的学习\n\n## 伪代码\n\n![](./rl-rough-reading/naf-pseudo.png)\n\n解析：\n\n- 待写\n\n\n\n<h1 align=\"center\" style=\"color:blue\" id=\"ERE\">[NYU]Boosting Soft Actor-Critic: Emphasizing Recent Experience without Forgetting the Past[ERE]</h1>\n\n<p>论文地址：<a href=\"http://arxiv.org/abs/1906.04009\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1906.04009</a></p>\n<p>代码仓库：<a href=\"https://github.com/BY571/Soft-Actor-Critic-and-Extensions\" rel=\"external nofollow\" target=\"_blank\">https://github.com/BY571/Soft-Actor-Critic-and-Extensions</a>(不确定是否为论文原作者的仓库，该仓库PER的实现没有用sum-tree，2020年04月02日13:42:44)</p>\n<p>这篇论文主要是对经验池机制的扩展，SAC是被应用的算法。</p>\n<p>ERE是Emphasizing Recent Experience的缩写，从名字即可以看出，该经验池机制的侧重点是近期经验。简单说一下ERE的思想及流程：</p>\n<ol>\n<li>强调近期观测到的数据，同时不遗忘过去学到的知识；</li>\n<li>在更新神经网络参数时，比如要连续更新$K$次，即要从经验池中循环取$K$个mini-batch的数据，那么，在第一次更新时，从整个经验池进行采样，后续更新时，逐渐缩小经验池的可采样范围，也就是收缩，使得在间隔内更新的次数也多，近期经验被采样出的概率越大</li>\n</ol>\n<p>论文中的原句：</p>\n<blockquote>\n<p>We propose Emphasizing Recent Experience (ERE), a simple but powerful off-policy sampling technique, which emphasizes recently observed data while not forgetting the past. The ERE algorithm samples more aggressively from recent experience, and also orders the updates to ensure that updates from old data do not overwrite updates from new data.</p>\n</blockquote>\n<h2 id=\"经验池逐渐缩放的原理\"><a href=\"#经验池逐渐缩放的原理\" class=\"headerlink\" title=\"经验池逐渐缩放的原理\"></a>经验池逐渐缩放的原理</h2><p>核心思想是，在训练阶段（也就是先收集好一批轨迹，然后再更新$K$次的阶段），第一个mini-batch数据从整个经验池范围采样，在后续次序的更新中，我们逐渐减小经验池的可采样范围，使得mini-batch数据中包含越来越多的近期经验。</p>\n<p>举个例子：假如经验池共十个位置，即0到9，0放置最新的经验，9放置最旧的经验，batch-size为2，那么在第一次更新时，从0-9中采样两条经验。在第二次更新时，从0-8中采样两条经验。……以此类推。</p>\n<p>论文中提出了下边这个公式：</p>\n<script type=\"math/tex; mode=display\">\nc_{k}=\\max \\left\\{N \\cdot \\eta^{k \\frac{1000}{K}}, c_{\\min }\\right\\}</script><p>在这个公式中，$N$代表经验池的总容量；$\\eta \\in(0,1]$是引入的一个超参数，用来决定<strong>对近期数据的重视程度</strong>，当$\\eta=1$时等同于均匀采样，当$\\eta&lt;1$时，$c_k$随着更新次数逐渐减小。作者通过实验发现$\\eta \\in(0.994,0.999)$时效果不错；$c_{min}$是为$c_k$设置的一个下界，防止从一个很小的范围内采样数据，可能会导致过拟合现象。大写的$K$表示更新的册数，小写的$k$，$1\\leq k \\leq K$，表示当前是第几次更新。</p>\n<p>虽然作者说只引入了$\\eta$这一个超参数，但其实我觉得，更新次数$K$与基数$1000$也属于可调的超参数，虽然在实验中往往将$K$设置为一条轨迹的步长，即有多少步就更新多少次，这样在更新次数上与一步一更新是一致的，但是说到底它也是个可变的参数。</p>\n<p>文中还提到ERE可以与PER相结合，先决定采样区间，再按照区间内经验的权重选择批数据进行更新。通过代码没有看到在ERE与PER结合时使用sum-tree结构，可能在sum-tree结构上ERE不能很好适用，因为区间的选择也会改变树根节点的位置，为各种功能的计算都引入不便。</p>\n<script type=\"math/tex; mode=display\">\nP(i)=\\frac{p_{i}^{\\alpha}}{\\sum_{j} p_{j}^{\\alpha}}, i, j \\in D_{c_{k}}</script><p>$D_{c_k}$即为经验池中前$c_k$个近期的经验数据。</p>\n<h2 id=\"伪代码-3\"><a href=\"#伪代码-3\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><p><img src=\"./rl-rough-reading/ere-pseudo.png\" alt=\"\"></p>\n<h2 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h2><p>优点：</p>\n<ol>\n<li>简单有效</li>\n<li>可用于任何使用经验池机制的off-policy算法中，通用性强</li>\n<li>引入的额外计算损耗可以忽略不计</li>\n<li>只引入一个超参数$\\eta$，用来控制经验池可采样范围缩减的速率，容易调节（我觉得公式中的1000以及$c_{min}$应该也算是需要手动设置的超参数）</li>\n<li>可以结合PER使用</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>传统off-policy算法的更新方式是走一步更新一次参数，像baseline等许多仓库都是这么做的，但是OpenAI的Spinning Up仓库却采用先采样一条轨迹，然后按照轨迹的步长为更新次数，循环更新网络。该论文提出的ERE也是使用先采样轨迹再更新的方式，目前看来不能应用在一步一更新的优化方式中，因为各个时间步的经验池是略有不同的</li>\n<li>创新很小，实验上也没有看出明显的提升。而且，增加重放近期经验的次数的本质原因也不清楚，似乎只是实验效果不错，所以就这样错了，没有看到比较透彻的数学分析</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>该论文的实验图见原文。虽然在许多环境中都产生了1.收敛速度更快一点，2.最终性能得分更高一些，但是总感觉不那么make sense。我个人觉得这个ERE可用可不用，它更像是一种实验得出来有效的trick，而不像是为了解决某一问题而特定研究出来的方法。该方法可以当做是扩展眼界的trick。</p>\n<h1 align=\"center\" style=\"color:blue\" id=\"6SAN\">Reinforcement Learning with Attention that Works: A Self-Supervised Approach</h1>\n\n<p>论文地址：<a href=\"http://arxiv.org/abs/1904.03367\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1904.03367</a></p>\n<p>这篇文章是将self-attention结合进强化学习，并在PPO算法上进行了验证，使用了Arcade Learning Environment的10个环境，分3个随机种子进行实验。</p>\n<p>由于论文中没有明确的self-attention在RL中的运算过程，所以目前不太清楚中间的计算细节。</p>\n<h2 id=\"提出的方法\"><a href=\"#提出的方法\" class=\"headerlink\" title=\"提出的方法\"></a>提出的方法</h2><p><img src=\"./rl-rough-reading/6san.png\" alt=\"\"></p>\n<p>上图为论文提出的Self-Attention在RL中应用的总体架构，其中$H_1,H_2,H_3$均为卷积层。文中将自注意力层加在了卷积层中间，而不是像DARQN一样将注意力层放置在卷积层之后。文中并未对Self-Attention模块中$F_1,F_2,G_1,Y$的运算进行解释。</p>\n<p>作者对self-attention的可能实现做了深入的探索，提出并实验了六种结构：</p>\n<ol>\n<li><p>SAN: Self-Attending Network 在$H_1,H_2$最底层网络间加入自注意力机制</p>\n</li>\n<li><p>SSAN: Strong Self-Attending Network 意思似乎是将自注意力机制的输出$Y$乘以因子2，以增强注意力在网络中的影响</p>\n<blockquote>\n<p>Multiplying the output of the last convolutional layer in the self-attention component (’Y’) by a factor of two (thereby increasing the inﬂuence of attention on the network).</p>\n</blockquote>\n</li>\n<li><p>SADN: Self-Attending Double Network 加入两个自注意力层，分别在$H_1, H_2$与$H_2, H_3$之间</p>\n</li>\n<li><p>SSADN: Strong Self-Attending Double Network 两注意力层的输出均乘2</p>\n</li>\n<li><p>PSAN: Pure Self-Attending Network 只使用注意力层的输出作为特征表示</p>\n<blockquote>\n<p>Passing only the output of the selfattention forward, removing the addition of the previous convolutional layer output.</p>\n</blockquote>\n</li>\n<li><p>PSADN: Pure Self-Attending Double Network 与上相同</p>\n</li>\n</ol>\n<h2 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>实验结果与分析见论文原文。</p>\n<p>此篇文章略读思想即可，文章中没有自注意力机制的完整计算流程，也没有开源源代码，因此无法了解到具体细节。而且，文章中提出了六种自注意力机制结构并进行了实验，个人感觉这六种结构不全是必要的，比如SSAN与PSAN这两类的完全没有get到这么设置的意义，给人一种为了做对比试验而设置的感觉。本篇文章创新性也不高。</p>\n<h1 align=\"center\" style=\"color:blue\" id=\"MANet\">[SNU]Multi-focus Attention Network for Efficient Deep Reinforcement Learning[MANet]</h1>\n\n<p>论文地址：<a href=\"http://arxiv.org/abs/1712.04603\" rel=\"external nofollow\" target=\"_blank\">http://arxiv.org/abs/1712.04603</a></p>\n<p>这篇文章17年发表在AAAI上，提出了MANet算法(多焦点注意力+DQN)，它的创新点主要是将图像分割成若干区域，在这些区域中并行计算注意力权重，最终加权得到新的状态特征。作者展示了MANet算法可以应用在<strong>单智能体图像输</strong>入的环境中，也可以扩展模型应用<strong>在多智能体合作任务</strong>中。</p>\n<p>作者提出MANet针对的问题是：当前深度强化学习模型无法利用感知数据中实体与实体之间的关系，因此需要大量的采样经验去学习。作者希望通过多焦点注意力模型将感知数据中局部范围内实体之间的关系给embed到状态特征之中，加速策略模型学习并且提升模型性能。</p>\n<blockquote>\n<p>current DRL models connect the entire low-level sensory input to the state-action values rather than exploiting the relationship between and among entities that constitute the sensory input.</p>\n</blockquote>\n<p>最终实验结果简报是：</p>\n<ol>\n<li>与DQN做比较时，单智能体场景中使用更少经验取得最高得分</li>\n<li>在多智能体合作任务中，相较于SOTA算法(18年以前)，MANet加速学习20%</li>\n</ol>\n<blockquote>\n<p>MANet attains highest scores with significantly less experience samples. Additionally, the model shows higher performance compared to the Deep Q-network and the single attention model as benchmarks. Furthermore, we extend our model to attentive communication model for performing multi-agent cooperative tasks. In multi-agent cooperative task experiments, our model shows 20% faster learning than existing state-of-the-art model.</p>\n</blockquote>\n<h2 id=\"模型讲解\"><a href=\"#模型讲解\" class=\"headerlink\" title=\"模型讲解\"></a>模型讲解</h2><p><img src=\"./rl-rough-reading/MANet-structure.png\" alt=\"\"></p>\n<p>上图为论文中提出的MANet的结构示意图。MANet主要由四个模块组成：</p>\n<ul>\n<li>输入分割模块(Input Segmentation)</li>\n<li>特征提取模块(Feature Extraction)</li>\n<li>并行注意力模块(Parallel Attentions)</li>\n<li>状态-动作值估计模块(State-action Value Estimation)</li>\n</ul>\n<p><strong>在单智能体任务中</strong>：</p>\n<ol>\n<li><p>输入分割模块</p>\n<p>在这个阶段主要将底层传感器输入分割成多个块/区域，将每一个块的状态称为局部状态。作者使用了最简单的均匀格子切分方法，就是每个局部状态格子大小相同。作者也提到可以使用其他分割方式，可能由于实现困难或者切分后图像大小不一致使处理困难等因素而没有采用。</p>\n<blockquote>\n<p>We believe that we can apply more sophisticated methods like super-pixel segmentation (Achanta et al. 2010) or spatial transformer networks (Jaderberg, Simonyan, and Zisserman 2015).</p>\n</blockquote>\n</li>\n<li><p>特征提取模块</p>\n<p>这个模块主要从每个局部状态提取键(Key)特征和值(Value)特征。</p>\n<p>其中，键特征主要用于决定模型应该注意到的位置</p>\n<blockquote>\n<p>The key features are used to determine where the model should attend.</p>\n</blockquote>\n<p>值特征主要用于编码用于评估Q值的信息</p>\n<blockquote>\n<p>The value features are used to encode information for state-action value estimation.</p>\n</blockquote>\n<p>这一模块的计算过程是这样的，首先提取局部状态的通用特征：</p>\n<script type=\"math/tex; mode=display\">\nc_{i}=f_{f}\\left(s_{i}\\right) \\text { for all } i \\in(0,1, \\ldots, K)</script><p>其中，$K$为第一阶段切分的局部状态的个数，$s_i$表示第$i$个局部状态，$c_i$表示其通用特征，$f_f$是特征提取函数（作者使用深度卷积网络）。</p>\n<p>然后，将通用特征$c_i$与局部状态的索引$i$拼接后，再计算键特征与值特征：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&K e y_{i}=W_{k e y} * c_{i}\\\\\n&V a l_{i}=f_{v}\\left(W_{v a l} * c_{i}\\right)\n\\end{aligned}</script><p>其中，$Key_i$与$Val_i$分别表示第$i$个局部状态的键、值特征。$f_v$表示非线性激活函数（作者使用的是leaky ReLU），$W_{key},W_{val}$是权重矩阵。</p>\n</li>\n<li><p>并行注意力模块</p>\n<p>这一模块主要是区分各个局部状态的重要性，按重要性的不同加权表示特征。</p>\n<script type=\"math/tex; mode=display\">\nA_{i}^{n}=\\frac{\\exp \\left(a_{n} * Key_{i}^{T}\\right)}{\\sum_{i^{\\prime}} \\exp \\left(a_{n^{*} Key_{i^{\\prime}}^{T}}\\right)} \\text { for all } n \\in(0,1, \\ldots, N)</script><p>其中，$N$是上面结构图中注意力层的数量，$A_i^n$表示第$n$层注意力的向量的第$i$个元素，$i^{\\prime} \\in\\{0,1, \\ldots, \\mathrm{K}\\}$，$a_n$是第$n$个选择向量（图中的selector，像神经网络参数一样可以被训练）。上述公式其实是softmax的形式。</p>\n<p>由于$a$的随机初始化基本上相似，所以计算得来的注意力权重也必将相近，作者不希望所有的注意力层都注意某一局部区域（或者相似区域），比如说第5个局部区域，这样的话就很低效。作者希望多个注意力层可以皆可能地注意到不同的局部状态，以达到多焦点（multi-focus）的效果，作者探索了两种正则化方式来鼓励这种行为。</p>\n<p>第一种正则化方法是熵正则化：</p>\n<script type=\"math/tex; mode=display\">\nR_{e}=\\lambda_{e} * \\sum_{n}\\left\\|A^{n} * \\log A^{n}\\right\\|</script><p>这个式子的熵的负数形式，值越小，越随机（越雨露均沾），趋向于均匀分布，也就是越不集中注意力。</p>\n<p>第二种正则化方法是距离正则化：</p>\n<script type=\"math/tex; mode=display\">\nR_{d}=\\lambda_{d} * \\exp \\left(-\\sum_{n, m}\\left(A^{n}-A^{m}\\right)^{2}\\right)</script><p>这个式子为$e$的指数性质，值越小，说明两个注意力层注意关注的区域越不相同，也就是越集中注意力且注意不同的局部状态。</p>\n<p><em>由于论文没有开源源代码，所以目前不确定熵正则化项的具体应用方式，不知道是最大化熵正则化项以鼓励不同注意力层注意不同区域，还是最小化熵正则化项以trade-off距离正则化项，放置距离正则化项过多的注意不同区域。</em></p>\n</li>\n<li><p>状态-动作值估计模块</p>\n<p>这一模块综合每个注意力层的输出特征，并且输入到剩余网络以估计状态-动作值。作者将基于注意力的加权值特征定义为：</p>\n<script type=\"math/tex; mode=display\">\nh_{n}=\\sum_{i} V a l_{i} * A_{i}^{n}</script><p>其中，$h_n$是由第$n$个注意力层的注意力权重$A^n$加权的值特征。最终联合特征和Q值表示为：</p>\n<script type=\"math/tex; mode=display\">\ng=\\left\\{h_{0}, h_{1}, \\ldots, h_{N}\\right\\}</script><script type=\"math/tex; mode=display\">\nQ=f_{q}(g)</script></li>\n</ol>\n<p><strong>在多智能体合作任务中</strong>：</p>\n<p>​    在这种任务中，MANet主要将其它智能体的相关信息加权到某个智能体的状态特征中，相当于特征融合。</p>\n<ol>\n<li><p>输入分割模块</p>\n<p>每一个智能体即是局部状态，因此不用分割，故不需要该模块。</p>\n</li>\n<li><p>特征提取模块</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n&c_{i}=f_{f}\\left(s_{i}\\right) \\text { for all } i \\in(0,1, \\ldots, K)\\\\\n&K e y_{i}=W_{k e y} * c_{i}\\\\\n&\\color{red}{a_{i}=W_{a} * c_{i}}\\\\\n&V a l_{i}=f_{v}\\left(W_{v a l} * c_{i}\\right)\n\\end{aligned}</script><p>$K$表示任务中智能体的个数。与单智能体不同的是，这里的selector是由通用特征$c_i$与权重矩阵$W_a$计算得来的，如上述公式红色字体所示。</p>\n</li>\n<li><p>注意力交流模块（Attentive Communication）</p>\n<script type=\"math/tex; mode=display\">\nA_{j}^{i}=\\frac{\\exp \\left(a^{i} * \\operatorname{Key}_{j}^{T}\\right)}{\\sum_{j^{\\prime}} \\exp \\left(a^{i} * \\operatorname{Ke} y_{j^{\\prime}}^{T}\\right)} \\quad i, j \\in(0,1, \\ldots, K)</script><p>$A_j^i$表示智能体$j$对智能体$i$的注意力权重，值越大则$j$的信息对$i$越重要。</p>\n</li>\n<li><p>状态-动作值估计模块</p>\n<script type=\"math/tex; mode=display\">\n\\begin{array}{c}\nh_{i}=\\sum_{j} V a l_{j} * A_{j}^{i} \\quad j \\in(0,1, \\ldots, K) \\\\\ng_{i}=\\left\\{V a l_{i}, h_{i}\\right\\} \\\\\nQ_{i}=f\\left(g_{i}\\right)\n\\end{array}</script><p>$h_i$为第$i$个智能体的交流特征——从其他智能体的特征中基于注意力加权得来的。</p>\n<p>在多智能体任务中，由于selector $a$与智能体的通用特征相关，因此之间不太相似，所以不需要熵和距离正则化项（作者认为的）。</p>\n<p>作者添加了另一个正则化项$R=\\lambda \\cdot \\left(a \\cdot Key^{T} \\right)$以解决值容易发散的问题。<strong><em>我目前还没有理解到这个正则化项的作用及意义。</em></strong></p>\n</li>\n</ol>"}],"PostAsset":[{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/3.png","slug":"3.png","post":"ckbrzuszb002m20cdk0cc17yi","modified":0,"renderable":0},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/4.png","slug":"4.png","post":"ckbrzuszb002m20cdk0cc17yi","modified":0,"renderable":0},{"_id":"source/_posts/Hindsight-Experience-Replay/fourmodel.png","slug":"fourmodel.png","post":"ckbrzut8k004g20cd9b7b96o4","modified":0,"renderable":0},{"_id":"source/_posts/burn-system2raspberry-in-macos/downloads.png","slug":"downloads.png","post":"ckbrzuswd000b20cdzyfh9un4","modified":0,"renderable":0},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/experiment2.png","slug":"experiment2.png","post":"ckbrzut90004x20cd6o5drnip","modified":0,"renderable":0},{"_id":"source/_posts/options-critic/pseudo.png","slug":"pseudo.png","post":"ckbrzusy2001220cdmp6iscmu","modified":0,"renderable":0},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/7.png","slug":"7.png","post":"ckbrzuszb002m20cdk0cc17yi","modified":0,"renderable":0},{"_id":"source/_posts/价值与贝尔曼方程/example4.png","slug":"example4.png","post":"ckbrzut9v005c20cdsuar141q","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/17.png","slug":"17.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/Evolution-Strategies-2017/atari.png","slug":"atari.png","post":"ckbrzut8e004a20cdrstd6opy","modified":0,"renderable":0},{"_id":"source/_posts/burn-system2raspberry-in-macos/cmd2.png","slug":"cmd2.png","post":"ckbrzuswd000b20cdzyfh9un4","modified":0,"renderable":0},{"_id":"source/_posts/dynamic-programming/iteration.png","slug":"iteration.png","post":"ckbrzut8w004q20cd0fljrs1v","modified":0,"renderable":0},{"_id":"source/_posts/dynamic-programming/pi.png","slug":"pi.png","post":"ckbrzut8w004q20cd0fljrs1v","modified":0,"renderable":0},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/mean-success.png","slug":"mean-success.png","post":"ckbrzut91005020cdr60ebfmk","modified":0,"renderable":0},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/2.png","slug":"2.png","post":"ckbrzuszb002m20cdk0cc17yi","modified":0,"renderable":0},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/MRP.png","slug":"MRP.png","post":"ckbrzutl8006220cdgzgwut2g","modified":0,"renderable":0},{"_id":"source/_posts/install-atari-and-box2d-on-win10/box2d.png","slug":"box2d.png","post":"ckbrzusx1000m20cdyeez4ghq","modified":0,"renderable":0},{"_id":"source/_posts/learn-grpc/gRPC.svg","slug":"gRPC.svg","post":"ckbrzusxv000s20cdb0q3pvfe","modified":0,"renderable":0},{"_id":"source/_posts/leetcode/42.png","slug":"42.png","post":"ckbrzusxx000v20cd531plkiw","modified":0,"renderable":0},{"_id":"source/_posts/random-network-distillation/pseudo.png","slug":"pseudo.png","post":"ckbrzusy7001420cdibi72fyh","modified":0,"renderable":0},{"_id":"source/_posts/something-hard-install-docker/1.png","slug":"1.png","post":"ckbrzusyu001z20cd0ska3mt0","modified":0,"renderable":0},{"_id":"source/_posts/universal-value-function-approximators/sg.png","slug":"sg.png","post":"ckbrzusz4002b20cd6e4j8yj9","modified":0,"renderable":0},{"_id":"source/_posts/rl2/meta-rl.png","slug":"meta-rl.png","post":"ckbrzusym001o20cdsq43wi4f","modified":0,"renderable":0},{"_id":"source/_posts/rl2/meta.png","slug":"meta.png","post":"ckbrzusym001o20cdsq43wi4f","modified":0,"renderable":0},{"_id":"source/_posts/mc-td/dp.png","slug":"dp.png","post":"ckbrzusxz000y20cdkzz0y24v","modified":0,"renderable":0},{"_id":"source/_posts/mc-td/mc.png","slug":"mc.png","post":"ckbrzusxz000y20cdkzz0y24v","modified":0,"renderable":0},{"_id":"source/_posts/mc-td/td.png","slug":"td.png","post":"ckbrzusxz000y20cdkzz0y24v","modified":0,"renderable":0},{"_id":"source/_posts/use-conda-env-in-jupyter/1.png","slug":"1.png","post":"ckbrzusz6002f20cdz0m5gez1","modified":0,"renderable":0},{"_id":"source/_posts/use-conda-env-in-jupyter/2.png","slug":"2.png","post":"ckbrzusz6002f20cdz0m5gez1","modified":0,"renderable":0},{"_id":"source/_posts/use-conda-env-in-jupyter/3.png","slug":"3.png","post":"ckbrzusz6002f20cdz0m5gez1","modified":0,"renderable":0},{"_id":"source/_posts/use-conda-env-in-jupyter/4.png","slug":"4.png","post":"ckbrzusz6002f20cdz0m5gez1","modified":0,"renderable":0},{"_id":"source/_posts/win-rightclick-create-md/1546050455.jpg","slug":"1546050455.jpg","post":"ckbrzusz8002j20cdk6kvvttu","modified":0,"renderable":0},{"_id":"source/_posts/win-rightclick-create-md/20181229103503.png","slug":"20181229103503.png","post":"ckbrzusz8002j20cdk6kvvttu","modified":0,"renderable":0},{"_id":"source/_posts/win-rightclick-create-md/20181229103752.png","slug":"20181229103752.png","post":"ckbrzusz8002j20cdk6kvvttu","modified":0,"renderable":0},{"_id":"source/_posts/win-rightclick-create-md/20181229105300.png","slug":"20181229105300.png","post":"ckbrzusz8002j20cdk6kvvttu","modified":0,"renderable":0},{"_id":"source/_posts/win-rightclick-create-md/20181229105408.png","slug":"20181229105408.png","post":"ckbrzusz8002j20cdk6kvvttu","modified":0,"renderable":0},{"_id":"source/_posts/rl-classification/model-classification.png","slug":"model-classification.png","post":"ckbrzusyh001g20cdqhc7jg7s","modified":0,"renderable":0},{"_id":"source/_posts/rl-classification/non-stationary.png","slug":"non-stationary.png","post":"ckbrzusyh001g20cdqhc7jg7s","modified":0,"renderable":0},{"_id":"source/_posts/rl-classification/policy-based.png","slug":"policy-based.png","post":"ckbrzusyh001g20cdqhc7jg7s","modified":0,"renderable":0},{"_id":"source/_posts/rl-classification/stationary.png","slug":"stationary.png","post":"ckbrzusyh001g20cdqhc7jg7s","modified":0,"renderable":0},{"_id":"source/_posts/rl-classification/value-based.png","slug":"value-based.png","post":"ckbrzusyh001g20cdqhc7jg7s","modified":0,"renderable":0},{"_id":"source/_posts/rl-classification/图.vsdx","slug":"图.vsdx","post":"ckbrzusyh001g20cdqhc7jg7s","modified":0,"renderable":0},{"_id":"source/_posts/burn-system2raspberry-in-macos/cmd1.png","slug":"cmd1.png","post":"ckbrzuswd000b20cdzyfh9un4","modified":0,"renderable":0},{"_id":"source/_posts/burn-system2raspberry-in-macos/end.png","slug":"end.png","post":"ckbrzuswd000b20cdzyfh9un4","modified":0,"renderable":0},{"_id":"source/_posts/burn-system2raspberry-in-macos/formatter.png","slug":"formatter.png","post":"ckbrzuswd000b20cdzyfh9un4","modified":0,"renderable":0},{"_id":"source/_posts/burn-system2raspberry-in-macos/imgs.png","slug":"imgs.png","post":"ckbrzuswd000b20cdzyfh9un4","modified":0,"renderable":0},{"_id":"source/_posts/burn-system2raspberry-in-macos/start.png","slug":"start.png","post":"ckbrzuswd000b20cdzyfh9un4","modified":0,"renderable":0},{"_id":"source/_posts/burn-system2raspberry-in-macos/success.png","slug":"success.png","post":"ckbrzuswd000b20cdzyfh9un4","modified":0,"renderable":0},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/1.png","slug":"1.png","post":"ckbrzuszb002m20cdk0cc17yi","modified":0,"renderable":0},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/10.png","slug":"10.png","post":"ckbrzuszb002m20cdk0cc17yi","modified":0,"renderable":0},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/5.png","slug":"5.png","post":"ckbrzuszb002m20cdk0cc17yi","modified":0,"renderable":0},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/6.png","slug":"6.png","post":"ckbrzuszb002m20cdk0cc17yi","modified":0,"renderable":0},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/8.png","slug":"8.png","post":"ckbrzuszb002m20cdk0cc17yi","modified":0,"renderable":0},{"_id":"source/_posts/为远程Ubuntu服务器安装图像界面/9.png","slug":"9.png","post":"ckbrzuszb002m20cdk0cc17yi","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/16.png","slug":"16.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/2.png","slug":"2.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/4.png","slug":"4.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/7.png","slug":"7.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/1.png","slug":"1.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/10.png","slug":"10.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/11.png","slug":"11.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/12.png","slug":"12.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/13.png","slug":"13.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/14.png","slug":"14.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/15.png","slug":"15.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/18.png","slug":"18.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/19.png","slug":"19.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/20.png","slug":"20.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/21.png","slug":"21.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/22.png","slug":"22.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/23.png","slug":"23.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/24.png","slug":"24.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/25.png","slug":"25.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/26.png","slug":"26.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/27.png","slug":"27.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/28.png","slug":"28.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/3.png","slug":"3.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/5.png","slug":"5.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/6.png","slug":"6.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/8.png","slug":"8.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/AnderewNg-deeplearning-note-summary/9.png","slug":"9.png","post":"ckbrzusvp000020cd1zyq3v36","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/fig5.png","slug":"fig5.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/table6.png","slug":"table6.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/pseudo.png","slug":"pseudo.png","post":"ckbrzut8x004u20cd2ax0y581","modified":0,"renderable":0},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/motivating-example.png","slug":"motivating-example.png","post":"ckbrzut90004x20cd6o5drnip","modified":0,"renderable":0},{"_id":"source/_posts/FuNs/illustration.png","slug":"illustration.png","post":"ckbrzut8g004d20cduapyz616","modified":0,"renderable":0},{"_id":"source/_posts/强化学习的里程碑/GKBattleWithDeepBlue.jpeg","slug":"GKBattleWithDeepBlue.jpeg","post":"ckbrzut8d004820cd6hoog5wp","modified":0,"renderable":0},{"_id":"source/_posts/强化学习的里程碑/KeJieBattleWithAlphaGo.jpeg","slug":"KeJieBattleWithAlphaGo.jpeg","post":"ckbrzut8d004820cd6hoog5wp","modified":0,"renderable":0},{"_id":"source/_posts/强化学习的里程碑/LeeSedolBattleWithAlphaGo.jpeg","slug":"LeeSedolBattleWithAlphaGo.jpeg","post":"ckbrzut8d004820cd6hoog5wp","modified":0,"renderable":0},{"_id":"source/_posts/Evolution-Strategies-2017/algorithm1.png","slug":"algorithm1.png","post":"ckbrzut8e004a20cdrstd6opy","modified":0,"renderable":0},{"_id":"source/_posts/Evolution-Strategies-2017/algorithm2.png","slug":"algorithm2.png","post":"ckbrzut8e004a20cdrstd6opy","modified":0,"renderable":0},{"_id":"source/_posts/Evolution-Strategies-2017/frame-skip.png","slug":"frame-skip.png","post":"ckbrzut8e004a20cdrstd6opy","modified":0,"renderable":0},{"_id":"source/_posts/Evolution-Strategies-2017/mujoco.png","slug":"mujoco.png","post":"ckbrzut8e004a20cdrstd6opy","modified":0,"renderable":0},{"_id":"source/_posts/Evolution-Strategies-2017/parallelization.png","slug":"parallelization.png","post":"ckbrzut8e004a20cdrstd6opy","modified":0,"renderable":0},{"_id":"source/_posts/dynamic-programming/dp.png","slug":"dp.png","post":"ckbrzut8w004q20cd0fljrs1v","modified":0,"renderable":0},{"_id":"source/_posts/dynamic-programming/gridworld.png","slug":"gridworld.png","post":"ckbrzut8w004q20cd0fljrs1v","modified":0,"renderable":0},{"_id":"source/_posts/dynamic-programming/pivsvi.png","slug":"pivsvi.png","post":"ckbrzut8w004q20cd0fljrs1v","modified":0,"renderable":0},{"_id":"source/_posts/dynamic-programming/vi.png","slug":"vi.png","post":"ckbrzut8w004q20cd0fljrs1v","modified":0,"renderable":0},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/experiment1.png","slug":"experiment1.png","post":"ckbrzut90004x20cd6o5drnip","modified":0,"renderable":0},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/experiment3.png","slug":"experiment3.png","post":"ckbrzut90004x20cd6o5drnip","modified":0,"renderable":0},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/pseudo.png","slug":"pseudo.png","post":"ckbrzut90004x20cd6o5drnip","modified":0,"renderable":0},{"_id":"source/_posts/keeping-your-distance-solving-sparse-reward-tasks/sr-example.png","slug":"sr-example.png","post":"ckbrzut90004x20cd6o5drnip","modified":0,"renderable":0},{"_id":"source/_posts/Hindsight-Experience-Replay/Her.png","slug":"Her.png","post":"ckbrzut8k004g20cd9b7b96o4","modified":0,"renderable":0},{"_id":"source/_posts/Hindsight-Experience-Replay/finalvsfuture.png","slug":"finalvsfuture.png","post":"ckbrzut8k004g20cd9b7b96o4","modified":0,"renderable":0},{"_id":"source/_posts/Hindsight-Experience-Replay/hindsight.png","slug":"hindsight.png","post":"ckbrzut8k004g20cd9b7b96o4","modified":0,"renderable":0},{"_id":"source/_posts/Hindsight-Experience-Replay/pseudo.png","slug":"pseudo.png","post":"ckbrzut8k004g20cd9b7b96o4","modified":0,"renderable":0},{"_id":"source/_posts/Hindsight-Experience-Replay/rewardshape.png","slug":"rewardshape.png","post":"ckbrzut8k004g20cd9b7b96o4","modified":0,"renderable":0},{"_id":"source/_posts/Hindsight-Experience-Replay/singlegoal.png","slug":"singlegoal.png","post":"ckbrzut8k004g20cd9b7b96o4","modified":0,"renderable":0},{"_id":"source/_posts/Hindsight-Experience-Replay/tasks.png","slug":"tasks.png","post":"ckbrzut8k004g20cd9b7b96o4","modified":0,"renderable":0},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/MEP.png","slug":"MEP.png","post":"ckbrzut91005020cdr60ebfmk","modified":0,"renderable":0},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/env.png","slug":"env.png","post":"ckbrzut91005020cdr60ebfmk","modified":0,"renderable":0},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/inequality.png","slug":"inequality.png","post":"ckbrzut91005020cdr60ebfmk","modified":0,"renderable":0},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/pseudo.png","slug":"pseudo.png","post":"ckbrzut91005020cdr60ebfmk","modified":0,"renderable":0},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/sample-efficiency.png","slug":"sample-efficiency.png","post":"ckbrzut91005020cdr60ebfmk","modified":0,"renderable":0},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/training-time.png","slug":"training-time.png","post":"ckbrzut91005020cdr60ebfmk","modified":0,"renderable":0},{"_id":"source/_posts/maximum-entropy-regularized-multi-goal-reinforcement-learning/x-x^2.png","slug":"x-x^2.png","post":"ckbrzut91005020cdr60ebfmk","modified":0,"renderable":0},{"_id":"source/_posts/asynchronous-methods-for-drl/a1stepq.png","slug":"a1stepq.png","post":"ckbrzut8o004k20cdaoqytz5x","modified":0,"renderable":0},{"_id":"source/_posts/asynchronous-methods-for-drl/a3c.png","slug":"a3c.png","post":"ckbrzut8o004k20cdaoqytz5x","modified":0,"renderable":0},{"_id":"source/_posts/asynchronous-methods-for-drl/anstepq.png","slug":"anstepq.png","post":"ckbrzut8o004k20cdaoqytz5x","modified":0,"renderable":0},{"_id":"source/_posts/asynchronous-methods-for-drl/gd.png","slug":"gd.png","post":"ckbrzut8o004k20cdaoqytz5x","modified":0,"renderable":0},{"_id":"source/_posts/asynchronous-methods-for-drl/lossfunction.png","slug":"lossfunction.png","post":"ckbrzut8o004k20cdaoqytz5x","modified":0,"renderable":0},{"_id":"source/_posts/asynchronous-methods-for-drl/regression.png","slug":"regression.png","post":"ckbrzut8o004k20cdaoqytz5x","modified":0,"renderable":0},{"_id":"source/_posts/asynchronous-methods-for-drl/sgdvsgd.png","slug":"sgdvsgd.png","post":"ckbrzut8o004k20cdaoqytz5x","modified":0,"renderable":0},{"_id":"source/_posts/asynchronous-methods-for-drl/table1.png","slug":"table1.png","post":"ckbrzut8o004k20cdaoqytz5x","modified":0,"renderable":0},{"_id":"source/_posts/asynchronous-methods-for-drl/table2.png","slug":"table2.png","post":"ckbrzut8o004k20cdaoqytz5x","modified":0,"renderable":0},{"_id":"source/_posts/asynchronous-methods-for-drl/threeoptimizer.png","slug":"threeoptimizer.png","post":"ckbrzut8o004k20cdaoqytz5x","modified":0,"renderable":0},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/env.png","slug":"env.png","post":"ckbrzut8x004u20cd2ax0y581","modified":0,"renderable":0},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/finalmeanrate.png","slug":"finalmeanrate.png","post":"ckbrzut8x004u20cd2ax0y581","modified":0,"renderable":0},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/issue.png","slug":"issue.png","post":"ckbrzut8x004u20cd2ax0y581","modified":0,"renderable":0},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/issue2.png","slug":"issue2.png","post":"ckbrzut8x004u20cd2ax0y581","modified":0,"renderable":0},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/issue3.png","slug":"issue3.png","post":"ckbrzut8x004u20cd2ax0y581","modified":0,"renderable":0},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/meansuccessrate.png","slug":"meansuccessrate.png","post":"ckbrzut8x004u20cd2ax0y581","modified":0,"renderable":0},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/pearsoncorrelation.png","slug":"pearsoncorrelation.png","post":"ckbrzut8x004u20cd2ax0y581","modified":0,"renderable":0},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/sampleefficiency.png","slug":"sampleefficiency.png","post":"ckbrzut8x004u20cd2ax0y581","modified":0,"renderable":0},{"_id":"source/_posts/energy-based-hindsight-experience-prioritization/trainingtime.png","slug":"trainingtime.png","post":"ckbrzut8x004u20cd2ax0y581","modified":0,"renderable":0},{"_id":"source/_posts/价值与贝尔曼方程/example1.png","slug":"example1.png","post":"ckbrzut9v005c20cdsuar141q","modified":0,"renderable":0},{"_id":"source/_posts/价值与贝尔曼方程/example2.png","slug":"example2.png","post":"ckbrzut9v005c20cdsuar141q","modified":0,"renderable":0},{"_id":"source/_posts/价值与贝尔曼方程/example3.png","slug":"example3.png","post":"ckbrzut9v005c20cdsuar141q","modified":0,"renderable":0},{"_id":"source/_posts/价值与贝尔曼方程/example5.png","slug":"example5.png","post":"ckbrzut9v005c20cdsuar141q","modified":0,"renderable":0},{"_id":"source/_posts/价值与贝尔曼方程/example6.png","slug":"example6.png","post":"ckbrzut9v005c20cdsuar141q","modified":0,"renderable":0},{"_id":"source/_posts/价值与贝尔曼方程/q.jpg","slug":"q.jpg","post":"ckbrzut9v005c20cdsuar141q","modified":0,"renderable":0},{"_id":"source/_posts/价值与贝尔曼方程/qsa.jpg","slug":"qsa.jpg","post":"ckbrzut9v005c20cdsuar141q","modified":0,"renderable":0},{"_id":"source/_posts/价值与贝尔曼方程/v.jpg","slug":"v.jpg","post":"ckbrzut9v005c20cdsuar141q","modified":0,"renderable":0},{"_id":"source/_posts/价值与贝尔曼方程/vq.jpg","slug":"vq.jpg","post":"ckbrzut9v005c20cdsuar141q","modified":0,"renderable":0},{"_id":"source/_posts/价值与贝尔曼方程/vs.jpg","slug":"vs.jpg","post":"ckbrzut9v005c20cdsuar141q","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-44-58.png","slug":"Snipaste_2019-01-04_10-44-58.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_10-52-49.png","slug":"Snipaste_2019-01-04_10-52-49.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-29-30.png","slug":"Snipaste_2019-01-04_11-29-30.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_11-36-31.png","slug":"Snipaste_2019-01-04_11-36-31.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-01-32.png","slug":"Snipaste_2019-01-04_12-01-32.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_12-02-47.png","slug":"Snipaste_2019-01-04_12-02-47.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-28-19.png","slug":"Snipaste_2019-01-04_13-28-19.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-15.png","slug":"Snipaste_2019-01-04_13-31-15.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_13-31-52.png","slug":"Snipaste_2019-01-04_13-31-52.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-16-44.png","slug":"Snipaste_2019-01-04_15-16-44.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-04_15-18-40.png","slug":"Snipaste_2019-01-04_15-18-40.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-25-17.png","slug":"Snipaste_2019-01-11_13-25-17.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-35-56.png","slug":"Snipaste_2019-01-11_13-35-56.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-11_13-39-26.png","slug":"Snipaste_2019-01-11_13-39-26.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-11_15-02-16.png","slug":"Snipaste_2019-01-11_15-02-16.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/创建ML-Agents的Docker镜像/Snipaste_2019-01-11_22-38-42.png","slug":"Snipaste_2019-01-11_22-38-42.png","post":"ckbrzut99005720cdvkrls0z2","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_08-30-41.png","slug":"Snipaste_2019-01-03_08-30-41.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_09-42-07.png","slug":"Snipaste_2019-01-03_09-42-07.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_09-56-41.png","slug":"Snipaste_2019-01-03_09-56-41.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_10-03-30.png","slug":"Snipaste_2019-01-03_10-03-30.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_10-11-01.png","slug":"Snipaste_2019-01-03_10-11-01.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_10-56-08.png","slug":"Snipaste_2019-01-03_10-56-08.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_10-57-56.png","slug":"Snipaste_2019-01-03_10-57-56.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_13-49-28.png","slug":"Snipaste_2019-01-03_13-49-28.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-24-49.png","slug":"Snipaste_2019-01-03_16-24-49.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-29-58.png","slug":"Snipaste_2019-01-03_16-29-58.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-32-08.png","slug":"Snipaste_2019-01-03_16-32-08.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-33-27.png","slug":"Snipaste_2019-01-03_16-33-27.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-40-53.png","slug":"Snipaste_2019-01-03_16-40-53.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_16-44-22.png","slug":"Snipaste_2019-01-03_16-44-22.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_17-05-30.png","slug":"Snipaste_2019-01-03_17-05-30.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_17-12-36.png","slug":"Snipaste_2019-01-03_17-12-36.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_17-39-07.png","slug":"Snipaste_2019-01-03_17-39-07.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_18-08-49.png","slug":"Snipaste_2019-01-03_18-08-49.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_18-11-49.png","slug":"Snipaste_2019-01-03_18-11-49.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_18-14-21.png","slug":"Snipaste_2019-01-03_18-14-21.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_18-20-07.png","slug":"Snipaste_2019-01-03_18-20-07.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/create-sniper-docker-image/Snipaste_2019-01-03_18-31-16.png","slug":"Snipaste_2019-01-03_18-31-16.png","post":"ckbrzut8p004n20cd9evxpgtz","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/fig8.png","slug":"fig8.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/Prioritized-Experience-Replay/learning-speed.png","slug":"learning-speed.png","post":"ckbrzutl5005y20cdco9mod2h","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/fig1.png","slug":"fig1.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/rl-with-deep-energy-based-policies/1dgmm.gif","slug":"1dgmm.gif","post":"ckbrzutl7006020cdel76sbz1","modified":0,"renderable":0},{"_id":"source/_posts/rl-with-deep-energy-based-policies/multimodal-policy.png","slug":"multimodal-policy.png","post":"ckbrzutl7006020cdel76sbz1","modified":0,"renderable":0},{"_id":"source/_posts/rl-with-deep-energy-based-policies/pseudo.png","slug":"pseudo.png","post":"ckbrzutl7006020cdel76sbz1","modified":0,"renderable":0},{"_id":"source/_posts/rl-with-deep-energy-based-policies/unimodal-policy.png","slug":"unimodal-policy.png","post":"ckbrzutl7006020cdel76sbz1","modified":0,"renderable":0},{"_id":"source/_posts/rl-with-deep-energy-based-policies/vp.gif","slug":"vp.gif","post":"ckbrzutl7006020cdel76sbz1","modified":0,"renderable":0},{"_id":"source/_posts/Prioritized-Experience-Replay/normalized-score.png","slug":"normalized-score.png","post":"ckbrzutl5005y20cdco9mod2h","modified":0,"renderable":0},{"_id":"source/_posts/Prioritized-Experience-Replay/normalized-score1.png","slug":"normalized-score1.png","post":"ckbrzutl5005y20cdco9mod2h","modified":0,"renderable":0},{"_id":"source/_posts/Prioritized-Experience-Replay/pseudo.png","slug":"pseudo.png","post":"ckbrzutl5005y20cdco9mod2h","modified":0,"renderable":0},{"_id":"source/_posts/Prioritized-Experience-Replay/sum-tree.png","slug":"sum-tree.png","post":"ckbrzutl5005y20cdco9mod2h","modified":0,"renderable":0},{"_id":"source/_posts/Prioritized-Experience-Replay/visio.vsdx","slug":"visio.vsdx","post":"ckbrzutl5005y20cdco9mod2h","modified":0,"renderable":0},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/M.jpg","slug":"M.jpg","post":"ckbrzutl8006220cdgzgwut2g","modified":0,"renderable":0},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/MDP.jpg","slug":"MDP.jpg","post":"ckbrzutl8006220cdgzgwut2g","modified":0,"renderable":0},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/MP.jpg","slug":"MP.jpg","post":"ckbrzutl8006220cdgzgwut2g","modified":0,"renderable":0},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/MPs.jpg","slug":"MPs.jpg","post":"ckbrzutl8006220cdgzgwut2g","modified":0,"renderable":0},{"_id":"source/_posts/强化学习之MDP马尔科夫决策过程/agent-env.png","slug":"agent-env.png","post":"ckbrzutl8006220cdgzgwut2g","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/Long_tailed_distribution.png","slug":"Long_tailed_distribution.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/fig10.png","slug":"fig10.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/fig14.png","slug":"fig14.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/fig2.png","slug":"fig2.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/fig3.png","slug":"fig3.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/fig4.png","slug":"fig4.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/fig6.png","slug":"fig6.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/fig9.png","slug":"fig9.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/table1.png","slug":"table1.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/table2.png","slug":"table2.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/table3.png","slug":"table3.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/table4.png","slug":"table4.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/PaStaNet/table7.png","slug":"table7.png","post":"ckbrzutl1005x20cdar27w44w","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/skill.png","slug":"skill.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/6san.png","slug":"6san.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/Agakov.png","slug":"Agakov.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/MANet-structure.png","slug":"MANet-structure.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/cdp-pseudo.png","slug":"cdp-pseudo.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/cdp-sg.png","slug":"cdp-sg.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/diayn-pseudo.png","slug":"diayn-pseudo.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/diayn.png","slug":"diayn.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/ere-pseudo.png","slug":"ere-pseudo.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/gorila-pseudo.png","slug":"gorila-pseudo.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/gorila.png","slug":"gorila.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/mb-mpo-pseudo.png","slug":"mb-mpo-pseudo.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/mb-mpo-visio.png","slug":"mb-mpo-visio.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/naf-pseudo.png","slug":"naf-pseudo.png","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0},{"_id":"source/_posts/rl-rough-reading/visio.vsdx","slug":"visio.vsdx","post":"ckbrzutyu006a20cd3dfdzqj7","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckbrzusvp000020cd1zyq3v36","category_id":"ckbrzusw2000320cd40357ph2","_id":"ckbrzuswe000c20cdbleqj948"},{"post_id":"ckbrzusvy000220cdofcp1bim","category_id":"ckbrzuswb000820cdyg17badw","_id":"ckbrzuswl000j20cdg5ctkhyo"},{"post_id":"ckbrzuswf000f20cd28atv86w","category_id":"ckbrzuswb000820cdyg17badw","_id":"ckbrzusx5000p20cdvm3566hm"},{"post_id":"ckbrzusw8000520cddz241ks4","category_id":"ckbrzuswe000d20cd8cjtu6xp","_id":"ckbrzusxw000t20cdpyoit0x0"},{"post_id":"ckbrzusx1000m20cdyeez4ghq","category_id":"ckbrzuswe000d20cd8cjtu6xp","_id":"ckbrzusxy000w20cd5kfvfxrl"},{"post_id":"ckbrzusw9000620cdp2ojwudj","category_id":"ckbrzuswe000d20cd8cjtu6xp","_id":"ckbrzusy1000z20cd4p1h9j2d"},{"post_id":"ckbrzuswa000720cddcoz0rgu","category_id":"ckbrzusx7000q20cdgblhfte6","_id":"ckbrzusy6001320cd20w3wmw2"},{"post_id":"ckbrzusy2001220cdmp6iscmu","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzusyd001a20cdapgtndbu"},{"post_id":"ckbrzuswb000a20cdfekfv8t7","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzusyg001e20cd39x22l7r"},{"post_id":"ckbrzusy7001420cdibi72fyh","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzusyi001h20cd7zqbnury"},{"post_id":"ckbrzusy9001720cdpimsg0gt","category_id":"ckbrzuswe000d20cd8cjtu6xp","_id":"ckbrzusyl001m20cd1sf858qy"},{"post_id":"ckbrzuswd000b20cdzyfh9un4","category_id":"ckbrzusy8001520cd8uilm9s7","_id":"ckbrzusym001p20cdi1mgrchm"},{"post_id":"ckbrzusyf001d20cdfuqs3mec","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzusyo001s20cd55mfnfqp"},{"post_id":"ckbrzuswh000h20cdzcowqs1r","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzusyt001w20cd41zrk75w"},{"post_id":"ckbrzusyh001g20cdqhc7jg7s","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzusyv002020cdje62ralk"},{"post_id":"ckbrzusyk001l20cdizuekyjq","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzusyy002420cdwy9tn58s"},{"post_id":"ckbrzusx3000o20cdfedfs1fg","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzusz1002820cdbm83ieo1"},{"post_id":"ckbrzusym001o20cdsq43wi4f","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzusz5002c20cdln2ozax5"},{"post_id":"ckbrzusyn001r20cd1dhnffyg","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzusz7002g20cdkrdtcfh3"},{"post_id":"ckbrzusxv000s20cdb0q3pvfe","category_id":"ckbrzusyn001q20cd6vrd1jtz","_id":"ckbrzusz9002k20cdocxxhul9"},{"post_id":"ckbrzusyr001v20cdtpd25hkh","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzuszc002n20cdhpyw19x2"},{"post_id":"ckbrzusyu001z20cd0ska3mt0","category_id":"ckbrzuswb000820cdyg17badw","_id":"ckbrzuszg002r20cdps5ugv81"},{"post_id":"ckbrzusxx000v20cd531plkiw","category_id":"ckbrzusyn001q20cd6vrd1jtz","_id":"ckbrzuszh002u20cdfteexncd"},{"post_id":"ckbrzusyw002320cdzdw43r16","category_id":"ckbrzuswe000d20cd8cjtu6xp","_id":"ckbrzuszh002x20cde8qi1tee"},{"post_id":"ckbrzusyz002720cd0px2p6pt","category_id":"ckbrzuswe000d20cd8cjtu6xp","_id":"ckbrzuszi002z20cd3qf2pjlt"},{"post_id":"ckbrzusxz000y20cdkzz0y24v","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzuszi003220cdza5zbjwx"},{"post_id":"ckbrzusz4002b20cd6e4j8yj9","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzuszi003420cdgydat8oh"},{"post_id":"ckbrzusz6002f20cdz0m5gez1","category_id":"ckbrzusx7000q20cdgblhfte6","_id":"ckbrzuszj003720cd97yuo7xr"},{"post_id":"ckbrzusyc001920cdaw53ppl2","category_id":"ckbrzusz6002d20cdaps7378v","_id":"ckbrzuszj003920cdzm3sjnuv"},{"post_id":"ckbrzusz8002j20cdk6kvvttu","category_id":"ckbrzuswe000d20cd8cjtu6xp","_id":"ckbrzuszl003b20cdxyrk76b4"},{"post_id":"ckbrzuszd002q20cd3toq9wlg","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzuszm003d20cd6fcibou1"},{"post_id":"ckbrzuszb002m20cdk0cc17yi","category_id":"ckbrzuszg002s20cdyrdpnbv9","_id":"ckbrzuszo003g20cdxfrvpdpe"},{"post_id":"ckbrzut8d004820cd6hoog5wp","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzut8l004h20cdr9jto9tm"},{"post_id":"ckbrzut8e004a20cdrstd6opy","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzut8p004l20cd51t7n2uh"},{"post_id":"ckbrzut8g004d20cduapyz616","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzut8r004o20cduzcmw5qm"},{"post_id":"ckbrzut8k004g20cd9b7b96o4","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzut8w004r20cd43o0c8ri"},{"post_id":"ckbrzut8o004k20cdaoqytz5x","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzut8y004v20cd1thccx5r"},{"post_id":"ckbrzut8p004n20cd9evxpgtz","category_id":"ckbrzuswb000820cdyg17badw","_id":"ckbrzut91004y20cdifmq6sxt"},{"post_id":"ckbrzut8w004q20cd0fljrs1v","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzut92005220cdxetvtfhf"},{"post_id":"ckbrzut8x004u20cd2ax0y581","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzut93005520cdkv8fd7lu"},{"post_id":"ckbrzut90004x20cd6o5drnip","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzut9a005820cdoq9ii32t"},{"post_id":"ckbrzut91005020cdr60ebfmk","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzut9w005d20cdcdxqfieu"},{"post_id":"ckbrzut9v005c20cdsuar141q","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzutbf005k20cd0mi94t2u"},{"post_id":"ckbrzutah005f20cd2nzzgh03","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzutbl005m20cd2jz7qk8q"},{"post_id":"ckbrzut93005420cd8eeddnsn","category_id":"ckbrzut9k005920cdufe21js0","_id":"ckbrzutbs005p20cddftgig5w"},{"post_id":"ckbrzut99005720cdvkrls0z2","category_id":"ckbrzuswb000820cdyg17badw","_id":"ckbrzutbz005r20cdput9mnr0"},{"post_id":"ckbrzut99005720cdvkrls0z2","category_id":"ckbrzutb5005h20cd326euho1","_id":"ckbrzutc4005t20cd045lwrq2"},{"post_id":"ckbrzutl1005x20cdar27w44w","category_id":"ckbrzusw2000320cd40357ph2","_id":"ckbrzutl9006320cd03gti6ar"},{"post_id":"ckbrzutl5005y20cdco9mod2h","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzutl9006520cduckqoebt"},{"post_id":"ckbrzutl7006020cdel76sbz1","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzutla006720cdyeuz9szg"},{"post_id":"ckbrzutl8006220cdgzgwut2g","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzutla006920cdj1ye1xke"},{"post_id":"ckbrzutyu006a20cd3dfdzqj7","category_id":"ckbrzusxy000x20cdruoikxo3","_id":"ckbrzutz0006c20cdc2a8qzn7"}],"PostTag":[{"post_id":"ckbrzusvp000020cd1zyq3v36","tag_id":"ckbrzusw7000420cd3e8b6u1j","_id":"ckbrzuswg000g20cdxa18v7rs"},{"post_id":"ckbrzusvp000020cd1zyq3v36","tag_id":"ckbrzuswb000920cd9wa9dmlx","_id":"ckbrzuswk000i20cdkoxbb33f"},{"post_id":"ckbrzusvy000220cdofcp1bim","tag_id":"ckbrzuswf000e20cddwvkwxhs","_id":"ckbrzusx2000n20cdv2l6s9v1"},{"post_id":"ckbrzusw8000520cddz241ks4","tag_id":"ckbrzuswm000l20cd1cl2a2c8","_id":"ckbrzusxw000u20cd2aupo11d"},{"post_id":"ckbrzusw9000620cdp2ojwudj","tag_id":"ckbrzusx8000r20cd57c715eo","_id":"ckbrzusy2001120cdje92urd2"},{"post_id":"ckbrzuswa000720cddcoz0rgu","tag_id":"ckbrzusy2001020cd4r4yp4o1","_id":"ckbrzusyb001820cd9y73se2m"},{"post_id":"ckbrzuswb000a20cdfekfv8t7","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzusyg001f20cd9fis3cf1"},{"post_id":"ckbrzusyf001d20cdfuqs3mec","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzusyj001j20cdzxrh51c6"},{"post_id":"ckbrzusyh001g20cdqhc7jg7s","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzusyl001n20cduia6p5vf"},{"post_id":"ckbrzusym001o20cdsq43wi4f","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzusyq001u20cd9msacgo7"},{"post_id":"ckbrzuswd000b20cdzyfh9un4","tag_id":"ckbrzusye001c20cdak8w3f2j","_id":"ckbrzusyu001y20cdbpt9785s"},{"post_id":"ckbrzuswd000b20cdzyfh9un4","tag_id":"ckbrzusyj001k20cd6015qzre","_id":"ckbrzusyw002220cdugh5r70o"},{"post_id":"ckbrzusyn001r20cd1dhnffyg","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzusyz002620cdrtse1gy3"},{"post_id":"ckbrzusyr001v20cdtpd25hkh","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzusz3002a20cd9jg7ycpx"},{"post_id":"ckbrzuswf000f20cd28atv86w","tag_id":"ckbrzuswf000e20cddwvkwxhs","_id":"ckbrzusz6002e20cdbwdax9gg"},{"post_id":"ckbrzuswf000f20cd28atv86w","tag_id":"ckbrzusy2001020cd4r4yp4o1","_id":"ckbrzusz8002i20cd3spzzfza"},{"post_id":"ckbrzusyu001z20cd0ska3mt0","tag_id":"ckbrzuswf000e20cddwvkwxhs","_id":"ckbrzusza002l20cdxprzli03"},{"post_id":"ckbrzuswh000h20cdzcowqs1r","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzuszd002p20cdcarylzxr"},{"post_id":"ckbrzusz4002b20cd6e4j8yj9","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzuszg002t20cda6qi2n8t"},{"post_id":"ckbrzusz8002j20cdk6kvvttu","tag_id":"ckbrzusx8000r20cd57c715eo","_id":"ckbrzuszh002w20cd5cpqzrl0"},{"post_id":"ckbrzusx1000m20cdyeez4ghq","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzuszi002y20cdoh98282r"},{"post_id":"ckbrzusx1000m20cdyeez4ghq","tag_id":"ckbrzusz7002h20cdhtukrxtj","_id":"ckbrzuszi003120cdmfjnucfb"},{"post_id":"ckbrzuszd002q20cd3toq9wlg","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzuszi003320cd6r5rj8zj"},{"post_id":"ckbrzusx3000o20cdfedfs1fg","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzuszj003620cdgzyy6xm8"},{"post_id":"ckbrzusxv000s20cdb0q3pvfe","tag_id":"ckbrzuszh002v20cd3h9o6pzm","_id":"ckbrzuszj003820cdnppac4ut"},{"post_id":"ckbrzusxx000v20cd531plkiw","tag_id":"ckbrzuszh002v20cd3h9o6pzm","_id":"ckbrzuszl003c20cdwswlyeql"},{"post_id":"ckbrzusxx000v20cd531plkiw","tag_id":"ckbrzuszj003520cdszyzds2u","_id":"ckbrzuszn003e20cd33w2w4l3"},{"post_id":"ckbrzusxz000y20cdkzz0y24v","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzuszp003h20cd8sxrups5"},{"post_id":"ckbrzusy2001220cdmp6iscmu","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzuszq003j20cdh7ccwtw6"},{"post_id":"ckbrzusy7001420cdibi72fyh","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzut0w003m20cdko9bzxdq"},{"post_id":"ckbrzusy7001420cdibi72fyh","tag_id":"ckbrzut0v003k20cdigdhmug3","_id":"ckbrzut0x003n20cdi0xqgrg2"},{"post_id":"ckbrzusy9001720cdpimsg0gt","tag_id":"ckbrzuswf000e20cddwvkwxhs","_id":"ckbrzut0y003p20cdb30a5chg"},{"post_id":"ckbrzusy9001720cdpimsg0gt","tag_id":"ckbrzut0w003l20cdevnuvyog","_id":"ckbrzut0y003q20cdkt5i459d"},{"post_id":"ckbrzusyc001920cdaw53ppl2","tag_id":"ckbrzusye001c20cdak8w3f2j","_id":"ckbrzut10003t20cdtpqqu9mr"},{"post_id":"ckbrzusyc001920cdaw53ppl2","tag_id":"ckbrzusyj001k20cd6015qzre","_id":"ckbrzut10003u20cdgcf6gyd0"},{"post_id":"ckbrzusyk001l20cdizuekyjq","tag_id":"ckbrzut0z003s20cdj27z3w3f","_id":"ckbrzut11003w20cdjnyp8bnx"},{"post_id":"ckbrzusyw002320cdzdw43r16","tag_id":"ckbrzut10003v20cd5wuotmdx","_id":"ckbrzut12003y20cdimy2vvkc"},{"post_id":"ckbrzusyz002720cd0px2p6pt","tag_id":"ckbrzut11003x20cd71074fe3","_id":"ckbrzut1v004020cd9rs56mfy"},{"post_id":"ckbrzusyz002720cd0px2p6pt","tag_id":"ckbrzusw7000420cd3e8b6u1j","_id":"ckbrzut2w004120cdxeged3v0"},{"post_id":"ckbrzusz6002f20cdz0m5gez1","tag_id":"ckbrzusy2001020cd4r4yp4o1","_id":"ckbrzut37004320cdtm4lww85"},{"post_id":"ckbrzusz6002f20cdz0m5gez1","tag_id":"ckbrzut1e003z20cd61v26fox","_id":"ckbrzut3i004420cdyizty8gi"},{"post_id":"ckbrzuszb002m20cdk0cc17yi","tag_id":"ckbrzut11003x20cd71074fe3","_id":"ckbrzut46004620cdvmxfwkxx"},{"post_id":"ckbrzuszb002m20cdk0cc17yi","tag_id":"ckbrzut3j004520cdd8f0vly1","_id":"ckbrzut4f004720cdhcjnxzfd"},{"post_id":"ckbrzut8d004820cd6hoog5wp","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzut8g004c20cdogsaap0f"},{"post_id":"ckbrzut8e004a20cdrstd6opy","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzut8k004f20cdvo3vgpzx"},{"post_id":"ckbrzut8k004g20cd9b7b96o4","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzut8p004m20cdxoco186h"},{"post_id":"ckbrzut8o004k20cdaoqytz5x","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzut8v004p20cdkw1y25cw"},{"post_id":"ckbrzut8g004d20cduapyz616","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzut8x004t20cd626swsax"},{"post_id":"ckbrzut8g004d20cduapyz616","tag_id":"ckbrzut8m004j20cdo1ru2a7o","_id":"ckbrzut90004w20cdl8gg4eij"},{"post_id":"ckbrzut8w004q20cd0fljrs1v","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzut91004z20cde1i7hg1x"},{"post_id":"ckbrzut8x004u20cd2ax0y581","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzut93005320cdjt3qx7w2"},{"post_id":"ckbrzut90004x20cd6o5drnip","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzut99005620cdo6gotlwf"},{"post_id":"ckbrzut91005020cdr60ebfmk","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzut9k005b20cd0nhi2azc"},{"post_id":"ckbrzut8p004n20cd9evxpgtz","tag_id":"ckbrzuswf000e20cddwvkwxhs","_id":"ckbrzuta4005e20cd0wcqm0vc"},{"post_id":"ckbrzut8p004n20cd9evxpgtz","tag_id":"ckbrzut8x004s20cd26v7g2vp","_id":"ckbrzutb5005g20cdlzbzjwtk"},{"post_id":"ckbrzut8p004n20cd9evxpgtz","tag_id":"ckbrzut92005120cdhlv0vbum","_id":"ckbrzutbf005j20cdbrjc07ov"},{"post_id":"ckbrzut9v005c20cdsuar141q","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzutbl005l20cdoe63wpg3"},{"post_id":"ckbrzutah005f20cd2nzzgh03","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzutbs005o20cdw8bv3zzj"},{"post_id":"ckbrzut93005420cd8eeddnsn","tag_id":"ckbrzut9k005a20cdrjrfmbe6","_id":"ckbrzutbz005q20cddku4czkx"},{"post_id":"ckbrzut93005420cd8eeddnsn","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzutc3005s20cd8sd0dima"},{"post_id":"ckbrzut99005720cdvkrls0z2","tag_id":"ckbrzuswf000e20cddwvkwxhs","_id":"ckbrzutc8005u20cd0c3fqcdi"},{"post_id":"ckbrzut99005720cdvkrls0z2","tag_id":"ckbrzutb5005i20cdzf094ypw","_id":"ckbrzutcf005v20cdwrw9mv2w"},{"post_id":"ckbrzut99005720cdvkrls0z2","tag_id":"ckbrzutbn005n20cd14rp6a60","_id":"ckbrzutcu005w20cdh5fvq2p4"},{"post_id":"ckbrzutl5005y20cdco9mod2h","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzutl8006120cdeeqkv3xf"},{"post_id":"ckbrzutl7006020cdel76sbz1","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzutl9006420cdbqvawzkk"},{"post_id":"ckbrzutl8006220cdgzgwut2g","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzutla006620cdilz45j9w"},{"post_id":"ckbrzutl1005x20cdar27w44w","tag_id":"ckbrzutl7005z20cdc8bx4hfx","_id":"ckbrzutla006820cdzr7wy1w6"},{"post_id":"ckbrzutyu006a20cd3dfdzqj7","tag_id":"ckbrzusy8001620cd87fn87k4","_id":"ckbrzutyy006b20cdvs004t3m"}],"Tag":[{"name":"note","_id":"ckbrzusw7000420cd3e8b6u1j"},{"name":"deeplearning","_id":"ckbrzuswb000920cd9wa9dmlx"},{"name":"docker","_id":"ckbrzuswf000e20cddwvkwxhs"},{"name":"Git","_id":"ckbrzuswm000l20cd1cl2a2c8"},{"name":"markdown","_id":"ckbrzusx8000r20cd57c715eo"},{"name":"conda","_id":"ckbrzusy2001020cd4r4yp4o1"},{"name":"rl","_id":"ckbrzusy8001620cd87fn87k4"},{"name":"os","_id":"ckbrzusye001c20cdak8w3f2j"},{"name":"raspberry","_id":"ckbrzusyj001k20cd6015qzre"},{"name":"gym","_id":"ckbrzusz7002h20cdhtukrxtj"},{"name":"python","_id":"ckbrzuszh002v20cd3h9o6pzm"},{"name":"leetcode","_id":"ckbrzuszj003520cdszyzds2u"},{"name":"exploration","_id":"ckbrzut0v003k20cdigdhmug3"},{"name":"overleaf","_id":"ckbrzut0w003l20cdevnuvyog"},{"name":"RL","_id":"ckbrzut0z003s20cdj27z3w3f"},{"name":"pip","_id":"ckbrzut10003v20cd5wuotmdx"},{"name":"ubuntu","_id":"ckbrzut11003x20cd71074fe3"},{"name":"jupyter notebook","_id":"ckbrzut1e003z20cd61v26fox"},{"name":"x2go","_id":"ckbrzut3j004520cdd8f0vly1"},{"name":"hrl","_id":"ckbrzut8m004j20cdo1ru2a7o"},{"name":"mxnet","_id":"ckbrzut8x004s20cd26v7g2vp"},{"name":"sniper","_id":"ckbrzut92005120cdhlv0vbum"},{"name":"tf2","_id":"ckbrzut9k005a20cdrjrfmbe6"},{"name":"unity","_id":"ckbrzutb5005i20cdzf094ypw"},{"name":"ml-agents","_id":"ckbrzutbn005n20cd14rp6a60"},{"name":"dl","_id":"ckbrzutl7005z20cdc8bx4hfx"}]}}